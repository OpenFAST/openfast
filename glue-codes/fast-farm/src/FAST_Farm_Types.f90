!STARTOFREGISTRYGENERATEDFILE 'FAST_Farm_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FAST_Farm_Types
!.................................................................................................................................
! This file is part of FAST_Farm.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FAST_Farm. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FAST_Farm_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE FASTWrapper_Types
USE WakeDynamics_Types
USE AWAE_Types
USE SuperController_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: NumFFModules = 5      ! The number of modules available in FAST.Farm [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_None = 0      ! No module selected [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_SC = 1      ! Super Controller [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_FWrap = 2      ! FAST Wrapper [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_WD = 3      ! Wake Dynamics [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_AWAE = 4      ! Ambient Wind and Array Effects [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModuleFF_MD = 5      ! Farm-level MoorDyn [-]
! =========  Farm_ParameterType  =======
  TYPE, PUBLIC :: Farm_ParameterType
    REAL(DbKi)  :: DT_low = 0.0_R8Ki      !< Time step for low-resolution wind data input files; will be used as the global FAST.Farm time step [seconds]
    REAL(DbKi)  :: DT_high = 0.0_R8Ki      !< High-resolution time step [seconds]
    REAL(DbKi)  :: TMax = 0.0_R8Ki      !< Total run time [seconds]
    INTEGER(IntKi)  :: n_high_low = 0_IntKi      !< Number of high-resolution time steps per low-resolution time step [-]
    INTEGER(IntKi)  :: NumTurbines = 0_IntKi      !< Number of turbines in the simulation [-]
    CHARACTER(1024)  :: WindFilePath      !< Path name of wind data files from ABLSolver precursor [-]
    CHARACTER(1024)  :: SC_FileName      !< Name/location of the dynamic library {.dll [Windows] or .so [Linux]} containing the Super Controller algorithms [-]
    LOGICAL  :: UseSC = .false.      !< Use a super controller? [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WT_Position      !< X-Y-Z position of each wind turbine; index 1 = XYZ; index 2 = turbine number [meters]
    INTEGER(IntKi)  :: WaveFieldMod = 0_IntKi      !< Wave field handling (-) (switch) {0: use individual HydroDyn inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin} [-]
    INTEGER(IntKi)  :: MooringMod = 0_IntKi      !< Mod_SharedMooring is a flag for array-level mooring. (switch) {0: none, 3: yes/MoorDyn} [-]
    CHARACTER(1024)  :: MD_FileName      !< Name/location of the farm-level MoorDyn input file [-]
    REAL(DbKi)  :: DT_mooring = 0.0_R8Ki      !< Time step for farm-levem mooring coupling with each turbine [used only when Mod_SharedMooring > 0] [seconds]
    INTEGER(IntKi)  :: n_mooring = 0_IntKi      !< Number of FAST and MoorDyn time steps per FAST.Farm timestep when mooring > 0 [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: WT_FASTInFile      !< Name of input file for each turbine [-]
    CHARACTER(1024)  :: FTitle      !< The description line from the primary FAST.Farm input file [-]
    CHARACTER(1024)  :: OutFileRoot      !< The root name derived from the primary FAST.Farm input file [-]
    INTEGER(IntKi)  :: n_ChkptTime = 0_IntKi      !< Number of time steps between writing checkpoint files [-]
    REAL(DbKi)  :: TStart = 0.0_R8Ki      !< Time to begin tabular output [s]
    INTEGER(IntKi)  :: n_TMax = 0_IntKi      !< Number of the time step of TMax (the end time of the simulation) [-]
    LOGICAL  :: SumPrint = .false.      !< Print summary data to file? (.sum) [-]
    LOGICAL  :: WrBinOutFile = .false.      !< Write a binary output file? (.outb) [-]
    LOGICAL  :: WrTxtOutFile = .false.      !< Write a text (formatted) output file? (.out) [-]
    CHARACTER(1)  :: Delim      !< Delimiter between columns of text output file (.out): space or tab [-]
    CHARACTER(20)  :: OutFmt      !< Format used for text tabular output (except time); resulting field should be 10 characters [-]
    CHARACTER(20)  :: OutFmt_t      !< Format used for time channel in text tabular output; resulting field should be 10 characters [-]
    INTEGER(IntKi)  :: FmtWidth = 0_IntKi      !< width of the time OutFmt specifier [-]
    INTEGER(IntKi)  :: TChanLen = 0_IntKi      !< width of the time channel [-]
    INTEGER(IntKi)  :: NOutTurb = 0_IntKi      !< Number of turbines for write output [1 to 9] [-]
    INTEGER(IntKi)  :: NOutRadii = 0_IntKi      !< Number of radial nodes for wake output for an individual rotor [0 to 20] [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: OutRadii      !< List of radial nodes for wake output for an individual rotor [1 to NOutRadii] [-]
    INTEGER(IntKi)  :: NOutDist = 0_IntKi      !< Number of downstream distances for wake output for an individual rotor [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDist      !< List of downstream distances for wake output for an individual rotor [1 to NOutDist] [meters]
    INTEGER(IntKi)  :: NWindVel = 0_IntKi      !< Number of points for wind output [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVelX      !< List of coordinates in the X direction for wind output [1 to NWindVel] [meters]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVelY      !< List of coordinates in the Y direction for wind output [1 to NWindVel] [meters]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVelZ      !< List of coordinates in the Z direction for wind output [1 to NWindVel] [meters]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !< Number of user-requested outputs [-]
    INTEGER(IntKi)  :: NOutSteps = 0_IntKi      !< Maximum number of output steps [-]
    CHARACTER(1024) , DIMENSION(1:3)  :: FileDescLines      !< File Description lines [-]
    TYPE(ProgDesc) , DIMENSION(1:NumModules)  :: Module_Ver      !< Version information from all modules [-]
    INTEGER(IntKi)  :: UnOu = 0_IntKi      !< File unit for Fast.Farm output data [-]
    REAL(ReKi)  :: dX_low = 0.0_ReKi      !< The spacing of the low-resolution nodes in X direction [m]
    REAL(ReKi)  :: dY_low = 0.0_ReKi      !< The spacing of the low-resolution nodes in Y direction [m]
    REAL(ReKi)  :: dZ_low = 0.0_ReKi      !< The spacing of the low-resolution nodes in Z direction [m]
    INTEGER(IntKi)  :: nX_low = 0_IntKi      !< Number of low-resolution spatial nodes in X direction [-]
    INTEGER(IntKi)  :: nY_low = 0_IntKi      !< Number of low-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_low = 0_IntKi      !< Number of low-resolution spatial nodes in Z direction [-]
    REAL(ReKi)  :: X0_low = 0.0_ReKi      !< X-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Y0_low = 0.0_ReKi      !< Y-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Z0_low = 0.0_ReKi      !< Z-component of the origin of the low-resolution spatial domain [m]
  END TYPE Farm_ParameterType
! =======================
! =========  Farm_MiscVarType  =======
  TYPE, PUBLIC :: Farm_MiscVarType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllOuts      !< An array holding the value of all of the calculated (not only selected) output channels [see OutListParameters.xlsx spreadsheet]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TimeData      !< Array to contain the time output data for the binary file (first output time and a time [fixed] increment) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AllOutData      !< Array to contain all the output data (time history of all outputs); Index 1 is NumOuts, Index 2 is Time step [-]
    INTEGER(IntKi)  :: n_Out = 0_IntKi      !< Time index into the AllOutData array [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: FWrap_2_MD      !< Map platform kinematics from each FAST instance to MD [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: MD_2_FWrap      !< Map MD loads at the array level to each FAST instance [-]
  END TYPE Farm_MiscVarType
! =======================
! =========  FASTWrapper_Data  =======
  TYPE, PUBLIC :: FASTWrapper_Data
    TYPE(FWrap_ContinuousStateType)  :: x      !< Continuous states [-]
    TYPE(FWrap_DiscreteStateType)  :: xd      !< Discrete states [-]
    TYPE(FWrap_ConstraintStateType)  :: z      !< Constraint states [-]
    TYPE(FWrap_OtherStateType)  :: OtherSt      !< Other states [-]
    TYPE(FWrap_ParameterType)  :: p      !< Parameters [-]
    TYPE(FWrap_InputType)  :: u      !< System inputs [-]
    TYPE(FWrap_OutputType)  :: y      !< System outputs [-]
    TYPE(FWrap_MiscVarType)  :: m      !< Misc/optimization variables [-]
    LOGICAL  :: IsInitialized = .FALSE.      !< Has FWrap_Init been called [-]
  END TYPE FASTWrapper_Data
! =======================
! =========  WakeDynamics_Data  =======
  TYPE, PUBLIC :: WakeDynamics_Data
    TYPE(WD_ContinuousStateType)  :: x      !< Continuous states [-]
    TYPE(WD_DiscreteStateType)  :: xd      !< Discrete states [-]
    TYPE(WD_ConstraintStateType)  :: z      !< Constraint states [-]
    TYPE(WD_OtherStateType)  :: OtherSt      !< Other states [-]
    TYPE(WD_ParameterType)  :: p      !< Parameters [-]
    TYPE(WD_InputType)  :: u      !< System inputs [-]
    TYPE(WD_OutputType)  :: y      !< System outputs [-]
    TYPE(WD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    LOGICAL  :: IsInitialized = .FALSE.      !< Has WD_Init been called [-]
  END TYPE WakeDynamics_Data
! =======================
! =========  AWAE_Data  =======
  TYPE, PUBLIC :: AWAE_Data
    TYPE(AWAE_ContinuousStateType)  :: x      !< Continuous states [-]
    TYPE(AWAE_DiscreteStateType)  :: xd      !< Discrete states [-]
    TYPE(AWAE_ConstraintStateType)  :: z      !< Constraint states [-]
    TYPE(AWAE_OtherStateType)  :: OtherSt      !< Other states [-]
    TYPE(AWAE_ParameterType)  :: p      !< Parameters [-]
    TYPE(AWAE_InputType)  :: u      !< System inputs [-]
    TYPE(AWAE_OutputType)  :: y      !< System outputs [-]
    TYPE(AWAE_MiscVarType)  :: m      !< Misc/optimization variables [-]
    LOGICAL  :: IsInitialized = .FALSE.      !< Has AWAE_Init been called [-]
  END TYPE AWAE_Data
! =======================
! =========  SC_Data  =======
  TYPE, PUBLIC :: SC_Data
    TYPE(SC_ContinuousStateType)  :: x      !< Continuous states [-]
    TYPE(SC_DiscreteStateType)  :: xd      !< Discrete states [-]
    TYPE(SC_ConstraintStateType)  :: z      !< Constraint states [-]
    TYPE(SC_OtherStateType)  :: OtherState      !< Other states [-]
    TYPE(SC_ParameterType)  :: p      !< Parameters [-]
    TYPE(SC_InputType)  :: uInputs      !< System inputs [-]
    REAL(DbKi) , DIMENSION(1:1)  :: utimes = 0.0_R8Ki      !< Current time [s]
    TYPE(SC_OutputType)  :: y      !< System outputs [-]
    TYPE(SC_MiscVarType)  :: m      !< Misc/optimization variables [-]
    LOGICAL  :: IsInitialized = .FALSE.      !< Has SC_Init been called [-]
  END TYPE SC_Data
! =======================
! =========  MD_Data  =======
  TYPE, PUBLIC :: MD_Data
    TYPE(MD_ContinuousStateType)  :: x      !< Continuous states [-]
    TYPE(MD_DiscreteStateType)  :: xd      !< Discrete states [-]
    TYPE(MD_ConstraintStateType)  :: z      !< Constraint states [-]
    TYPE(MD_OtherStateType)  :: OtherSt      !< Other states [-]
    TYPE(MD_ParameterType)  :: p      !< Parameters [-]
    TYPE(MD_InputType)  :: u      !< Extrapolated system inputs [-]
    TYPE(MD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< System inputs [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Current time [s]
    TYPE(MD_OutputType)  :: y      !< System outputs [-]
    TYPE(MD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    LOGICAL  :: IsInitialized = .FALSE.      !< Has MD_Init been called [-]
  END TYPE MD_Data
! =======================
! =========  All_FastFarm_Data  =======
  TYPE, PUBLIC :: All_FastFarm_Data
    TYPE(Farm_ParameterType)  :: p      !< FAST.Farm parameter data [-]
    TYPE(Farm_MiscVarType)  :: m      !< FAST.Farm misc var data [-]
    TYPE(FASTWrapper_Data) , DIMENSION(:), ALLOCATABLE  :: FWrap      !< FASTWrapper data (one instance per turbine) [-]
    TYPE(WakeDynamics_Data) , DIMENSION(:), ALLOCATABLE  :: WD      !< WakeDynamics (WD) data [-]
    TYPE(AWAE_Data)  :: AWAE      !< Ambient Wind & Array Effects (AWAE) data [-]
    TYPE(SC_Data)  :: SC      !< Super Controller (SC) data [-]
    TYPE(MD_Data)  :: MD      !< Farm-level MoorDyn model data [-]
  END TYPE All_FastFarm_Data
! =======================
CONTAINS

subroutine Farm_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(Farm_ParameterType), intent(in) :: SrcParamData
   type(Farm_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT_low = SrcParamData%DT_low
   DstParamData%DT_high = SrcParamData%DT_high
   DstParamData%TMax = SrcParamData%TMax
   DstParamData%n_high_low = SrcParamData%n_high_low
   DstParamData%NumTurbines = SrcParamData%NumTurbines
   DstParamData%WindFilePath = SrcParamData%WindFilePath
   DstParamData%SC_FileName = SrcParamData%SC_FileName
   DstParamData%UseSC = SrcParamData%UseSC
   if (allocated(SrcParamData%WT_Position)) then
      LB(1:2) = lbound(SrcParamData%WT_Position, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%WT_Position, kind=B8Ki)
      if (.not. allocated(DstParamData%WT_Position)) then
         allocate(DstParamData%WT_Position(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WT_Position.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WT_Position = SrcParamData%WT_Position
   end if
   DstParamData%WaveFieldMod = SrcParamData%WaveFieldMod
   DstParamData%MooringMod = SrcParamData%MooringMod
   DstParamData%MD_FileName = SrcParamData%MD_FileName
   DstParamData%DT_mooring = SrcParamData%DT_mooring
   DstParamData%n_mooring = SrcParamData%n_mooring
   if (allocated(SrcParamData%WT_FASTInFile)) then
      LB(1:1) = lbound(SrcParamData%WT_FASTInFile, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%WT_FASTInFile, kind=B8Ki)
      if (.not. allocated(DstParamData%WT_FASTInFile)) then
         allocate(DstParamData%WT_FASTInFile(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WT_FASTInFile.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WT_FASTInFile = SrcParamData%WT_FASTInFile
   end if
   DstParamData%FTitle = SrcParamData%FTitle
   DstParamData%OutFileRoot = SrcParamData%OutFileRoot
   DstParamData%n_ChkptTime = SrcParamData%n_ChkptTime
   DstParamData%TStart = SrcParamData%TStart
   DstParamData%n_TMax = SrcParamData%n_TMax
   DstParamData%SumPrint = SrcParamData%SumPrint
   DstParamData%WrBinOutFile = SrcParamData%WrBinOutFile
   DstParamData%WrTxtOutFile = SrcParamData%WrTxtOutFile
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutFmt_t = SrcParamData%OutFmt_t
   DstParamData%FmtWidth = SrcParamData%FmtWidth
   DstParamData%TChanLen = SrcParamData%TChanLen
   DstParamData%NOutTurb = SrcParamData%NOutTurb
   DstParamData%NOutRadii = SrcParamData%NOutRadii
   if (allocated(SrcParamData%OutRadii)) then
      LB(1:1) = lbound(SrcParamData%OutRadii, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%OutRadii, kind=B8Ki)
      if (.not. allocated(DstParamData%OutRadii)) then
         allocate(DstParamData%OutRadii(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutRadii.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%OutRadii = SrcParamData%OutRadii
   end if
   DstParamData%NOutDist = SrcParamData%NOutDist
   if (allocated(SrcParamData%OutDist)) then
      LB(1:1) = lbound(SrcParamData%OutDist, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%OutDist, kind=B8Ki)
      if (.not. allocated(DstParamData%OutDist)) then
         allocate(DstParamData%OutDist(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutDist.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%OutDist = SrcParamData%OutDist
   end if
   DstParamData%NWindVel = SrcParamData%NWindVel
   if (allocated(SrcParamData%WindVelX)) then
      LB(1:1) = lbound(SrcParamData%WindVelX, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%WindVelX, kind=B8Ki)
      if (.not. allocated(DstParamData%WindVelX)) then
         allocate(DstParamData%WindVelX(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WindVelX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WindVelX = SrcParamData%WindVelX
   end if
   if (allocated(SrcParamData%WindVelY)) then
      LB(1:1) = lbound(SrcParamData%WindVelY, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%WindVelY, kind=B8Ki)
      if (.not. allocated(DstParamData%WindVelY)) then
         allocate(DstParamData%WindVelY(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WindVelY.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WindVelY = SrcParamData%WindVelY
   end if
   if (allocated(SrcParamData%WindVelZ)) then
      LB(1:1) = lbound(SrcParamData%WindVelZ, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%WindVelZ, kind=B8Ki)
      if (.not. allocated(DstParamData%WindVelZ)) then
         allocate(DstParamData%WindVelZ(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WindVelZ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WindVelZ = SrcParamData%WindVelZ
   end if
   if (allocated(SrcParamData%OutParam)) then
      LB(1:1) = lbound(SrcParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%OutParam, kind=B8Ki)
      if (.not. allocated(DstParamData%OutParam)) then
         allocate(DstParamData%OutParam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyOutParmType(SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%NOutSteps = SrcParamData%NOutSteps
   DstParamData%FileDescLines = SrcParamData%FileDescLines
   LB(1:1) = lbound(SrcParamData%Module_Ver, kind=B8Ki)
   UB(1:1) = ubound(SrcParamData%Module_Ver, kind=B8Ki)
   do i1 = LB(1), UB(1)
      call NWTC_Library_CopyProgDesc(SrcParamData%Module_Ver(i1), DstParamData%Module_Ver(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   DstParamData%UnOu = SrcParamData%UnOu
   DstParamData%dX_low = SrcParamData%dX_low
   DstParamData%dY_low = SrcParamData%dY_low
   DstParamData%dZ_low = SrcParamData%dZ_low
   DstParamData%nX_low = SrcParamData%nX_low
   DstParamData%nY_low = SrcParamData%nY_low
   DstParamData%nZ_low = SrcParamData%nZ_low
   DstParamData%X0_low = SrcParamData%X0_low
   DstParamData%Y0_low = SrcParamData%Y0_low
   DstParamData%Z0_low = SrcParamData%Z0_low
end subroutine

subroutine Farm_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(Farm_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%WT_Position)) then
      deallocate(ParamData%WT_Position)
   end if
   if (allocated(ParamData%WT_FASTInFile)) then
      deallocate(ParamData%WT_FASTInFile)
   end if
   if (allocated(ParamData%OutRadii)) then
      deallocate(ParamData%OutRadii)
   end if
   if (allocated(ParamData%OutDist)) then
      deallocate(ParamData%OutDist)
   end if
   if (allocated(ParamData%WindVelX)) then
      deallocate(ParamData%WindVelX)
   end if
   if (allocated(ParamData%WindVelY)) then
      deallocate(ParamData%WindVelY)
   end if
   if (allocated(ParamData%WindVelZ)) then
      deallocate(ParamData%WindVelZ)
   end if
   if (allocated(ParamData%OutParam)) then
      LB(1:1) = lbound(ParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(ParamData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyOutParmType(ParamData%OutParam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%OutParam)
   end if
   LB(1:1) = lbound(ParamData%Module_Ver, kind=B8Ki)
   UB(1:1) = ubound(ParamData%Module_Ver, kind=B8Ki)
   do i1 = LB(1), UB(1)
      call NWTC_Library_DestroyProgDesc(ParamData%Module_Ver(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
end subroutine

subroutine Farm_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Farm_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackParam'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%DT_low)
   call RegPack(Buf, InData%DT_high)
   call RegPack(Buf, InData%TMax)
   call RegPack(Buf, InData%n_high_low)
   call RegPack(Buf, InData%NumTurbines)
   call RegPack(Buf, InData%WindFilePath)
   call RegPack(Buf, InData%SC_FileName)
   call RegPack(Buf, InData%UseSC)
   call RegPack(Buf, allocated(InData%WT_Position))
   if (allocated(InData%WT_Position)) then
      call RegPackBounds(Buf, 2, lbound(InData%WT_Position, kind=B8Ki), ubound(InData%WT_Position, kind=B8Ki))
      call RegPack(Buf, InData%WT_Position)
   end if
   call RegPack(Buf, InData%WaveFieldMod)
   call RegPack(Buf, InData%MooringMod)
   call RegPack(Buf, InData%MD_FileName)
   call RegPack(Buf, InData%DT_mooring)
   call RegPack(Buf, InData%n_mooring)
   call RegPack(Buf, allocated(InData%WT_FASTInFile))
   if (allocated(InData%WT_FASTInFile)) then
      call RegPackBounds(Buf, 1, lbound(InData%WT_FASTInFile, kind=B8Ki), ubound(InData%WT_FASTInFile, kind=B8Ki))
      call RegPack(Buf, InData%WT_FASTInFile)
   end if
   call RegPack(Buf, InData%FTitle)
   call RegPack(Buf, InData%OutFileRoot)
   call RegPack(Buf, InData%n_ChkptTime)
   call RegPack(Buf, InData%TStart)
   call RegPack(Buf, InData%n_TMax)
   call RegPack(Buf, InData%SumPrint)
   call RegPack(Buf, InData%WrBinOutFile)
   call RegPack(Buf, InData%WrTxtOutFile)
   call RegPack(Buf, InData%Delim)
   call RegPack(Buf, InData%OutFmt)
   call RegPack(Buf, InData%OutFmt_t)
   call RegPack(Buf, InData%FmtWidth)
   call RegPack(Buf, InData%TChanLen)
   call RegPack(Buf, InData%NOutTurb)
   call RegPack(Buf, InData%NOutRadii)
   call RegPack(Buf, allocated(InData%OutRadii))
   if (allocated(InData%OutRadii)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutRadii, kind=B8Ki), ubound(InData%OutRadii, kind=B8Ki))
      call RegPack(Buf, InData%OutRadii)
   end if
   call RegPack(Buf, InData%NOutDist)
   call RegPack(Buf, allocated(InData%OutDist))
   if (allocated(InData%OutDist)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDist, kind=B8Ki), ubound(InData%OutDist, kind=B8Ki))
      call RegPack(Buf, InData%OutDist)
   end if
   call RegPack(Buf, InData%NWindVel)
   call RegPack(Buf, allocated(InData%WindVelX))
   if (allocated(InData%WindVelX)) then
      call RegPackBounds(Buf, 1, lbound(InData%WindVelX, kind=B8Ki), ubound(InData%WindVelX, kind=B8Ki))
      call RegPack(Buf, InData%WindVelX)
   end if
   call RegPack(Buf, allocated(InData%WindVelY))
   if (allocated(InData%WindVelY)) then
      call RegPackBounds(Buf, 1, lbound(InData%WindVelY, kind=B8Ki), ubound(InData%WindVelY, kind=B8Ki))
      call RegPack(Buf, InData%WindVelY)
   end if
   call RegPack(Buf, allocated(InData%WindVelZ))
   if (allocated(InData%WindVelZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%WindVelZ, kind=B8Ki), ubound(InData%WindVelZ, kind=B8Ki))
      call RegPack(Buf, InData%WindVelZ)
   end if
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam, kind=B8Ki), ubound(InData%OutParam, kind=B8Ki))
      LB(1:1) = lbound(InData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(InData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   call RegPack(Buf, InData%NumOuts)
   call RegPack(Buf, InData%NOutSteps)
   call RegPack(Buf, InData%FileDescLines)
   LB(1:1) = lbound(InData%Module_Ver, kind=B8Ki)
   UB(1:1) = ubound(InData%Module_Ver, kind=B8Ki)
   do i1 = LB(1), UB(1)
      call NWTC_Library_PackProgDesc(Buf, InData%Module_Ver(i1)) 
   end do
   call RegPack(Buf, InData%UnOu)
   call RegPack(Buf, InData%dX_low)
   call RegPack(Buf, InData%dY_low)
   call RegPack(Buf, InData%dZ_low)
   call RegPack(Buf, InData%nX_low)
   call RegPack(Buf, InData%nY_low)
   call RegPack(Buf, InData%nZ_low)
   call RegPack(Buf, InData%X0_low)
   call RegPack(Buf, InData%Y0_low)
   call RegPack(Buf, InData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Farm_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackParam'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%DT_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DT_high)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%n_high_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WindFilePath)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SC_FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UseSC)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WT_Position)) deallocate(OutData%WT_Position)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WT_Position(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WT_Position.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WT_Position)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MooringMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MD_FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DT_mooring)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%n_mooring)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WT_FASTInFile)) deallocate(OutData%WT_FASTInFile)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WT_FASTInFile(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WT_FASTInFile.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WT_FASTInFile)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%FTitle)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%n_ChkptTime)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TStart)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%n_TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrBinOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrTxtOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutFmt_t)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FmtWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TChanLen)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NOutTurb)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NOutRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutRadii)) deallocate(OutData%OutRadii)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutRadii(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutRadii.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutRadii)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NOutDist)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutDist)) deallocate(OutData%OutDist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDist(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NWindVel)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WindVelX)) deallocate(OutData%WindVelX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindVelX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVelX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindVelX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WindVelY)) deallocate(OutData%WindVelY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindVelY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVelY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindVelY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WindVelZ)) deallocate(OutData%WindVelZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindVelZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVelZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindVelZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NOutSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FileDescLines)
   if (RegCheckErr(Buf, RoutineName)) return
   LB(1:1) = lbound(OutData%Module_Ver, kind=B8Ki)
   UB(1:1) = ubound(OutData%Module_Ver, kind=B8Ki)
   do i1 = LB(1), UB(1)
      call NWTC_Library_UnpackProgDesc(Buf, OutData%Module_Ver(i1)) ! Module_Ver 
   end do
   call RegUnpack(Buf, OutData%UnOu)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Farm_MiscVarType), intent(inout) :: SrcMiscData
   type(Farm_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%AllOuts)) then
      LB(1:1) = lbound(SrcMiscData%AllOuts, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%AllOuts, kind=B8Ki)
      if (.not. allocated(DstMiscData%AllOuts)) then
         allocate(DstMiscData%AllOuts(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AllOuts.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%AllOuts = SrcMiscData%AllOuts
   end if
   if (allocated(SrcMiscData%TimeData)) then
      LB(1:1) = lbound(SrcMiscData%TimeData, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%TimeData, kind=B8Ki)
      if (.not. allocated(DstMiscData%TimeData)) then
         allocate(DstMiscData%TimeData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TimeData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%TimeData = SrcMiscData%TimeData
   end if
   if (allocated(SrcMiscData%AllOutData)) then
      LB(1:2) = lbound(SrcMiscData%AllOutData, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%AllOutData, kind=B8Ki)
      if (.not. allocated(DstMiscData%AllOutData)) then
         allocate(DstMiscData%AllOutData(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AllOutData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%AllOutData = SrcMiscData%AllOutData
   end if
   DstMiscData%n_Out = SrcMiscData%n_Out
   if (allocated(SrcMiscData%FWrap_2_MD)) then
      LB(1:1) = lbound(SrcMiscData%FWrap_2_MD, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FWrap_2_MD, kind=B8Ki)
      if (.not. allocated(DstMiscData%FWrap_2_MD)) then
         allocate(DstMiscData%FWrap_2_MD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FWrap_2_MD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyMeshMapType(SrcMiscData%FWrap_2_MD(i1), DstMiscData%FWrap_2_MD(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%MD_2_FWrap)) then
      LB(1:1) = lbound(SrcMiscData%MD_2_FWrap, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%MD_2_FWrap, kind=B8Ki)
      if (.not. allocated(DstMiscData%MD_2_FWrap)) then
         allocate(DstMiscData%MD_2_FWrap(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%MD_2_FWrap.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyMeshMapType(SrcMiscData%MD_2_FWrap(i1), DstMiscData%MD_2_FWrap(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine Farm_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(Farm_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%AllOuts)) then
      deallocate(MiscData%AllOuts)
   end if
   if (allocated(MiscData%TimeData)) then
      deallocate(MiscData%TimeData)
   end if
   if (allocated(MiscData%AllOutData)) then
      deallocate(MiscData%AllOutData)
   end if
   if (allocated(MiscData%FWrap_2_MD)) then
      LB(1:1) = lbound(MiscData%FWrap_2_MD, kind=B8Ki)
      UB(1:1) = ubound(MiscData%FWrap_2_MD, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyMeshMapType(MiscData%FWrap_2_MD(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%FWrap_2_MD)
   end if
   if (allocated(MiscData%MD_2_FWrap)) then
      LB(1:1) = lbound(MiscData%MD_2_FWrap, kind=B8Ki)
      UB(1:1) = ubound(MiscData%MD_2_FWrap, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyMeshMapType(MiscData%MD_2_FWrap(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%MD_2_FWrap)
   end if
end subroutine

subroutine Farm_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Farm_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%AllOuts))
   if (allocated(InData%AllOuts)) then
      call RegPackBounds(Buf, 1, lbound(InData%AllOuts, kind=B8Ki), ubound(InData%AllOuts, kind=B8Ki))
      call RegPack(Buf, InData%AllOuts)
   end if
   call RegPack(Buf, allocated(InData%TimeData))
   if (allocated(InData%TimeData)) then
      call RegPackBounds(Buf, 1, lbound(InData%TimeData, kind=B8Ki), ubound(InData%TimeData, kind=B8Ki))
      call RegPack(Buf, InData%TimeData)
   end if
   call RegPack(Buf, allocated(InData%AllOutData))
   if (allocated(InData%AllOutData)) then
      call RegPackBounds(Buf, 2, lbound(InData%AllOutData, kind=B8Ki), ubound(InData%AllOutData, kind=B8Ki))
      call RegPack(Buf, InData%AllOutData)
   end if
   call RegPack(Buf, InData%n_Out)
   call RegPack(Buf, allocated(InData%FWrap_2_MD))
   if (allocated(InData%FWrap_2_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%FWrap_2_MD, kind=B8Ki), ubound(InData%FWrap_2_MD, kind=B8Ki))
      LB(1:1) = lbound(InData%FWrap_2_MD, kind=B8Ki)
      UB(1:1) = ubound(InData%FWrap_2_MD, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%FWrap_2_MD(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%MD_2_FWrap))
   if (allocated(InData%MD_2_FWrap)) then
      call RegPackBounds(Buf, 1, lbound(InData%MD_2_FWrap, kind=B8Ki), ubound(InData%MD_2_FWrap, kind=B8Ki))
      LB(1:1) = lbound(InData%MD_2_FWrap, kind=B8Ki)
      UB(1:1) = ubound(InData%MD_2_FWrap, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%MD_2_FWrap(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Farm_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%AllOuts)) deallocate(OutData%AllOuts)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOuts(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOuts.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOuts)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TimeData)) deallocate(OutData%TimeData)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TimeData(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TimeData.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TimeData)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AllOutData)) deallocate(OutData%AllOutData)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOutData(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOutData.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOutData)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%n_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%FWrap_2_MD)) deallocate(OutData%FWrap_2_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FWrap_2_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FWrap_2_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%FWrap_2_MD(i1)) ! FWrap_2_MD 
      end do
   end if
   if (allocated(OutData%MD_2_FWrap)) deallocate(OutData%MD_2_FWrap)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MD_2_FWrap(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MD_2_FWrap.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%MD_2_FWrap(i1)) ! MD_2_FWrap 
      end do
   end if
end subroutine

subroutine Farm_CopyFASTWrapper_Data(SrcFASTWrapper_DataData, DstFASTWrapper_DataData, CtrlCode, ErrStat, ErrMsg)
   type(FASTWrapper_Data), intent(inout) :: SrcFASTWrapper_DataData
   type(FASTWrapper_Data), intent(inout) :: DstFASTWrapper_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyFASTWrapper_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call FWrap_CopyContState(SrcFASTWrapper_DataData%x, DstFASTWrapper_DataData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyDiscState(SrcFASTWrapper_DataData%xd, DstFASTWrapper_DataData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyConstrState(SrcFASTWrapper_DataData%z, DstFASTWrapper_DataData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyOtherState(SrcFASTWrapper_DataData%OtherSt, DstFASTWrapper_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyParam(SrcFASTWrapper_DataData%p, DstFASTWrapper_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyInput(SrcFASTWrapper_DataData%u, DstFASTWrapper_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyOutput(SrcFASTWrapper_DataData%y, DstFASTWrapper_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FWrap_CopyMisc(SrcFASTWrapper_DataData%m, DstFASTWrapper_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstFASTWrapper_DataData%IsInitialized = SrcFASTWrapper_DataData%IsInitialized
end subroutine

subroutine Farm_DestroyFASTWrapper_Data(FASTWrapper_DataData, ErrStat, ErrMsg)
   type(FASTWrapper_Data), intent(inout) :: FASTWrapper_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyFASTWrapper_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call FWrap_DestroyContState(FASTWrapper_DataData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyDiscState(FASTWrapper_DataData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyConstrState(FASTWrapper_DataData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyOtherState(FASTWrapper_DataData%OtherSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyParam(FASTWrapper_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyInput(FASTWrapper_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyOutput(FASTWrapper_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FWrap_DestroyMisc(FASTWrapper_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackFASTWrapper_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FASTWrapper_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackFASTWrapper_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   call FWrap_PackContState(Buf, InData%x) 
   call FWrap_PackDiscState(Buf, InData%xd) 
   call FWrap_PackConstrState(Buf, InData%z) 
   call FWrap_PackOtherState(Buf, InData%OtherSt) 
   call FWrap_PackParam(Buf, InData%p) 
   call FWrap_PackInput(Buf, InData%u) 
   call FWrap_PackOutput(Buf, InData%y) 
   call FWrap_PackMisc(Buf, InData%m) 
   call RegPack(Buf, InData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackFASTWrapper_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FASTWrapper_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackFASTWrapper_Data'
   if (Buf%ErrStat /= ErrID_None) return
   call FWrap_UnpackContState(Buf, OutData%x) ! x 
   call FWrap_UnpackDiscState(Buf, OutData%xd) ! xd 
   call FWrap_UnpackConstrState(Buf, OutData%z) ! z 
   call FWrap_UnpackOtherState(Buf, OutData%OtherSt) ! OtherSt 
   call FWrap_UnpackParam(Buf, OutData%p) ! p 
   call FWrap_UnpackInput(Buf, OutData%u) ! u 
   call FWrap_UnpackOutput(Buf, OutData%y) ! y 
   call FWrap_UnpackMisc(Buf, OutData%m) ! m 
   call RegUnpack(Buf, OutData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopyWakeDynamics_Data(SrcWakeDynamics_DataData, DstWakeDynamics_DataData, CtrlCode, ErrStat, ErrMsg)
   type(WakeDynamics_Data), intent(in) :: SrcWakeDynamics_DataData
   type(WakeDynamics_Data), intent(inout) :: DstWakeDynamics_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyWakeDynamics_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WD_CopyContState(SrcWakeDynamics_DataData%x, DstWakeDynamics_DataData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyDiscState(SrcWakeDynamics_DataData%xd, DstWakeDynamics_DataData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyConstrState(SrcWakeDynamics_DataData%z, DstWakeDynamics_DataData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyOtherState(SrcWakeDynamics_DataData%OtherSt, DstWakeDynamics_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyParam(SrcWakeDynamics_DataData%p, DstWakeDynamics_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyInput(SrcWakeDynamics_DataData%u, DstWakeDynamics_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyOutput(SrcWakeDynamics_DataData%y, DstWakeDynamics_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call WD_CopyMisc(SrcWakeDynamics_DataData%m, DstWakeDynamics_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstWakeDynamics_DataData%IsInitialized = SrcWakeDynamics_DataData%IsInitialized
end subroutine

subroutine Farm_DestroyWakeDynamics_Data(WakeDynamics_DataData, ErrStat, ErrMsg)
   type(WakeDynamics_Data), intent(inout) :: WakeDynamics_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyWakeDynamics_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call WD_DestroyContState(WakeDynamics_DataData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyDiscState(WakeDynamics_DataData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyConstrState(WakeDynamics_DataData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyOtherState(WakeDynamics_DataData%OtherSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyParam(WakeDynamics_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyInput(WakeDynamics_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyOutput(WakeDynamics_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call WD_DestroyMisc(WakeDynamics_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackWakeDynamics_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WakeDynamics_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackWakeDynamics_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   call WD_PackContState(Buf, InData%x) 
   call WD_PackDiscState(Buf, InData%xd) 
   call WD_PackConstrState(Buf, InData%z) 
   call WD_PackOtherState(Buf, InData%OtherSt) 
   call WD_PackParam(Buf, InData%p) 
   call WD_PackInput(Buf, InData%u) 
   call WD_PackOutput(Buf, InData%y) 
   call WD_PackMisc(Buf, InData%m) 
   call RegPack(Buf, InData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackWakeDynamics_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WakeDynamics_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackWakeDynamics_Data'
   if (Buf%ErrStat /= ErrID_None) return
   call WD_UnpackContState(Buf, OutData%x) ! x 
   call WD_UnpackDiscState(Buf, OutData%xd) ! xd 
   call WD_UnpackConstrState(Buf, OutData%z) ! z 
   call WD_UnpackOtherState(Buf, OutData%OtherSt) ! OtherSt 
   call WD_UnpackParam(Buf, OutData%p) ! p 
   call WD_UnpackInput(Buf, OutData%u) ! u 
   call WD_UnpackOutput(Buf, OutData%y) ! y 
   call WD_UnpackMisc(Buf, OutData%m) ! m 
   call RegUnpack(Buf, OutData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopyAWAE_Data(SrcAWAE_DataData, DstAWAE_DataData, CtrlCode, ErrStat, ErrMsg)
   type(AWAE_Data), intent(in) :: SrcAWAE_DataData
   type(AWAE_Data), intent(inout) :: DstAWAE_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyAWAE_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call AWAE_CopyContState(SrcAWAE_DataData%x, DstAWAE_DataData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyDiscState(SrcAWAE_DataData%xd, DstAWAE_DataData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyConstrState(SrcAWAE_DataData%z, DstAWAE_DataData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyOtherState(SrcAWAE_DataData%OtherSt, DstAWAE_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyParam(SrcAWAE_DataData%p, DstAWAE_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyInput(SrcAWAE_DataData%u, DstAWAE_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyOutput(SrcAWAE_DataData%y, DstAWAE_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AWAE_CopyMisc(SrcAWAE_DataData%m, DstAWAE_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstAWAE_DataData%IsInitialized = SrcAWAE_DataData%IsInitialized
end subroutine

subroutine Farm_DestroyAWAE_Data(AWAE_DataData, ErrStat, ErrMsg)
   type(AWAE_Data), intent(inout) :: AWAE_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyAWAE_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call AWAE_DestroyContState(AWAE_DataData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyDiscState(AWAE_DataData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyConstrState(AWAE_DataData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyOtherState(AWAE_DataData%OtherSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyParam(AWAE_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyInput(AWAE_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyOutput(AWAE_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AWAE_DestroyMisc(AWAE_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackAWAE_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackAWAE_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   call AWAE_PackContState(Buf, InData%x) 
   call AWAE_PackDiscState(Buf, InData%xd) 
   call AWAE_PackConstrState(Buf, InData%z) 
   call AWAE_PackOtherState(Buf, InData%OtherSt) 
   call AWAE_PackParam(Buf, InData%p) 
   call AWAE_PackInput(Buf, InData%u) 
   call AWAE_PackOutput(Buf, InData%y) 
   call AWAE_PackMisc(Buf, InData%m) 
   call RegPack(Buf, InData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackAWAE_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackAWAE_Data'
   if (Buf%ErrStat /= ErrID_None) return
   call AWAE_UnpackContState(Buf, OutData%x) ! x 
   call AWAE_UnpackDiscState(Buf, OutData%xd) ! xd 
   call AWAE_UnpackConstrState(Buf, OutData%z) ! z 
   call AWAE_UnpackOtherState(Buf, OutData%OtherSt) ! OtherSt 
   call AWAE_UnpackParam(Buf, OutData%p) ! p 
   call AWAE_UnpackInput(Buf, OutData%u) ! u 
   call AWAE_UnpackOutput(Buf, OutData%y) ! y 
   call AWAE_UnpackMisc(Buf, OutData%m) ! m 
   call RegUnpack(Buf, OutData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopySC_Data(SrcSC_DataData, DstSC_DataData, CtrlCode, ErrStat, ErrMsg)
   type(SC_Data), intent(in) :: SrcSC_DataData
   type(SC_Data), intent(inout) :: DstSC_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopySC_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call SC_CopyContState(SrcSC_DataData%x, DstSC_DataData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyDiscState(SrcSC_DataData%xd, DstSC_DataData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyConstrState(SrcSC_DataData%z, DstSC_DataData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyOtherState(SrcSC_DataData%OtherState, DstSC_DataData%OtherState, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyParam(SrcSC_DataData%p, DstSC_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyInput(SrcSC_DataData%uInputs, DstSC_DataData%uInputs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstSC_DataData%utimes = SrcSC_DataData%utimes
   call SC_CopyOutput(SrcSC_DataData%y, DstSC_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SC_CopyMisc(SrcSC_DataData%m, DstSC_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstSC_DataData%IsInitialized = SrcSC_DataData%IsInitialized
end subroutine

subroutine Farm_DestroySC_Data(SC_DataData, ErrStat, ErrMsg)
   type(SC_Data), intent(inout) :: SC_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroySC_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call SC_DestroyContState(SC_DataData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyDiscState(SC_DataData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyConstrState(SC_DataData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyOtherState(SC_DataData%OtherState, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyParam(SC_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyInput(SC_DataData%uInputs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyOutput(SC_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SC_DestroyMisc(SC_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackSC_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SC_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackSC_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   call SC_PackContState(Buf, InData%x) 
   call SC_PackDiscState(Buf, InData%xd) 
   call SC_PackConstrState(Buf, InData%z) 
   call SC_PackOtherState(Buf, InData%OtherState) 
   call SC_PackParam(Buf, InData%p) 
   call SC_PackInput(Buf, InData%uInputs) 
   call RegPack(Buf, InData%utimes)
   call SC_PackOutput(Buf, InData%y) 
   call SC_PackMisc(Buf, InData%m) 
   call RegPack(Buf, InData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackSC_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SC_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackSC_Data'
   if (Buf%ErrStat /= ErrID_None) return
   call SC_UnpackContState(Buf, OutData%x) ! x 
   call SC_UnpackDiscState(Buf, OutData%xd) ! xd 
   call SC_UnpackConstrState(Buf, OutData%z) ! z 
   call SC_UnpackOtherState(Buf, OutData%OtherState) ! OtherState 
   call SC_UnpackParam(Buf, OutData%p) ! p 
   call SC_UnpackInput(Buf, OutData%uInputs) ! uInputs 
   call RegUnpack(Buf, OutData%utimes)
   if (RegCheckErr(Buf, RoutineName)) return
   call SC_UnpackOutput(Buf, OutData%y) ! y 
   call SC_UnpackMisc(Buf, OutData%m) ! m 
   call RegUnpack(Buf, OutData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopyMD_Data(SrcMD_DataData, DstMD_DataData, CtrlCode, ErrStat, ErrMsg)
   type(MD_Data), intent(inout) :: SrcMD_DataData
   type(MD_Data), intent(inout) :: DstMD_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyMD_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MD_CopyContState(SrcMD_DataData%x, DstMD_DataData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyDiscState(SrcMD_DataData%xd, DstMD_DataData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyConstrState(SrcMD_DataData%z, DstMD_DataData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyOtherState(SrcMD_DataData%OtherSt, DstMD_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyParam(SrcMD_DataData%p, DstMD_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyInput(SrcMD_DataData%u, DstMD_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMD_DataData%Input)) then
      LB(1:1) = lbound(SrcMD_DataData%Input, kind=B8Ki)
      UB(1:1) = ubound(SrcMD_DataData%Input, kind=B8Ki)
      if (.not. allocated(DstMD_DataData%Input)) then
         allocate(DstMD_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMD_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyInput(SrcMD_DataData%Input(i1), DstMD_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMD_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcMD_DataData%InputTimes, kind=B8Ki)
      UB(1:1) = ubound(SrcMD_DataData%InputTimes, kind=B8Ki)
      if (.not. allocated(DstMD_DataData%InputTimes)) then
         allocate(DstMD_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMD_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMD_DataData%InputTimes = SrcMD_DataData%InputTimes
   end if
   call MD_CopyOutput(SrcMD_DataData%y, DstMD_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyMisc(SrcMD_DataData%m, DstMD_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMD_DataData%IsInitialized = SrcMD_DataData%IsInitialized
end subroutine

subroutine Farm_DestroyMD_Data(MD_DataData, ErrStat, ErrMsg)
   type(MD_Data), intent(inout) :: MD_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyMD_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MD_DestroyContState(MD_DataData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyDiscState(MD_DataData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyConstrState(MD_DataData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyOtherState(MD_DataData%OtherSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyParam(MD_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyInput(MD_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MD_DataData%Input)) then
      LB(1:1) = lbound(MD_DataData%Input, kind=B8Ki)
      UB(1:1) = ubound(MD_DataData%Input, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyInput(MD_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MD_DataData%Input)
   end if
   if (allocated(MD_DataData%InputTimes)) then
      deallocate(MD_DataData%InputTimes)
   end if
   call MD_DestroyOutput(MD_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyMisc(MD_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackMD_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackMD_Data'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call MD_PackContState(Buf, InData%x) 
   call MD_PackDiscState(Buf, InData%xd) 
   call MD_PackConstrState(Buf, InData%z) 
   call MD_PackOtherState(Buf, InData%OtherSt) 
   call MD_PackParam(Buf, InData%p) 
   call MD_PackInput(Buf, InData%u) 
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input, kind=B8Ki), ubound(InData%Input, kind=B8Ki))
      LB(1:1) = lbound(InData%Input, kind=B8Ki)
      UB(1:1) = ubound(InData%Input, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes, kind=B8Ki), ubound(InData%InputTimes, kind=B8Ki))
      call RegPack(Buf, InData%InputTimes)
   end if
   call MD_PackOutput(Buf, InData%y) 
   call MD_PackMisc(Buf, InData%m) 
   call RegPack(Buf, InData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackMD_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackMD_Data'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call MD_UnpackContState(Buf, OutData%x) ! x 
   call MD_UnpackDiscState(Buf, OutData%xd) ! xd 
   call MD_UnpackConstrState(Buf, OutData%z) ! z 
   call MD_UnpackOtherState(Buf, OutData%OtherSt) ! OtherSt 
   call MD_UnpackParam(Buf, OutData%p) ! p 
   call MD_UnpackInput(Buf, OutData%u) ! u 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call MD_UnpackOutput(Buf, OutData%y) ! y 
   call MD_UnpackMisc(Buf, OutData%m) ! m 
   call RegUnpack(Buf, OutData%IsInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_CopyAll_FastFarm_Data(SrcAll_FastFarm_DataData, DstAll_FastFarm_DataData, CtrlCode, ErrStat, ErrMsg)
   type(All_FastFarm_Data), intent(inout) :: SrcAll_FastFarm_DataData
   type(All_FastFarm_Data), intent(inout) :: DstAll_FastFarm_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_CopyAll_FastFarm_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Farm_CopyParam(SrcAll_FastFarm_DataData%p, DstAll_FastFarm_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Farm_CopyMisc(SrcAll_FastFarm_DataData%m, DstAll_FastFarm_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcAll_FastFarm_DataData%FWrap)) then
      LB(1:1) = lbound(SrcAll_FastFarm_DataData%FWrap, kind=B8Ki)
      UB(1:1) = ubound(SrcAll_FastFarm_DataData%FWrap, kind=B8Ki)
      if (.not. allocated(DstAll_FastFarm_DataData%FWrap)) then
         allocate(DstAll_FastFarm_DataData%FWrap(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAll_FastFarm_DataData%FWrap.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Farm_CopyFASTWrapper_Data(SrcAll_FastFarm_DataData%FWrap(i1), DstAll_FastFarm_DataData%FWrap(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAll_FastFarm_DataData%WD)) then
      LB(1:1) = lbound(SrcAll_FastFarm_DataData%WD, kind=B8Ki)
      UB(1:1) = ubound(SrcAll_FastFarm_DataData%WD, kind=B8Ki)
      if (.not. allocated(DstAll_FastFarm_DataData%WD)) then
         allocate(DstAll_FastFarm_DataData%WD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAll_FastFarm_DataData%WD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Farm_CopyWakeDynamics_Data(SrcAll_FastFarm_DataData%WD(i1), DstAll_FastFarm_DataData%WD(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call Farm_CopyAWAE_Data(SrcAll_FastFarm_DataData%AWAE, DstAll_FastFarm_DataData%AWAE, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Farm_CopySC_Data(SrcAll_FastFarm_DataData%SC, DstAll_FastFarm_DataData%SC, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Farm_CopyMD_Data(SrcAll_FastFarm_DataData%MD, DstAll_FastFarm_DataData%MD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Farm_DestroyAll_FastFarm_Data(All_FastFarm_DataData, ErrStat, ErrMsg)
   type(All_FastFarm_Data), intent(inout) :: All_FastFarm_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Farm_DestroyAll_FastFarm_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Farm_DestroyParam(All_FastFarm_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Farm_DestroyMisc(All_FastFarm_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(All_FastFarm_DataData%FWrap)) then
      LB(1:1) = lbound(All_FastFarm_DataData%FWrap, kind=B8Ki)
      UB(1:1) = ubound(All_FastFarm_DataData%FWrap, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Farm_DestroyFASTWrapper_Data(All_FastFarm_DataData%FWrap(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(All_FastFarm_DataData%FWrap)
   end if
   if (allocated(All_FastFarm_DataData%WD)) then
      LB(1:1) = lbound(All_FastFarm_DataData%WD, kind=B8Ki)
      UB(1:1) = ubound(All_FastFarm_DataData%WD, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Farm_DestroyWakeDynamics_Data(All_FastFarm_DataData%WD(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(All_FastFarm_DataData%WD)
   end if
   call Farm_DestroyAWAE_Data(All_FastFarm_DataData%AWAE, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Farm_DestroySC_Data(All_FastFarm_DataData%SC, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Farm_DestroyMD_Data(All_FastFarm_DataData%MD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Farm_PackAll_FastFarm_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(All_FastFarm_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Farm_PackAll_FastFarm_Data'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call Farm_PackParam(Buf, InData%p) 
   call Farm_PackMisc(Buf, InData%m) 
   call RegPack(Buf, allocated(InData%FWrap))
   if (allocated(InData%FWrap)) then
      call RegPackBounds(Buf, 1, lbound(InData%FWrap, kind=B8Ki), ubound(InData%FWrap, kind=B8Ki))
      LB(1:1) = lbound(InData%FWrap, kind=B8Ki)
      UB(1:1) = ubound(InData%FWrap, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Farm_PackFASTWrapper_Data(Buf, InData%FWrap(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%WD))
   if (allocated(InData%WD)) then
      call RegPackBounds(Buf, 1, lbound(InData%WD, kind=B8Ki), ubound(InData%WD, kind=B8Ki))
      LB(1:1) = lbound(InData%WD, kind=B8Ki)
      UB(1:1) = ubound(InData%WD, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Farm_PackWakeDynamics_Data(Buf, InData%WD(i1)) 
      end do
   end if
   call Farm_PackAWAE_Data(Buf, InData%AWAE) 
   call Farm_PackSC_Data(Buf, InData%SC) 
   call Farm_PackMD_Data(Buf, InData%MD) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Farm_UnPackAll_FastFarm_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(All_FastFarm_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Farm_UnPackAll_FastFarm_Data'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call Farm_UnpackParam(Buf, OutData%p) ! p 
   call Farm_UnpackMisc(Buf, OutData%m) ! m 
   if (allocated(OutData%FWrap)) deallocate(OutData%FWrap)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FWrap(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FWrap.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Farm_UnpackFASTWrapper_Data(Buf, OutData%FWrap(i1)) ! FWrap 
      end do
   end if
   if (allocated(OutData%WD)) deallocate(OutData%WD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Farm_UnpackWakeDynamics_Data(Buf, OutData%WD(i1)) ! WD 
      end do
   end if
   call Farm_UnpackAWAE_Data(Buf, OutData%AWAE) ! AWAE 
   call Farm_UnpackSC_Data(Buf, OutData%SC) ! SC 
   call Farm_UnpackMD_Data(Buf, OutData%MD) ! MD 
end subroutine
END MODULE FAST_Farm_Types
!ENDOFREGISTRYGENERATEDFILE
