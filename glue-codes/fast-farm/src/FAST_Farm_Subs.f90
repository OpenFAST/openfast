!**********************************************************************************************************************************
!> ## FAST_Farm
!! The FAST_Farm, FAST_Farm_Subs, and FAST_Farm_Types modules make up a driver for the multi-turbine FAST.Farm code. 
!! FAST_Farms_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! FAST_Farm_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2017  Bonnie Jonkman, independent contributor
!! Copyright (C) 2017  National Renewable Energy Laboratory
!!
!!    This file is part of FAST_Farm.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE FAST_Farm_Subs

   USE FAST_Farm_Types
   USE NWTC_Library
   USE WakeDynamics
   USE AWAE
   USE FAST_Farm_IO
   USE FAST_Subs
   USE FASTWrapper


   IMPLICIT NONE


    
   integer, parameter :: maxOutputPoints = 9
   
   CONTAINS

   subroutine TrilinearInterpRegGrid(V, pt, dims, val)
   
      real(ReKi),     intent(in   ) :: V(:,:,:,:)
      real(ReKi),     intent(in   ) :: pt(3)
      integer(IntKi), intent(in   ) :: dims(3)
      real(ReKi),     intent(  out) :: val(3)
   
      integer(IntKi) :: x0,x1,y0,y1,z0,z1
      real(ReKi) :: xd,yd,zd,c00(3),c01(3),c10(3),c11(3),c0(3),c1(3)
      
      x0 = floor(pt(1))

      x1 = x0 + 1
      if (x0 == dims(1)) x1 = x0  ! Handle case where x0 is the last index in the grid, in this case xd = 0.0, so the 2nd term in the interpolation will not contribute
      xd = pt(1) - x0
      y0 = floor(pt(2))
      y1 = y0 + 1
      if (y0 == dims(2)) y1 = y0  ! Handle case where y0 is the last index in the grid, in this case yd = 0.0, so the 2nd term in the interpolation will not contribute
      yd = pt(2) - y0
      z0 = floor(pt(3))
      z1 = z0 + 1
      if (z0 == dims(3)) z1 = z0  ! Handle case where z0 is the last index in the grid, in this case zd = 0.0, so the 2nd term in the interpolation will not contribute
      zd = pt(3) - z0
      

      c00 = V(:,x0,y0,z0)*(1.0_ReKi-xd) + V(:,x1,y0,z0)*xd
      c01 = V(:,x0,y0,z1)*(1.0_ReKi-xd) + V(:,x1,y0,z1)*xd
      c10 = V(:,x0,y1,z0)*(1.0_ReKi-xd) + V(:,x1,y1,z0)*xd
      c11 = V(:,x0,y1,z1)*(1.0_ReKi-xd) + V(:,x1,y1,z1)*xd
      
      c0  = c00*(1.0_ReKi-yd) + c10*yd
      c1  = c01*(1.0_ReKi-yd) + c11*yd
      
      val = c0 *(1.0_ReKi-zd) + c1 *zd
      
   end subroutine TrilinearInterpRegGrid

   
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to call Init routine for each module. This routine sets all of the init input data for each module. The initialization algorithm is: \n
!!   -  Read-In Input File
!!   -  Check Inputs and Set Parameters
!!   -  In parallel:
!!      1.  CALL AWAE_Init
!!      2.  CALL_SC_Init
!!      3.  CALL WD_Init
!!   -  Transfer y_AWAE_Init to u_F_Init and CALL F_Init
!!   -  Open Output File
!!   -  n=0
!!   -  t=0
SUBROUTINE Farm_Initialize( farm, InputFile, ErrStat, ErrMsg )

   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                !< FAST.Farm data
      
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat             !< Error status of the operation
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg              !< Error message if ErrStat /= ErrID_None
   CHARACTER(*),             INTENT(IN   ) :: InputFile           !< A CHARACTER string containing the name of the primary FAST.Farm input file
   
   
   ! local variables 
   type(AWAE_InitInputType)                :: AWAE_InitInput
   type(AWAE_InitOutputType)               :: AWAE_InitOutput
   
   INTEGER(IntKi)                          :: ErrStat2   
   CHARACTER(ErrMsgLen)                    :: ErrMsg2
   TYPE(WD_InitInputType)                  :: WD_InitInput        ! init-input data for WakeDynamics module
   
   CHARACTER(*), PARAMETER                 :: RoutineName = 'Farm_Initialize'       
   CHARACTER(ChanLenFF),ALLOCATABLE          :: OutList(:)             ! list of user-requested output channels
   
   !..........
   ErrStat = ErrID_None
   ErrMsg  = ""         
   AbortErrLev  = ErrID_Fatal                                 ! Until we read otherwise from the FAST input file, we abort only on FATAL errors
      
   
      ! ... Open and read input files, initialize global parameters. ...
      
   IF (LEN_TRIM(InputFile) == 0) THEN ! no input file was specified
      CALL SetErrStat( ErrID_Fatal, 'The required input file was not specified on the command line.', ErrStat, ErrMsg, RoutineName )

      CALL NWTC_DisplaySyntax( InputFile, 'FAST.Farm.exe' )
         
      RETURN
   END IF            
                        
      ! Determine the root name of the primary file (will be used for output files)
   CALL GetRoot( InputFile, farm%p%OutFileRoot )      
                     
   !...............................................................................................................................  
   ! step 1: read input file
   !...............................................................................................................................  
      
   call Farm_ReadPrimaryFile( InputFile, farm%p, WD_InitInput%InputFileData, AWAE_InitInput%InputFileData, OutList, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF

   !...............................................................................................................................  
   ! step 2: validate input & set parameters
   !...............................................................................................................................  
   call Farm_ValidateInput( farm%p, WD_InitInput%InputFileData, AWAE_InitInput%InputFileData, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF   
      
      ! Set parameters for output channels:
   CALL SetOutParam(OutList, farm%p, ErrStat2, ErrMsg2 ) ! requires: p%NumOuts, sets: p%OutParam.
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF  
      
   
   farm%p%n_high_low = NINT( farm%p%dt / farm%p%dt_high )
            
         ! let's make sure the FAST DT is an exact integer divisor of dt_high 
         ! (i'm doing this outside of Farm_ValidateInput so we know that dt/=0 before computing n_high_low):
      IF ( .NOT. EqualRealNos( real(farm%p%dt,SiKi), real(farm%p%dt_high,SiKi) * farm%p%n_high_low )  ) THEN
         CALL SetErrStat(ErrID_Fatal, "dt_high ("//TRIM(Num2LStr(farm%p%dt_high))//" s) must be an integer divisor of dt (" &
                        //TRIM(Num2LStr(farm%p%dt))//" s).", ErrStat, ErrMsg, RoutineName ) 
      END IF
      
   farm%p%TChanLen = max( 10, int(log10(farm%p%TMax))+7 )
   farm%p%OutFmt_t = 'F'//trim(num2lstr( farm%p%TChanLen ))//'.4' ! 'F10.4'    
   farm%p%n_TMax  = FLOOR( ( farm%p%TMax / farm%p%DT ) ) + 1  ! We're going to go from step 0 to n_TMax 
                   ! [note that FAST uses the ceiling function, so it might think we're doing one more step than FAST.Farm; 
                   ! This difference will be a problem only if FAST thinks it's doing FEWER timesteps than FAST.Farm does.]
   
   IF ( WD_InitInput%InputFileData%NumPlanes > farm%p%n_TMax ) THEN
      WD_InitInput%InputFileData%NumPlanes = max( 2, min( WD_InitInput%InputFileData%NumPlanes, farm%p%n_TMax ) )
      call SetErrStat(ErrID_Warn, "For efficiency, NumPlanes has been reduced to the number of time steps ("//TRIM(Num2LStr(WD_InitInput%InputFileData%NumPlanes))//").", ErrStat, ErrMsg, RoutineName )
   ENDIF
   
   !...............................................................................................................................  
   ! step 3: initialize SC, AWAE, and WD (a, b, and c can be done in parallel)
   !...............................................................................................................................  
   
      !-------------------
      ! a. CALL AWAE_Init
   
   AWAE_InitInput%InputFileData%dr           = WD_InitInput%InputFileData%dr
   AWAE_InitInput%InputFileData%dt           = farm%p%dt 
   AWAE_InitInput%InputFileData%NumTurbines  = farm%p%NumTurbines
   AWAE_InitInput%InputFileData%NumRadii     = WD_InitInput%InputFileData%NumRadii
   AWAE_InitInput%InputFileData%NumPlanes    = WD_InitInput%InputFileData%NumPlanes
   AWAE_InitInput%InputFileData%WindFilePath = farm%p%WindFilePath
   AWAE_InitInput%n_high_low                 = farm%p%n_high_low
   AWAE_InitInput%NumDT                      = farm%p%n_TMax
      
   call AWAE_Init( AWAE_InitInput, farm%AWAE%u, farm%AWAE%p, farm%AWAE%x, farm%AWAE%xd, farm%AWAE%z, farm%AWAE%OtherSt, farm%AWAE%y, &
                   farm%AWAE%m, farm%p%DT, AWAE_InitOutput, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF   

   farm%p%X0_Low = AWAE_InitOutput%X0_Low
   farm%p%Y0_low = AWAE_InitOutput%Y0_low
   farm%p%Z0_low = AWAE_InitOutput%Z0_low
   farm%p%nX_Low = AWAE_InitOutput%nX_Low
   farm%p%nY_low = AWAE_InitOutput%nY_low
   farm%p%nZ_low = AWAE_InitOutput%nZ_low
   farm%p%dX_low = AWAE_InitOutput%dX_low
   farm%p%dY_low = AWAE_InitOutput%dY_low
   farm%p%dZ_low = AWAE_InitOutput%dZ_low
   
      !-------------------
      ! b. CALL SC_Init

   
      
      !-------------------
      ! c. initialize WD (one instance per turbine, each can be done in parallel, too)
      
   call Farm_InitWD( farm, WD_InitInput, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF   
      
      
   !...............................................................................................................................  
   ! step 4: initialize FAST (each instance of FAST can also be done in parallel)
   !...............................................................................................................................  
         
   CALL Farm_InitFAST( farm, WD_InitInput%InputFileData, AWAE_InitOutput, ErrStat2, ErrMsg2)
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) THEN
         CALL Cleanup()
         RETURN
      END IF   

   !...............................................................................................................................  
   ! step 5: Open output file (or set up output file handling)      
   !...............................................................................................................................  
   
   call Farm_InitOutput( farm, ErrStat, ErrMsg )

   !...............................................................................................................................
   ! Destroy initializion data
   !...............................................................................................................................      
   CALL Cleanup()
   
CONTAINS
   SUBROUTINE Cleanup()
   
      call WD_DestroyInitInput(WD_InitInput, ErrStat2, ErrMsg2)
      call AWAE_DestroyInitInput(AWAE_InitInput, ErrStat2, ErrMsg2)
      call AWAE_DestroyInitOutput(AWAE_InitOutput, ErrStat2, ErrMsg2)
         
   END SUBROUTINE Cleanup

END SUBROUTINE Farm_Initialize
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine reads in the primary FAST.Farm input file, does some validation, and places the values it reads in the
!!   parameter structure (p). It prints to an echo file if requested.
SUBROUTINE Farm_ReadPrimaryFile( InputFile, p, WD_InitInp, AWAE_InitInp, OutList, ErrStat, ErrMsg )


      ! Passed variables
   TYPE(Farm_ParameterType),       INTENT(INOUT) :: p                               !< The parameter data for the FAST (glue-code) simulation
   CHARACTER(*),                   INTENT(IN   ) :: InputFile                       !< Name of the file containing the primary input data
   TYPE(WD_InputFileType),         INTENT(  OUT) :: WD_InitInp                      !< input-file data for WakeDynamics module
   TYPE(AWAE_InputFileType),       INTENT(  OUT) :: AWAE_InitInp                    !< input-file data for AWAE module
   CHARACTER(ChanLenFF),ALLOCATABLE, INTENT(  OUT) :: OutList(:)                    !< list of user-requested output channels
   INTEGER(IntKi),                 INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),                   INTENT(  OUT) :: ErrMsg                          !< Error message

      ! Local variables:
   REAL(DbKi)                    :: TmpTime                                   ! temporary variable to read SttsTime and ChkptTime before converting to #steps based on DT
   INTEGER(IntKi)                :: I                                         ! loop counter
   INTEGER(IntKi)                :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                :: UnEc                                      ! I/O unit for echo file. If > 0, file is open for writing.

   INTEGER(IntKi)                :: IOS                                       ! Temporary Error status
   INTEGER(IntKi)                :: OutFileFmt                                ! An integer that indicates what kind of tabular output should be generated (1=text, 2=binary, 3=both)
   INTEGER(IntKi)                :: NLinTimes                                 ! An integer that indicates how many times to linearize
   LOGICAL                       :: Echo                                      ! Determines if an echo file should be written
   LOGICAL                       :: TabDelim                                  ! Determines if text output should be delimited by tabs (true) or space (false)
   CHARACTER(1024)               :: PriPath                                   ! Path name of the primary file

   CHARACTER(10)                 :: AbortLevel                                ! String that indicates which error level should be used to abort the program: WARNING, SEVERE, or FATAL
   CHARACTER(30)                 :: Line                                      ! string for default entry in input file

   INTEGER(IntKi)                :: ErrStat2                                  ! Temporary Error status
   CHARACTER(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(*),   PARAMETER     :: RoutineName = 'Farm_ReadPrimaryFile'
   
   
      ! Initialize some variables:
   UnEc = -1
   Echo = .FALSE.                        ! Don't echo until we've read the "Echo" flag
   CALL GetPath( InputFile, PriPath )    ! Input files will be relative to the path where the primary input file is located.


      ! Get an available unit number for the file.

   CALL GetNewUnit( UnIn, ErrStat, ErrMsg )
   IF ( ErrStat >= AbortErrLev ) RETURN


      ! Open the Primary input file.

   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
! TODO: Fix this! GJH 3/13/2017
   !ALLOCATE ( OutList(MaxOutPts) , STAT=ErrStat )   
   CALL AllocAry( OutList, MaxOutPts, "FAST.Farm's Input File's Outlist", ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF

   ! Read the lines up/including to the "Echo" simulation control variable
   ! If echo is FALSE, don't write these lines to the echo file.
   ! If Echo is TRUE, rewind and write on the second try.

   I = 1 !set the number of times we've read the file
   DO
   !-------------------------- HEADER ---------------------------------------------

      CALL ReadCom( UnIn, InputFile, 'File header: FAST.Farm Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if

      CALL ReadStr( UnIn, InputFile, p%FTitle, 'FTitle', 'File Header: File Description (line 2)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if


   !---------------------- SIMULATION CONTROL --------------------------------------
      CALL ReadCom( UnIn, InputFile, 'Section Header: Simulation Control', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if


         ! Echo - Echo input data to <RootName>.ech (flag):
      CALL ReadVar( UnIn, InputFile, Echo, "Echo", "Echo input data to <RootName>.ech (flag)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if


      IF (.NOT. Echo .OR. I > 1) EXIT !exit this loop

         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read

      I = I + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)

      CALL OpenEcho ( UnEc, TRIM(p%OutFileRoot)//'.ech', ErrStat2, ErrMsg2, Farm_Ver )
         CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if

      IF ( UnEc > 0 )  WRITE (UnEc,'(/,A,/)')  'Data from '//TRIM(Farm_Ver%Name)//' primary input file "'//TRIM( InputFile )//'":'

      REWIND( UnIn, IOSTAT=ErrStat2 )
         IF (ErrStat2 /= 0_IntKi ) THEN
            CALL SetErrStat( ErrID_Fatal, 'Error rewinding file "'//TRIM(InputFile)//'".',ErrStat,ErrMsg,RoutineName)
            call cleanup()
            RETURN        
         END IF

   END DO

   CALL WrScr( ' Heading of the '//TRIM(Farm_Ver%Name)//' input file: ' )
   CALL WrScr( '   '//TRIM( p%FTitle ) )


      ! AbortLevel - Error level when simulation should abort:
   CALL ReadVar( UnIn, InputFile, AbortLevel, "AbortLevel", "Error level when simulation should abort (string)", &
                        ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if

      ! Let's set the abort level here.... knowing that everything before this aborted only on FATAL errors!
      CALL Conv2UC( AbortLevel ) !convert to upper case
      SELECT CASE( TRIM(AbortLevel) )
         CASE ( "WARNING" )
            AbortErrLev = ErrID_Warn
         CASE ( "SEVERE" )
            AbortErrLev = ErrID_Severe
         CASE ( "FATAL" )
            AbortErrLev = ErrID_Fatal
         CASE DEFAULT
            CALL SetErrStat( ErrID_Fatal, 'Invalid AbortLevel specified in FAST.Farm input file. '// &
                             'Valid entries are "WARNING", "SEVERE", or "FATAL".',ErrStat,ErrMsg,RoutineName)
            call cleanup()
            RETURN
      END SELECT


      ! TMax - Total run time (s):
   CALL ReadVar( UnIn, InputFile, p%TMax, "TMax", "Total run time (s)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      
   !---------------------- AMBIENT WIND ---------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Ambient Wind', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! DT - Time step for low-resolution wind data input files; will be used as the global FAST.Farm time step (s) [>0.0]:
   CALL ReadVar( UnIn, InputFile, p%DT, "DT", "Time step for low-resolution wind data input files; will be used as the global FAST.Farm time step (s) [>0.0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if

      ! DT_high - Time step for high-resolution wind data input files (s) [>0.0]:
   CALL ReadVar( UnIn, InputFile, p%DT_high, "DT_high", "Time step for high-resolution wind data input files (s) [>0.0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! WindFilePath - Path name of wind data files from ABLSolver precursor (string):
   CALL ReadVar( UnIn, InputFile, p%WindFilePath, "WindFilePath", "Path name of wind data files from ABLSolver precursor (string)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   IF ( PathIsRelative( p%WindFilePath ) ) p%WindFilePath = TRIM(PriPath)//TRIM(p%WindFilePath)
            
      
   !---------------------- WIND TURBINES ---------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Wind Turbines', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      
      ! NumTurbines - Number of wind turbines (-) [>=1]:
   CALL ReadVar( UnIn, InputFile, p%NumTurbines, "NumTurbines", "Number of wind turbines (-) [>=1]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
   CALL ReadCom( UnIn, InputFile, 'Section Header: WT column names', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   CALL ReadCom( UnIn, InputFile, 'Section Header: WT column units', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
   call AllocAry( p%WT_Position, 3, p%NumTurbines, 'WT_Position',   ErrStat2, ErrMsg2);  CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AllocAry( p%WT_FASTInFile,  p%NumTurbines, 'WT_FASTInFile', ErrStat2, ErrMsg2);  CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      

      ! WT_Position (WT_X, WT_Y, WT_Z) and WT_FASTInFile
   do i=1,p%NumTurbines
      READ (UnIn, *, IOSTAT=IOS) p%WT_Position(:,i), p%WT_FASTInFile(i)
      
      CALL CheckIOS ( IOS, InputFile, 'Wind Turbine Columns', NumType, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      IF ( UnEc > 0 ) THEN      
         WRITE( UnEc, "(3(ES11.4e2,2X),'""',A,'""',T50,' - WT(',I5,')')" ) p%WT_Position(:,i), TRIM( p%WT_FASTInFile(i) ), I
      END IF
      IF ( PathIsRelative( p%WT_FASTInFile(i) ) ) p%WT_FASTInFile(i) = TRIM(PriPath)//TRIM(p%WT_FASTInFile(i))
      
   end do
      
      
   !---------------------- WAKE DYNAMICS ---------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Wake Dynamics', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      
      ! dr - Radial increment of radial finite-difference grid (m) [>0.0]:
   CALL ReadVar( UnIn, InputFile, WD_InitInp%dr, "dr", "Radial increment of radial finite-difference grid (m) [>0.0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   
      ! NumRadii - Number of radii in the radial finite-difference grid (-) [>=2]:
   CALL ReadVar( UnIn, InputFile, WD_InitInp%NumRadii, "NumRadii", "Number of radii in the radial finite-difference grid (-) [>=2]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   
      ! NumPlanes - Number of wake planes (-) [>=2]:
   CALL ReadVar( UnIn, InputFile, WD_InitInp%NumPlanes, "NumPlanes", "Number of wake planes (-) [>=2]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! f_c - Cut-off (corner) frequency of the low-pass time-filter for the wake advection, deflection, and meandering model (Hz) [>0.0] or DEFAULT [DEFAULT=1/300]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%f_c, "f_c", &
      "Cut-off (corner) frequency of the low-pass time-filter for the wake advection, deflection, and meandering model (Hz) [>0.0] or DEFAULT [DEFAULT=1/300]", &
      1.0_ReKi/300.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! C_HWkDfl_O - Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor (m) or DEFAULT [DEFAULT=-2.9]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_HWkDfl_O, "C_HWkDfl_O", &
      "Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor (m) or DEFAULT [DEFAULT=-2.9]", &
      -2.9_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if

      ! C_HWkDfl_OY - Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor scaled with yaw error (m/deg) or DEFAULT [DEFAULT=-0.24]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_HWkDfl_OY, "C_HWkDfl_OY", &
      "Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor scaled with yaw error (m/deg) or DEFAULT [DEFAULT=-0.24]", &
      -0.24_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   WD_InitInp%C_HWkDfl_OY = WD_InitInp%C_HWkDfl_OY/D2R !immediately convert to m/radians instead of m/degrees      
      
      ! C_HWkDfl_x - Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance (-) or DEFAULT [DEFAULT=-0.0054]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_HWkDfl_x, "C_HWkDfl_x", &
      "Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance (-) or DEFAULT [DEFAULT=-0.0054]", &
      -0.0054_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
         
      ! C_HWkDfl_xY - Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance and yaw error (1/deg) or DEFAULT [DEFAULT= 0.00039]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_HWkDfl_xY, "C_HWkDfl_xY", &
      "Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance and yaw error (1/deg) or DEFAULT [DEFAULT= 0.00039]", &
      0.00039_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
   WD_InitInp%C_HWkDfl_xY = WD_InitInp%C_HWkDfl_xY/D2R !immediately convert to 1/radians instead of 1/degrees      

   
      ! C_NearWake - Calibrated parameter for the near-wake correction (-) [>1.0] or DEFAULT [DEFAULT=2.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_NearWake, "C_NearWake", &
      "Calibrated parameter for the near-wake correction (-) [>1.0] or DEFAULT [DEFAULT=2.0]", &
      2.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
              
      ! k_vAmb - Calibrated parameter for the influence of ambient turbulence in the eddy viscosity (-) [>=0.0] or DEFAULT [DEFAULT=0.07 ]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%k_vAmb, "k_vAmb", &
      "Calibrated parameter for the influence of ambient turbulence in the eddy viscosity (-) [>=0.0] or DEFAULT [DEFAULT=0.07]", &
      0.07_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
         
      ! k_vShr - Calibrated parameter for the influence of the shear layer in the eddy viscosity (-) [>=0.0] or DEFAULT [DEFAULT=0.018]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%k_vShr, "k_vShr", &
      "Calibrated parameter for the influence of the shear layer in the eddy viscosity (-) [>=0.0] or DEFAULT [DEFAULT=0.018]", &
      0.018_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      

      ! C_vAmb_DMin - Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the minimum and exponential regions (-) [>=0.0] or DEFAULT [DEFAULT=0.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vAmb_DMin, "C_vAmb_DMin", &
      "Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the minimum and exponential regions (-) [>=0.0] or DEFAULT [DEFAULT=0.0]", &
      0.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      ! C_vAmb_DMax - Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the exponential and maximum regions (-) [> C_vAmb_DMin  ] or DEFAULT [DEFAULT=2.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vAmb_DMax, "C_vAmb_DMax", &
      "Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the exponential and maximum regions (-) [> C_vAmb_DMin  ] or DEFAULT [DEFAULT=2.0]", &
      2.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
        
      ! C_vAmb_FMin - Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the value in the minimum region (-) [>=0.0 and <=1.0] or DEFAULT [DEFAULT=0.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vAmb_FMin, "C_vAmb_FMin", &
      "Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the value in the minimum region (-) [>=0.0 and <=1.0] or DEFAULT [DEFAULT=0.0]", &
      0.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      ! C_vAmb_Exp - Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the exponent in the exponential region (-) [> 0.0] or DEFAULT [DEFAULT=1.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vAmb_Exp, "C_vAmb_Exp", &
      "Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the exponent in the exponential region (-) [> 0.0] or DEFAULT [DEFAULT=1.0]", &
      1.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
        
      ! C_vShr_DMin - Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the minimum and exponential regions (-) [>=0.0] or DEFAULT [DEFAULT=2.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vShr_DMin, "C_vShr_DMin", &
      "Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the minimum and exponential regions (-) [>=0.0] or DEFAULT [DEFAULT=2.0]", &
      2.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
         
      ! C_vShr_DMax - Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the exponential and maximum regions (-) [> C_vShr_DMin] or DEFAULT [DEFAULT=11.0]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vShr_DMax, "C_vShr_DMax", &
      "Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the exponential and maximum regions (-) [> C_vShr_DMin] or DEFAULT [DEFAULT=11.0]", &
      11.0_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
         
      ! C_vShr_FMin - Calibrated parameter in the eddy viscosity filter function for the shear layer defining the value in the minimum region (-) [>=0.0 and <=1.0] or DEFAULT [DEFAULT=0.035]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vShr_FMin, "C_vShr_FMin", &
      "Calibrated parameter in the eddy viscosity filter function for the shear layer defining the value in the minimum region (-) [>=0.0 and <=1.0] or DEFAULT [DEFAULT=0.035]", &
      0.035_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
        
      ! C_vShr_Exp - Calibrated parameter in the eddy viscosity filter function for the shear layer defining the exponent in the exponential region (-) [> 0.0] or DEFAULT [DEFAULT=0.4]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_vShr_Exp, "C_vShr_Exp", &
      "Calibrated parameter in the eddy viscosity filter function for the shear layer defining the exponent in the exponential region (-) [> 0.0] or DEFAULT [DEFAULT=0.4]", &
      0.4_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
        
      ! Mod_WakeDiam - Wake diameter calculation model (-) (switch) {1: rotor diameter, 2: velocity-based, 3: mass-flux based, 4: momentum-flux based} or DEFAULT [DEFAULT=1]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%Mod_WakeDiam, "Mod_WakeDiam", &
      "Wake diameter calculation model (-) (switch) {1: rotor diameter, 2: velocity-based, 3: mass-flux based, 4: momentum-flux based} or DEFAULT [DEFAULT=1]", &
      WakeDiamMod_RotDiam, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
        
      ! C_WakeDiam - Calibrated parameter for wake diameter calculation (-) [>0.0 and <1.0] or DEFAULT [DEFAULT=0.95] [unused for Mod_WakeDiam=1]:
   CALL ReadVarWDefault( UnIn, InputFile, WD_InitInp%C_WakeDiam, "C_WakeDiam", &
      "Calibrated parameter for wake diameter calculation (-) [>0.0 and <1.0] or DEFAULT [DEFAULT=0.95] [unused for Mod_WakeDiam=1]", &
      0.95_ReKi, ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if            
                  
   !---------------------- VISUALIZATION --------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Visualization', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
      ! WrDisWind - Write disturbed wind data to <WindFilePath>/Low/Dis.t<n>.vtk etc.? (flag):
   CALL ReadVar( UnIn, InputFile, AWAE_InitInp%WrDisWind, "WrDisWind", "Write disturbed wind data to <WindFilePath>/Low/Dis.t<n>.vtk etc.? (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
      ! NOutDisWindXY - Number of XY planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXY.<n_out>.t<n>.vtk (-) [0 to 9]:
   CALL ReadVar( UnIn, InputFile, AWAE_InitInp%NOutDisWindXY, "NOutDisWindXY", "Number of XY planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXY.<n_out>.t<n>.vtk (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
     
      call allocAry( AWAE_InitInp%OutDisWindZ, AWAE_InitInp%NOutDisWindXY, "OutDisWindZ", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! OutDisWindZ - Z coordinates of XY planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindXY] [unused for NOutDisWindXY=0]:
   CALL ReadAry( UnIn, InputFile, AWAE_InitInp%OutDisWindZ, AWAE_InitInp%NOutDisWindXY, "OutDisWindZ", "Z coordinates of XY planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindXY] [unused for NOutDisWindXY=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! NOutDisWindYZ - Number of YZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisYZ.<n_out>.t<n>.vtk (-) [0 to 9]:
   CALL ReadVar( UnIn, InputFile, AWAE_InitInp%NOutDisWindYZ, "NOutDisWindYZ", "Number of YZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisYZ.<n_out>.t<n>.vtk (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
     
      call allocAry( AWAE_InitInp%OutDisWindX, AWAE_InitInp%NOutDisWindYZ, "OutDisWindX", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! OutDisWindX - X coordinates of YZ planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindYZ] [unused for NOutDisWindYZ=0]:
   CALL ReadAry( UnIn, InputFile, AWAE_InitInp%OutDisWindX, AWAE_InitInp%NOutDisWindYZ, "OutDisWindX", "X coordinates of YZ planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindYZ] [unused for NOutDisWindYZ=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      ! NOutDisWindXZ - Number of XZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXZ.<n_out>.t<n>.vtk (-) [0 to 9]:
   CALL ReadVar( UnIn, InputFile, AWAE_InitInp%NOutDisWindXZ, "NOutDisWindXZ", "Number of XZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXZ.<n_out>.t<n>.vtk (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      call allocAry( AWAE_InitInp%OutDisWindY, AWAE_InitInp%NOutDisWindXZ, "OutDisWindY", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! OutDisWindY - Y coordinates of XZ planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindXZ] [unused for NOutDisWindXZ=0]:
   CALL ReadAry( UnIn, InputFile, AWAE_InitInp%OutDisWindY, AWAE_InitInp%NOutDisWindXZ, "OutDisWindY", "Y coordinates of XZ planes for output of disturbed wind data across the low-resolution domain (m) [1 to NOutDisWindXZ] [unused for NOutDisWindXZ=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
                  
      
   !---------------------- OUTPUT --------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Output', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if

      ! ChkptTime - Amount of time between creating checkpoint files for potential restart (s) [>0.0]:
   CALL ReadVar( UnIn, InputFile, TmpTime, "ChkptTime", "Amount of time between creating checkpoint files for potential restart (s) [>0.0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      IF (TmpTime > p%TMax) THEN
         p%n_ChkptTime = HUGE(p%n_ChkptTime)
      ELSE         
         p%n_ChkptTime = NINT( TmpTime / p%DT )
      END IF
      

      ! TStart - Time to begin tabular output (s) [>=0.0]:
   CALL ReadVar( UnIn, InputFile, p%TStart, "TStart", "Time to begin tabular output (s) [>=0.0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   
      ! OutFileFmt - Format for tabular (time-marching) output file (switch) {1: text file [<RootName>.out], 2: binary file [<RootName>.outb], 3: both}:
   CALL ReadVar( UnIn, InputFile, OutFileFmt, "OutFileFmt", "Format for tabular (time-marching) output file (switch) {1: text file [<RootName>.out], 2: binary file [<RootName>.outb], 3: both}", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   
      SELECT CASE (OutFileFmt)
         CASE (1_IntKi)
            p%WrBinOutFile = .FALSE.
            p%WrTxtOutFile = .TRUE.
         CASE (2_IntKi)
            p%WrBinOutFile = .TRUE.
            p%WrTxtOutFile = .FALSE.
         CASE (3_IntKi)
            p%WrBinOutFile = .TRUE.
            p%WrTxtOutFile = .TRUE.
         CASE DEFAULT
            ! we'll check this later....
            !CALL SetErrStat( ErrID_Fatal, "FAST.Farm's OutFileFmt must be 1, 2, or 3.",ErrStat,ErrMsg,RoutineName)
            !if ( ErrStat >= AbortErrLev ) then
            !   call cleanup()
            !   RETURN        
            !end if
      END SELECT
   
      ! TabDelim - Use tab delimiters in text tabular output file? (flag) {uses spaces if False}:
   CALL ReadVar( UnIn, InputFile, TabDelim, "TabDelim", "Use tab delimiters in text tabular output file? (flag) {uses spaces if False}", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
   
      IF ( TabDelim ) THEN
         p%Delim = TAB
      ELSE
         p%Delim = ' '
      END IF
   
      ! OutFmt - Format used for text tabular output, excluding the time channel. Resulting field should be 10 characters. (quoted string):
   CALL ReadVar( UnIn, InputFile, p%OutFmt, "OutFmt", "Format used for text tabular output, excluding the time channel. Resulting field should be 10 characters. (quoted string)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      ! NOutRadii - Number of radial nodes for wake output for an individual rotor (-) [0 to 20]:
   CALL ReadVar( UnIn, InputFile, p%NOutRadii, "NOutRadii", "Number of radial nodes for wake output for an individual rotor (-) [0 to 20]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      call allocary( p%OutRadii, p%NOutRadii, "OutRadii", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! OutRadii - List of radial nodes for wake output for an individual rotor (-) [1 to NOutRadii]:
   CALL ReadAry( UnIn, InputFile, p%OutRadii, p%NOutRadii, "OutRadii", "List of radial nodes for wake output for an individual rotor (-) [1 to NOutRadii]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      ! NOutDist - Number of downstream distances for wake output for an individual rotor (-) [0 to 9]:
   CALL ReadVar( UnIn, InputFile, p%NOutDist, "NOutDist", "Number of downstream distances for wake output for an individual rotor (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      call allocary( p%OutDist, p%NOutDist, "OutDist", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! OutDist - List of downstream distances for wake output for an individual rotor (m) [1 to NOutDist] [unused for NOutDist=0]:
   CALL ReadAry( UnIn, InputFile, p%OutDist, p%NOutDist, "OutDist", "List of downstream distances for wake output for an individual rotor (m) [1 to NOutDist] [unused for NOutDist=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
            
      ! NWindVel - Number of points for wind output (-) [0 to 9]:
   CALL ReadVar( UnIn, InputFile, p%NWindVel, "NWindVel", "Number of points for wind output (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if
      
      call allocAry( p%WindVelX, p%NWindVel, "WindVelX", ErrStat2, ErrMsg2 );  CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      call allocAry( p%WindVelY, p%NWindVel, "WindVelY", ErrStat2, ErrMsg2 );  CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      call allocAry( p%WindVelZ, p%NWindVel, "WindVelZ", ErrStat2, ErrMsg2 );  CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if ( ErrStat >= AbortErrLev ) then
            call cleanup()
            RETURN        
         end if
      
      ! WindVelX - List of coordinates in the X direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]:
   CALL ReadAry( UnIn, InputFile, p%WindVelX, p%NWindVel, "WindVelX", "List of coordinates in the X direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
         
      ! WindVelY - List of coordinates in the Y direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]:
   CALL ReadAry( UnIn, InputFile, p%WindVelY, p%NWindVel, "WindVelY", "List of coordinates in the Y direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      ! WindVelZ - List of coordinates in the Z direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]:
   CALL ReadAry( UnIn, InputFile, p%WindVelZ, p%NWindVel, "WindVelZ", "List of coordinates in the Z direction for wind output (m) [1 to NWindVel] [unused for NWindVel=0]", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)      
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         RETURN        
      end if      
      
      
 !!!!!!!                  OutList            The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels (quoted string)      
      !---------------------- OUTLIST  --------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: OutList', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF

      ! OutList - List of user-requested output channels (-):
   CALL ReadOutputList ( UnIn, InputFile, OutList, p%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF      
   !---------------------- END OF FILE -----------------------------------------

   call cleanup()
   RETURN

CONTAINS
   !...............................................................................................................................
   subroutine cleanup()
      CLOSE( UnIn )
      IF ( UnEc > 0 ) CLOSE ( UnEc )   
   end subroutine cleanup
   !...............................................................................................................................
END SUBROUTINE Farm_ReadPrimaryFile
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Farm_ValidateInput( p, WD_InitInp, AWAE_InitInp, ErrStat, ErrMsg )
      ! Passed variables
   TYPE(Farm_ParameterType), INTENT(INOUT) :: p                               !< The parameter data for the FAST (glue-code) simulation
   TYPE(WD_InputFileType),   INTENT(IN   ) :: WD_InitInp                      !< input-file data for WakeDynamics module
   TYPE(AWAE_InputFileType), INTENT(IN   ) :: AWAE_InitInp                    !< input-file data for AWAE module
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

      ! Local variables:
   INTEGER(IntKi)                :: i  
   INTEGER(IntKi)                :: ErrStat2                                  ! Temporary Error status
   CHARACTER(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(*),   PARAMETER     :: RoutineName = 'Farm_ValidateInput'
   
   ErrStat = ErrID_None
   ErrMsg  = ""
   
   IF (p%DT <= 0.0_ReKi) CALL SetErrStat(ErrID_Fatal,'DT must be positive.',ErrStat,ErrMsg,RoutineName)
   IF (p%TMax < 0.0_ReKi) CALL SetErrStat(ErrID_Fatal,'TMax must not be negative.',ErrStat,ErrMsg,RoutineName)
   IF (p%NumTurbines < 1) CALL SetErrStat(ErrID_Fatal,'FAST.Farm requires at least 1 turbine. Set NumTurbines > 0.',ErrStat,ErrMsg,RoutineName)
   
   ! --- WAKE DYNAMICS ---
   IF (WD_InitInp%dr <= 0.0_ReKi) CALL SetErrStat(ErrID_Fatal,'dr (radial increment) must be larger than 0.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%NumRadii < 2) CALL SetErrStat(ErrID_Fatal,'NumRadii (number of radii) must be at least 2.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%NumPlanes < 2) CALL SetErrStat(ErrID_Fatal,'NumPlanes (number of wake planes) must be at least 2.',ErrStat,ErrMsg,RoutineName)

   IF (WD_InitInp%f_c <= 0.0_ReKi) CALL SetErrStat(ErrID_Fatal,'f_c (cut-off [corner] frequency) must be more than 0 Hz.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_NearWake <= 1.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_NearWake parameter must be greater than 1.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%k_vAmb < 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'k_vAmb parameter must not be negative.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%k_vShr < 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'k_vShr parameter must not be negative.',ErrStat,ErrMsg,RoutineName)
   
   IF (WD_InitInp%C_vAmb_DMin < 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_vAmb_DMin parameter must not be negative.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vAmb_DMax <= WD_InitInp%C_vAmb_DMin) CALL SetErrStat(ErrID_Fatal,'C_vAmb_DMax parameter must be larger than C_vAmb_DMin.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vAmb_FMin < 0.0_Reki .or. WD_InitInp%C_vAmb_FMin > 1.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_vAmb_FMin parameter must be between 0 and 1 (inclusive).',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vAmb_Exp  <= 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_vAmb_Exp parameter must be positive.',ErrStat,ErrMsg,RoutineName)

   IF (WD_InitInp%C_vShr_DMin < 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_vShr_DMin parameter must not be negative.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vShr_DMax <= WD_InitInp%C_vShr_DMin) CALL SetErrStat(ErrID_Fatal,'C_vShr_DMax parameter must be larger than C_vShr_DMin.',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vShr_FMin < 0.0_Reki .or. WD_InitInp%C_vShr_FMin > 1.0_ReKi) CALL SetErrStat(ErrID_Fatal,'C_vShr_FMin parameter must be between 0 and 1 (inclusive).',ErrStat,ErrMsg,RoutineName)
   IF (WD_InitInp%C_vShr_Exp  <= 0.0_Reki) CALL SetErrStat(ErrID_Fatal,'C_vShr_Exp parameter must be positive.',ErrStat,ErrMsg,RoutineName)

   IF (WD_InitInp%Mod_WakeDiam < WakeDiamMod_RotDiam .or. WD_InitInp%Mod_WakeDiam > WakeDiamMod_MtmFlux) THEN
      call SetErrStat(ErrID_Fatal,'Wake diameter calculation model, Mod_WakeDiam, must be 1 (rotor diameter), 2 (velocity-based), 3 (mass-flux based), 4 (momentum-flux based) or DEFAULT.',ErrStat,ErrMsg,RoutineName)
   END IF
   
   IF (WD_InitInp%Mod_WakeDiam /= WakeDiamMod_RotDiam) THEN
      IF (WD_InitInp%C_WakeDiam <= 0.0_Reki .or. WD_InitInp%C_WakeDiam >= 1.0_ReKi) THEN
         CALL SetErrStat(ErrID_Fatal,'C_vShr_FMin parameter must be between 0 and 1 (exclusive).',ErrStat,ErrMsg,RoutineName)
      END IF
   END IF
         
   !--- OUTPUT ---
   IF ( p%n_ChkptTime < 1_IntKi   ) CALL SetErrStat( ErrID_Fatal, 'ChkptTime must be greater than 0 seconds.', ErrStat, ErrMsg, RoutineName )
   IF (p%TStart < 0.0_ReKi) CALL SetErrStat(ErrID_Fatal,'TStart must not be negative.',ErrStat,ErrMsg,RoutineName)
   IF (.not. p%WrBinOutFile .and. .not. p%WrTxtOutFile) CALL SetErrStat( ErrID_Fatal, "FAST.Farm's OutFileFmt must be 1, 2, or 3.",ErrStat,ErrMsg,RoutineName)

   if (AWAE_InitInp%NOutDisWindXY < 0 .or. AWAE_InitInp%NOutDisWindXY > maxOutputPoints ) CALL SetErrStat( ErrID_Fatal, 'NOutDisWindXY must be in the range [0, 9].', ErrStat, ErrMsg, RoutineName )
   if (AWAE_InitInp%NOutDisWindYZ < 0 .or. AWAE_InitInp%NOutDisWindYZ > maxOutputPoints ) CALL SetErrStat( ErrID_Fatal, 'NOutDisWindYZ must be in the range [0, 9].', ErrStat, ErrMsg, RoutineName )
   if (AWAE_InitInp%NOutDisWindXZ < 0 .or. AWAE_InitInp%NOutDisWindXZ > maxOutputPoints ) CALL SetErrStat( ErrID_Fatal, 'NOutDisWindXZ must be in the range [0, 9].', ErrStat, ErrMsg, RoutineName )
   if (p%NOutDist < 0 .or. p%NOutDist > maxOutputPoints ) CALL SetErrStat( ErrID_Fatal, 'NOutDist must be in the range [0, 9].', ErrStat, ErrMsg, RoutineName )
   if (p%NWindVel < 0 .or. p%NWindVel > maxOutputPoints ) CALL SetErrStat( ErrID_Fatal, 'NWindVel must be in the range [0, 9].', ErrStat, ErrMsg, RoutineName )
   if (p%NOutRadii < 0 .or. p%NOutRadii > 20 ) then
      CALL SetErrStat( ErrID_Fatal, 'NOutRadii must be in the range [0, 20].', ErrStat, ErrMsg, RoutineName )
   else
      do i=1,p%NOutRadii
         if (p%OutRadii(i) > WD_InitInp%NumRadii - 1 .or. p%OutRadii(i) < 0) then
            CALL SetErrStat( ErrID_Fatal, 'OutRadii must be in the range [0, NumRadii - 1].', ErrStat, ErrMsg, RoutineName )
            exit
         end if
      end do      
   end if
   
   
   
      ! Check that OutFmt is a valid format specifier and will fit over the column headings
   CALL ChkRealFmtStr( p%OutFmt, 'OutFmt', p%FmtWidth, ErrStat2, ErrMsg2 ) !this sets p%FmtWidth!
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
   IF ( p%FmtWidth /= ChanLen ) CALL SetErrStat( ErrID_Warn, 'OutFmt produces a column width of '// &
         TRIM(Num2LStr(p%FmtWidth))//' instead of '//TRIM(Num2LStr(ChanLen))//' characters.', ErrStat, ErrMsg, RoutineName )
      
   
END SUBROUTINE Farm_ValidateInput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine initializes all instances of WakeDynamics
SUBROUTINE Farm_InitWD( farm, WD_InitInp, ErrStat, ErrMsg )


      ! Passed variables
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data
   TYPE(WD_InitInputType),   INTENT(INOUT) :: WD_InitInp                      !< init input for WakeDynamics module; input file data already filled in
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   ! local variables
   type(WD_InitOutputType)                 :: WD_InitOut

   INTEGER(IntKi)                          :: i_turb                          ! loop counter for rotor number
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'Farm_InitWD'
         
   ErrStat = ErrID_None
   ErrMsg = ""
   
   ALLOCATE(farm%WD(farm%p%NumTurbines),STAT=ErrStat2)
   if (ErrStat2 /= 0) then
      CALL SetErrStat( ErrID_Fatal, 'Could not allocate memory for Wake Dynamics data', ErrStat, ErrMsg, RoutineName )
      return
   end if
            
      !.................
      ! Initialize each instance of WD
      !................                  
      
      DO i_turb = 1,farm%p%NumTurbines
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! initialization can be done in parallel (careful for FWrap_InitInp, though)
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++         
         
         WD_InitInp%RootName    = trim(farm%p%OutFileRoot)//'.T'//num2lstr(i_turb)
         WD_InitInp%TurbNum     = i_turb
         
            ! note that WD_Init has Interval as INTENT(IN) so, we don't need to worry about overwriting farm%p%dt here:
         call WD_Init( WD_InitInp, farm%WD(i_turb)%u, farm%WD(i_turb)%p, farm%WD(i_turb)%x, farm%WD(i_turb)%xd, farm%WD(i_turb)%z, &
                          farm%WD(i_turb)%OtherSt, farm%WD(i_turb)%y, farm%WD(i_turb)%m, farm%p%dt, WD_InitOut, ErrStat2, ErrMsg2 )
         
         farm%WD(i_turb)%IsInitialized = .true.
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
            if (ErrStat >= AbortErrLev) then
               call cleanup()
               return
            end if
            
      END DO   
   
      call cleanup()
      
contains
   subroutine cleanup()
      call WD_DestroyInitOutput( WD_InitOut, ErrStat2, ErrMsg2 )
   end subroutine cleanup
END SUBROUTINE Farm_InitWD
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine initializes all instances of FAST using the FASTWrapper module
SUBROUTINE Farm_InitFAST( farm, WD_InitInp, AWAE_InitOutput, ErrStat, ErrMsg )


      ! Passed variables
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data
   TYPE(WD_InputFileType),   INTENT(IN   ) :: WD_InitInp                      !< input-file data for WakeDynamics module
   TYPE(AWAE_InitOutputType),INTENT(IN   ) :: AWAE_InitOutput                 !< initialization output from AWAE
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   ! local variables
   type(FWrap_InitInputType)               :: FWrap_InitInp
   type(FWrap_InitOutputType)              :: FWrap_InitOut

   INTEGER(IntKi)                          :: i_turb                          ! loop counter for rotor number
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'Farm_InitFAST'
   
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   ALLOCATE(farm%FWrap(farm%p%NumTurbines),STAT=ErrStat2)
   if (ErrStat2 /= 0) then
      CALL SetErrStat( ErrID_Fatal, 'Could not allocate memory for FAST Wrapper data', ErrStat, ErrMsg, RoutineName )
      return
   end if
            
      !.................
      ! Initialize each instance of FAST
      !................            
      FWrap_InitInp%nr            = WD_InitInp%NumRadii
      FWrap_InitInp%dr            = WD_InitInp%dr
      FWrap_InitInp%tmax          = farm%p%TMax
      FWrap_InitInp%n_high_low    = farm%p%n_high_low
      FWrap_InitInp%dt_high       = farm%p%dt_high
     
      FWrap_InitInp%nX_high       = AWAE_InitOutput%nX_high
      FWrap_InitInp%nY_high       = AWAE_InitOutput%nY_high
      FWrap_InitInp%nZ_high       = AWAE_InitOutput%nZ_high
      
      DO i_turb = 1,farm%p%NumTurbines
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! initialization can be done in parallel (careful for FWrap_InitInp, though)
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++         
         
         FWrap_InitInp%FASTInFile    = farm%p%WT_FASTInFile(i_turb)
         FWrap_InitInp%p_ref_Turbine = farm%p%WT_Position(:,i_turb)
         FWrap_InitInp%TurbNum       = i_turb
         FWrap_InitInp%RootName      = trim(farm%p%OutFileRoot)//'.T'//num2lstr(i_turb)
         
         
         FWrap_InitInp%p_ref_high(1) = AWAE_InitOutput%X0_high(i_turb)
         FWrap_InitInp%p_ref_high(2) = AWAE_InitOutput%Y0_high(i_turb)
         FWrap_InitInp%p_ref_high(3) = AWAE_InitOutput%Z0_high(i_turb)

         FWrap_InitInp%dX_high       = AWAE_InitOutput%dX_high(i_turb)
         FWrap_InitInp%dY_high       = AWAE_InitOutput%dY_high(i_turb)
         FWrap_InitInp%dZ_high       = AWAE_InitOutput%dZ_high(i_turb)
         
         
            ! note that FWrap_Init has Interval as INTENT(IN) so, we don't need to worry about overwriting farm%p%dt here:
         call FWrap_Init( FWrap_InitInp, farm%FWrap(i_turb)%u, farm%FWrap(i_turb)%p, farm%FWrap(i_turb)%x, farm%FWrap(i_turb)%xd, farm%FWrap(i_turb)%z, &
                          farm%FWrap(i_turb)%OtherSt, farm%FWrap(i_turb)%y, farm%FWrap(i_turb)%m, farm%p%dt, FWrap_InitOut, ErrStat2, ErrMsg2 )
         
         farm%FWrap(i_turb)%IsInitialized = .true.
         
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
            if (ErrStat >= AbortErrLev) then
               call cleanup()
               return
            end if
            
      END DO   
   
      call cleanup()
      
contains
   subroutine cleanup()
      call FWrap_DestroyInitInput( FWrap_InitInp, ErrStat2, ErrMsg2 )
      call FWrap_DestroyInitOutput( FWrap_InitOut, ErrStat2, ErrMsg2 )
   end subroutine cleanup
END SUBROUTINE Farm_InitFAST
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine performs the initial call to calculate outputs (at t=0).
!! The Initial Calculate Output algorithm: \n
!!    -  In parallel: 
!!       1. Set u_AWAE=0, CALL AWAE_CO, and transfer y_AWAE to u_F and u_WD
!!       2. Set u_SC=0, CALL SC_CO, and transfer y_SC to u_F
!!    -  CALL F_t0
!!    -  Transfer y_F to u_SC and u_WD
!!    -  CALL WD_CO
!!    -  Transfer y_WD to u_AWAE
!!    -  CALL AWAE_CO
!!    -  Transfer y_AWAE to u_F and u_WD
!!    -  Write Output to File
subroutine FARM_InitialCO(farm, ErrStat, ErrMsg)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   INTEGER(IntKi)                          :: i_turb                    
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'FARM_InitialCO'
   
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   
   !.......................................................................................
   ! Initial calls to AWAE and SC modules (steps 1. and 2. can be done in parallel)
   !.......................................................................................
   
      !--------------------
      ! 1a. u_AWAE=0         
   farm%AWAE%u%xhat_plane = 0.0_ReKi     ! Orientations of wake planes, normal to wake planes, for each turbine
   farm%AWAE%u%p_plane    = 0.0_ReKi     ! Center positions of wake planes for each turbine
   farm%AWAE%u%Vx_wake    = 0.0_ReKi     ! Axial wake velocity deficit at wake planes, distributed radially, for each turbine
   farm%AWAE%u%Vr_wake    = 0.0_ReKi     ! Radial wake velocity deficit at wake planes, distributed radially, for each turbine
   farm%AWAE%u%D_wake     = 0.0_ReKi     ! Wake diameters at wake planes for each turbine      
   
      !--------------------
      ! 1b. CALL AWAE_CO         
   call AWAE_CalcOutput( 0.0_DbKi, farm%AWAE%u, farm%AWAE%p, farm%AWAE%x, farm%AWAE%xd, farm%AWAE%z, &
                     farm%AWAE%OtherSt, farm%AWAE%y, farm%AWAE%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

      !--------------------
      ! 1c. transfer y_AWAE to u_F and u_WD         
   
   call Transfer_AWAE_to_FAST(farm)      
   call Transfer_AWAE_to_WD(farm)   
   
      !--------------------
      ! 2a. u_SC=0         

      !--------------------
      ! 2b. CALL SC_CO         

      !--------------------
      ! 2c. transfer y_SC to u_F         
   
   !DO i_turb = 1,farm%p%NumTurbines
   !   farm%FWrap(i_turb)%u%FromSC_Global =
   !   farm%FWrap(i_turb)%u%FromSC_Turbine =
   !END DO
   
   !.......................................................................................
   ! CALL F_t0 (can be done in parallel)
   !.......................................................................................
         
   DO i_turb = 1,farm%p%NumTurbines
      
      call FWrap_t0( farm%FWrap(i_turb)%u, farm%FWrap(i_turb)%p, farm%FWrap(i_turb)%x, farm%FWrap(i_turb)%xd, farm%FWrap(i_turb)%z, &
                     farm%FWrap(i_turb)%OtherSt, farm%FWrap(i_turb)%y, farm%FWrap(i_turb)%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
               
   END DO
   if (ErrStat >= AbortErrLev) return
   
   !.......................................................................................
   ! Transfer y_F to u_SC and u_WD (can be done in parallel)
   !.......................................................................................
      
      !--------------------
      ! 1.  Transfer y_F to u_SC     
   
   !DO i_turb = 1,farm%p%NumTurbines   
   !   = farm%FWrap(i_turb)%y%ToSC_Turbine   
   !END DO
   
      !--------------------
      ! 2.  Transfer y_F to u_WD     
   
   call Transfer_FAST_to_WD(farm)
      
   !.......................................................................................
   ! CALL WD_CO (can be done in parallel)
   !.......................................................................................
   
   DO i_turb = 1,farm%p%NumTurbines
      
      call WD_CalcOutput( 0.0_DbKi, farm%WD(i_turb)%u, farm%WD(i_turb)%p, farm%WD(i_turb)%x, farm%WD(i_turb)%xd, farm%WD(i_turb)%z, &
                     farm%WD(i_turb)%OtherSt, farm%WD(i_turb)%y, farm%WD(i_turb)%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
               
   END DO
   if (ErrStat >= AbortErrLev) return
   
   !.......................................................................................
   ! Transfer y_WD to u_AWAE
   !.......................................................................................
   
   call Transfer_WD_to_AWAE(farm)
   
   !.......................................................................................
   ! CALL AWAE_CO
   !.......................................................................................
   
   call AWAE_CalcOutput( 0.0_DbKi, farm%AWAE%u, farm%AWAE%p, farm%AWAE%x, farm%AWAE%xd, farm%AWAE%z, &
                     farm%AWAE%OtherSt, farm%AWAE%y, farm%AWAE%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   
   !.......................................................................................
   ! Transfer y_AWAE to u_F and u_WD
   !.......................................................................................
   
   call Transfer_AWAE_to_FAST(farm)              
   call Transfer_AWAE_to_WD(farm)   
   
   !.......................................................................................
   ! Write Output to File
   !.......................................................................................
   
   call Farm_WriteOutput(0.0_DbKi, farm, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   
end subroutine FARM_InitialCO
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine updates states each time increment.
!! The update states algorithm: \n
!!    -  In parallel: 
!!       1. call WD_US
!!       2. call SC_US
!!       3. call F_Increment
!!    -  \f$ n = n + 1 \f$
!!    -  \f$ t = t + \Delta t \f$
subroutine FARM_UpdateStates(t, n, farm, ErrStat, ErrMsg)
   REAL(DbKi),               INTENT(IN   ) :: t                               !< Current simulation time in seconds
   INTEGER(IntKi),           INTENT(IN   ) :: n                               !< Current step of the simulation: t = n*Interval
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   INTEGER(IntKi)                          :: i_turb                    
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'FARM_UpdateStates'
   
   
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   !.......................................................................................
   ! update module states (steps 1. and 2. and 3. can be done in parallel)
   !.......................................................................................
   
      !--------------------
      ! 1. CALL WD_US         
   
   DO i_turb = 1,farm%p%NumTurbines
      
      call WD_UpdateStates( t, n, farm%WD(i_turb)%u, farm%WD(i_turb)%p, farm%WD(i_turb)%x, farm%WD(i_turb)%xd, farm%WD(i_turb)%z, &
                     farm%WD(i_turb)%OtherSt, farm%WD(i_turb)%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
               
   END DO
   if (ErrStat >= AbortErrLev) return
   
   
      !--------------------
      ! 2. CALL SC_US         
   

      !--------------------
      ! 3. CALL F_Increment         
         
   DO i_turb = 1,farm%p%NumTurbines
      
      call FWrap_Increment( t, n, farm%FWrap(i_turb)%u, farm%FWrap(i_turb)%p, farm%FWrap(i_turb)%x, farm%FWrap(i_turb)%xd, farm%FWrap(i_turb)%z, &
                     farm%FWrap(i_turb)%OtherSt, farm%FWrap(i_turb)%y, farm%FWrap(i_turb)%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
               
   END DO
   if (ErrStat >= AbortErrLev) return
      
   
end subroutine FARM_UpdateStates

subroutine Farm_WriteOutput(t, farm, ErrStat, ErrMsg)

   REAL(DbKi),               INTENT(IN   ) :: t                               !< Current simulation time in seconds
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message
                
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'FARM_WriteOutput'
   INTEGER(IntKi)                          :: i_turb, ir, iOutDist, i_plane, iVelPt  ! Loop counters
   REAL(ReKi)                              :: vel(3), pt(3)
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
      ! If requested write output channel data
   if ( farm%p%NumOuts > 0 ) then
    
      
         ! Define the output channel specifying the current simulation time:
      farm%m%AllOuts(  Time) = REAL( t, ReKi )

      do i_turb = 1, farm%p%NumTurbines
         
         !.......................................................................................
         ! Super controller Outputs
         !.......................................................................................
             
            ! TODO: Add super controller outputs

         !.......................................................................................
         ! Wind Turbine and its Inflow
         !.......................................................................................

            ! Orientation of rotor centerline, normal to disk
         farm%m%AllOuts(RtAxsXT(i_turb)) = farm%FWrap(i_turb)%y%xHat_Disk(1)
         farm%m%AllOuts(RtAxsYT(i_turb)) = farm%FWrap(i_turb)%y%xHat_Disk(2)
         farm%m%AllOuts(RtAxsZT(i_turb)) = farm%FWrap(i_turb)%y%xHat_Disk(3)
         
            ! Center position of hub, m
         farm%m%AllOuts(RtPosXT(i_turb)) = farm%FWrap(i_turb)%y%p_hub(1)
         farm%m%AllOuts(RtPosYT(i_turb)) = farm%FWrap(i_turb)%y%p_hub(2)
         farm%m%AllOuts(RtPosZT(i_turb)) = farm%FWrap(i_turb)%y%p_hub(3)
         
            ! Rotor diameter, m
         farm%m%AllOuts(RtDiamT(i_turb)) = farm%FWrap(i_turb)%y%D_rotor
         
            ! Nacelle-yaw error at the wake planes, deg 
         farm%m%AllOuts(YawErrT(i_turb)) = farm%FWrap(i_turb)%y%YawErr*R2D
         
            ! Ambient turbulence intensity of the wind at the rotor disk, percent
            ! TODO: Is this really in percent form? GJH 3/21/2017
         farm%m%AllOuts(TIAmbT(i_turb))  = farm%AWAE%y%TI_amb(i_turb)
         
            ! Rotor-disk-averaged ambient wind speed (normal to disk, not including structural motion, local induction or wakes from upstream turbines), m/s
         farm%m%AllOuts(RtVAmbT(i_turb)) = farm%AWAE%y%Vx_wind_disk(i_turb)
         
            ! Rotor-disk-averaged relative wind speed (normal to disk, including structural motion and wakes from upstream turbines, but not including local induction), m/s
         farm%m%AllOuts(RtVRelT(i_turb)) = farm%FWrap(i_turb)%y%DiskAvg_Vx_Rel
         
            ! Azimuthally averaged thrust force coefficient (normal to disk), distributed radially, -
         do ir = 1, farm%p%NOutRadii
            farm%m%AllOuts(CtTN(ir, i_turb)) = farm%FWrap(i_turb)%y%AzimAvg_Ct(farm%p%OutRadii(ir))
         end do
         
         !.......................................................................................
         ! Wake (for an Individual Rotor)
         !.......................................................................................
         
            ! Loop over user-requested, downstream distances (OutDist), m   
         do iOutDist = 1, farm%p%NOutDist
            
            if (  farm%p%OutDist(iOutDist) >= farm%WD(i_turb)%xd%x_plane(farm%WD(i_turb)%p%NumPlanes-1) ) then
               ! TODO: Handle this case. Invalid output
               
               farm%m%AllOuts(WkAxsXTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkAxsYTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkAxsZTD(iOutDist,i_turb)) = 0.0_ReKi
                                                           
                  ! Center position of the wake centerline 
               farm%m%AllOuts(WkPosXTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkPosYTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkPosZTD(iOutDist,i_turb)) = 0.0_ReKi
                                                           
                  ! Advection, deflection, and meandering  
                  !  of the wake for downstream wake volum 
               farm%m%AllOuts(WkVelXTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkVelYTD(iOutDist,i_turb)) = 0.0_ReKi
               farm%m%AllOuts(WkVelZTD(iOutDist,i_turb)) = 0.0_ReKi
                                                           
                  ! Wake diameter for downstream wake volu 
               farm%m%AllOuts(WkDiamTD(iOutDist,i_turb)) = 0.0_ReKi
               
               do ir = 1, farm%p%NOutRadii
                  
                     ! Axial and radial wake velocity deficits for radial node, OutRadii(ir), and downstream wake volume, i_plane, of turbine, i_turb, m/s
                  farm%m%AllOuts(WkDfVxTND(ir,iOutDist,i_turb)) = 0.0_ReKi
                  farm%m%AllOuts(WkDfVrTND(ir,iOutDist,i_turb)) = 0.0_ReKi
               
                     ! Total eddy viscosity, and individual contributions to the eddy viscosity from ambient turbulence and the shear layer, 
                     !  or radial node, OutRadii(ir), and downstream wake volume, i_plane, of turbine, i_turb, m/s
                  farm%m%AllOuts(EddVisTND(ir,iOutDist,i_turb)) = 0.0_ReKi
                  farm%m%AllOuts(EddAmbTND(ir,iOutDist,i_turb)) = 0.0_ReKi
                  farm%m%AllOuts(EddShrTND(ir,iOutDist,i_turb)) = 0.0_ReKi
                  
               end do  

            else
               
               ! TODO: Verify with Jason that all of this should be within the else block. GJH 
               
                  ! Find wake volume which contains the user-requested downstream location.
               do i_plane = 0, farm%WD(i_turb)%p%NumPlanes-2 
                  if ( ( farm%p%OutDist(iOutDist) >= farm%WD(i_turb)%xd%x_plane(i_plane) ) .and. ( farm%p%OutDist(iOutDist) < farm%WD(i_turb)%xd%x_plane(i_plane+1) ) ) exit
               end do           
            
                  ! Orientation of the wake centerline for downstream wake volume, i_plane, of turbine, i_turb, in the global coordinate system, -
               farm%m%AllOuts(WkAxsXTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%xhat_plane(1, i_plane) !farm%AWAE%u%xhat_plane(1,i_plane,i_turb)
               farm%m%AllOuts(WkAxsYTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%xhat_plane(2, i_plane) !farm%AWAE%u%xhat_plane(2,i_plane,i_turb)
               farm%m%AllOuts(WkAxsZTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%xhat_plane(3, i_plane) !farm%AWAE%u%xhat_plane(3,i_plane,i_turb)

                  ! Center position of the wake centerline for downstream wake volume, i_plane, of turbine, i_turb, in the global coordinate system, m
               farm%m%AllOuts(WkPosXTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%p_plane(1, i_plane)    !farm%AWAE%u%p_plane(1,i_plane,i_turb)
               farm%m%AllOuts(WkPosYTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%p_plane(2, i_plane)    !farm%AWAE%u%p_plane(2,i_plane,i_turb)
               farm%m%AllOuts(WkPosZTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%p_plane(3, i_plane)    !farm%AWAE%u%p_plane(3,i_plane,i_turb)

                  ! Advection, deflection, and meandering velocity (not including the horizontal wake-deflection correction) 
                  !  of the wake for downstream wake volume, i_plane, of turbine, i_turb, in the global coordinate system, m/s
               farm%m%AllOuts(WkVelXTD(iOutDist,i_turb)) = farm%AWAE%y%V_plane(1,i_plane,i_turb)
               farm%m%AllOuts(WkVelYTD(iOutDist,i_turb)) = farm%AWAE%y%V_plane(2,i_plane,i_turb)
               farm%m%AllOuts(WkVelZTD(iOutDist,i_turb)) = farm%AWAE%y%V_plane(3,i_plane,i_turb)

                  ! Wake diameter for downstream wake volume, i_plane, of turbine, i_turb, m
               farm%m%AllOuts(WkDiamTD(iOutDist,i_turb)) = farm%WD(i_turb)%y%D_wake(i_plane)  !farm%AWAE%u%D_wake(i_plane,i_turb)
            
                  
               do ir = 1, farm%p%NOutRadii
                  
                     ! Axial and radial wake velocity deficits for radial node, OutRadii(ir), and downstream wake volume, i_plane, of turbine, i_turb, m/s
                  farm%m%AllOuts(WkDfVxTND(ir,iOutDist,i_turb)) = farm%WD(i_turb)%y%Vx_wake(farm%p%OutRadii(ir),i_plane) !farm%AWAE%u%Vx_wake(farm%p%OutRadii(ir),i_plane,i_turb)
                  farm%m%AllOuts(WkDfVrTND(ir,iOutDist,i_turb)) = farm%WD(i_turb)%y%Vr_wake(farm%p%OutRadii(ir),i_plane) !farm%AWAE%u%Vr_wake(farm%p%OutRadii(ir),i_plane,i_turb)
               
                     ! Total eddy viscosity, and individual contributions to the eddy viscosity from ambient turbulence and the shear layer, 
                     !  or radial node, OutRadii(ir), and downstream wake volume, i_plane, of turbine, i_turb, m/s
                  farm%m%AllOuts(EddVisTND(ir,iOutDist,i_turb)) = farm%WD(i_turb)%m%vt_tot(farm%p%OutRadii(ir),i_plane)
                  farm%m%AllOuts(EddAmbTND(ir,iOutDist,i_turb)) = farm%WD(i_turb)%m%vt_amb(farm%p%OutRadii(ir),i_plane)
                  farm%m%AllOuts(EddShrTND(ir,iOutDist,i_turb)) = farm%WD(i_turb)%m%vt_shr(farm%p%OutRadii(ir),i_plane)
                  
               end do  
            end if
         end do
      end do
      
      !.......................................................................................
      ! Ambient Wind and Array Effects
      !.......................................................................................
      
         ! Loop over user-requested, velocity locations  
      do iVelPt = 1, farm%p%NWindVel        
         
            ! Determine the requested pt in grid coordinates
         pt = (/farm%p%WindVelX(iVelPt), farm%p%WindVelY(iVelPt),farm%p%WindVelZ(iVelPt)/)
         pt(1) = (pt(1) - farm%p%X0_low)/ farm%p%dX_low
         pt(2) = (pt(2) - farm%p%Y0_low)/ farm%p%dY_low
         pt(3) = (pt(3) - farm%p%Z0_low)/ farm%p%dZ_low
         
            ! Ambient wind velocity (not including wakes) for point, pt,  in global coordinates (from the low-resolution domain), m/s
         call TrilinearInterpRegGrid(farm%AWAE%m%Vamb_low, pt, (/farm%p%nX_low,farm%p%nY_low,farm%p%nZ_low/), vel)
         farm%m%AllOuts(WVAmbX(iVelPt)) = vel(1)
         farm%m%AllOuts(WVAmbY(iVelPt)) = vel(2)
         farm%m%AllOuts(WVAmbZ(iVelPt)) = vel(3)
         
            ! Disturbed wind velocity (including wakes) for point, pt,  in global coordinates (from the low-resolution domain), m/s
         call TrilinearInterpRegGrid(farm%AWAE%m%Vdist_low, pt, (/farm%p%nX_low,farm%p%nY_low,farm%p%nZ_low/), vel)
         farm%m%AllOuts(WVDisX(iVelPt)) = vel(1)
         farm%m%AllOuts(WVDisY(iVelPt)) = vel(2)
         farm%m%AllOuts(WVDisZ(iVelPt)) = vel(3)
            
              
      end do
      
      

      
      call WriteFarmOutputToFile(t, farm, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         
   end if
end subroutine Farm_WriteOutput

!----------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates outputs at each time increment and solves for the inputs at the next step.
!! The calculate output algorithm: \n
!!    -  In parallel: 
!!       1. call WD_CO and transfer y_WD to u_AWAE
!!       2. call SC_CO and transfer y_SC to u_F
!!       3. Transfer y_F to u_SC and u_WD
!!    -  CALL AWAE_CO
!!    -  Transfer y_AWAE to u_F and u_WD
!!    -  Write Output to File
subroutine FARM_CalcOutput(t, farm, ErrStat, ErrMsg)
   REAL(DbKi),               INTENT(IN   ) :: t                               !< Current simulation time in seconds
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   INTEGER(IntKi)                          :: i_turb                    
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'FARM_CalcOutput'
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   !.......................................................................................
   ! calculate module outputs and perform some input-output solves (steps 1. and 2. and 3. can be done in parallel,
   !  but be careful that step 3 doesn't modify the inputs to steps 1 or 2)
   !.......................................................................................
   
      !--------------------
      ! 1. call WD_CO and transfer y_WD to u_AWAE        
   
   DO i_turb = 1,farm%p%NumTurbines
      
      call WD_CalcOutput( t, farm%WD(i_turb)%u, farm%WD(i_turb)%p, farm%WD(i_turb)%x, farm%WD(i_turb)%xd, farm%WD(i_turb)%z, &
                     farm%WD(i_turb)%OtherSt, farm%WD(i_turb)%y, farm%WD(i_turb)%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
               
   END DO
   if (ErrStat >= AbortErrLev) return

   call Transfer_WD_to_AWAE(farm)
   
      !--------------------
      ! 2. call SC_CO and transfer y_SC to u_F         
   

      !--------------------
      ! 3. Transfer y_F to u_SC and u_WD         
         
   call Transfer_FAST_to_WD(farm)
         
   !.......................................................................................
   ! calculate AWAE outputs and perform rest of input-output solves
   !.......................................................................................
   
      !--------------------
      ! 1. call AWAE_CO 
   call AWAE_CalcOutput( t, farm%AWAE%u, farm%AWAE%p, farm%AWAE%x, farm%AWAE%xd, farm%AWAE%z, &
                     farm%AWAE%OtherSt, farm%AWAE%y, farm%AWAE%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

      !--------------------
      ! 2. Transfer y_AWAE to u_F  and u_WD   
   call Transfer_AWAE_to_FAST(farm)      
   call Transfer_AWAE_to_WD(farm)   
   
   
   !.......................................................................................
   ! Write Output to File
   !.......................................................................................
      ! NOTE: Visualization data is output via the AWAE module

   call Farm_WriteOutput(t, farm, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   
   
   
end subroutine FARM_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine ends the modules used in this simulation. It does not exit the program.
!!    -  In parallel: 
!!       1. CALL AWAE_End
!!       2. CALL WD_End
!!       3. CALL SC_End
!!       4. CALL F_End
!!    -  Close Output File   
subroutine FARM_End(farm, ErrStat, ErrMsg)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm  
   INTEGER(IntKi),           INTENT(  OUT) :: ErrStat                         !< Error status
   CHARACTER(*),             INTENT(  OUT) :: ErrMsg                          !< Error message

   INTEGER(IntKi)                          :: i_turb                    
   INTEGER(IntKi)                          :: ErrStat2                        ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                         ! Temporary Error message
   CHARACTER(*),   PARAMETER               :: RoutineName = 'FARM_End'
   
   
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   !.......................................................................................
   ! end all modules (1-4 can be done in parallel) 
   !.......................................................................................
   
      !--------------
      ! 1. end AWAE   
   if (farm%AWAE%IsInitialized) then      
      call AWAE_End( farm%AWAE%u, farm%AWAE%p, farm%AWAE%x, farm%AWAE%xd, farm%AWAE%z, &
                     farm%AWAE%OtherSt, farm%AWAE%y, farm%AWAE%m, ErrStat2, ErrMsg2 )         
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end if      
      
   
      !--------------
      ! 2. end WakeDynamics
   if (allocated(farm%WD)) then
      
      DO i_turb = 1,farm%p%NumTurbines
         if (farm%WD(i_turb)%IsInitialized) then      
            call WD_End( farm%WD(i_turb)%u, farm%WD(i_turb)%p, farm%WD(i_turb)%x, farm%WD(i_turb)%xd, farm%WD(i_turb)%z, &
                         farm%WD(i_turb)%OtherSt, farm%WD(i_turb)%y, farm%WD(i_turb)%m, ErrStat2, ErrMsg2 )         
               call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
         end if      
      END DO
      
   end if
   
      !--------------
      ! 3. End supercontroller
   
   !CALL SC_End()
   
      !--------------
      ! 4. End each instance of FAST (each instance of FAST can be done in parallel, too)   
   if (allocated(farm%FWrap)) then
      
      DO i_turb = 1,farm%p%NumTurbines
         if (farm%FWrap(i_turb)%IsInitialized) then
            CALL FWrap_End( farm%FWrap(i_turb)%u, farm%FWrap(i_turb)%p, farm%FWrap(i_turb)%x, farm%FWrap(i_turb)%xd, farm%FWrap(i_turb)%z, &
                            farm%FWrap(i_turb)%OtherSt, farm%FWrap(i_turb)%y, farm%FWrap(i_turb)%m, ErrStat2, ErrMsg2 )
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
         end if
      END DO
      
   end if   
   
   !.......................................................................................
   ! close output file
   !.......................................................................................
   call Farm_EndOutput( farm, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, 'T'//trim(num2lstr(i_turb))//':'//RoutineName)
end subroutine FARM_End
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Transfer_FAST_to_WD(farm)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  

   integer(intKi)  :: i_turb
   
   DO i_turb = 1,farm%p%NumTurbines   
      farm%WD(i_turb)%u%xhat_disk      = farm%FWrap(i_turb)%y%xHat_Disk       ! Orientation of rotor centerline, normal to disk
      farm%WD(i_turb)%u%p_hub          = farm%FWrap(i_turb)%y%p_hub           ! Center position of hub, m
      farm%WD(i_turb)%u%D_rotor        = farm%FWrap(i_turb)%y%D_rotor         ! Rotor diameter, m
      farm%WD(i_turb)%u%Vx_rel_disk    = farm%FWrap(i_turb)%y%DiskAvg_Vx_Rel  ! Rotor-disk-averaged relative wind speed (ambient + deficits + motion), normal to disk, m/s
      farm%WD(i_turb)%u%Ct_azavg       = farm%FWrap(i_turb)%y%AzimAvg_Ct      ! Azimuthally averaged thrust force coefficient (normal to disk), distributed radially, -
      farm%WD(i_turb)%u%YawErr         = farm%FWrap(i_turb)%y%YawErr          ! Nacelle-yaw error at the wake planes, rad   
   END DO
   
END SUBROUTINE Transfer_FAST_to_WD
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Transfer_AWAE_to_WD(farm)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  

   integer(intKi)  :: i_turb
   
   DO i_turb = 1,farm%p%NumTurbines
      farm%WD(i_turb)%u%V_plane      = farm%AWAE%y%V_plane(:,:,i_turb)   ! Advection, deflection, and meandering velocity of wake planes, m/s
      farm%WD(i_turb)%u%Vx_wind_disk = farm%AWAE%y%Vx_wind_disk(i_turb)  ! Rotor-disk-averaged ambient wind speed, normal to planes, m/s
      farm%WD(i_turb)%u%TI_amb       = farm%AWAE%y%TI_amb(i_turb)        ! Ambient turbulence intensity of wind at rotor disk
   END DO
   
END SUBROUTINE Transfer_AWAE_to_WD
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Transfer_AWAE_to_FAST(farm)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  

   integer(intKi)  :: i_turb
   
   DO i_turb = 1,farm%p%NumTurbines
         ! allocated in FAST's IfW initialization as 3,x,y,z,t
      farm%FWrap(i_turb)%u%Vdist_High = farm%AWAE%y%Vdist_High(:,:,:,:,:,i_turb)
   END DO
   
END SUBROUTINE Transfer_AWAE_to_FAST
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Transfer_WD_to_AWAE(farm)
   type(All_FastFarm_Data),  INTENT(INOUT) :: farm                            !< FAST.Farm data  

   integer(intKi)  :: i_turb
   
   DO i_turb = 1,farm%p%NumTurbines   
      farm%AWAE%u%xhat_plane(:,:,i_turb) = farm%WD(i_turb)%y%xhat_plane     ! Orientations of wake planes, normal to wake planes, for each turbine
      farm%AWAE%u%p_plane(:,:,i_turb)    = farm%WD(i_turb)%y%p_plane        ! Center positions of wake planes for each turbine
      farm%AWAE%u%Vx_wake(:,:,i_turb)    = farm%WD(i_turb)%y%Vx_wake        ! Axial wake velocity deficit at wake planes, distributed radially, for each turbine
      farm%AWAE%u%Vr_wake(:,:,i_turb)    = farm%WD(i_turb)%y%Vr_wake        ! Radial wake velocity deficit at wake planes, distributed radially, for each turbine
      farm%AWAE%u%D_wake(:,i_turb)       = farm%WD(i_turb)%y%D_wake         ! Wake diameters at wake planes for each turbine      
   END DO
   
END SUBROUTINE Transfer_WD_to_AWAE
!----------------------------------------------------------------------------------------------------------------------------------
END MODULE FAST_Farm_Subs
!**********************************************************************************************************************************
