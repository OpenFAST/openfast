!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2015  National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!**********************************************************************************************************************************
!> This module contains the input/output parameters and routines for the BeamDyn module.
MODULE BeamDyn_IO

   USE BeamDyn_Types
   USE BeamDyn_Subs
   USE NWTC_Library

   IMPLICIT NONE

   TYPE(ProgDesc), PARAMETER:: BeamDyn_Ver = ProgDesc('BeamDyn', 'v1.01.00','15-Dec-2015')


! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 29-Sep-2015 10:23:41.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =   0


     ! Reaction Loads:

   INTEGER(IntKi), PARAMETER      :: RootFxr   =   1
   INTEGER(IntKi), PARAMETER      :: RootFyr   =   2
   INTEGER(IntKi), PARAMETER      :: RootFzr   =   3
   INTEGER(IntKi), PARAMETER      :: RootMxr   =   4
   INTEGER(IntKi), PARAMETER      :: RootMyr   =   5
   INTEGER(IntKi), PARAMETER      :: RootMzr   =   6


     ! Tip Motions:

   INTEGER(IntKi), PARAMETER      :: TipTDxr   =   7
   INTEGER(IntKi), PARAMETER      :: TipTDyr   =   8
   INTEGER(IntKi), PARAMETER      :: TipTDzr   =   9
   INTEGER(IntKi), PARAMETER      :: TipRDxr   =  10
   INTEGER(IntKi), PARAMETER      :: TipRDyr   =  11
   INTEGER(IntKi), PARAMETER      :: TipRDzr   =  12
   INTEGER(IntKi), PARAMETER      :: TipTVXg   =  13
   INTEGER(IntKi), PARAMETER      :: TipTVYg   =  14
   INTEGER(IntKi), PARAMETER      :: TipTVZg   =  15
   INTEGER(IntKi), PARAMETER      :: TipRVXg   =  16
   INTEGER(IntKi), PARAMETER      :: TipRVYg   =  17
   INTEGER(IntKi), PARAMETER      :: TipRVZg   =  18
   INTEGER(IntKi), PARAMETER      :: TipTAXg   =  19
   INTEGER(IntKi), PARAMETER      :: TipTAYg   =  20
   INTEGER(IntKi), PARAMETER      :: TipTAZg   =  21
   INTEGER(IntKi), PARAMETER      :: TipRAXg   =  22
   INTEGER(IntKi), PARAMETER      :: TipRAYg   =  23
   INTEGER(IntKi), PARAMETER      :: TipRAZg   =  24


     ! Sectional Loads:

   INTEGER(IntKi), PARAMETER      :: N1Fxl     =  25
   INTEGER(IntKi), PARAMETER      :: N1Fyl     =  26
   INTEGER(IntKi), PARAMETER      :: N1Fzl     =  27
   INTEGER(IntKi), PARAMETER      :: N2Fxl     =  28
   INTEGER(IntKi), PARAMETER      :: N2Fyl     =  29
   INTEGER(IntKi), PARAMETER      :: N2Fzl     =  30
   INTEGER(IntKi), PARAMETER      :: N3Fxl     =  31
   INTEGER(IntKi), PARAMETER      :: N3Fyl     =  32
   INTEGER(IntKi), PARAMETER      :: N3Fzl     =  33
   INTEGER(IntKi), PARAMETER      :: N4Fxl     =  34
   INTEGER(IntKi), PARAMETER      :: N4Fyl     =  35
   INTEGER(IntKi), PARAMETER      :: N4Fzl     =  36
   INTEGER(IntKi), PARAMETER      :: N5Fxl     =  37
   INTEGER(IntKi), PARAMETER      :: N5Fyl     =  38
   INTEGER(IntKi), PARAMETER      :: N5Fzl     =  39
   INTEGER(IntKi), PARAMETER      :: N6Fxl     =  40
   INTEGER(IntKi), PARAMETER      :: N6Fyl     =  41
   INTEGER(IntKi), PARAMETER      :: N6Fzl     =  42
   INTEGER(IntKi), PARAMETER      :: N7Fxl     =  43
   INTEGER(IntKi), PARAMETER      :: N7Fyl     =  44
   INTEGER(IntKi), PARAMETER      :: N7Fzl     =  45
   INTEGER(IntKi), PARAMETER      :: N8Fxl     =  46
   INTEGER(IntKi), PARAMETER      :: N8Fyl     =  47
   INTEGER(IntKi), PARAMETER      :: N8Fzl     =  48
   INTEGER(IntKi), PARAMETER      :: N9Fxl     =  49
   INTEGER(IntKi), PARAMETER      :: N9Fyl     =  50
   INTEGER(IntKi), PARAMETER      :: N9Fzl     =  51
   INTEGER(IntKi), PARAMETER      :: N1Mxl     =  52
   INTEGER(IntKi), PARAMETER      :: N1Myl     =  53
   INTEGER(IntKi), PARAMETER      :: N1Mzl     =  54
   INTEGER(IntKi), PARAMETER      :: N2Mxl     =  55
   INTEGER(IntKi), PARAMETER      :: N2Myl     =  56
   INTEGER(IntKi), PARAMETER      :: N2Mzl     =  57
   INTEGER(IntKi), PARAMETER      :: N3Mxl     =  58
   INTEGER(IntKi), PARAMETER      :: N3Myl     =  59
   INTEGER(IntKi), PARAMETER      :: N3Mzl     =  60
   INTEGER(IntKi), PARAMETER      :: N4Mxl     =  61
   INTEGER(IntKi), PARAMETER      :: N4Myl     =  62
   INTEGER(IntKi), PARAMETER      :: N4Mzl     =  63
   INTEGER(IntKi), PARAMETER      :: N5Mxl     =  64
   INTEGER(IntKi), PARAMETER      :: N5Myl     =  65
   INTEGER(IntKi), PARAMETER      :: N5Mzl     =  66
   INTEGER(IntKi), PARAMETER      :: N6Mxl     =  67
   INTEGER(IntKi), PARAMETER      :: N6Myl     =  68
   INTEGER(IntKi), PARAMETER      :: N6Mzl     =  69
   INTEGER(IntKi), PARAMETER      :: N7Mxl     =  70
   INTEGER(IntKi), PARAMETER      :: N7Myl     =  71
   INTEGER(IntKi), PARAMETER      :: N7Mzl     =  72
   INTEGER(IntKi), PARAMETER      :: N8Mxl     =  73
   INTEGER(IntKi), PARAMETER      :: N8Myl     =  74
   INTEGER(IntKi), PARAMETER      :: N8Mzl     =  75
   INTEGER(IntKi), PARAMETER      :: N9Mxl     =  76
   INTEGER(IntKi), PARAMETER      :: N9Myl     =  77
   INTEGER(IntKi), PARAMETER      :: N9Mzl     =  78


     ! Sectional Motions:

   INTEGER(IntKi), PARAMETER      :: N1TDxr    =  79
   INTEGER(IntKi), PARAMETER      :: N1TDyr    =  80
   INTEGER(IntKi), PARAMETER      :: N1TDzr    =  81
   INTEGER(IntKi), PARAMETER      :: N2TDxr    =  82
   INTEGER(IntKi), PARAMETER      :: N2TDyr    =  83
   INTEGER(IntKi), PARAMETER      :: N2TDzr    =  84
   INTEGER(IntKi), PARAMETER      :: N3TDxr    =  85
   INTEGER(IntKi), PARAMETER      :: N3TDyr    =  86
   INTEGER(IntKi), PARAMETER      :: N3TDzr    =  87
   INTEGER(IntKi), PARAMETER      :: N4TDxr    =  88
   INTEGER(IntKi), PARAMETER      :: N4TDyr    =  89
   INTEGER(IntKi), PARAMETER      :: N4TDzr    =  90
   INTEGER(IntKi), PARAMETER      :: N5TDxr    =  91
   INTEGER(IntKi), PARAMETER      :: N5TDyr    =  92
   INTEGER(IntKi), PARAMETER      :: N5TDzr    =  93
   INTEGER(IntKi), PARAMETER      :: N6TDxr    =  94
   INTEGER(IntKi), PARAMETER      :: N6TDyr    =  95
   INTEGER(IntKi), PARAMETER      :: N6TDzr    =  96
   INTEGER(IntKi), PARAMETER      :: N7TDxr    =  97
   INTEGER(IntKi), PARAMETER      :: N7TDyr    =  98
   INTEGER(IntKi), PARAMETER      :: N7TDzr    =  99
   INTEGER(IntKi), PARAMETER      :: N8TDxr    = 100
   INTEGER(IntKi), PARAMETER      :: N8TDyr    = 101
   INTEGER(IntKi), PARAMETER      :: N8TDzr    = 102
   INTEGER(IntKi), PARAMETER      :: N9TDxr    = 103
   INTEGER(IntKi), PARAMETER      :: N9TDyr    = 104
   INTEGER(IntKi), PARAMETER      :: N9TDzr    = 105
   INTEGER(IntKi), PARAMETER      :: N1RDxr    = 106
   INTEGER(IntKi), PARAMETER      :: N1RDyr    = 107
   INTEGER(IntKi), PARAMETER      :: N1RDzr    = 108
   INTEGER(IntKi), PARAMETER      :: N2RDxr    = 109
   INTEGER(IntKi), PARAMETER      :: N2RDyr    = 110
   INTEGER(IntKi), PARAMETER      :: N2RDzr    = 111
   INTEGER(IntKi), PARAMETER      :: N3RDxr    = 112
   INTEGER(IntKi), PARAMETER      :: N3RDyr    = 113
   INTEGER(IntKi), PARAMETER      :: N3RDzr    = 114
   INTEGER(IntKi), PARAMETER      :: N4RDxr    = 115
   INTEGER(IntKi), PARAMETER      :: N4RDyr    = 116
   INTEGER(IntKi), PARAMETER      :: N4RDzr    = 117
   INTEGER(IntKi), PARAMETER      :: N5RDxr    = 118
   INTEGER(IntKi), PARAMETER      :: N5RDyr    = 119
   INTEGER(IntKi), PARAMETER      :: N5RDzr    = 120
   INTEGER(IntKi), PARAMETER      :: N6RDxr    = 121
   INTEGER(IntKi), PARAMETER      :: N6RDyr    = 122
   INTEGER(IntKi), PARAMETER      :: N6RDzr    = 123
   INTEGER(IntKi), PARAMETER      :: N7RDxr    = 124
   INTEGER(IntKi), PARAMETER      :: N7RDyr    = 125
   INTEGER(IntKi), PARAMETER      :: N7RDzr    = 126
   INTEGER(IntKi), PARAMETER      :: N8RDxr    = 127
   INTEGER(IntKi), PARAMETER      :: N8RDyr    = 128
   INTEGER(IntKi), PARAMETER      :: N8RDzr    = 129
   INTEGER(IntKi), PARAMETER      :: N9RDxr    = 130
   INTEGER(IntKi), PARAMETER      :: N9RDyr    = 131
   INTEGER(IntKi), PARAMETER      :: N9RDzr    = 132
   INTEGER(IntKi), PARAMETER      :: N1TVXg    = 133
   INTEGER(IntKi), PARAMETER      :: N1TVYg    = 134
   INTEGER(IntKi), PARAMETER      :: N1TVZg    = 135
   INTEGER(IntKi), PARAMETER      :: N2TVXg    = 136
   INTEGER(IntKi), PARAMETER      :: N2TVYg    = 137
   INTEGER(IntKi), PARAMETER      :: N2TVZg    = 138
   INTEGER(IntKi), PARAMETER      :: N3TVXg    = 139
   INTEGER(IntKi), PARAMETER      :: N3TVYg    = 140
   INTEGER(IntKi), PARAMETER      :: N3TVZg    = 141
   INTEGER(IntKi), PARAMETER      :: N4TVXg    = 142
   INTEGER(IntKi), PARAMETER      :: N4TVYg    = 143
   INTEGER(IntKi), PARAMETER      :: N4TVZg    = 144
   INTEGER(IntKi), PARAMETER      :: N5TVXg    = 145
   INTEGER(IntKi), PARAMETER      :: N5TVYg    = 146
   INTEGER(IntKi), PARAMETER      :: N5TVZg    = 147
   INTEGER(IntKi), PARAMETER      :: N6TVXg    = 148
   INTEGER(IntKi), PARAMETER      :: N6TVYg    = 149
   INTEGER(IntKi), PARAMETER      :: N6TVZg    = 150
   INTEGER(IntKi), PARAMETER      :: N7TVXg    = 151
   INTEGER(IntKi), PARAMETER      :: N7TVYg    = 152
   INTEGER(IntKi), PARAMETER      :: N7TVZg    = 153
   INTEGER(IntKi), PARAMETER      :: N8TVXg    = 154
   INTEGER(IntKi), PARAMETER      :: N8TVYg    = 155
   INTEGER(IntKi), PARAMETER      :: N8TVZg    = 156
   INTEGER(IntKi), PARAMETER      :: N9TVXg    = 157
   INTEGER(IntKi), PARAMETER      :: N9TVYg    = 158
   INTEGER(IntKi), PARAMETER      :: N9TVZg    = 159
   INTEGER(IntKi), PARAMETER      :: N1RVXg    = 160
   INTEGER(IntKi), PARAMETER      :: N1RVYg    = 161
   INTEGER(IntKi), PARAMETER      :: N1RVZg    = 162
   INTEGER(IntKi), PARAMETER      :: N2RVXg    = 163
   INTEGER(IntKi), PARAMETER      :: N2RVYg    = 164
   INTEGER(IntKi), PARAMETER      :: N2RVZg    = 165
   INTEGER(IntKi), PARAMETER      :: N3RVXg    = 166
   INTEGER(IntKi), PARAMETER      :: N3RVYg    = 167
   INTEGER(IntKi), PARAMETER      :: N3RVZg    = 168
   INTEGER(IntKi), PARAMETER      :: N4RVXg    = 169
   INTEGER(IntKi), PARAMETER      :: N4RVYg    = 170
   INTEGER(IntKi), PARAMETER      :: N4RVZg    = 171
   INTEGER(IntKi), PARAMETER      :: N5RVXg    = 172
   INTEGER(IntKi), PARAMETER      :: N5RVYg    = 173
   INTEGER(IntKi), PARAMETER      :: N5RVZg    = 174
   INTEGER(IntKi), PARAMETER      :: N6RVXg    = 175
   INTEGER(IntKi), PARAMETER      :: N6RVYg    = 176
   INTEGER(IntKi), PARAMETER      :: N6RVZg    = 177
   INTEGER(IntKi), PARAMETER      :: N7RVXg    = 178
   INTEGER(IntKi), PARAMETER      :: N7RVYg    = 179
   INTEGER(IntKi), PARAMETER      :: N7RVZg    = 180
   INTEGER(IntKi), PARAMETER      :: N8RVXg    = 181
   INTEGER(IntKi), PARAMETER      :: N8RVYg    = 182
   INTEGER(IntKi), PARAMETER      :: N8RVZg    = 183
   INTEGER(IntKi), PARAMETER      :: N9RVXg    = 184
   INTEGER(IntKi), PARAMETER      :: N9RVYg    = 185
   INTEGER(IntKi), PARAMETER      :: N9RVZg    = 186
   INTEGER(IntKi), PARAMETER      :: N1TAXg    = 187
   INTEGER(IntKi), PARAMETER      :: N1TAYg    = 188
   INTEGER(IntKi), PARAMETER      :: N1TAZg    = 189
   INTEGER(IntKi), PARAMETER      :: N2TAXg    = 190
   INTEGER(IntKi), PARAMETER      :: N2TAYg    = 191
   INTEGER(IntKi), PARAMETER      :: N2TAZg    = 192
   INTEGER(IntKi), PARAMETER      :: N3TAXg    = 193
   INTEGER(IntKi), PARAMETER      :: N3TAYg    = 194
   INTEGER(IntKi), PARAMETER      :: N3TAZg    = 195
   INTEGER(IntKi), PARAMETER      :: N4TAXg    = 196
   INTEGER(IntKi), PARAMETER      :: N4TAYg    = 197
   INTEGER(IntKi), PARAMETER      :: N4TAZg    = 198
   INTEGER(IntKi), PARAMETER      :: N5TAXg    = 199
   INTEGER(IntKi), PARAMETER      :: N5TAYg    = 200
   INTEGER(IntKi), PARAMETER      :: N5TAZg    = 201
   INTEGER(IntKi), PARAMETER      :: N6TAXg    = 202
   INTEGER(IntKi), PARAMETER      :: N6TAYg    = 203
   INTEGER(IntKi), PARAMETER      :: N6TAZg    = 204
   INTEGER(IntKi), PARAMETER      :: N7TAXg    = 205
   INTEGER(IntKi), PARAMETER      :: N7TAYg    = 206
   INTEGER(IntKi), PARAMETER      :: N7TAZg    = 207
   INTEGER(IntKi), PARAMETER      :: N8TAXg    = 208
   INTEGER(IntKi), PARAMETER      :: N8TAYg    = 209
   INTEGER(IntKi), PARAMETER      :: N8TAZg    = 210
   INTEGER(IntKi), PARAMETER      :: N9TAXg    = 211
   INTEGER(IntKi), PARAMETER      :: N9TAYg    = 212
   INTEGER(IntKi), PARAMETER      :: N9TAZg    = 213
   INTEGER(IntKi), PARAMETER      :: N1RAXg    = 214
   INTEGER(IntKi), PARAMETER      :: N1RAYg    = 215
   INTEGER(IntKi), PARAMETER      :: N1RAZg    = 216
   INTEGER(IntKi), PARAMETER      :: N2RAXg    = 217
   INTEGER(IntKi), PARAMETER      :: N2RAYg    = 218
   INTEGER(IntKi), PARAMETER      :: N2RAZg    = 219
   INTEGER(IntKi), PARAMETER      :: N3RAXg    = 220
   INTEGER(IntKi), PARAMETER      :: N3RAYg    = 221
   INTEGER(IntKi), PARAMETER      :: N3RAZg    = 222
   INTEGER(IntKi), PARAMETER      :: N4RAXg    = 223
   INTEGER(IntKi), PARAMETER      :: N4RAYg    = 224
   INTEGER(IntKi), PARAMETER      :: N4RAZg    = 225
   INTEGER(IntKi), PARAMETER      :: N5RAXg    = 226
   INTEGER(IntKi), PARAMETER      :: N5RAYg    = 227
   INTEGER(IntKi), PARAMETER      :: N5RAZg    = 228
   INTEGER(IntKi), PARAMETER      :: N6RAXg    = 229
   INTEGER(IntKi), PARAMETER      :: N6RAYg    = 230
   INTEGER(IntKi), PARAMETER      :: N6RAZg    = 231
   INTEGER(IntKi), PARAMETER      :: N7RAXg    = 232
   INTEGER(IntKi), PARAMETER      :: N7RAYg    = 233
   INTEGER(IntKi), PARAMETER      :: N7RAZg    = 234
   INTEGER(IntKi), PARAMETER      :: N8RAXg    = 235
   INTEGER(IntKi), PARAMETER      :: N8RAYg    = 236
   INTEGER(IntKi), PARAMETER      :: N8RAZg    = 237
   INTEGER(IntKi), PARAMETER      :: N9RAXg    = 238
   INTEGER(IntKi), PARAMETER      :: N9RAYg    = 239
   INTEGER(IntKi), PARAMETER      :: N9RAZg    = 240


     ! Applied Loads:

   INTEGER(IntKi), PARAMETER      :: N1PFxl    = 241
   INTEGER(IntKi), PARAMETER      :: N1PFyl    = 242
   INTEGER(IntKi), PARAMETER      :: N1PFzl    = 243
   INTEGER(IntKi), PARAMETER      :: N2PFxl    = 244
   INTEGER(IntKi), PARAMETER      :: N2PFyl    = 245
   INTEGER(IntKi), PARAMETER      :: N2PFzl    = 246
   INTEGER(IntKi), PARAMETER      :: N3PFxl    = 247
   INTEGER(IntKi), PARAMETER      :: N3PFyl    = 248
   INTEGER(IntKi), PARAMETER      :: N3PFzl    = 249
   INTEGER(IntKi), PARAMETER      :: N4PFxl    = 250
   INTEGER(IntKi), PARAMETER      :: N4PFyl    = 251
   INTEGER(IntKi), PARAMETER      :: N4PFzl    = 252
   INTEGER(IntKi), PARAMETER      :: N5PFxl    = 253
   INTEGER(IntKi), PARAMETER      :: N5PFyl    = 254
   INTEGER(IntKi), PARAMETER      :: N5PFzl    = 255
   INTEGER(IntKi), PARAMETER      :: N6PFxl    = 256
   INTEGER(IntKi), PARAMETER      :: N6PFyl    = 257
   INTEGER(IntKi), PARAMETER      :: N6PFzl    = 258
   INTEGER(IntKi), PARAMETER      :: N7PFxl    = 259
   INTEGER(IntKi), PARAMETER      :: N7PFyl    = 260
   INTEGER(IntKi), PARAMETER      :: N7PFzl    = 261
   INTEGER(IntKi), PARAMETER      :: N8PFxl    = 262
   INTEGER(IntKi), PARAMETER      :: N8PFyl    = 263
   INTEGER(IntKi), PARAMETER      :: N8PFzl    = 264
   INTEGER(IntKi), PARAMETER      :: N9PFxl    = 265
   INTEGER(IntKi), PARAMETER      :: N9PFyl    = 266
   INTEGER(IntKi), PARAMETER      :: N9PFzl    = 267
   INTEGER(IntKi), PARAMETER      :: N1PMxl    = 268
   INTEGER(IntKi), PARAMETER      :: N1PMyl    = 269
   INTEGER(IntKi), PARAMETER      :: N1PMzl    = 270
   INTEGER(IntKi), PARAMETER      :: N2PMxl    = 271
   INTEGER(IntKi), PARAMETER      :: N2PMyl    = 272
   INTEGER(IntKi), PARAMETER      :: N2PMzl    = 273
   INTEGER(IntKi), PARAMETER      :: N3PMxl    = 274
   INTEGER(IntKi), PARAMETER      :: N3PMyl    = 275
   INTEGER(IntKi), PARAMETER      :: N3PMzl    = 276
   INTEGER(IntKi), PARAMETER      :: N4PMxl    = 277
   INTEGER(IntKi), PARAMETER      :: N4PMyl    = 278
   INTEGER(IntKi), PARAMETER      :: N4PMzl    = 279
   INTEGER(IntKi), PARAMETER      :: N5PMxl    = 280
   INTEGER(IntKi), PARAMETER      :: N5PMyl    = 281
   INTEGER(IntKi), PARAMETER      :: N5PMzl    = 282
   INTEGER(IntKi), PARAMETER      :: N6PMxl    = 283
   INTEGER(IntKi), PARAMETER      :: N6PMyl    = 284
   INTEGER(IntKi), PARAMETER      :: N6PMzl    = 285
   INTEGER(IntKi), PARAMETER      :: N7PMxl    = 286
   INTEGER(IntKi), PARAMETER      :: N7PMyl    = 287
   INTEGER(IntKi), PARAMETER      :: N7PMzl    = 288
   INTEGER(IntKi), PARAMETER      :: N8PMxl    = 289
   INTEGER(IntKi), PARAMETER      :: N8PMyl    = 290
   INTEGER(IntKi), PARAMETER      :: N8PMzl    = 291
   INTEGER(IntKi), PARAMETER      :: N9PMxl    = 292
   INTEGER(IntKi), PARAMETER      :: N9PMyl    = 293
   INTEGER(IntKi), PARAMETER      :: N9PMzl    = 294
   INTEGER(IntKi), PARAMETER      :: N1DFxl    = 295
   INTEGER(IntKi), PARAMETER      :: N1DFyl    = 296
   INTEGER(IntKi), PARAMETER      :: N1DFzl    = 297
   INTEGER(IntKi), PARAMETER      :: N2DFxl    = 298
   INTEGER(IntKi), PARAMETER      :: N2DFyl    = 299
   INTEGER(IntKi), PARAMETER      :: N2DFzl    = 300
   INTEGER(IntKi), PARAMETER      :: N3DFxl    = 301
   INTEGER(IntKi), PARAMETER      :: N3DFyl    = 302
   INTEGER(IntKi), PARAMETER      :: N3DFzl    = 303
   INTEGER(IntKi), PARAMETER      :: N4DFxl    = 304
   INTEGER(IntKi), PARAMETER      :: N4DFyl    = 305
   INTEGER(IntKi), PARAMETER      :: N4DFzl    = 306
   INTEGER(IntKi), PARAMETER      :: N5DFxl    = 307
   INTEGER(IntKi), PARAMETER      :: N5DFyl    = 308
   INTEGER(IntKi), PARAMETER      :: N5DFzl    = 309
   INTEGER(IntKi), PARAMETER      :: N6DFxl    = 310
   INTEGER(IntKi), PARAMETER      :: N6DFyl    = 311
   INTEGER(IntKi), PARAMETER      :: N6DFzl    = 312
   INTEGER(IntKi), PARAMETER      :: N7DFxl    = 313
   INTEGER(IntKi), PARAMETER      :: N7DFyl    = 314
   INTEGER(IntKi), PARAMETER      :: N7DFzl    = 315
   INTEGER(IntKi), PARAMETER      :: N8DFxl    = 316
   INTEGER(IntKi), PARAMETER      :: N8DFyl    = 317
   INTEGER(IntKi), PARAMETER      :: N8DFzl    = 318
   INTEGER(IntKi), PARAMETER      :: N9DFxl    = 319
   INTEGER(IntKi), PARAMETER      :: N9DFyl    = 320
   INTEGER(IntKi), PARAMETER      :: N9DFzl    = 321
   INTEGER(IntKi), PARAMETER      :: N1DMxl    = 322
   INTEGER(IntKi), PARAMETER      :: N1DMyl    = 323
   INTEGER(IntKi), PARAMETER      :: N1DMzl    = 324
   INTEGER(IntKi), PARAMETER      :: N2DMxl    = 325
   INTEGER(IntKi), PARAMETER      :: N2DMyl    = 326
   INTEGER(IntKi), PARAMETER      :: N2DMzl    = 327
   INTEGER(IntKi), PARAMETER      :: N3DMxl    = 328
   INTEGER(IntKi), PARAMETER      :: N3DMyl    = 329
   INTEGER(IntKi), PARAMETER      :: N3DMzl    = 330
   INTEGER(IntKi), PARAMETER      :: N4DMxl    = 331
   INTEGER(IntKi), PARAMETER      :: N4DMyl    = 332
   INTEGER(IntKi), PARAMETER      :: N4DMzl    = 333
   INTEGER(IntKi), PARAMETER      :: N5DMxl    = 334
   INTEGER(IntKi), PARAMETER      :: N5DMyl    = 335
   INTEGER(IntKi), PARAMETER      :: N5DMzl    = 336
   INTEGER(IntKi), PARAMETER      :: N6DMxl    = 337
   INTEGER(IntKi), PARAMETER      :: N6DMyl    = 338
   INTEGER(IntKi), PARAMETER      :: N6DMzl    = 339
   INTEGER(IntKi), PARAMETER      :: N7DMxl    = 340
   INTEGER(IntKi), PARAMETER      :: N7DMyl    = 341
   INTEGER(IntKi), PARAMETER      :: N7DMzl    = 342
   INTEGER(IntKi), PARAMETER      :: N8DMxl    = 343
   INTEGER(IntKi), PARAMETER      :: N8DMyl    = 344
   INTEGER(IntKi), PARAMETER      :: N8DMzl    = 345
   INTEGER(IntKi), PARAMETER      :: N9DMxl    = 346
   INTEGER(IntKi), PARAMETER      :: N9DMyl    = 347
   INTEGER(IntKi), PARAMETER      :: N9DMzl    = 348


     ! Pitch Actuator:

   INTEGER(IntKi), PARAMETER      :: PAngInp   = 349
   INTEGER(IntKi), PARAMETER      :: PAngAct   = 350
   INTEGER(IntKi), PARAMETER      :: PRatAct   = 351
   INTEGER(IntKi), PARAMETER      :: PAccAct   = 352


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts = 352

!End of code generated by Matlab script
! ===================================================================================================
   
   INTEGER,  PARAMETER          :: NFl(9, 3) = RESHAPE( (/ &      ! Sectional force resultants expressed in l
                                     N1Fxl,N2Fxl,N3Fxl,N4Fxl,N5Fxl,N6Fxl,N7Fxl,N8Fxl,N9Fxl, &
                                     N1Fyl,N2Fyl,N3Fyl,N4Fyl,N5Fyl,N6Fyl,N7Fyl,N8Fyl,N9Fyl, &
                                     N1Fzl,N2Fzl,N3Fzl,N4Fzl,N5Fzl,N6Fzl,N7Fzl,N8Fzl,N9Fzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NMl(9, 3) = RESHAPE( (/ &      ! Sectional moment resultants expressed in l
                                     N1Mxl,N2Mxl,N3Mxl,N4Mxl,N5Mxl,N6Mxl,N7Mxl,N8Mxl,N9Mxl, &
                                     N1Myl,N2Myl,N3Myl,N4Myl,N5Myl,N6Myl,N7Myl,N8Myl,N9Myl, &
                                     N1Mzl,N2Mzl,N3Mzl,N4Mzl,N5Mzl,N6Mzl,N7Mzl,N8Mzl,N9Mzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTDr(9, 3) = RESHAPE( (/ &      ! Sectional translational deflections expressed in r
                                     N1TDxr,N2TDxr,N3TDxr,N4TDxr,N5TDxr,N6TDxr,N7TDxr,N8TDxr,N9TDxr, &
                                     N1TDyr,N2TDyr,N3TDyr,N4TDyr,N5TDyr,N6TDyr,N7TDyr,N8TDyr,N9TDyr, &
                                     N1TDzr,N2TDzr,N3TDzr,N4TDzr,N5TDzr,N6TDzr,N7TDzr,N8TDzr,N9TDzr  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRDr(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational deflections expressed in r
                                     N1RDxr,N2RDxr,N3RDxr,N4RDxr,N5RDxr,N6RDxr,N7RDxr,N8RDxr,N9RDxr, &
                                     N1RDyr,N2RDyr,N3RDyr,N4RDyr,N5RDyr,N6RDyr,N7RDyr,N8RDyr,N9RDyr, &
                                     N1RDzr,N2RDzr,N3RDzr,N4RDzr,N5RDzr,N6RDzr,N7RDzr,N8RDzr,N9RDzr  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTVg(9, 3) = RESHAPE( (/ &      ! Sectional translational velocities expressed in g
                                     N1TVXg,N2TVXg,N3TVXg,N4TVXg,N5TVXg,N6TVXg,N7TVXg,N8TVXg,N9TVXg, &
                                     N1TVYg,N2TVYg,N3TVYg,N4TVYg,N5TVYg,N6TVYg,N7TVYg,N8TVYg,N9TVYg, &
                                     N1TVZg,N2TVZg,N3TVZg,N4TVZg,N5TVZg,N6TVZg,N7TVZg,N8TVZg,N9TVZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRVg(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational velocities expressed in g
                                     N1RVXg,N2RVXg,N3RVXg,N4RVXg,N5RVXg,N6RVXg,N7RVXg,N8RVXg,N9RVXg, &
                                     N1RVYg,N2RVYg,N3RVYg,N4RVYg,N5RVYg,N6RVYg,N7RVYg,N8RVYg,N9RVYg, &
                                     N1RVZg,N2RVZg,N3RVZg,N4RVZg,N5RVZg,N6RVZg,N7RVZg,N8RVZg,N9RVZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTAg(9, 3) = RESHAPE( (/ &      ! Sectional translational accelerations expressed in g
                                     N1TAXg,N2TAXg,N3TAXg,N4TAXg,N5TAXg,N6TAXg,N7TAXg,N8TAXg,N9TAXg, &
                                     N1TAYg,N2TAYg,N3TAYg,N4TAYg,N5TAYg,N6TAYg,N7TAYg,N8TAYg,N9TAYg, &
                                     N1TAZg,N2TAZg,N3TAZg,N4TAZg,N5TAZg,N6TAZg,N7TAZg,N8TAZg,N9TAZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRAg(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational accelerations expressed in g
                                     N1RAXg,N2RAXg,N3RAXg,N4RAXg,N5RAXg,N6RAXg,N7RAXg,N8RAXg,N9RAXg, &
                                     N1RAYg,N2RAYg,N3RAYg,N4RAYg,N5RAYg,N6RAYg,N7RAYg,N8RAYg,N9RAYg, &
                                     N1RAZg,N2RAZg,N3RAZg,N4RAZg,N5RAZg,N6RAZg,N7RAZg,N8RAZg,N9RAZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NPFl(9, 3) = RESHAPE( (/ &      ! Applied point forces expressed in l
                                     N1PFxl,N2PFxl,N3PFxl,N4PFxl,N5PFxl,N6PFxl,N7PFxl,N8PFxl,N9PFxl, &
                                     N1PFyl,N2PFyl,N3PFyl,N4PFyl,N5PFyl,N6PFyl,N7PFyl,N8PFyl,N9PFyl, &
                                     N1PFzl,N2PFzl,N3PFzl,N4PFzl,N5PFzl,N6PFzl,N7PFzl,N8PFzl,N9PFzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NPMl(9, 3) = RESHAPE( (/ &      ! Applied point moments expressed in l
                                     N1PMxl,N2PMxl,N3PMxl,N4PMxl,N5PMxl,N6PMxl,N7PMxl,N8PMxl,N9PMxl, &
                                     N1PMyl,N2PMyl,N3PMyl,N4PMyl,N5PMyl,N6PMyl,N7PMyl,N8PMyl,N9PMyl, &
                                     N1PMzl,N2PMzl,N3PMzl,N4PMzl,N5PMzl,N6PMzl,N7PMzl,N8PMzl,N9PMzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NDFl(9, 3) = RESHAPE( (/ &      ! Applied distributed forces expressed in l
                                     N1DFxl,N2DFxl,N3DFxl,N4DFxl,N5DFxl,N6DFxl,N7DFxl,N8DFxl,N9DFxl, &
                                     N1DFyl,N2DFyl,N3DFyl,N4DFyl,N5DFyl,N6DFyl,N7DFyl,N8DFyl,N9DFyl, &
                                     N1DFzl,N2DFzl,N3DFzl,N4DFzl,N5DFzl,N6DFzl,N7DFzl,N8DFzl,N9DFzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NDMl(9, 3) = RESHAPE( (/ &      ! Applied distributed moments expressed in l
                                     N1DMxl,N2DMxl,N3DMxl,N4DMxl,N5DMxl,N6DMxl,N7DMxl,N8DMxl,N9DMxl, &
                                     N1DMyl,N2DMyl,N3DMyl,N4DMyl,N5DMyl,N6DMyl,N7DMyl,N8DMyl,N9DMyl, &
                                     N1DMzl,N2DMzl,N3DMzl,N4DMzl,N5DMzl,N6DMzl,N7DMzl,N8DMzl,N9DMzl  &
                                   /), (/9, 3/) )
   
   
CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ReadInput(InputFileName,InputFileData,OutFileRoot, Default_DT,ErrStat,ErrMsg)

   ! Passed Variables:
   CHARACTER(*),                 INTENT(IN   )  :: InputFileName    !< Name of the input file
   CHARACTER(*),                 INTENT(IN   )  :: OutFileRoot      !< Name of the input file
   REAL(DbKi),                   INTENT(IN   )  :: Default_DT       !< The default DT (from glue code)
   TYPE(BD_InputFile),           INTENT(  OUT)  :: InputFileData    !< Data stored in the module's input file
   INTEGER(IntKi),               INTENT(  OUT)  :: ErrStat          !< The error status code
   CHARACTER(*),                 INTENT(  OUT)  :: ErrMsg           !< The error message, if an error occurred


   ! Local variables:
   INTEGER(IntKi)                               :: UnEcho
   INTEGER(IntKi)                               :: ErrStat2
   CHARACTER(ErrMsgLen)                         :: ErrMsg2
   character(*), parameter                      :: RoutineName = 'BD_ReadInput'


   ErrStat = ErrID_None
   ErrMsg = ''
   UnEcho = -1

   InputFileData%DTBeam = Default_DT
   CALL BD_ReadPrimaryFile(InputFileName,InputFileData,OutFileRoot,UnEcho,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      IF(ErrStat >= AbortErrLev) THEN
         IF (UnEcho > 0) CLOSE (UnEcho)
         RETURN
      END IF
      
   CALL BD_ReadBladeFile(InputFileData%BldFile,InputFileData%InpBl,UnEcho,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      IF(ErrStat >= AbortErrLev) THEN
         IF (UnEcho > 0) CLOSE (UnEcho)
         RETURN
      END IF

END SUBROUTINE BD_ReadInput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine reads in the primary BeamDyn input file and places the values it reads
!! in the InputFileData structure.
!!   It opens an echo file if requested and returns the (still-open) echo file to the
!!     calling routine.
SUBROUTINE BD_ReadPrimaryFile(InputFile,InputFileData,OutFileRoot,UnEc,ErrStat,ErrMsg)

   ! Passed variables
   INTEGER(IntKi),               INTENT(  OUT) :: UnEc
   INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
   CHARACTER(*),                 INTENT(IN   ) :: InputFile
   CHARACTER(*),                 INTENT(IN   ) :: OutFileRoot
   CHARACTER(*),                 INTENT(  OUT) :: ErrMsg

   TYPE(BD_InputFile),           INTENT(INOUT) :: InputFileData

   ! Local variables:
   INTEGER(IntKi)               :: UnIn                         ! Unit number for reading file
   INTEGER(IntKi)               :: ErrStat2                     ! Temporary Error status
   LOGICAL                      :: Echo                         ! Determines if an echo file should be written
   INTEGER(IntKi)               :: IOS                          ! Temporary Error status
   CHARACTER(ErrMsgLen)         :: ErrMsg2                      ! Temporary Error message
   character(*), parameter      :: RoutineName = 'BD_ReadPrimaryFile'
   
   CHARACTER(1024)              :: PriPath                      ! Path name of the primary file
   CHARACTER(1024)              :: FTitle                       ! "File Title": the 2nd line of the input file, which contains a description of its contents
   CHARACTER(200)               :: Line                         ! Temporary storage of a line from the input

   INTEGER(IntKi)               :: i
   INTEGER(IntKi)               :: j
   INTEGER(IntKi)               :: temp_int
   REAL(BDKi)                   :: tmpReAry(4)

   ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
   Echo = .FALSE.
   UnEc = -1
   CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.

   CALL AllocAry( InputFileData%OutList, MaxOutPts, "Outlist", ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   
   CALL GetNewUnit(UnIn,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL OpenFInpFile(UnIn,InputFile,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) then
         call cleanup()
         RETURN
      end if
      
      
      
   I = 1 !set the number of times we've read the file
   DO    
   !-------------------------- HEADER ---------------------------------------------
   CALL ReadCom(UnIn,InputFile,'File Header: Module Version (line 1)',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadStr(UnIn,InputFile,FTitle,'FTitle','File Header: File Description (line 2)',ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
   
   
   !---------------------- SIMULATION CONTROL --------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Simulation Control',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,Echo,'Echo','Echo switch',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
   
   
      IF (.NOT. Echo .OR. I > 1) EXIT !exit this loop
   
         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read
      
      I = I + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)
   
      CALL OpenEcho ( UnEc, TRIM(OutFileRoot)//'.ech', ErrStat2, ErrMsg2, BeamDyn_Ver )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
   
      IF ( UnEc > 0 )  WRITE (UnEc,'(/,A,/)')  'Data from '//TRIM(BeamDyn_Ver%Name)//' primary input file "'//TRIM( InputFile )//'":'
         
      REWIND( UnIn, IOSTAT=ErrStat2 )  
         IF (ErrStat2 /= 0_IntKi ) THEN
            CALL SetErrStat( ErrID_Fatal, 'Error rewinding file "'//TRIM(InputFile)//'".', ErrStat, ErrMsg, RoutineName )
            call cleanup()
            RETURN
         END IF         
      
   END DO          
      
   CALL ReadVar(UnIn,InputFile,InputFileData%analysis_type,"analysis_type", "Analysis type",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%rhoinf,"rhoinf", "Coefficient for GA2",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%quadrature,"quadrature", "Quadrature type",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "refine", "Refinement parameter for trapezoidal quadrature {or default} ", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%refine = 1
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%refine
            CALL CheckIOS ( IOS, InputFile, 'refine', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "n_fact", "Factorization frequency {or default}", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%n_fact = 5
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%n_fact
            CALL CheckIOS ( IOS, InputFile, 'n_fact', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "DTBeam", "Time interval for BeamDyn  calculations {or default} (s)", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%DTBeam
            CALL CheckIOS ( IOS, InputFile, 'DTBeam', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "NRMax", "Max number of interations in Newton-Raphson algorithm", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%NRMax = 10
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%NRMax
            CALL CheckIOS ( IOS, InputFile, 'NRMax', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF
      
   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "stop_tol", "Tolerance for stopping criterion", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%stop_tol = 1.0D-05
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%stop_tol
            CALL CheckIOS ( IOS, InputFile, 'stop_tol', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      
   !---------------------- GEOMETRY PARAMETER --------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Geometry Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%member_total,"member_total", "Total number of member",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%kp_total,"kp_total", "Total number of key point",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
         ! check these values before allocating the arrays below
      if (InputFileData%member_total<1 .or. InputFileData%kp_total<1) then
         CALL SetErrStat( ErrID_Fatal, "member_total and kp_total must be positive numbers", ErrStat, ErrMsg, RoutineName )         
         call cleanup()
         return
      end if
         
      CALL AllocAry(InputFileData%kp_member,InputFileData%member_total,'Number of key point in each member',ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      CALL AllocAry(InputFileData%kp_coordinate,InputFileData%kp_total,4,'Key point coordinates input array',ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
   InputFileData%kp_member = 0
   InputFileData%kp_coordinate = 0.0_BDKi
   temp_int = 0
   DO i=1,InputFileData%member_total
      ! bjj: we cannot read j, InputFileData%kp_member(j) because j could be outside the valid range:
      READ(UnIn,*,IOSTAT=IOS) j,temp_int 
         CALL CheckIOS ( IOS, InputFile, 'Member number; Number of key points in this member', NumType, ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
         if (j>0 .and. j<= InputFileData%member_total) then
            InputFileData%kp_member(j) = temp_int
         end if
         
         !bjj: what happens if the user enters a member number multiple times? or if not each member is accounted for?
         !    I'm going to force them to be entered 1-InputFileData%kp_member to avoid this issue for now.
         if (j /= i) then
            call SetErrStat(ErrID_Warn, "Member numbers must be entered in monotonicly increasing order, starting with 1.",ErrStat,ErrMsg,RoutineName)
         end if
         
   ENDDO
   
   
   CALL ReadCom(UnIn,InputFile,'key point x,y,z locations and initial twist angles',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadCom(UnIn,InputFile,'key point and initial twist units',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   DO i=1,InputFileData%kp_total
       CALL ReadAry( UnIn, InputFile, TmpReAry, 4, 'kp_coordinate', 'Key point coordinates and initial twist', ErrStat2, ErrMsg2, UnEc )       
          CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
       InputFileData%kp_coordinate(i,2) =  TmpReAry(1)
       InputFileData%kp_coordinate(i,3) =  TmpReAry(2)
       InputFileData%kp_coordinate(i,1) =  TmpReAry(3)
       InputFileData%kp_coordinate(i,4) = -TmpReAry(4)
   ENDDO
   
   !---------------------- MESH PARAMETER -----------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Mesh Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadVar(UnIn,InputFile,InputFileData%order_elem,"order_elem","Order of basis function",&
                ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !---------------------- BEAM SECTIONAL PARAMETER ----------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Beam Material Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadVar ( UnIn, InputFile, InputFileData%BldFile, 'BldFile', 'Name of the file containing properties for beam', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( PathIsRelative( InputFileData%BldFile ) ) InputFileData%BldFile = TRIM(PriPath)//TRIM(InputFileData%BldFile)

      
   !---------------------- PITCH ACTUATOR PARAMETER ----------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Pitch Actuator Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar ( UnIn, InputFile, InputFileData%UsePitchAct, 'UsePitchAct', 'Whether a pitch actuator should be used (flag)', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar ( UnIn, InputFile, InputFileData%PitchJ, 'PitchJ', 'Pitch actuator inertia (kg-m^2)', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar ( UnIn, InputFile, InputFileData%PitchK, 'PitchK', 'Pitch actuator stiffness (kg-m^2/s^2)', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar ( UnIn, InputFile, InputFileData%PitchC, 'PitchC', 'Pitch actuator damping (kg-m^2/s)', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      
   !----------- OUTPUTS  -----------------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Outputs', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      ! SumPrint - Print summary data to <RootName>.BD.sum (flag):
   CALL ReadVar( UnIn, InputFile, InputFileData%SumPrint, "SumPrint", "Print summary data to <RootName>.BD.sum (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )           
      
   call ReadVar( UnIn, InputFile, InputFileData%OutFmt, "OutFmt", "Format used for text tabular output (except time).  Resulting field should be 10 characters. (-)",ErrStat2, ErrMsg2, UnEc)
      call setErrStat( errStat2, ErrMsg2 , errStat, ErrMsg , RoutineName )

      ! NNodeOuts - Number of node outputs [0 - 9] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%NNodeOuts, "NNodeOuts", "Number of node outputs [0 - 9] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      IF ( InputFileData%NNodeOuts > SIZE(InputFileData%OutNd) ) THEN
         CALL SetErrStat( ErrID_Warn, ' Warning: number of output nodes exceeds '//&
                           TRIM(Num2LStr(SIZE(InputFileData%OutNd))) //'.', ErrStat, ErrMsg, RoutineName )
         InputFileData%NNodeOuts = SIZE(InputFileData%OutNd)
      END IF
      
      ! OutNd - Nodes whose values will be output (-):
   CALL ReadAry( UnIn, InputFile, InputFileData%OutNd, InputFileData%NNodeOuts, "OutNd", "Nodes whose values will be output (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            

      ! Return on error at end of section
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF
                  
   !----------- OUTLIST  -----------------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: OutList', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      ! OutList - List of user-requested output channels (-):
   CALL ReadOutputList ( UnIn, InputFile, InputFileData%OutList, InputFileData%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   !---------------------- END OF FILE -----------------------------------------      
      
      
   call cleanup()
   return
      
contains
   subroutine cleanup() 
      if (UnIn > 0) close(UnIn)
      ! don't close the echo file here
   end subroutine cleanup         
END SUBROUTINE BD_ReadPrimaryFile
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ReadBladeFile(BldFile,BladeInputFileData,UnEc,ErrStat,ErrMsg)

   ! Passed variables:
   TYPE(BladeInputData), INTENT(  OUT):: BladeInputFileData
   CHARACTER(*),         INTENT(IN   ):: BldFile
   INTEGER(IntKi),       INTENT(IN   ):: UnEc
   INTEGER(IntKi),       INTENT(  OUT):: ErrStat                             !< Error status
   CHARACTER(*),         INTENT(  OUT):: ErrMsg                              !< Error message

   ! Local variables:
   INTEGER(IntKi)             :: UnIn                                            ! Unit number for reading file
   INTEGER(IntKi)             :: ErrStat2                                        ! Temporary Error status
   CHARACTER(ErrMsgLen)       :: ErrMsg2                                         ! Temporary Err msg
   character(*), parameter    :: RoutineName = 'BD_ReadBladeFile'
   INTEGER(IntKi)             :: i
   INTEGER(IntKi)             :: j
   
   REAL(BDKi)                 :: temp66(6,6)
   REAL(BDKi)                 :: temp6(6)

   ErrStat = ErrID_None
   ErrMsg  = ""

   CALL GetNewUnit(UnIn,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL OpenFInpFile (UnIn,BldFile,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            return
         end if

   !  -------------- HEADER -------------------------------------------------------
   ! Skip the header.
   CALL ReadCom(UnIn,BldFile,'unused beam file header line 1',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'unused beam file header line 2',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   !  -------------- BLADE PARAMETER-----------------------------------------------
   CALL ReadCom(UnIn,BldFile,'beam parameters',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar(UnIn,BldFile,BladeInputFileData%station_total,'station_total','Number of blade input stations',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL AllocAry(BladeInputFileData%stiff0,6,6,BladeInputFileData%station_total,'Cross-sectional 6 by 6 stiffness matrix',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL AllocAry(BladeInputFileData%mass0,6,6,BladeInputFileData%station_total,'Cross-sectional 6 by 6 mass matrix',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL AllocAry(BladeInputFileData%station_eta,BladeInputFileData%station_total,'Station eta array',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      !after allocating these arrays, we'll make sure it was successful:
   if (ErrStat >= AbortErrLev) then
      call cleanup()
      return
   end if
            
   CALL ReadVar(UnIn,BldFile,BladeInputFileData%damp_flag,'damp_flag','Damping flag',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   !  -------------- DAMPING PARAMETER-----------------------------------------------
   CALL ReadCom(UnIn,BldFile,'damping parameters',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'mu1 to mu6',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'units',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
                  
   CALL ReadAry(UnIn,BldFile,temp6,6,'damping coefficient','damping coefficient',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      
   BladeInputFileData%beta(1) = temp6(3)
   BladeInputFileData%beta(2) = temp6(1)
   BladeInputFileData%beta(3) = temp6(2)
   BladeInputFileData%beta(4) = temp6(6)
   BladeInputFileData%beta(5) = temp6(4)
   BladeInputFileData%beta(6) = temp6(5)
   
   
!  -------------- DISTRIBUTED PROPERTIES--------------------------------------------      
   CALL ReadCom(UnIn,BldFile,'Distributed properties',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            
   DO i=1,BladeInputFileData%station_total
      
      CALL ReadVar(UnIn,BldFile,BladeInputFileData%station_eta(i),'station_eta','Station '//trim(num2lstr(i))//' Eta',ErrStat2,ErrMsg2,UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         
      DO j=1,6
         CALL ReadAry(UnIn,BldFile,temp66(j,:),6,'siffness_matrix','Blade C/S stiffness matrix',ErrStat2,ErrMsg2,UnEc)
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      ENDDO
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if       
      BladeInputFileData%stiff0(:,:,i) = IEC_to_BD_coords(temp66)
              
      DO j=1,6
         CALL ReadAry(UnIn,BldFile,temp66(j,:),6,'mass_matrix','Blade C/S mass matrix',ErrStat2,ErrMsg2,UnEc)
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      ENDDO
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      BladeInputFileData%mass0(:,:,i) = IEC_to_BD_coords(temp66)
       
   ENDDO

   call cleanup()
   return
      
contains
   function IEC_to_BD_coords(temp66) result(BD_temp66)
    
      real(BDKi), intent(in) :: temp66(6,6)    ! matrix in IEC coordinates
      real(BDKi)             :: BD_temp66(6,6) ! equivalent matrix in BD coordinates

      integer, parameter     :: indx(6) = (/ 3,1,2,6,4,5 /)
      integer                :: i,j            ! loop counters
                                                 
      do j=1,6
         do i=1,6
            BD_temp66(i,j) = temp66( indx(i), indx(j) )
         end do
      end do
                  
   end function IEC_to_BD_coords
   !.....................
   subroutine cleanup() 
      close(UnIn)
      return
   end subroutine cleanup         
END SUBROUTINE BD_ReadBladeFile
!----------------------------------------------------------------------------------------------------------------------------------
!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 29-Sep-2015 10:23:41.
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
!! warning if any of the channels are not available outputs from the module.
!!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!!  the sign is set to 0 if the channel is invalid.
!! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        !< The list out user-requested outputs
   TYPE(BD_ParameterType),    INTENT(INOUT)  :: p                                 !< The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           !< The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            !< The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
!   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(352) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "N1DFXL   ","N1DFYL   ","N1DFZL   ","N1DMXL   ","N1DMYL   ","N1DMZL   ","N1FXL    ", &
                               "N1FYL    ","N1FZL    ","N1MXL    ","N1MYL    ","N1MZL    ","N1PFXL   ","N1PFYL   ", &
                               "N1PFZL   ","N1PMXL   ","N1PMYL   ","N1PMZL   ","N1RAXG   ","N1RAYG   ","N1RAZG   ", &
                               "N1RDXR   ","N1RDYR   ","N1RDZR   ","N1RVXG   ","N1RVYG   ","N1RVZG   ","N1TAXG   ", &
                               "N1TAYG   ","N1TAZG   ","N1TDXR   ","N1TDYR   ","N1TDZR   ","N1TVXG   ","N1TVYG   ", &
                               "N1TVZG   ","N2DFXL   ","N2DFYL   ","N2DFZL   ","N2DMXL   ","N2DMYL   ","N2DMZL   ", &
                               "N2FXL    ","N2FYL    ","N2FZL    ","N2MXL    ","N2MYL    ","N2MZL    ","N2PFXL   ", &
                               "N2PFYL   ","N2PFZL   ","N2PMXL   ","N2PMYL   ","N2PMZL   ","N2RAXG   ","N2RAYG   ", &
                               "N2RAZG   ","N2RDXR   ","N2RDYR   ","N2RDZR   ","N2RVXG   ","N2RVYG   ","N2RVZG   ", &
                               "N2TAXG   ","N2TAYG   ","N2TAZG   ","N2TDXR   ","N2TDYR   ","N2TDZR   ","N2TVXG   ", &
                               "N2TVYG   ","N2TVZG   ","N3DFXL   ","N3DFYL   ","N3DFZL   ","N3DMXL   ","N3DMYL   ", &
                               "N3DMZL   ","N3FXL    ","N3FYL    ","N3FZL    ","N3MXL    ","N3MYL    ","N3MZL    ", &
                               "N3PFXL   ","N3PFYL   ","N3PFZL   ","N3PMXL   ","N3PMYL   ","N3PMZL   ","N3RAXG   ", &
                               "N3RAYG   ","N3RAZG   ","N3RDXR   ","N3RDYR   ","N3RDZR   ","N3RVXG   ","N3RVYG   ", &
                               "N3RVZG   ","N3TAXG   ","N3TAYG   ","N3TAZG   ","N3TDXR   ","N3TDYR   ","N3TDZR   ", &
                               "N3TVXG   ","N3TVYG   ","N3TVZG   ","N4DFXL   ","N4DFYL   ","N4DFZL   ","N4DMXL   ", &
                               "N4DMYL   ","N4DMZL   ","N4FXL    ","N4FYL    ","N4FZL    ","N4MXL    ","N4MYL    ", &
                               "N4MZL    ","N4PFXL   ","N4PFYL   ","N4PFZL   ","N4PMXL   ","N4PMYL   ","N4PMZL   ", &
                               "N4RAXG   ","N4RAYG   ","N4RAZG   ","N4RDXR   ","N4RDYR   ","N4RDZR   ","N4RVXG   ", &
                               "N4RVYG   ","N4RVZG   ","N4TAXG   ","N4TAYG   ","N4TAZG   ","N4TDXR   ","N4TDYR   ", &
                               "N4TDZR   ","N4TVXG   ","N4TVYG   ","N4TVZG   ","N5DFXL   ","N5DFYL   ","N5DFZL   ", &
                               "N5DMXL   ","N5DMYL   ","N5DMZL   ","N5FXL    ","N5FYL    ","N5FZL    ","N5MXL    ", &
                               "N5MYL    ","N5MZL    ","N5PFXL   ","N5PFYL   ","N5PFZL   ","N5PMXL   ","N5PMYL   ", &
                               "N5PMZL   ","N5RAXG   ","N5RAYG   ","N5RAZG   ","N5RDXR   ","N5RDYR   ","N5RDZR   ", &
                               "N5RVXG   ","N5RVYG   ","N5RVZG   ","N5TAXG   ","N5TAYG   ","N5TAZG   ","N5TDXR   ", &
                               "N5TDYR   ","N5TDZR   ","N5TVXG   ","N5TVYG   ","N5TVZG   ","N6DFXL   ","N6DFYL   ", &
                               "N6DFZL   ","N6DMXL   ","N6DMYL   ","N6DMZL   ","N6FXL    ","N6FYL    ","N6FZL    ", &
                               "N6MXL    ","N6MYL    ","N6MZL    ","N6PFXL   ","N6PFYL   ","N6PFZL   ","N6PMXL   ", &
                               "N6PMYL   ","N6PMZL   ","N6RAXG   ","N6RAYG   ","N6RAZG   ","N6RDXR   ","N6RDYR   ", &
                               "N6RDZR   ","N6RVXG   ","N6RVYG   ","N6RVZG   ","N6TAXG   ","N6TAYG   ","N6TAZG   ", &
                               "N6TDXR   ","N6TDYR   ","N6TDZR   ","N6TVXG   ","N6TVYG   ","N6TVZG   ","N7DFXL   ", &
                               "N7DFYL   ","N7DFZL   ","N7DMXL   ","N7DMYL   ","N7DMZL   ","N7FXL    ","N7FYL    ", &
                               "N7FZL    ","N7MXL    ","N7MYL    ","N7MZL    ","N7PFXL   ","N7PFYL   ","N7PFZL   ", &
                               "N7PMXL   ","N7PMYL   ","N7PMZL   ","N7RAXG   ","N7RAYG   ","N7RAZG   ","N7RDXR   ", &
                               "N7RDYR   ","N7RDZR   ","N7RVXG   ","N7RVYG   ","N7RVZG   ","N7TAXG   ","N7TAYG   ", &
                               "N7TAZG   ","N7TDXR   ","N7TDYR   ","N7TDZR   ","N7TVXG   ","N7TVYG   ","N7TVZG   ", &
                               "N8DFXL   ","N8DFYL   ","N8DFZL   ","N8DMXL   ","N8DMYL   ","N8DMZL   ","N8FXL    ", &
                               "N8FYL    ","N8FZL    ","N8MXL    ","N8MYL    ","N8MZL    ","N8PFXL   ","N8PFYL   ", &
                               "N8PFZL   ","N8PMXL   ","N8PMYL   ","N8PMZL   ","N8RAXG   ","N8RAYG   ","N8RAZG   ", &
                               "N8RDXR   ","N8RDYR   ","N8RDZR   ","N8RVXG   ","N8RVYG   ","N8RVZG   ","N8TAXG   ", &
                               "N8TAYG   ","N8TAZG   ","N8TDXR   ","N8TDYR   ","N8TDZR   ","N8TVXG   ","N8TVYG   ", &
                               "N8TVZG   ","N9DFXL   ","N9DFYL   ","N9DFZL   ","N9DMXL   ","N9DMYL   ","N9DMZL   ", &
                               "N9FXL    ","N9FYL    ","N9FZL    ","N9MXL    ","N9MYL    ","N9MZL    ","N9PFXL   ", &
                               "N9PFYL   ","N9PFZL   ","N9PMXL   ","N9PMYL   ","N9PMZL   ","N9RAXG   ","N9RAYG   ", &
                               "N9RAZG   ","N9RDXR   ","N9RDYR   ","N9RDZR   ","N9RVXG   ","N9RVYG   ","N9RVZG   ", &
                               "N9TAXG   ","N9TAYG   ","N9TAZG   ","N9TDXR   ","N9TDYR   ","N9TDZR   ","N9TVXG   ", &
                               "N9TVYG   ","N9TVZG   ","PACCACT  ","PANGACT  ","PANGINP  ","PRATACT  ","ROOTFXR  ", &
                               "ROOTFYR  ","ROOTFZR  ","ROOTMXR  ","ROOTMYR  ","ROOTMZR  ","TIPRAXG  ","TIPRAYG  ", &
                               "TIPRAZG  ","TIPRDXR  ","TIPRDYR  ","TIPRDZR  ","TIPRVXG  ","TIPRVYG  ","TIPRVZG  ", &
                               "TIPTAXG  ","TIPTAYG  ","TIPTAZG  ","TIPTDXR  ","TIPTDYR  ","TIPTDZR  ","TIPTVXG  ", &
                               "TIPTVYG  ","TIPTVZG  "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(352) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                   N1DFxl ,    N1DFyl ,    N1DFzl ,    N1DMxl ,    N1DMyl ,    N1DMzl ,     N1Fxl , &
                                    N1Fyl ,     N1Fzl ,     N1Mxl ,     N1Myl ,     N1Mzl ,    N1PFxl ,    N1PFyl , &
                                   N1PFzl ,    N1PMxl ,    N1PMyl ,    N1PMzl ,    N1RAXg ,    N1RAYg ,    N1RAZg , &
                                   N1RDxr ,    N1RDyr ,    N1RDzr ,    N1RVXg ,    N1RVYg ,    N1RVZg ,    N1TAXg , &
                                   N1TAYg ,    N1TAZg ,    N1TDxr ,    N1TDyr ,    N1TDzr ,    N1TVXg ,    N1TVYg , &
                                   N1TVZg ,    N2DFxl ,    N2DFyl ,    N2DFzl ,    N2DMxl ,    N2DMyl ,    N2DMzl , &
                                    N2Fxl ,     N2Fyl ,     N2Fzl ,     N2Mxl ,     N2Myl ,     N2Mzl ,    N2PFxl , &
                                   N2PFyl ,    N2PFzl ,    N2PMxl ,    N2PMyl ,    N2PMzl ,    N2RAXg ,    N2RAYg , &
                                   N2RAZg ,    N2RDxr ,    N2RDyr ,    N2RDzr ,    N2RVXg ,    N2RVYg ,    N2RVZg , &
                                   N2TAXg ,    N2TAYg ,    N2TAZg ,    N2TDxr ,    N2TDyr ,    N2TDzr ,    N2TVXg , &
                                   N2TVYg ,    N2TVZg ,    N3DFxl ,    N3DFyl ,    N3DFzl ,    N3DMxl ,    N3DMyl , &
                                   N3DMzl ,     N3Fxl ,     N3Fyl ,     N3Fzl ,     N3Mxl ,     N3Myl ,     N3Mzl , &
                                   N3PFxl ,    N3PFyl ,    N3PFzl ,    N3PMxl ,    N3PMyl ,    N3PMzl ,    N3RAXg , &
                                   N3RAYg ,    N3RAZg ,    N3RDxr ,    N3RDyr ,    N3RDzr ,    N3RVXg ,    N3RVYg , &
                                   N3RVZg ,    N3TAXg ,    N3TAYg ,    N3TAZg ,    N3TDxr ,    N3TDyr ,    N3TDzr , &
                                   N3TVXg ,    N3TVYg ,    N3TVZg ,    N4DFxl ,    N4DFyl ,    N4DFzl ,    N4DMxl , &
                                   N4DMyl ,    N4DMzl ,     N4Fxl ,     N4Fyl ,     N4Fzl ,     N4Mxl ,     N4Myl , &
                                    N4Mzl ,    N4PFxl ,    N4PFyl ,    N4PFzl ,    N4PMxl ,    N4PMyl ,    N4PMzl , &
                                   N4RAXg ,    N4RAYg ,    N4RAZg ,    N4RDxr ,    N4RDyr ,    N4RDzr ,    N4RVXg , &
                                   N4RVYg ,    N4RVZg ,    N4TAXg ,    N4TAYg ,    N4TAZg ,    N4TDxr ,    N4TDyr , &
                                   N4TDzr ,    N4TVXg ,    N4TVYg ,    N4TVZg ,    N5DFxl ,    N5DFyl ,    N5DFzl , &
                                   N5DMxl ,    N5DMyl ,    N5DMzl ,     N5Fxl ,     N5Fyl ,     N5Fzl ,     N5Mxl , &
                                    N5Myl ,     N5Mzl ,    N5PFxl ,    N5PFyl ,    N5PFzl ,    N5PMxl ,    N5PMyl , &
                                   N5PMzl ,    N5RAXg ,    N5RAYg ,    N5RAZg ,    N5RDxr ,    N5RDyr ,    N5RDzr , &
                                   N5RVXg ,    N5RVYg ,    N5RVZg ,    N5TAXg ,    N5TAYg ,    N5TAZg ,    N5TDxr , &
                                   N5TDyr ,    N5TDzr ,    N5TVXg ,    N5TVYg ,    N5TVZg ,    N6DFxl ,    N6DFyl , &
                                   N6DFzl ,    N6DMxl ,    N6DMyl ,    N6DMzl ,     N6Fxl ,     N6Fyl ,     N6Fzl , &
                                    N6Mxl ,     N6Myl ,     N6Mzl ,    N6PFxl ,    N6PFyl ,    N6PFzl ,    N6PMxl , &
                                   N6PMyl ,    N6PMzl ,    N6RAXg ,    N6RAYg ,    N6RAZg ,    N6RDxr ,    N6RDyr , &
                                   N6RDzr ,    N6RVXg ,    N6RVYg ,    N6RVZg ,    N6TAXg ,    N6TAYg ,    N6TAZg , &
                                   N6TDxr ,    N6TDyr ,    N6TDzr ,    N6TVXg ,    N6TVYg ,    N6TVZg ,    N7DFxl , &
                                   N7DFyl ,    N7DFzl ,    N7DMxl ,    N7DMyl ,    N7DMzl ,     N7Fxl ,     N7Fyl , &
                                    N7Fzl ,     N7Mxl ,     N7Myl ,     N7Mzl ,    N7PFxl ,    N7PFyl ,    N7PFzl , &
                                   N7PMxl ,    N7PMyl ,    N7PMzl ,    N7RAXg ,    N7RAYg ,    N7RAZg ,    N7RDxr , &
                                   N7RDyr ,    N7RDzr ,    N7RVXg ,    N7RVYg ,    N7RVZg ,    N7TAXg ,    N7TAYg , &
                                   N7TAZg ,    N7TDxr ,    N7TDyr ,    N7TDzr ,    N7TVXg ,    N7TVYg ,    N7TVZg , &
                                   N8DFxl ,    N8DFyl ,    N8DFzl ,    N8DMxl ,    N8DMyl ,    N8DMzl ,     N8Fxl , &
                                    N8Fyl ,     N8Fzl ,     N8Mxl ,     N8Myl ,     N8Mzl ,    N8PFxl ,    N8PFyl , &
                                   N8PFzl ,    N8PMxl ,    N8PMyl ,    N8PMzl ,    N8RAXg ,    N8RAYg ,    N8RAZg , &
                                   N8RDxr ,    N8RDyr ,    N8RDzr ,    N8RVXg ,    N8RVYg ,    N8RVZg ,    N8TAXg , &
                                   N8TAYg ,    N8TAZg ,    N8TDxr ,    N8TDyr ,    N8TDzr ,    N8TVXg ,    N8TVYg , &
                                   N8TVZg ,    N9DFxl ,    N9DFyl ,    N9DFzl ,    N9DMxl ,    N9DMyl ,    N9DMzl , &
                                    N9Fxl ,     N9Fyl ,     N9Fzl ,     N9Mxl ,     N9Myl ,     N9Mzl ,    N9PFxl , &
                                   N9PFyl ,    N9PFzl ,    N9PMxl ,    N9PMyl ,    N9PMzl ,    N9RAXg ,    N9RAYg , &
                                   N9RAZg ,    N9RDxr ,    N9RDyr ,    N9RDzr ,    N9RVXg ,    N9RVYg ,    N9RVZg , &
                                   N9TAXg ,    N9TAYg ,    N9TAZg ,    N9TDxr ,    N9TDyr ,    N9TDzr ,    N9TVXg , &
                                   N9TVYg ,    N9TVZg ,   PAccAct ,   PAngAct ,   PAngInp ,   PRatAct ,   RootFxr , &
                                  RootFyr ,   RootFzr ,   RootMxr ,   RootMyr ,   RootMzr ,   TipRAXg ,   TipRAYg , &
                                  TipRAZg ,   TipRDxr ,   TipRDyr ,   TipRDzr ,   TipRVXg ,   TipRVYg ,   TipRVZg , &
                                  TipTAXg ,   TipTAYg ,   TipTAZg ,   TipTDxr ,   TipTDyr ,   TipTDzr ,   TipTVXg , &
                                  TipTVYg ,   TipTVZg /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(352) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ", &
                               "(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ", &
                               "(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ", &
                               "(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ", &
                               "(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ", &
                               "(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ", &
                               "(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ", &
                               "(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ", &
                               "(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ", &
                               "(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ", &
                               "(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ", &
                               "(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ", &
                               "(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ", &
                               "(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ", &
                               "(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ", &
                               "(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ", &
                               "(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ", &
                               "(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ", &
                               "(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ", &
                               "(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ", &
                               "(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ", &
                               "(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ", &
                               "(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ", &
                               "(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ", &
                               "(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ", &
                               "(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ", &
                               "(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ", &
                               "(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ", &
                               "(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ", &
                               "(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ", &
                               "(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ", &
                               "(m/s)     ","(m/s)     ","(deg/s^2) ","(deg)     ","(deg)     ","(deg/s)   ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ", &
                               "(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ", &
                               "(m/s)     ","(m/s)     "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....
   DO I = p%NNodeOuts+1,9  ! Invalid nodes
      
      InvalidOutput( NFl( i,:) ) = .true.
      InvalidOutput( NMl( i,:) ) = .true.
      InvalidOutput( NTDr(i,:) ) = .true.
      InvalidOutput( NRDr(i,:) ) = .true.
      InvalidOutput( NTVg(i,:) ) = .true.
      InvalidOutput( NRVg(i,:) ) = .true.
      InvalidOutput( NTAg(i,:) ) = .true.
      InvalidOutput( NRAg(i,:) ) = .true.
      InvalidOutput( NPFl(i,:) ) = .true.
      InvalidOutput( NPMl(i,:) ) = .true.
      InvalidOutput( NDFl(i,:) ) = .true.
      InvalidOutput( NDMl(i,:) ) = .true.
         
   END DO   
   
   IF (.not. p%UsePitchAct) THEN
      InvalidOutput( PAngInp ) = .true.
      InvalidOutput( PAngAct ) = .true.
      InvalidOutput( PRatAct ) = .true.
      InvalidOutput( PAccAct ) = .true.
   END IF
      
   
!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the BeamDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
            
            if ( p%OutParam(I)%Indx >= N1DFxl .and. p%OutParam(I)%Indx <= N9DMzl ) p%OutInputs = .true.
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************

!----------------------------------------------------------------------------------------------------------------------------------
!> This routine validates the inputs from the BeamDyn input files.
SUBROUTINE BD_ValidateInputData( InputFileData, ErrStat, ErrMsg )
      
      ! Passed variables:

   TYPE(BD_InputFile),   INTENT(IN   ):: InputFileData                       !< All the data in the BeamDyn input file
   INTEGER(IntKi),       INTENT(  OUT):: ErrStat                             !< Error status
   CHARACTER(*),         INTENT(  OUT):: ErrMsg                              !< Error message

   
      ! local variables
   INTEGER(IntKi)                     :: i,j                                 ! loop counters
   INTEGER(IntKi)                     :: nNodes                              ! number of nodes that will be on the BldMotion mesh
      
   CHARACTER(*), PARAMETER            :: RoutineName = 'BD_ValidateInputData'
   
   ErrStat = ErrID_None
   ErrMsg  = ""
         
   IF(InputFileData%analysis_type .NE. 1 .AND. InputFileData%analysis_type .NE. 2) &
       CALL SetErrStat ( ErrID_Fatal, 'Analysis type must be 1 (static) or 2 (dynamic)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%rhoinf .LT. 0.0_BDKi .OR. InputFileData%rhoinf .GT. 1.0_BDKi) &
       CALL SetErrStat ( ErrID_Fatal, 'Numerical damping parameter \rho_{inf} must be in the range of [0.0,1.0]', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%quadrature .NE. 1 .AND. InputFileData%quadrature .NE. 2) &
       CALL SetErrStat ( ErrID_Fatal, 'Quadrature type must be 1 (Gauss) or 2 (Trapezoidal)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%refine .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Refinement parameter must be greater than or equal to 1', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%n_fact .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Factorization parameter must be greater than or equal to 1', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%member_total .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'member_total must be greater than 0', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%member_total .NE. 1 .AND. InputFileData%quadrature .EQ. 2) &
       CALL SetErrStat ( ErrID_Fatal, 'Trapzoidal quadrature only allows one member (element)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%kp_total .LT. 3 ) &
       CALL SetErrStat ( ErrID_Fatal, 'kp_total must be greater than or equal to 3', ErrStat, ErrMsg, RoutineName )
   DO i=1,InputFileData%member_total
       IF(InputFileData%kp_member(i) .LT. 3) THEN
          CALL SetErrStat(ErrID_Fatal,'There must be at least three key points in '//TRIM(Num2LStr(i))//'th member.', ErrStat, ErrMsg,RoutineName)
          EXIT
       ENDIF
   ENDDO
   IF(SUM(InputFileData%kp_member) .NE. InputFileData%kp_total+InputFileData%member_total-1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Geometric definition error: kp_total and key points in each member are inconsistent', ErrStat, ErrMsg,RoutineName)

   IF(InputFileData%order_elem .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'order_elem must be greater than 0', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%order_elem .LT. 2 .AND. InputFileData%quadrature .EQ. 1) &
       CALL SetErrStat ( ErrID_Fatal, 'order_elem must be greater than 1 for Gauss quadrature', ErrStat, ErrMsg, RoutineName )
       
   IF(InputFileData%InpBl%station_total .LT. 2 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Number of material stations along blade axis much be greater than 2', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%InpBl%station_eta(1) .NE. 0.0_BDKi ) &
       CALL SetErrStat ( ErrID_Fatal, 'The first station_eta must be equal to 0.0 (root)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%InpBl%station_eta(InputFileData%InpBl%station_total) .NE. 1.0_BDKi ) &
       CALL SetErrStat ( ErrID_Fatal, 'The last station_eta must be equal to 1.0 (tip)', ErrStat, ErrMsg, RoutineName )
   
   IF (InputFileData%NRMax < 2) CALL SetErrStat ( ErrID_Fatal, 'Maximum number of iterations in Newton-Raphson (NRMax) must be greater than 1.', ErrStat, ErrMsg, RoutineName )
   IF (InputFileData%stop_tol < EPSILON(InputFileData%stop_tol) ) &
      CALL SetErrStat ( ErrID_Fatal, 'Tolerance for stopping (stop_tol) must be larger than machine precision ('//trim(num2lstr(EPSILON(InputFileData%stop_tol)))//').', ErrStat, ErrMsg, RoutineName )
       
   if (InputFileData%UsePitchAct) then
      if ( EqualRealNos(InputFileData%pitchJ, 0.0_BDKi) ) call SetErrStat(ErrID_Fatal,'Pitch actuator inertia must not be 0.',ErrStat,ErrMsg,RoutineName)
   end if
   
   
      ! .............................
      ! check outputs:
      ! .............................
                     
   if ( ( InputFileData%NNodeOuts < 0_IntKi ) .OR. ( InputFileData%NNodeOuts > 9_IntKi ) )  then
      call SetErrStat( ErrID_Fatal, 'NNodeOuts must be between 0 and 9 (inclusive).', ErrStat, ErrMsg, RoutineName )
   else 

   ! Check to see if all OutNd(:) analysis points are existing analysis points:
      nNodes = (InputFileData%order_elem + 1)*InputFileData%member_total  ! = p%node_elem*p%elem_total (number of nodes on y%BldMotion mesh)
       
      do j=1,InputFileData%NNodeOuts
         if ( InputFileData%OutNd(j) < 1_IntKi .OR. InputFileData%OutNd(j) > nNodes ) then
            call SetErrStat( ErrID_Fatal, ' All OutNd values must be between 1 and '//&
                    trim( Num2LStr( nNodes ) )//' (inclusive).', ErrStat, ErrMsg, RoutineName )
            exit ! stop checking this loop
         end if
      end do
      
   end if      
   
END SUBROUTINE BD_ValidateInputData
!----------------------------------------------------------------------------------------------------------------------------------
!> this routine fills the AllOuts array, which is used to send data to the glue code to be written to an output file.
SUBROUTINE Calc_WriteOutput( p, u, AllOuts, y, m, ErrStat, ErrMsg )
   

   TYPE(BD_ParameterType),    INTENT(IN   )  :: p                                 !< The module parameters
   TYPE(BD_InputType),        INTENT(IN   )  :: u                                 !< inputs
   REAL(ReKi),                INTENT(INOUT)  :: AllOuts(0:)                       !< array of values to potentially write to file
   TYPE(BD_OutputType),       INTENT(IN   )  :: y                                 !< outputs
   TYPE(BD_MiscVarType),      INTENT(INOUT)  :: m                                 !< misc/optimization variables (for computing mesh transfers)
   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat                           !< The error status code
   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg                            !< The error message, if an error occurred

      ! local variables
   CHARACTER(*), PARAMETER                   :: RoutineName = 'Calc_WriteOutput'
   INTEGER(IntKi)                            :: ErrStat2
   CHARACTER(ErrMsgLen)                      :: ErrMsg2
   
   
   INTEGER(IntKi)                            :: j,beta,j_BldMotion
   INTEGER(IntKi)                            :: elem_no
   INTEGER(IntKi)                            :: node_no
   INTEGER(IntKi)                            :: temp_id
   REAL(BDKi)                                :: temp_glb(3)
   REAL(BDKi)                                :: temp_vec(3)
   REAL(BDKi)                                :: temp_vec2(3)
   REAL(BDKi)                                :: temp_glbp(3)
   REAL(BDKi)                                :: temp_roott(3)
   REAL(BDKi)                                :: temp_tip0(3)
   REAL(BDKi)                                :: temp_ini(3)
   REAL(BDKi)                                :: temp_cur(3)
   REAL(BDKi)                                :: temp_cc(3)
   REAL(BDKi)                                :: temp_R(3,3)
   REAL(BDKi)                                :: temp33(3,3)
   REAL(BDKi)                                :: temp33_2(3,3)
   
   
      ! start routine:
   ErrStat = ErrID_None
   ErrMsg  = ""
   
   
   temp_vec = MATMUL(u%RootMotion%Orientation(:,:,1),y%ReactionForce%Force(:,1))
   AllOuts( RootFxr ) = temp_vec(1)
   AllOuts( RootFyr ) = temp_vec(2)
   AllOuts( RootFzr ) = temp_vec(3) 

   temp_vec = MATMUL(u%RootMotion%Orientation(:,:,1),y%ReactionForce%Moment(:,1))
   AllOuts( RootMxr ) = temp_vec(1)
   AllOuts( RootMyr ) = temp_vec(2)
   AllOuts( RootMzr ) = temp_vec(3) 

   
      ! we don't need to calculate the rest of these values if we don't ask for WriteOutput channels
   ! (but we did need RootMxr and RootMyr)
   if ( p%NumOuts <= 0 ) RETURN

   ! convert global position and crv values:
   temp_glb(1) = p%Glb_crv(2)
   temp_glb(2) = p%Glb_crv(3)
   temp_glb(3) = p%Glb_crv(1)

   temp_glbp(1) = p%GlbPos(2)
   temp_glbp(2) = p%GlbPos(3)
   temp_glbp(3) = p%GlbPos(1)
   
      ! tip motions:   
   temp_vec = MATMUL(p%GlbRot, p%uuN0( (p%node_elem*p%dof_node-5):(p%node_elem*p%dof_node-3),p%elem_total) )
   temp_tip0(1) = temp_vec(2)
   temp_tip0(2) = temp_vec(3)
   temp_tip0(3) = temp_vec(1)
   temp_ini(:) = temp_glbp(:) + temp_tip0(:)
   temp_roott(:) = temp_glbp(:) + u%RootMotion%TranslationDisp(:,1)
   temp33_2=TRANSPOSE(u%RootMotion%Orientation(1:3,1:3,1))  ! possible type conversion here
   CALL BD_CrvExtractCrv(temp33_2,temp_vec,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvCompose(temp_cc,temp_vec,temp_glb,2,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvMatrixR(temp_cc,temp_R,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   temp_vec = MATMUL(temp_R,temp_tip0)
   temp_cur = temp_roott + temp_vec
   temp_vec = y%BldMotion%TranslationDisp(1:3,p%node_elem*p%elem_total) - (temp_cur(:) - temp_ini(:))
   temp_vec = MATMUL(u%RootMotion%Orientation(1:3,1:3,1),temp_vec)
   AllOuts( TipTDxr ) = temp_vec(1)
   AllOuts( TipTDyr ) = temp_vec(2)
   AllOuts( TipTDzr ) = temp_vec(3)
   !
   temp_vec(1:3) = MATMUL(p%GlbRot, p%uuN0( (p%node_elem*p%dof_node-2):(p%node_elem*p%dof_node),p%elem_total) )
   temp_vec2   = temp_vec
   temp_vec(1) = temp_vec2(2)
   temp_vec(2) = temp_vec2(3)
   temp_vec(3) = temp_vec2(1)
   CALL BD_CrvCompose(temp_vec2,temp_vec,temp_glb,0,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvCompose(temp_vec,temp_cc,temp_vec2,0,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   temp_cur(:) = 0.0_BDKi
   temp33_2=TRANSPOSE(y%BldMotion%Orientation(1:3,1:3,p%node_elem*p%elem_total)) ! possible type conversion here   
   CALL BD_CrvExtractCrv(temp33_2,temp_cur,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvCompose(temp_vec2,temp_cur,temp_vec,2,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   temp_vec(:) = MATMUL(u%RootMotion%Orientation(1:3,1:3,1),temp_vec2)
   AllOuts( TipRDxr ) = temp_vec(1)
   AllOuts( TipRDyr ) = temp_vec(2)
   AllOuts( TipRDzr ) = temp_vec(3)
   !
   AllOuts( TipTVXg ) = y%BldMotion%TranslationVel(1,p%node_elem*p%elem_total)
   AllOuts( TipTVYg ) = y%BldMotion%TranslationVel(2,p%node_elem*p%elem_total)
   AllOuts( TipTVZg ) = y%BldMotion%TranslationVel(3,p%node_elem*p%elem_total)
   !
   AllOuts( TipRVXg ) = y%BldMotion%RotationVel(1,p%node_elem*p%elem_total)
   AllOuts( TipRVYg ) = y%BldMotion%RotationVel(2,p%node_elem*p%elem_total)
   AllOuts( TipRVZg ) = y%BldMotion%RotationVel(3,p%node_elem*p%elem_total)
   !
   AllOuts( TipTAXg ) = y%BldMotion%TranslationAcc(1,p%node_elem*p%elem_total)
   AllOuts( TipTAYg ) = y%BldMotion%TranslationAcc(2,p%node_elem*p%elem_total)
   AllOuts( TipTAZg ) = y%BldMotion%TranslationAcc(3,p%node_elem*p%elem_total)
   !
   AllOuts( TipRAXg ) = y%BldMotion%RotationAcc(1,p%node_elem*p%elem_total)
   AllOuts( TipRAYg ) = y%BldMotion%RotationAcc(2,p%node_elem*p%elem_total)
   AllOuts( TipRAZg ) = y%BldMotion%RotationAcc(3,p%node_elem*p%elem_total)


      ! outputs on the nodes
   do beta=1,p%NNodeOuts
         
      j=p%OutNd(beta)
      j_BldMotion = p%NdIndx(j)      
      
      !bjj: if we have a zero-length element, we probably need to use j_BldMotion in the following "if" statement
      IF(j .LE. p%node_elem) THEN
          elem_no = 1
          node_no = j
      ELSE
          elem_no = INT((j+1)/(p%node_elem-1))
          node_no = j - (elem_no - 1)*(p%node_elem-1)
      ENDIF
      temp_id = (elem_no-1)*p%node_elem+node_no
      temp33 = y%BldMotion%Orientation(1:3,1:3,temp_id)

      temp_vec = MATMUL(temp33,y%BldForce%Force(:,j))
      AllOuts( NFl( beta,1 ) ) = temp_vec(1) 
      AllOuts( NFl( beta,2 ) ) = temp_vec(2)
      AllOuts( NFl( beta,3 ) ) = temp_vec(3)
      !
      temp_vec = MATMUL(temp33,y%BldForce%Moment(:,j))
      AllOuts( NMl( beta,1 ) ) = temp_vec(1) 
      AllOuts( NMl( beta,2 ) ) = temp_vec(2)
      AllOuts( NMl( beta,3 ) ) = temp_vec(3)
      !
      temp_vec = MATMUL(p%GlbRot, p%uuN0( (node_no*p%dof_node-5):(node_no*p%dof_node-3),elem_no) )
      temp_tip0(1) = temp_vec(2)
      temp_tip0(2) = temp_vec(3)
      temp_tip0(3) = temp_vec(1)
      temp_ini = temp_glbp + temp_tip0
      temp_vec = MATMUL(temp_R,temp_tip0)
      temp_cur = temp_roott + temp_vec
      temp_vec = y%BldMotion%TranslationDisp(1:3,p%node_elem*(elem_no-1)+node_no) - (temp_cur - temp_ini)
      temp_vec = MATMUL(u%RootMotion%Orientation(1:3,1:3,1),temp_vec)
      AllOuts( NTDr( beta,1 ) ) = temp_vec(1) 
      AllOuts( NTDr( beta,2 ) ) = temp_vec(2)
      AllOuts( NTDr( beta,3 ) ) = temp_vec(3)
      !
      temp_vec = MATMUL(p%GlbRot, p%uuN0( (node_no*p%dof_node-2):(node_no*p%dof_node),elem_no) )
      temp_vec2 = temp_vec
      temp_vec(1) = temp_vec2(2)
      temp_vec(2) = temp_vec2(3)
      temp_vec(3) = temp_vec2(1)
      CALL BD_CrvCompose(temp_vec2,temp_vec,temp_glb,0,ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL BD_CrvCompose(temp_vec,temp_cc,temp_vec2,0,ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      temp33_2 = TRANSPOSE(y%BldMotion%Orientation(1:3,1:3,temp_id)) ! possible type conversion here
      CALL BD_CrvExtractCrv(temp33_2,temp_cur,ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL BD_CrvCompose(temp_vec2,temp_cur,temp_vec,2,ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      temp_vec = MATMUL(u%RootMotion%Orientation(1:3,1:3,1),temp_vec2)
      AllOuts( NRDr( beta,1 ) ) = temp_vec(1)
      AllOuts( NRDr( beta,2 ) ) = temp_vec(2) 
      AllOuts( NRDr( beta,3 ) ) = temp_vec(3)
            
      AllOuts( NTVg( beta,1 ) ) = y%BldMotion%TranslationVel(1,j)
      AllOuts( NTVg( beta,2 ) ) = y%BldMotion%TranslationVel(2,j)
      AllOuts( NTVg( beta,3 ) ) = y%BldMotion%TranslationVel(3,j)
         
      AllOuts( NRVg( beta,1 ) ) = y%BldMotion%RotationVel(1,j)*R2D
      AllOuts( NRVg( beta,2 ) ) = y%BldMotion%RotationVel(2,j)*R2D
      AllOuts( NRVg( beta,3 ) ) = y%BldMotion%RotationVel(3,j)*R2D
    
      AllOuts( NTAg( beta,1 ) ) = y%BldMotion%TranslationAcc(1,j)
      AllOuts( NTAg( beta,2 ) ) = y%BldMotion%TranslationAcc(2,j)
      AllOuts( NTAg( beta,3 ) ) = y%BldMotion%TranslationAcc(3,j)
         
      AllOuts( NRAg( beta,1 ) ) = y%BldMotion%RotationAcc(1,j)*R2D
      AllOuts( NRAg( beta,2 ) ) = y%BldMotion%RotationAcc(2,j)*R2D
      AllOuts( NRAg( beta,3 ) ) = y%BldMotion%RotationAcc(3,j)*R2D
            
      !
      temp_vec = MATMUL(temp33,u%PointLoad%Force(:,j))
      AllOuts( NPFl( beta,1 ) ) = temp_vec(1) 
      AllOuts( NPFl( beta,2 ) ) = temp_vec(2) 
      AllOuts( NPFl( beta,3 ) ) = temp_vec(3)     
      !
      temp_vec = MATMUL(temp33,u%PointLoad%Moment(:,j))
      AllOuts( NPMl( beta,1 ) ) = temp_vec(1) 
      AllOuts( NPMl( beta,2 ) ) = temp_vec(2) 
      AllOuts( NPMl( beta,3 ) ) = temp_vec(3) 
      
      
   end do ! nodes
         
      ! to avoid unnecessary mesh mapping calculations, calculate these outputs only when we've requested them 
   if (p%OutInputs) then 

         ! transfer the output motions to the input nodes for load transfer
      CALL Transfer_Line2_to_Line2( y%BldMotion, m%y_BldMotion_at_u, m%Map_y_BldMotion_to_u, ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
         ! transfer the input loads to the output nodes for writing output
      CALL Transfer_Line2_to_Line2( u%DistrLoad, m%u_DistrLoad_at_y, m%Map_u_DistrLoad_to_y, ErrStat2, ErrMsg2, m%y_BldMotion_at_u, y%BldMotion)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         
      
      do beta=1,p%NNodeOuts
         
         j=p%OutNd(beta)         
         j_BldMotion = p%NdIndx(j)      
      
         !bjj: if we have a zero-length element, we probably need to use j_BldMotion in the following "if" statement
         IF(j .LE. p%node_elem) THEN
             elem_no = 1
             node_no = j
         ELSE
             elem_no = INT((j+1)/(p%node_elem-1))
             node_no = j - (elem_no - 1)*(p%node_elem-1)
         ENDIF
         temp_id = (elem_no-1)*p%node_elem+node_no
         temp33 = y%BldMotion%Orientation(1:3,1:3,temp_id)
         
         AllOuts( NDFl( beta,: ) ) = MATMUL(temp33,m%u_DistrLoad_at_y%Force( :,j))
         AllOuts( NDMl( beta,: ) ) = MATMUL(temp33,m%u_DistrLoad_at_y%Moment(:,j))
         
      end do ! nodes
         
      
   end if
   
   
   
   
END SUBROUTINE Calc_WriteOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine generates the summary file, which contains a regurgitation of  the input data and interpolated flexible body data.
SUBROUTINE BD_PrintSum( p, u, y, x, m, RootName, ErrStat, ErrMsg )

      ! passed variables
   TYPE(BD_ParameterType),       INTENT(IN)  :: p                 !< Parameters of the structural dynamics module
   TYPE(BD_InputType),           INTENT(IN)  :: u                 !< inputs 
   TYPE(BD_OutputType),          INTENT(IN)  :: y                 !< outputs
   type(BD_ContinuousStateType), intent(in)  :: x                 !< Continuous states
   TYPE(BD_MiscVarType),         INTENT(IN)  :: m                 !< misc/optimization variables 
   CHARACTER(*),                 INTENT(IN)  :: RootName          !< root name of summary file to be generated (will add .sum in this routine)
   INTEGER(IntKi),               INTENT(OUT) :: ErrStat           !< error status
   CHARACTER(*),                 INTENT(OUT) :: ErrMsg            !< error message


      ! Local variables.

   INTEGER(IntKi)               :: I                                               ! Index for the nodes
   INTEGER(IntKi)               :: j, k                                            ! Generic index
   INTEGER(IntKi)               :: temp_id                                         ! Generic index
   INTEGER(IntKi)               :: UnSu                                            ! I/O unit number for the summary output file

   CHARACTER(*), PARAMETER      :: FmtDat    = '(A,T35,1(:,F13.3))'                ! Format for outputting mass and modal data.
   CHARACTER(*), PARAMETER      :: FmtDatT   = '(A,T35,1(:,F13.8))'                ! Format for outputting time steps.

   CHARACTER(30)                :: OutPFmt                                         ! Format to print list of selected output channels to summary file

   ! Open the summary file and give it a heading.
      
   CALL GetNewUnit( UnSu, ErrStat, ErrMsg )
   CALL OpenFOutFile ( UnSu, TRIM( RootName )//'.sum', ErrStat, ErrMsg )
   IF ( ErrStat >= AbortErrLev ) RETURN

      ! Heading:
   WRITE (UnSu,'(/,A)')  'This summary information was generated by '//TRIM( GetNVD(BeamDyn_Ver) )// &
                         ' on '//CurDate()//' at '//CurTime()//'.'

   WRITE (UnSu,'(A,F13.3)')  'Blade mass                  (kg)    ', p%blade_mass
   WRITE (UnSu,'(A,F13.3)' ) 'Blade length                 (m)    ', p%blade_length

   WRITE (UnSu,'(A)')  'Blade center of mass: '
   WRITE (UnSu,'(3ES18.5)' ) p%blade_CG(:)

!   WRITE (UnSu,'(A)')  'Blade mass moment of inertia: '
!   DO i=1,3
!       WRITE (UnSu,'(3ES18.5)' ) p%blade_IN(i,:)
!   ENDDO

   WRITE (UnSu,'(A)')  'Global position vector:' 
   WRITE (UnSu,'(3ES18.5)' ) p%GlbPos(:)

   WRITE (UnSu,'(A)')  'Global rotation tensor:' 
   DO i=1,3
       WRITE (UnSu,'(3ES18.5)' ) p%GlbRot(i,:)
   ENDDO

   WRITE (UnSu,'(A)')  'Gravity vector (m/s^2):' 
   WRITE (UnSu,'(3ES18.5)' ) p%gravity(:)

   IF(p%analysis_type .EQ. 1) THEN
       WRITE (UnSu,'(A)')  'Analysis type: STATIC' 
   ELSEIF(p%analysis_type .EQ. 2) THEN
       WRITE (UnSu,'(A)')  'Analysis type: DYNAMIC' 
   ENDIF

   WRITE (UnSu,'(A,1ES18.5)')  'Numerical damping parameter:',p%rhoinf

   WRITE (UnSu,'(A,1ES18.5)')  'Time increment:',p%dt 

   WRITE (UnSu,'(A,I4)' ) 'Maximum number of iterations in Newton-Ralphson solution:', p%niter
   WRITE (UnSu,'(A,1ES18.5)' ) 'Convergence parameter:', p%tol
   WRITE (UnSu,'(A,I4)' ) 'Factorization frequency in Newton-Ralphson solution:', p%n_fact

   IF(p%quadrature .EQ. 1) THEN
       WRITE (UnSu,'(A)')  'Quadrature method: Gauss quadrature' 
   ELSEIF(p%quadrature .EQ. 2) THEN
       WRITE (UnSu,'(A)')  'Quadrature method: Trapezoidal quadrature' 
       WRITE (UnSu,'(A,I4)' ) 'FE mesh refinement factor:', p%refine
   ENDIF

   WRITE (UnSu,'(A,I4)' ) 'Number of elements:    ', p%elem_total

   WRITE (UnSu,'(A,I4)' ) 'Number of nodes:       ', p%node_total

   WRITE (UnSu,'(/,A)')  'Initial position vectors'
   k=1
   DO i=1,p%elem_total
       WRITE (UnSu,'(2x,A,I4)')  'Element number: ',i
       WRITE (UnSu, '(2x,A,1x,A)') 'Node', 'Global node' 
       WRITE (UnSu, '(2x,A,1x,A)') '----', '-----------' 
       DO j = 1, p%node_elem
           temp_id = (j-1)*p%dof_node
           WRITE(UnSu,'(I6,1x,I9,2x,3ES18.5)') j,k,p%uuN0(temp_id+1:temp_id+3,i)
           k=k+1
       ENDDO
       k = k-1
   ENDDO
   WRITE (UnSu,'(/,A)')  'Initial rotation vectors'
   k=1
   DO i=1,p%elem_total
       WRITE (UnSu,'(2x,A,I4)')  'Element number: ',i
       WRITE (UnSu, '(2x,A,1x,A)') 'Node', 'Global node' 
       WRITE (UnSu, '(2x,A,1x,A)') '----', '-----------' 
       DO j = 1, p%node_elem
           temp_id = (j-1)*p%dof_node
           WRITE(UnSu,'(I6,1x,I9,2x,3ES18.5)') j,k,p%uuN0(temp_id+4:temp_id+6,i)
           k=k+1
       ENDDO
       k = k-1
   ENDDO

   WRITE (UnSu,'(/,A)')  'Quadrature point position vectors'
   IF(p%quadrature .EQ. 1) THEN
       DO i=2,p%ngp*p%elem_total + 1
           WRITE(UnSu,'(I4,3ES18.5)') i-1,p%Gauss(1:3,i)
       ENDDO
   ELSEIF(p%quadrature .EQ. 2) THEN
       DO i=1,p%ngp
           WRITE(UnSu,'(I4,3ES18.5)') i,p%Gauss(1:3,i)
       ENDDO
   ENDIF
   WRITE (UnSu,'(/,A)')  'Sectional stiffness and mass matrices at quadrature points'
   IF(p%quadrature .EQ. 1) THEN
       DO i=1,p%ngp*p%elem_total
           WRITE (UnSu,'(/,A,I4)')  'Gauss point number: ',i
           DO j=1,6
               WRITE(UnSu,'(6ES15.5)') p%Stif0_GL(j,1:6,i)
           ENDDO
           WRITE(UnSu,'(A)') 
           DO j=1,6
               WRITE(UnSu,'(6ES15.5)') p%Mass0_GL(j,1:6,i)
           ENDDO
       ENDDO
   ELSEIF(p%quadrature .EQ. 2) THEN
       DO i=1,p%ngp
           WRITE (UnSu,'(/,A,I4)')  'Quadrature point number: ',i
           DO j=1,6
               WRITE(UnSu,'(6ES15.5)') p%Stif0_GL(j,1:6,i)
           ENDDO
           WRITE(UnSu,'(A)') 
           DO j=1,6
               WRITE(UnSu,'(6ES15.5)') p%Mass0_GL(j,1:6,i)
           ENDDO
       ENDDO
   ENDIF

   WRITE (UnSu,'(/,A)')  'Initial displacement'
   DO i=1,p%node_total
       temp_id = (i - 1)*p%dof_node
       WRITE(UnSu,'(I4,3ES18.5)') i,x%q(temp_id+1:temp_id+3)
   ENDDO

   WRITE (UnSu,'(/,A)')  'Initial rotation'
   DO i=1,p%node_total
       temp_id = (i - 1)*p%dof_node
       WRITE(UnSu,'(I4,3ES18.5)') i,x%q(temp_id+4:temp_id+6)
   ENDDO

   WRITE (UnSu,'(/,A)')  'Initial velocity'
   DO i=1,p%node_total
       temp_id = (i - 1)*p%dof_node
       WRITE(UnSu,'(I4,3ES18.5)') i,x%dqdt(temp_id+1:temp_id+3)
   ENDDO

   WRITE (UnSu,'(/,A)')  'Initial angular velocity'
   DO i=1,p%node_total
       temp_id = (i - 1)*p%dof_node
       WRITE(UnSu,'(I4,3ES18.5)') i,x%dqdt(temp_id+4:temp_id+6)
   ENDDO

         
   ! output channels:
   OutPFmt = '( I4, 3X,A '//TRIM(Num2LStr(ChanLen))//',1 X, A'//TRIM(Num2LStr(ChanLen))//' )'
   WRITE (UnSu,'(//,A,/)')  'Requested Outputs:'
   WRITE (UnSu,"( '  Col  Parameter  Units', /, '  ---  ---------  -----')")
   DO I = 0,p%NumOuts
      WRITE (UnSu,OutPFmt)  I, p%OutParam(I)%Name, p%OutParam(I)%Units
   END DO             

   CLOSE(UnSu)

RETURN
END SUBROUTINE BD_PrintSum
!----------------------------------------------------------------------------------------------------------------------------------
END MODULE BeamDyn_IO
