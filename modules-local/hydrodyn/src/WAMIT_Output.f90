!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2013  National Renewable Energy Laboratory
!
!    This file is part of HydroDyn.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!    
!**********************************************************************************************************************************
! File last committed: $Date: 2013-09-30 08:26:40 -0600 (Mon, 30 Sep 2013) $
! (File) Revision #: $Rev: 232 $
! URL: $HeadURL: https://windsvn.nrel.gov/HydroDyn/branches/HydroDyn_Modularization/Source/WAMIT_Output.f90 $
!**********************************************************************************************************************************
MODULE WAMIT_Output

      ! This MODULE stores variables used for output.

   USE                              NWTC_Library
   USE                              WAMIT_Types
   !USE                              HydroDyn_Output_Types
   USE                              Waves
   IMPLICIT                         NONE
   
   PRIVATE

       ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

    

  ! WAMIT Body Forces:

   INTEGER, PARAMETER             :: WavesFxi  =  1
   INTEGER, PARAMETER             :: WavesFyi  =  2
   INTEGER, PARAMETER             :: WavesFzi  =  3
   INTEGER, PARAMETER             :: WavesMxi  =  4
   INTEGER, PARAMETER             :: WavesMyi  =  5
   INTEGER, PARAMETER             :: WavesMzi  =  6
   INTEGER, PARAMETER             :: HdrStcFxi =  7
   INTEGER, PARAMETER             :: HdrStcFyi =  8
   INTEGER, PARAMETER             :: HdrStcFzi =  9
   INTEGER, PARAMETER             :: HdrStcMxi = 10
   INTEGER, PARAMETER             :: HdrStcMyi = 11
   INTEGER, PARAMETER             :: HdrStcMzi = 12
   INTEGER, PARAMETER             :: RdtnFxi   = 13
   INTEGER, PARAMETER             :: RdtnFyi   = 14
   INTEGER, PARAMETER             :: RdtnFzi   = 15
   INTEGER, PARAMETER             :: RdtnMxi   = 16
   INTEGER, PARAMETER             :: RdtnMyi   = 17
   INTEGER, PARAMETER             :: RdtnMzi   = 18


  ! Forces due to additional preload, stiffness, and damping:

   INTEGER, PARAMETER             :: AddFxi    = 19
   INTEGER, PARAMETER             :: AddFyi    = 20
   INTEGER, PARAMETER             :: AddFzi    = 21
   INTEGER, PARAMETER             :: AddMxi    = 22
   INTEGER, PARAMETER             :: AddMyi    = 23
   INTEGER, PARAMETER             :: AddMzi    = 24


  ! Wave Motions:

   INTEGER, PARAMETER             :: Wave1Elev = 25
   INTEGER, PARAMETER             :: Wave2Elev = 26
   INTEGER, PARAMETER             :: Wave3Elev = 27
   INTEGER, PARAMETER             :: Wave4Elev = 28
   INTEGER, PARAMETER             :: Wave5Elev = 29
   INTEGER, PARAMETER             :: Wave6Elev = 30
   INTEGER, PARAMETER             :: Wave7Elev = 31
   INTEGER, PARAMETER             :: Wave8Elev = 32
   INTEGER, PARAMETER             :: Wave9Elev = 33



  
!End of code generated by Matlab script

   INTEGER, PARAMETER             :: WaveElevi(9) = (/Wave1Elev,Wave2Elev,Wave3Elev,Wave4Elev,Wave5Elev,Wave6Elev,Wave7Elev,Wave8Elev,Wave9Elev/)
   INTEGER, PARAMETER             :: FWaves(6)    = (/WavesFxi,WavesFyi,WavesFzi,WavesMxi,WavesMyi,WavesMzi/)
   INTEGER, PARAMETER             :: FAdd(6)      = (/AddFxi,AddFyi,AddFzi,AddMxi,AddMyi,AddMzi/)
   INTEGER, PARAMETER             :: FHdrSttc(6)  = (/HdrStcFxi,HdrStcFyi,HdrStcFzi,HdrStcMxi,HdrStcMyi,HdrStcMzi/)
   INTEGER, PARAMETER             :: FRdtn(6)     = (/RdtnFxi,RdtnFyi,RdtnFzi,RdtnMxi,RdtnMyi,RdtnMzi/)
   
  
   
   ! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 21-Mar-2013 08:13:04.
      CHARACTER( 9),PARAMETER  :: ValidParamAry(MaxOutputs) =  (/ &                         ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "ADDFXI   ","ADDFYI   ","ADDFZI   ","ADDMXI   ","ADDMYI   ","ADDMZI   ","HDRSTCFXI", &
                               "HDRSTCFYI","HDRSTCFZI","HDRSTCMXI","HDRSTCMYI","HDRSTCMZI","RDTNFXI  ","RDTNFYI  ", &
                               "RDTNFZI  ","RDTNMXI  ","RDTNMYI  ","RDTNMZI  ","WAVE1ELEV","WAVE2ELEV","WAVE3ELEV", &
                               "WAVE4ELEV","WAVE5ELEV","WAVE6ELEV","WAVE7ELEV","WAVE8ELEV","WAVE9ELEV","WAVESFXI ", &
                               "WAVESFYI ","WAVESFZI ","WAVESMXI ","WAVESMYI ","WAVESMZI "/)
   INTEGER,      PARAMETER  :: ParamIndxAry(MaxOutputs) =  (/ &                          ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                   AddFxi ,    AddFyi ,    AddFzi ,    AddMxi ,    AddMyi ,    AddMzi , HdrStcFxi , &
                                HdrStcFyi , HdrStcFzi , HdrStcMxi , HdrStcMyi , HdrStcMzi ,   RdtnFxi ,   RdtnFyi , &
                                  RdtnFzi ,   RdtnMxi ,   RdtnMyi ,   RdtnMzi , Wave1Elev , Wave2Elev , Wave3Elev , &
                                Wave4Elev , Wave5Elev , Wave6Elev , Wave7Elev , Wave8Elev , Wave9Elev ,  WavesFxi , &
                                 WavesFyi ,  WavesFzi ,  WavesMxi ,  WavesMyi ,  WavesMzi /)
   CHARACTER(10),PARAMETER  :: ParamUnitsAry(MaxOutputs) =  (/ &                         ! This lists the units corresponding to the allowed parameters
                               "(kN)      ","(kN)      ","(kN)      ","(kN·m)    ","(kN·m)    ","(kN·m)    ","(kN)      ", &
                               "(kN)      ","(kN)      ","(kN·m)    ","(kN·m)    ","(kN·m)    ","(kN)      ","(kN)      ", &
                               "(kN)      ","(kN·m)    ","(kN·m)    ","(kN·m)    ","(m)       ","(m)       ","(m)       ", &
                               "(m)       ","(m)       ","(m)       ","(m)       ","(m)       ","(m)       ","(kN)      ", &
                               "(kN)      ","(kN)      ","(kN·m)    ","(kN·m)    ","(kN·m)    "/)
   

  
   REAL(ReKi)               :: AllOuts(MaxOutputs)          ! Array of all possible outputs
   
      ! ..... Public Subroutines ...................................................................................................
   PUBLIC :: WMTOUT_MapOutputs
   PUBLIC :: WMTOUT_WriteOutputNames
   PUBLIC :: WMTOUT_WriteOutputUnits
   PUBLIC :: WMTOUT_WriteOutputs
   PUBLIC :: WMTOUT_Init
   PUBLIC :: WMTOUT_DestroyParam

CONTAINS




!====================================================================================================
SUBROUTINE WMTOUT_MapOutputs( CurrentTime, y, NWaveElev, WaveElev, F_Waves, F_HS, F_Rdtn, F_Add, AllOuts, ErrStat, ErrMsg )
! This subroutine writes the data stored in the y variable to the correct indexed postions in WriteOutput
! This is called by WAMIT_CalcOutput() at each time step.
!---------------------------------------------------------------------------------------------------- 
   REAL(DbKi),                         INTENT( IN    )  :: CurrentTime    ! Current simulation time in seconds
   TYPE(WAMIT_OutputType),             INTENT( INOUT )  :: y              ! WAMIT's output data
   INTEGER,                            INTENT( IN    )  :: NWaveElev      ! Number of wave elevation locations to output
   REAL(ReKi),                         INTENT( IN    )  :: WaveElev(:)    ! Instantaneous elevation of incident waves at each of the NWaveElev points where the incident wave elevations can be output (meters)   
   REAL(ReKi),                         INTENT( IN    )  :: F_Waves(6)
   REAL(ReKi),                         INTENT( IN    )  :: F_HS(6)
   REAL(ReKi),                         INTENT( IN    )  :: F_Rdtn(6)
   REAL(ReKi),                         INTENT( IN    )  :: F_Add(6)
   REAL(ReKi),                         INTENT(   OUT )  :: AllOuts(MaxOutputs)
   INTEGER(IntKi),                     INTENT(   OUT )  :: ErrStat        ! Error status of the operation
   CHARACTER(*),                       INTENT(   OUT )  :: ErrMsg         ! Error message if ErrStat /= ErrID_None

   INTEGER                                              :: I
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   
   ! TODO:  use y%mesh for the forces instead of individual parameters

   !AllOuts(Time)      = REAL(CurrentTime,ReKi)
   AllOuts(FWaves)   = F_Waves
   AllOuts(FHdrSttc) = F_HS
   AllOuts(FAdd)     = F_Add
   AllOuts(FRdtn)    = F_Rdtn
   
   DO I=1,NWaveElev
      AllOuts(WaveElevi(I)) = WaveElev(I)
   END DO
   
   
   
END SUBROUTINE WMTOUT_MapOutputs


!====================================================================================================

SUBROUTINE WMTOUT_WriteOutputNames( UnOutFile, p, ErrStat, ErrMsg )

   INTEGER,                      INTENT( IN    ) :: UnOutFile            ! file unit for the output file
   TYPE(WAMIT_ParameterType),    INTENT( IN    ) :: p                    ! WAMIT module's parameter data
   INTEGER,                      INTENT(   OUT ) :: ErrStat              ! returns a non-zero value when an error occurs  
   CHARACTER(*),                 INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
   CHARACTER(200)                                :: Frmt                 ! a string to hold a format statement
   INTEGER                                       :: I                    ! Generic loop counter
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   Frmt = '(A8,'//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutSFmt )//'))'

   WRITE(UnOutFile,Frmt)  'Time', ( p%Delim, TRIM( p%OutParam(I)%Name ), I=1,p%NumOuts )
      
END SUBROUTINE WMTOUT_WriteOutputNames

!====================================================================================================


SUBROUTINE WMTOUT_WriteOutputUnits( UnOutFile, p, ErrStat, ErrMsg )

   INTEGER,                      INTENT( IN    ) :: UnOutFile            ! file unit for the output file
   TYPE(WAMIT_ParameterType),    INTENT( IN    ) :: p                    ! WAMIT module's parameter data
   INTEGER,                      INTENT(   OUT ) :: ErrStat              ! returns a non-zero value when an error occurs  
   CHARACTER(*),                 INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
   CHARACTER(200)                         :: Frmt                        ! a string to hold a format statement
   INTEGER                                :: I                           ! Generic loop counter
   
   ErrStat = ErrID_None
   ErrMsg = ""
   
   Frmt = '(A8,'//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutSFmt )//'))'

   WRITE(UnOutFile,Frmt)  '(sec)', ( p%Delim, TRIM( p%OutParam(I)%Units ), I=1,p%NumOuts )
      
END SUBROUTINE WMTOUT_WriteOutputUnits

!====================================================================================================
SUBROUTINE WMTOUT_WriteOutputs( UnOutFile, Time, y, p, ErrStat, ErrMsg )
! This subroutine writes the data stored in WriteOutputs (and indexed in OutParam) to the file
! opened in WMTOUT_Init()
!---------------------------------------------------------------------------------------------------- 

      ! Passed variables  
   INTEGER               ,    INTENT( IN    ) :: UnOutFile
   REAL(DbKi),                INTENT( IN    ) :: Time                 ! Time for this output
   TYPE(WAMIT_OutputType),    INTENT( INOUT ) :: y                    ! WAMIT's output data
   TYPE(WAMIT_ParameterType), INTENT( IN    ) :: p                    ! WAMIT parameter data
   INTEGER,                   INTENT(   OUT ) :: ErrStat              ! returns a non-zero value when an error occurs  
   CHARACTER(*),              INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
      ! Local variables
   REAL(ReKi)                             :: OutData (0:p%NumOuts)       ! an output array
   INTEGER                                :: I                           ! Generic loop counter
   CHARACTER(200)                         :: Frmt                        ! a string to hold a format statement
   

  
      ! Initialize ErrStat and determine if it makes any sense to write output
      
   IF ( .NOT. ALLOCATED( p%OutParam ) .OR. UnOutFile < 0 )  THEN
      ErrMsg  = '  No WAMIT outputs written.  The OutParam array must be allocated and there must be a valid output file identifier before we can write outputs.'
      ErrStat = ErrID_Warn
      RETURN
   ELSE
      ErrStat = ErrID_None
      ErrMsg  = ''
   END IF


 


      ! Write the output parameters to the file
      
   Frmt = '(F8.3,'//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutFmt )//'))'
   !Frmt = '('//TRIM( p%OutFmt )//','//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutFmt )//'))'

   WRITE(UnOutFile,Frmt)  Time, ( p%Delim, y%WriteOutput(I), I=1,p%NumOuts )

   
   RETURN


END SUBROUTINE WMTOUT_WriteOutputs



!====================================================================================================
SUBROUTINE WMTOUT_Init( InitInp, y,  p, InitOut, ErrStat, ErrMsg )
! This subroutine initialized the output module, checking if the output parameter list (OutList)
! contains valid names, and opening the output file if there are any requested outputs
!----------------------------------------------------------------------------------------------------

   

      ! Passed variables

   
   TYPE(WAMIT_InitInputType ), INTENT( IN    ) :: InitInp              ! data needed to initialize the output module     
   TYPE(WAMIT_OutputType),     INTENT( INOUT ) :: y                    ! This module's internal data
   TYPE(WAMIT_ParameterType),  INTENT( INOUT ) :: p 
   TYPE(WAMIT_InitOutputType), INTENT(   OUT ) :: InitOut
   INTEGER,                    INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
   CHARACTER(*),               INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
      ! Local variables
   INTEGER                                        :: I                    ! Generic loop counter      
   INTEGER                                        :: J                    ! Generic loop counter      
   INTEGER                                        :: Indx                 ! Counts the current index into the WaveKinNd array
   CHARACTER(1024)                                ::  OutFileName         ! The name of the output file  including the full path.
   CHARACTER(200)                                 :: Frmt                 ! a string to hold a format statement
   
   !-------------------------------------------------------------------------------------------------      
   ! Initialize local variables
   !-------------------------------------------------------------------------------------------------      
     
         
   ErrStat = ErrID_None         
   ErrMsg  = ""  
      
  


   !-------------------------------------------------------------------------------------------------      
   ! Check that the variables in OutList are valid      
   !-------------------------------------------------------------------------------------------------      
      
   
   CALL WMTOUT_ChkOutLst( InitInp%OutList(1:p%NumOuts), y, p, ErrStat, ErrMsg )
   IF ( ErrStat /= 0 ) RETURN
   
   
  IF ( ALLOCATED( p%OutParam ) .AND. p%NumOuts > 0 ) THEN           ! Output has been requested so let's open an output file            
      
      ALLOCATE( y%WriteOutput( p%NumOuts ),  STAT = ErrStat )
      IF ( ErrStat /= ErrID_None ) THEN
         ErrMsg  = ' Error allocating space for WriteOutput array.'
         ErrStat = ErrID_Fatal
         RETURN
      END IF
      y%WriteOutput = 0
      
        ALLOCATE ( InitOut%WriteOutputHdr(p%NumOuts), STAT = ErrStat )
      IF ( ErrStat /= ErrID_None ) THEN
         ErrMsg  = ' Error allocating space for WriteOutputHdr array.'
         ErrStat = ErrID_Fatal
         RETURN
      END IF
      
      ALLOCATE ( InitOut%WriteOutputUnt(p%NumOuts), STAT = ErrStat )
      IF ( ErrStat /= ErrID_None ) THEN
         ErrMsg  = ' Error allocating space for WriteOutputHdr array.'
         ErrStat = ErrID_Fatal
         RETURN
      END IF   
 
      DO I = 1,p%NumOuts
         
         InitOut%WriteOutputHdr(I) = TRIM( p%OutParam(I)%Name  )
         InitOut%WriteOutputUnt(I) = TRIM( p%OutParam(I)%Units )      
      
      END DO   
      
   END IF   ! there are any requested outputs   

   RETURN

END SUBROUTINE WMTOUT_Init


!====================================================================================================
SUBROUTINE WMTOUT_ChkOutLst( OutList, y, p, ErrStat, ErrMsg )
! This routine checks the names of inputted output channels, checks to see if any of them are ill-
! conditioned (returning an error if so), and assigns the OutputDataType settings (i.e, the index,  
! name, and units of the output channels). 
! Note that the FloatingPlatform module must be initialized prior to calling this function (if it
! is being used) so that it can correctly determine if the Lines outputs are valid.
!----------------------------------------------------------------------------------------------------    
   
   
   
      ! Passed variables
      
   TYPE(WAMIT_OutputType),        INTENT( INOUT ) :: y                                ! This module's internal data
   TYPE(WAMIT_ParameterType),     INTENT( INOUT ) :: p                                   ! data for this instance of the floating platform module   
   CHARACTER(10),                 INTENT( IN    ) :: OutList (:)                               ! An array holding the names of the requested output channels.         
   INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
   CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
      ! Local variables.
   
   INTEGER                                :: I                                         ! Generic loop-counting index.
   INTEGER                                :: J                                         ! Generic loop-counting index.
   INTEGER                                :: INDX                                      ! Index for valid arrays
   
   CHARACTER(10)                          :: OutListTmp                                ! A string to temporarily hold OutList(I).
   CHARACTER(28), PARAMETER               :: OutPFmt   = "( I4, 3X,A 10,1 X, A10 )"    ! Output format parameter output list.
   
   
   ! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 09-Jan-2013 14:53:03.
  
   LOGICAL                  :: InvalidOutput(MaxOutputs)                        ! This array determines if the output channel is valid for this configuration

   LOGICAL                  :: CheckOutListAgain
   
      ! Initialize ErrStat
         
   ErrStat = ErrID_None         
   ErrMsg  = "" 
   
   InvalidOutput            = .FALSE.

!End of code generated by Matlab script
   
   !-------------------------------------------------------------------------------------------------
   ! ALLOCATE the OutParam array
   !-------------------------------------------------------------------------------------------------    
   ALLOCATE ( p%OutParam(p%NumOuts) , STAT=ErrStat )
   IF ( ErrStat /= 0 )  THEN
      ErrMsg  = ' Error allocating memory for the OutParam array.'
      ErrStat = ErrID_Fatal
      RETURN
   END IF
     
   
         
     
   DO I = 1,p%NumOuts
   
      p%OutParam(I)%Name = OutList(I)   
      OutListTmp         = OutList(I)
   
   
      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a '-', '_', 'm', or 'M' character indicating "minus".
      
      CheckOutListAgain = .FALSE.
      
      IF      ( INDEX( '-_', OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1     ! ex, '-TipDxc1' causes the sign of TipDxc1 to be switched.
         OutListTmp                   = OutListTmp(2:)
      ELSE IF ( INDEX( 'mM', OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain            = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF
      
      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case
   
   
      Indx =  IndexCharAry( OutListTmp(1:9), ValidParamAry )
      
      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again         
         p%OutParam(I)%SignM = -1            ! ex, 'MTipDxc1' causes the sign of TipDxc1 to be switched.
         OutListTmp                   = OutListTmp(2:)
         
         Indx = IndexCharAry( OutListTmp(1:9), ValidParamAry )         
      END IF
      
      IF ( Indx > 0 ) THEN
         p%OutParam(I)%Indx = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN
            p%OutParam(I)%Units = 'INVALID' 
            p%OutParam(I)%Indx  =  1
            p%OutParam(I)%SignM =  0           
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx)
         END IF
      ELSE
         ErrMsg  = p%OutParam(I)%Name//' is not an available output channel.'
         ErrStat = ErrID_Fatal
!         RETURN
         p%OutParam(I)%Units = 'INVALID'  
         p%OutParam(I)%Indx  =  1
         p%OutParam(I)%SignM =  0                              ! this will print all zeros
      END IF
      
   END DO
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize all output channels to zero so that we can avoid doing resetting them to zero at every time step.
   !-------------------------------------------------------------------------------------------------
!bjj: this isn't allocated, yet:
   !y%WriteOutput = 0.0 
   
   
   RETURN
END SUBROUTINE WMTOUT_ChkOutLst


!====================================================================================================
SUBROUTINE WMTOUT_DestroyParam ( p, ErrStat, ErrMsg )
! This function cleans up after running the WAMIT output module. It closes the output file,
! releases memory, and resets the number of outputs requested to 0.
!----------------------------------------------------------------------------------------------------

         ! Passed variables

   TYPE(WAMIT_ParameterType),     INTENT( INOUT ) :: p                    ! data for this instance of the floating platform module        
   INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
   CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None

!      ! Internal variables
   LOGICAL                               :: Err


   !-------------------------------------------------------------------------------------------------
   ! Initialize error information
   !-------------------------------------------------------------------------------------------------
   ErrStat = ErrID_None
   ErrMsg  = ""
   Err     = .FALSE.

  

   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------
   IF ( ALLOCATED( p%OutParam ) ) DEALLOCATE ( p%OutParam, STAT=ErrStat )
   IF ( ErrStat /= 0 ) Err = .TRUE.
     
   !-------------------------------------------------------------------------------------------------
   ! Reset number of outputs
   !-------------------------------------------------------------------------------------------------
   p%NumOuts   =  0
   p%UnOutFile = -1
   
   !p%WaveKinNd = -1        ! set this array to "invalid"

   !-------------------------------------------------------------------------------------------------
   ! Make sure ErrStat is non-zero if an error occurred
   !-------------------------------------------------------------------------------------------------
   IF ( Err ) ErrStat = ErrID_Fatal
   
   RETURN

END SUBROUTINE WMTOUT_DestroyParam
!====================================================================================================


END MODULE WAMIT_Output