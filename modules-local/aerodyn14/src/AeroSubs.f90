!BJJ Start of proposed change v12.70
MODULE AeroSubs

!bjj Start of proposed change AD v12.70b-bjj
!rm    USE                     Precision
    USE                     NWTC_Library
!    USE                     AeroGenSubs
!bjj End of proposed change
!bjj start of proposed change v12.70w
!    USE                     AeroWindSubs
   USE                     InflowWind
   USE                     SharedInflowDefns
!bjj end of proposed change


    IMPLICIT                NONE


CONTAINS
!bjj End of proposed change
! ************************************************
!  AeroDyn Subroutines for YawDyn, ADAMS,
!   SymDyn and FAST.
! ************************************************

!  UNIVERSITY OF UTAH, MECHANICAL ENGINEERING DEPARTMENT

!bjj start of proposed change - this is redundant
!rm! *****************************************************
!rm   SUBROUTINE ADInputGate
!rm!   This is the gateway to the input phase of AeroDyn
!rm!   This is the OLD version being phased OUT.
!rm! *****************************************************
!rm
!rm
!rmUSE              AD_IOParams
!rmUSE              Identify
!rm!bjj rm: USE              Precision
!rm
!rm
!rmIMPLICIT         NONE
!rm
!rm
!rm   ! Local variables:
!rm
!rmREAL(ReKi)    :: T_Shad_Refpt
!rm
!rmINTEGER(4)    :: NUMFOIL
!rm
!rmCHARACTER(80) :: TITLE
!rm
!rm
!rm!bjj Start of proposed change AD v12.70b-bjj
!rm!rm ! Get the constants dependent on PI from GenSubs
!rm!rm Call GetConstants
!rm!bjj End of proposed change AD v12.70b-bjj
!rm
!rm
!rm ! Open main input file - the hardwired name version
!rm!bjj Start of proposed change v12.70b-bjj
!rm!rmCALL OpenInputFile(UnADin, 'aerodyn.ipt', 'FORMATTED')
!rmCALL OpenFInpFile(UnADin, 'aerodyn.ipt')
!rm!bjj End of proposed change
!rm
!rm ! Read data from aerodyn.ipt file
!rmCALL ADIn ( T_Shad_Refpt, TITLE, 'aerodyn.ipt' )
!rm
!rm ! Open output file
!rmSELECT CASE (TRIM(DynProg))
!rm ! DJL - Some old ADAMS routines nay still call here - v12.53 15-Jul-2003
!rm CASE ('ADAMS')
!rm!bjj Start of proposed change v12.70b-bjj
!rm!rm      CALL OpenOutFile(UnADopt, 'gfosub.opt')
!rm      CALL OpenFOutFile (UnADopt, 'gfosub.opt')
!rm!bjj End of proposed change
!rm   CASE ('SymDyn')
!rm!bjj Start of proposed change v12.70b-bjj
!rm!rm      CALL OpenOutFile(UnADopt, 'symdyn.opt')
!rm      CALL OpenFOutFile (UnADopt, 'symdyn.opt')
!rm!bjj End of proposed change
!rm   CASE ('YawDyn')
!rm!bjj Start of proposed change v12.70b-bjj
!rm!rm      CALL OpenOutFile(UnADopt, 'yawdyn.opt')
!rm      CALL OpenFOutFile (UnADopt, 'yawdyn.opt')
!rm!bjj End of proposed change
!rm   CASE DEFAULT
!rm!bjj Start of proposed change v12.70b-bjj
!rm!rm      CALL OpenOutFile(UnADopt, 'aerodyn.opt')
!rm      CALL OpenFOutFile (UnADopt, 'aerodyn.opt')
!rm!bjj End of proposed change
!rmEND SELECT
!rm
!rm!bjj Start of proposed change v12.70b-bjj
!rmWRITE (UnADopt,"( / 'This file was generated by ' , A , A , ' on ' , A , ' at ' , A , '.' / )")  &
!rm        TRIM(ProgName), TRIM( ProgVer ), CurDate(), CurTime()
!rm!bjj End of proposed change
!rm
!rm
!rm ! Echo data from aerodyn.ipt file
!rmCALL ADOut( T_Shad_Refpt, TITLE )
!rm
!rm
!rm
!rmRETURN
!rmEND SUBROUTINE ADInputGate
!rm
!bjj end of proposed change
!! *****************************************************
!!bjj start of proposed change v12.70w
!!rm   SUBROUTINE AD_InputGate (AeroInFile)
!   SUBROUTINE AD_InputGate (AeroInFile, WindFileName, TITLE)
!!bjj end of proposed change
!!   This is the gateway to the input phase of AeroDyn
!!   This is the new version being phased in.
!!   So far this is only used by FAST and ADAMS
!! *****************************************************
!
!
!USE              AD_IOParams
!!bjj rm:USE              Identify
!!bjj rm: USE              Precision
!!bjj start of proposed change v12.70w
!USE               Rotor,    ONLY: HH
!!rmUSE               Blade,    ONLY: R, DR
!!rmUSE               Element,  ONLY: RELM, NELM
!!bjj end of proposed change v12.70w
!
!
!IMPLICIT         NONE
!
!
!   ! Passed Variables:
!
!!BJJ Start of proposed change v12.7
!!rmCHARACTER(*)  :: AeroInFile
!CHARACTER(*),   INTENT(IN)   :: AeroInFile
!CHARACTER(300), INTENT(OUT)  :: WindFileName
!!bjj End of proposed change
!
!!bjj start of proposed change v12.70w
!!REAL(ReKi), INTENT(IN)     :: InputRad          ! The rotor radius.  If unknown, InputRad < 0
!!bjj end of proposed change v12.70w
!
!
!!BJJ Start of proposed change v12.7
!!rm   ! Local Variables:
!!rm
!!REAL(ReKi)    :: T_Shad_Refpt
!!rm
!CHARACTER(200), INTENT(OUT) :: TITLE
!!bjj end of proposed change
!
!!bjj start of proposed change v12.70w
!!TYPE(InflInitInfo)         :: InitWindInfl
!INTEGER                    :: ErrStat
!!bjj end of proposed change
!
!
!!bjj Start of proposed change AD v12.70b-bjj
!!rm ! Get the constants dependent on PI from GenSubs
!!rmCall GetConstants
!CALL NWTC_Init()
!!CALL WrScr(' Initializing AeroDyn' ) !bjj this is just a test for A2AD
!!bjj End of proposed change AD v12.70b-bjj
!
! ! Open main input file
!!bjj Start of proposed change v12.70b-bjj !BJJ: MOVED TO ADIN!
!!rmCALL OpenInputFile(UnADin, TRIM(AeroInFile),'FORMATTED')
!!CALL OpenFInpFile(UnADin, TRIM(AeroInFile))
!!bjj End of proposed change
!
! ! Read data from the input file
!!bjj start of proposed chagne
!!rmCALL ADIn ( T_Shad_Refpt, TITLE, AeroInFile )
!!CALL ADIn ( TITLE, AeroInFile, WindFileName )
!
!CALL AD_GetInput(UnADin, AeroInFile, WindFileName, ErrStat )
!
!! CALL ADIn ( AeroInFile, InitWindInfl%WindFileName )
!!bjj end of proposed change
!
!!bjj start of proposed change
!!rm
!!rmIF (WrOptFile) THEN
!!rm!BJJ START OF PROPOSED CHANGE ADV13.00
!!rm!RM! Open output file
!!rm!RM   SELECT CASE (TRIM(DynProg))
!!rm!RM ! New ADAMS routines call here now (v12.53 15-Jul-2003)
!!rm!RM      CASE ('ADAMS')
!!rm!RM!bjj Start of proposed change v12.70b-bjj
!!rm!RM!rm      CALL OpenOutFile(UnADopt, 'gfosub.opt')
!!rm!RM         CALL OpenFOutFile (UnADopt, 'gfosub.opt')
!!rm!RM         WRITE (UnADopt,"( / 'This file was generated by ' , A , A , ' on ' , A , ' at ' , A , '.' / )")  &
!!rm!RM                TRIM(ProgName), TRIM( ProgVer ), CurDate(), CurTime()
!!rm!RM!bjj End of proposed change
!!rm!RM      CASE ('FAST')
!!rm!RM!bjj Start of proposed change v12.70b-bjj
!!rm!RM!rm      CALL OpenOutFile(UnADopt, TRIM(DynProgRoot)//'.opt')
!!rm!RM         CALL OpenFOutFile (UnADopt, TRIM(DynProgRoot)//'.opt')
!!rm!RM         WRITE (UnADopt,"( / 'This file was generated by ' , A , A , ' on ' , A , ' at ' , A , '.' / )")  &
!!rm!RM                TRIM(ProgName), TRIM( ProgVer ), CurDate(), CurTime()
!!rm!RM!bjj End of proposed change
!!rm!RM   END SELECT
!!rm
!!rm   CALL OpenFOutFile (UnADopt, TRIM(DynProgRoot)//'.opt')
!!rm   WRITE (UnADopt,"( / 'This file was generated by ' , A , ' on ' , A , ' at ' , A , '.' / )")  &
!!rm            TRIM(AeroProg)//' '//TRIM( AeroVer ), CurDate(), CurTime()
!!rm!BJJ END OF PROPOSED CHANGE
!!rm
!!rm ! Mimic data from input file
!!rm   CALL ADOut( T_Shad_Refpt, TITLE )
!!rm
!!rmENDIF
!!bjj end of proposed change
!
!
!!!bjj start of proposed change v12.70w
!!!----------------------------------------------------------------------------------------------------
!!! Initialize the wind inflow module;  NOTE that these lengths must be in meters!
!!!----------------------------------------------------------------------------------------------------
!!!comment: perhaps this should only be done if CompAero is true....
!!
!!   InitWindInfl%WindFileType    = -1            ! determine the type from the file name
!!   InitWindInfl%ReferenceHeight = HH
!!
!!   IF ( InputRad > 0 ) THEN
!!      InitWindInfl%Width = 2*InputRad
!!   ELSE  !estimate it
!!      InitWindInfl%Width = 2 *( RELM(NELM) + 0.5 * DR(NELM) ) !* COS( PC )
!!   END IF
!!
!!
!!   CALL WindInf_Init( InitWindInfl, ErrStat )
!!
!!   R = 0.5 * InitWindInfl%Width
!!
!!!bjj end of proposed change
!
!!!bjj: find a more appropriate spot for this, outside of the ff wind module
!!!------------------------------------------
!!   USE SWITCH, ONLY: DYNINFL
!!
!!      !DJL - Start of proposed change
!!      !DJL Comment out this code when using new proposed GDW check in ELEMFRC
!!         ! Check if the wind speed is below 8 m/s for dynamic inflow
!!         IF (DYNINFL .AND. UBar  <= 8.0) THEN
!!            DYNINFL = .FALSE.
!!            CALL ProgWarn( 'Average wind speed in turbulence file is less than 8 m/s. Dynamic Inflow will be turned off.' )
!!
!!         ENDIF
!!      !DJL - End of proposed change
!!!------------------------------------------
!
!
!RETURN
!END SUBROUTINE AD_InputGate
!bjj start of proposed change
!====================================================================================================
SUBROUTINE AD_GetInput(UnIn, AeroInFile, WindFileName, Title, ErrStat )
!====================================================================================================

   USE                           AeroGenSubs, ONLY: AllocArrays

   USE                           AD_IOParams
   USE                           AeroTime
   USE                           ElOutParams
   USE                           Airfoil
   USE                           Blade
   USE                           Element
   USE                           InducedVel
   USE                           Rotor
   USE                           Switch
   USE                           TwrProps
   USE                           Wind


   IMPLICIT                      NONE

      ! Passed Variables:
   INTEGER, INTENT(IN)       :: UnIn
   CHARACTER(*), INTENT(IN)  :: AeroInFile
   CHARACTER(*), INTENT(OUT) :: WindFileName
   CHARACTER(*), INTENT(OUT) :: Title           ! used for ADOUT() -- bjj: get rid of this when ADOUT is gone!!!!
   INTEGER, INTENT(OUT)      :: ErrStat

      ! Local Variables:
!   REAL(ReKi)                 :: T_Shad_Refpt

   INTEGER                    :: ElIndex
   INTEGER                    :: IELM
!   INTEGER                    :: IERR
   INTEGER                    :: IndPrint
!   INTEGER                    :: INF
!   INTEGER                    :: IOS
   INTEGER                    :: K
!   INTEGER                    :: Sttus
!rm not used:   INTEGER                    :: WndElIndex


   CHARACTER(1024)            :: LINE


   !-------------------------------------------------------------------------------------------------
   ! Open the AeroDyn input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile(UnIn, TRIM(AeroInFile))


   !-------------------------------------------------------------------------------------------------
   ! If the echo file is open, write the header...
   !-------------------------------------------------------------------------------------------------
   IF ( Echo ) THEN      
      WRITE( UnEc, '(// A /)' ) 'AeroDyn input data from file "'//TRIM( AeroInFile )//'":'  
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Read the AeroDyn input file
   !-------------------------------------------------------------------------------------------------

      ! Read in the title line
   CALL ReadStr( UnIn, AeroInFile, Title, 'Title', 'File title', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   CALL WrScr( ' Heading of the AeroDyn input file: '//TRIM(Title) )


      ! Read in the units specifier  - REMOVE SOON!!!!!
   CALL ReadVar( UnIn, AeroInFile, LINE, 'Units', 'Units option', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   LINE = ADJUSTL( LINE )
   CALL Conv2UC(LINE(1:3))

   IF (LINE(1:2) /= 'SI') THEN
      CALL ProgWarn( 'English units are no longer allowed in AeroDyn. Please modify your input files to use the metric system.')
      ErrStat = 1
      RETURN
   END IF

   SIunit = .TRUE.


      ! Read in the stall model
   CALL ReadVar( UnIn, AeroInFile, LINE, 'DStall', 'Stall model', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   CALL Conv2UC(LINE(1:7))

   SELECT CASE ( TRIM(Line) )
      CASE ('STEADY')
         DStall = .FALSE.
      CASE ('BEDDOES')
         DStall = .TRUE.
      CASE DEFAULT
         CALL ProgWarn( ' Error: Expecting "STEADY" or "BEDDOES" stall model option.')
         ErrStat = 1
         RETURN
   END SELECT


      ! Read in the CM option
   CALL ReadVar( UnIn, AeroInFile, LINE, 'PMoment', 'Pitching moment option', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   CALL Conv2UC(LINE(1:6))

   SELECT CASE ( TRIM(Line) )
      CASE ('USE_CM')
         PMoment = .TRUE.
      CASE ('NO_CM')
         PMoment = .FALSE.
      CASE DEFAULT
         CALL ProgWarn( ' Error: Expecting "USE_CM" or "NO_CM" pitching moment option.')
         ErrStat = 1
         RETURN
   END SELECT


      ! Read in the inflow model option
   CALL ReadVar( UnIn, AeroInFile, LINE, 'DynInfl', 'Inflow model', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   CALL Conv2UC(LINE(1:7))

   SELECT CASE ( Line(1:5) )
      CASE ('EQUIL')
         DynInfl = .FALSE.
         DynInit = .FALSE.

         IF (Line(6:7) == 'DA') THEN
            EqAIDmult = 1.0
            EquilDA   = .TRUE.
            EquilDT   = .FALSE.
         ELSEIF (LINE(6:7) == 'DB') THEN
            EqAIDmult = 1.0
            EquilDA   = .TRUE.
            EquilDT   = .TRUE.
         ELSEIF (LINE(6:7) == 'DT') THEN
            EqAIDmult = 0.0
            EquilDA   = .FALSE.
            EquilDT   = .TRUE.
         ELSE
            EqAIDmult = 0.0
            EquilDA   = .FALSE.
            EquilDT   = .FALSE.
         ENDIF

      CASE ('DYNIN')
         DynInfl = .TRUE.
         DynInit = .TRUE.
      CASE DEFAULT
         CALL ProgWarn( ' Error: Expecting "EQUIL" or "DYNIN" inflow model option.')
         ErrStat = 1
         RETURN
   END SELECT


      ! Read in the wake model
   CALL ReadVar( UnIn, AeroInFile, LINE, 'Wake', 'Wake model', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   CALL Conv2UC(LINE(1:5))

   SELECT CASE ( TRIM(Line) )
      CASE ('NONE')
         Wake = .FALSE.
         Swirl = .FALSE.

         CALL ProgWarn( ' All wake calculations are turned off! This option is recommended only '// &
                        'in high winds or for debugging.' )
      CASE ('WAKE')
         Wake = .TRUE.
         Swirl = .FALSE.
      CASE ('SWIRL')
         Wake = .TRUE.
         Swirl = .TRUE.
      CASE DEFAULT
         CALL ProgWarn( ' Error: Expecting "NONE", "WAKE", or "SWIRL" wake model option.')
         ErrStat = 1
         RETURN
   END SELECT

      ! Read in the tolerance for the wake model
   CALL ReadVar( UnIn, AeroInFile, AToler, 'AToler', 'Induction factor tolerance', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

       ! Read in the tip-loss model for EQUIL inflow
   CALL ReadVar( UnIn, AeroInFile, LINE, 'TLoss', 'Tip-loss model', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   IF ( DynInfl ) THEN          ! Initialize these variables, though they shouldn't be used
      TLoss = .FALSE.
      GTech = .FALSE.
   ELSE
      CALL Conv2UC(LINE(1:5))

      SELECT CASE ( LINE(1:5) )
         CASE ('NONE ')
            TLoss = .FALSE.
            GTech = .FALSE.
         CASE ('PRAND')
            TLoss = .TRUE.
            GTech = .FALSE.
         CASE ('GTECH')
            TLoss = .TRUE.
            GTech = .TRUE.
         CASE DEFAULT
            CALL ProgWarn( ' Error: Expecting "NONE", "PRAND", or "GTECH" tip-loss model option.')
            ErrStat = 1
            RETURN
      END SELECT
   END IF


       ! Read in the hub-loss model for EQUIL inflow
   CALL ReadVar( UnIn, AeroInFile, LINE, 'HLoss', 'Hub-loss model', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   IF ( DynInfl ) THEN          ! Initialize these variables, though they shouldn't be used
      HLoss = .FALSE.
   ELSE
      CALL Conv2UC( LINE(1:5) )

      SELECT CASE ( LINE(1:5) )
         CASE ('NONE')
            HLoss = .FALSE.
         CASE ('PRAND')
            HLoss = .TRUE.
         CASE DEFAULT
            CALL ProgWarn( ' Error: Expecting "NONE" or "PRAND" hub-loss model option.')
            ErrStat = 1
            RETURN
      END SELECT
   END IF


      ! Read in the wind file name
   CALL ReadVar( UnIn, AeroInFile, WindFileName, 'WindFileName', 'Name of the wind file', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

      ! Read in the wind reference (hub) height above ground
   CALL ReadVar( UnIn, AeroInFile, HH, 'RefHt', 'Wind reference height', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

!bjj: this is a hack job to allow both the new tower influence and the old tower wake models to be used
!rm   CALL ReadStr( UnIn, AeroInFile, Line, 'TwrShad', 'Tower shadow deficit', ErrStat )
   CALL ReadStr( UnIn, AeroInFile, Line, 'NewTowerModel?', 'Check for tower influence model', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

      ! Check if this is the "special string" to indicate the new tower influence model
   CALL Conv2UC( Line )
   IF ( INDEX(Line, "NEWTOWER" ) > 0 ) THEN

      !----------------------------------------------------------------------------------------------
      ! New tower influence model, as implemented by PJM
      !----------------------------------------------------------------------------------------------
      PJM_Version = .TRUE.


         ! Read in the tower potential flow switch
      CALL ReadVar( UnIn, AeroInFile, TwrPotent, 'TwrPotent', 'Tower influence model', ErrStat)
      IF ( ErrStat /= 0 ) RETURN

         ! Read in the tower shadow switch
      CALL ReadVar( UnIn, AeroInFile, TwrShadow, 'TwrShadow', 'Tower shadow model', ErrStat)
      IF ( ErrStat /= 0 ) RETURN

         ! Read in the tower drag file name
      CALL ReadVar( UnIn, AeroInFile, TwrFile, 'TwrFile', 'Tower data file name', ErrStat)
      IF ( ErrStat /= 0 ) RETURN

   ELSE
      !----------------------------------------------------------------------------------------------
      ! Old tower influence model, read TwrShad from Line for now
      !----------------------------------------------------------------------------------------------
      PJM_Version = .FALSE.

      TwrPotent = .FALSE.     ! We don't want to read the tower file!
      TwrShadow = .FALSE.     ! We don't want to read the tower file!

!
!         ! Read in the tower shadow deficit
!      CALL ReadVar( UnIn, AeroInFile, TwrShad, 'TwrShad', 'Tower shadow deficit', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN

         ! Read in the tower shadow deficit
      IF ( INDEX( 'FTft', Line(:1) ) > 0 )  THEN
         CALL ProgWarn( ' Invalid numeric input. "'//TRIM( Line )//'" found when trying to read TwrShad.' )

         ErrStat = 1
         RETURN
      ELSE
         READ (Line,*,IOSTAT=ErrStat)  TwrShad
         CALL CheckIOS ( ErrStat, AeroInFile, 'TwrShad', NumType, .TRUE. )

         IF ( Echo )  THEN
            WRITE (UnEc,"( 2X, ES11.4e2, 2X, A, T30, ' - ', A )")  TwrShad, "TwrShad", 'Tower shadow deficit'
         END IF

      END IF
!----------------

      IF ( TwrShad >= 1.0 ) THEN
         CALL ProgWarn( ' Tower shadow deficit cannot be >= 1.  Setting default deficit = 0.3' )
         TwrShad = 0.3
      END IF


         ! Read in the tower shadow width
      CALL ReadVar( UnIn, AeroInFile, ShadHWid, 'ShadHWid', 'Tower shadow half width', ErrStat)
      IF ( ErrStat /= 0 ) RETURN

      IF ( ShadHWid <= 0.0 ) THEN
         CALL ProgWarn( ' Tower shadow width cannot be <= zero.  Setting default half width = 1.0' )
         ShadHWid = 1.0
      END IF


         ! Read in the tower shadow reference point (distance from yaw axis to hub)
      CALL ReadVar( UnIn, AeroInFile, T_Shad_Refpt, 'T_Shad_Refpt', 'Tower shadow reference point', ErrStat)
      IF ( ErrStat /= 0 ) RETURN

         ! Constants used in tower shadow calculations
      TShadC1 = ShadHWid / SQRT ( ABS( T_Shad_Refpt ) )
      TShadC2 = TwrShad  * SQRT ( ABS( T_Shad_Refpt ) )

   END IF

!bjj end


!      ! Read Tower Shadow/Influence, depending on which version is set up
!   IF ( PJM_Version ) THEN
!
!         ! Read in the tower potential flow switch
!      CALL ReadVar( UnIn, AeroInFile, TwrPotent, 'TwrPotent', 'Tower influence model', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!         ! Read in the tower shadow switch
!      CALL ReadVar( UnIn, AeroInFile, TwrShadow, 'TwrShadow', 'Tower shadow model', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!         ! Read in the tower drag file name
!      CALL ReadVar( UnIn, AeroInFile, TwrFile, 'TwrFile', 'Tower data file name', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!   ELSE
!
!      TwrPotent = .FALSE.     ! We don't want to read the tower file!
!      TwrShadow = .FALSE.     ! We don't want to read the tower file!
!
!
!         ! Read in the tower shadow deficit
!      CALL ReadVar( UnIn, AeroInFile, TwrShad, 'TwrShad', 'Tower shadow deficit', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!      IF ( TwrShad >= 1.0 ) THEN
!         CALL ProgWarn( ' Tower shadow deficit cannot be >= 1.  Setting default deficit = 0.3' )
!         TwrShad = 0.3
!      END IF
!
!
!         ! Read in the tower shadow width
!      CALL ReadVar( UnIn, AeroInFile, ShadHWid, 'ShadHWid', 'Tower shadow half width', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!      IF ( ShadHWid <= 0.0 ) THEN
!         CALL ProgWarn( ' Tower shadow width cannot be <= zero.  Setting default half width = 1.0' )
!         ShadHWid = 1.0
!      END IF
!
!
!         ! Read in the tower shadow reference point (distance from yaw axis to hub)
!      CALL ReadVar( UnIn, AeroInFile, T_Shad_Refpt, 'T_Shad_Refpt', 'Tower shadow reference point', ErrStat)
!      IF ( ErrStat /= 0 ) RETURN
!
!         ! Constants used in tower shadow calculations
!      TShadC1 = ShadHWid / SQRT ( ABS( T_Shad_Refpt ) )
!      TShadC2 = TwrShad  * SQRT ( ABS( T_Shad_Refpt ) )
!
!   END IF


      ! Read in the air density
   CALL ReadVar( UnIn, AeroInFile, Rho, 'Rho', 'Air density', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !bjj do we need to check the the air density is non-negative?

   IF ( Rho == 0.0 .AND. DynInfl ) THEN  ! Turn off the GDW if RHO = 0.  It will crash
      CALL ProgWarn( 'Air density is zero. Dynamic Inflow will be turned off to avoid program crash.' )
      DynInfl = .FALSE.
   ENDIF

      ! Read in the kinematic viscosity
   CALL ReadVar( UnIn, AeroInFile, KinVisc, 'KinVisc', 'Kinematic viscosity', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

      ! Aero calculation time interval
   CALL ReadVar( UnIn, AeroInFile, DtAero, 'DtAero', 'Aero calculation time step', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

      ! Read the number of airfoil files
   CALL ReadVar( UnIn, AeroInFile, NumFoil, 'NumFoil', 'Number of airfoil files', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   IF ( NumFoil < 1 ) THEN
      CALL ProgWarn( ' Error: Number of airfoil files must be a positive integer.')
      ErrStat = 1
      RETURN
   END IF

      !..............................................................................................
      ! Allocate space for the airfoil data file name(s), then read them
      !..............................................................................................
   IF (.NOT. ALLOCATED(FoilNm)) THEN
      ALLOCATE ( FoilNm( NumFoil ) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn(' Error allocating space for the FoilNm array.')
         RETURN
      END IF
   END IF

   CALL ReadAryLines( UnIn, AeroInFile, FoilNm(1:NumFoil), NumFoil, 'FoilNm', 'Airfoil file names', ErrStat )
   IF ( ErrStat /= 0 ) RETURN


      ! Read in the number of blade elements
   CALL ReadVar( UnIn, AeroInFile, NElm, 'NElm', 'Number of blade elements', ErrStat)
   IF ( ErrStat /= 0 ) RETURN


      !..............................................................................................
      ! Allocate space for blade element data and read the arrays
      ! Read blade element data, check some inputs, convert twist to radians
      !..............................................................................................
   CALL AllocArrays ('Element')

   NumElOut    = 0 ! Initialize the element print array index
   NumWndElOut = 0

   CALL ReadCom( UnIn, AeroInFile, 'Element table headers', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO IElm = 1, NElm

      READ(UnIn,'(A)',IOSTAT=ErrStat) Line      !read into a line to see if print/no print is enabled

      IF (ErrStat == 0) THEN
         READ(Line,*,IOSTAT=ErrStat) RElm(IElm), Twist(IElm), DR(IElm), C(IElm), NFoil(IElm)
      END IF

      IF ( ErrStat == 0 ) THEN

         !'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
         ! Check if AeroDyn will print out the element and/or wind data
         !'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

         CALL Conv2UC(LINE)

         ElPrList(IElm) = 0               ! INITIALIZE
         IndPrint = INDEX(LINE,"PRINT")
         IF (IndPrint > 0) THEN
            IF (LINE(IndPrint-2:IndPrint+4) /= "NOPRINT") THEN
               NumElOut = NumElOut + 1
               ElPrList(IElm) = NumElOut
            END IF
         ENDIF


         WndElPrList(IElm) = 0            ! INITIALIZE
         IndPrint = INDEX(LINE,"WIND")
         IF (IndPrint > 0) THEN
            IF (LINE(IndPrint-2:IndPrint-1) /= "NO") THEN
               NumWndElOut = NumWndElOut + 1
               WndElPrList(IElm) = NumWndElOut
            END IF
         ENDIF

         !'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
         ! Echo data to the file NWTC_Library echo file, if requested
         !'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

         IF ( Echo ) THEN     ! NWTC_Library echo file
            WRITE (UnEc,'(4(2X,ES11.4e2),2X,I11,1(2X,L11))')  RElm(IElm), Twist(IElm), DR(IElm), C(IElm), NFoil(IElm), &
                   ElPrList(IElm) /= 0  !,  WndElPrList(IElm) == 0
         END IF

      ELSE IF ( ErrStat < 0 ) THEN
         CALL ProgWarn(' Error reading from line '//TRIM(Int2Lstr(IElm))//' of the AeroDyn element table.' )

         CALL ProgWarn( ' Premature end of file while reading line '//TRIM(Int2Lstr(IElm))// &
                     ' of the AeroDyn element table in file "'//TRIM(AeroInFile)//'."' )
         RETURN
      ELSE
         CALL ProgWarn(' Error reading from line '//TRIM(Int2Lstr(IElm))// &
                       ' of the AeroDyn element table in file "'//TRIM(AeroInFile)//'."' )
         RETURN
      END IF


         ! Check for valid data:

      IF( C(IElm) <= 0.0 ) THEN
         CALL ProgWarn(' Error reading from line '//TRIM(Int2Lstr(IElm))//' of the AeroDyn element table.'// &
                       ' Chord length must be larger than 0.' )
         ErrStat = 1
         RETURN
      ENDIF

      IF (NFoil(IElm) < 1 .OR. NFoil(IElm) > NumFoil) THEN
         CALL ProgWarn(' Error reading from line '//TRIM(Int2Lstr(IElm))//' of the AeroDyn element table.'// &
                       ' Airfoil file ID must be a number between 1 and '//TRIM(Int2Lstr(NumFoil))//'.' )
         ErrStat = 1
         RETURN
      END IF

         ! Convert Twist to radians:

      Twist(IElm) = Twist(IElm)*D2R

   ENDDO ! IELM


      !..............................................................................................
      ! Read multiple airfoil table option
      !..............................................................................................
!bjj, this would be ideal, but it's annoying to read EOF for all these files...
!   CALL ReadVar( UnIn, AeroInFile, Line, 'MultiTab', 'Multiple airfoil table option', ErrStat)
!   IF ( ErrStat > 0 ) RETURN

      READ(UnIn,*,IOSTAT=ErrStat) Line         !read MultiTab -- it may not exist
      IF (ErrStat > 0 ) THEN
         CALL WrScr1 ( ' Invalid character input for file "'//TRIM( AeroInFile )//'".' )
         CALL ProgWarn ( ' The error occurred while trying to read "MultiTab".' )
         RETURN
      ELSE IF (ErrStat == 0) THEN
         IF ( Echo )  THEN
            WRITE (UnEc, "( 15X, A, T30, ' - ', A, /, 2X, A )" )  &
                         'MultiTab', 'Multiple airfoil table option', '"'//TRIM( Line )//'"'
         END IF
      ELSE
         MultiTab = .FALSE.
         Reynolds = .FALSE.
      !  CALL PremEOF ( TRIM( Fil ), Variable, TrapThisError )
      END IF

   !-------------------------------------------------------------------------------------------------
   ! Close AeroDyn input file
   !-------------------------------------------------------------------------------------------------
   CLOSE(UnIn)

   !-------------------------------------------------------------------------------------------------
   ! Read airfoil data and check for MultiTab values using LINE, which was read above
   !-------------------------------------------------------------------------------------------------
   CALL READFL()                                      ! Read airfoil files; bjj: make sure there isn't a conflict with ErrStat when this gets rewritten; also make it use the same UnIn

   MulTabLoc = 0.0                                    ! Initialize this value


            ! Read in the type of airfoil data table in each file
   IF ( ErrStat < 0 ) THEN             ! If we hit the end of the file without MultiTab, use only 1 airfoil table
      IF ( ANY( NTables(1:NumFoil) > 1 ) ) THEN
         CALL ProgWarn( ' Error reading multiple airfoil table option. Only one table for each file will be used.' )
      END IF
      MultiTab = .FALSE.
      Reynolds = .FALSE.
      ErrStat  = 0
   ELSE ! ErrStat = 0

      IF ( ANY( NTables(1:NumFoil) > 1 ) ) THEN
         CALL Conv2UC(LINE(1:6))

         SELECT CASE ( TRIM(Line) )
            CASE ( 'USER' )
               MultiTab = .TRUE.
               Reynolds = .FALSE.

               DO K = 1, NumFoil
                  IF ( NTables(K) > 1 ) THEN
                     IF ( ( MulTabLoc < MulTabMet(K,1) ) .OR. ( MulTabLoc > MulTabMet(K,NTables(K) ) ))THEN  !bjj: why don't we have this error elsewhere??? can't MulTabLoc change?
                        CALL ProgWarn( 'Error interpolating between airfoil tables. '// &
                                 ' Initial interpolation value = '//TRIM(Flt2LStr(MulTabLoc))// &
                                 ' is outside table range of '//TRIM(Flt2LStr(MulTabMet(K,1)))// &
                                 ' to '//TRIM(Flt2LStr(MulTabMet(K,NTables(K))))// &
                                 ' in airfoil file #'//TRIM(Int2LStr(K))//'.' )
                        ErrStat = 1
                        RETURN
                     END IF
                  END IF ! NTables(K) > 1
               ENDDO ! K

            CASE ( 'RENUM' )
               MultiTab = .TRUE.
               Reynolds = .TRUE.
            CASE ( 'SINGLE' )
               MultiTab = .FALSE.
               Reynolds = .FALSE.
            CASE DEFAULT
               CALL WrScr( ' Error: control model option must be "SINGLE" or "MULTI".' )
         END SELECT
      ELSE
         MultiTab = .FALSE.
         Reynolds = .FALSE.
      END IF

   ENDIF

   !-------------------------------------------------------------------------------------------------
   ! Read tower drag input file, if necessary
   !-------------------------------------------------------------------------------------------------
   IF (TwrPotent .OR. TwrShadow) THEN                 ! Read in the tower drag file
      CALL READTwr(UnIn, TwrFile, ErrStat)
      IF (ErrStat /= 0) RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables for printing
   !-------------------------------------------------------------------------------------------------
   IF ( NumElOut > 0 .OR. NumWndElOut > 0 ) THEN
      ElemPrn = .TRUE.
      CALL AllocArrays ('ElPrint')     ! Allocate arrays with dimension NumElOut

      ElIndex = 0                      ! Re-Initialize the element print array index for wind
      DO IElm = 1, NElm
         IF (WndElPrList(IElm) > 0) THEN
            ElIndex = ElIndex + 1
            WndElPrNum(ElIndex) = IElm
         END IF
      END DO ! IELM

      ElIndex = 0 ! Re-Initialize the element print array index
      DO IElm = 1, NElm
         IF (ElPrList(IElm) > 0) THEN
            ElIndex = ElIndex + 1
            ElPrNum(ElIndex) = IElm
         END IF
      END DO ! IELM
   ELSE
      ElemPrn = .FALSE.
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Initialize BEDDOES dynamic stall data
   !-------------------------------------------------------------------------------------------------
   IF ( DStall ) CALL BEDDAT()


   RETURN

END SUBROUTINE AD_GetInput
!====================================================================================================
!bjj start of proposed change
!replace ADIn() with AD_GetInput()
!rm ! *****************************************************
!rm !bjj start of proposed change
!rm !rm   SUBROUTINE ADIn ( T_Shad_Refpt, TITLE, AeroInFile )
!rm !bjj start of proposed change for pjm
!rm !rm   SUBROUTINE ADIn ( T_Shad_Refpt, TITLE, AeroInFile, WindFileName )
!rm    SUBROUTINE ADIn ( TITLE, AeroInFile, WindFileName )
!rm !bjj end of proposed change for pjm
!rm !Let's combine ADIn with ADOut; then we get:
!rm !   SUBROUTINE ADIn ( AeroInFile, WindFileName )
!rm !bjj end of proposed change
!rm !   Used to read input data pertinent to the yaw
!rm !   dynamics routines
!rm ! *****************************************************
!rm 
!rm USE                           AeroGenSubs, ONLY: AllocArrays
!rm 
!rm USE                           AD_IOParams
!rm USE                           AeroTime
!rm USE                           ElOutParams
!rm USE                           Airfoil
!rm USE                           Blade
!rm !bjj rm NWTC_Lib:USE                           Constant
!rm USE                           Element
!rm !bjj rmUSE                           Identify
!rm USE                           InducedVel
!rm !bjj rm: USE                           Precision
!rm USE                           Rotor
!rm USE                           Switch
!rm !bjj start of proposed change for pjm
!rm USE                           TwrProps
!rm !bjj end of proposed change for pjm
!rm USE                           Wind
!rm 
!rm 
!rm IMPLICIT                      NONE
!rm 
!rm 
!rm    ! Passed Variables:
!rm !BJJ Start of proposed change v12.7
!rm !RMREAL(ReKi)                 :: T_Shad_Refpt
!rm !RM
!rm CHARACTER(*), INTENT(OUT)  :: TITLE
!rm !RMCHARACTER(  *)             :: AeroInFile
!rm !bjj start of proposed change for pjm
!rm !rmREAL(ReKi)                 :: T_Shad_Refpt
!rm !bjj end of proposed change for pjm
!rm 
!rm CHARACTER(  *),INTENT(IN)  :: AeroInFile
!rm CHARACTER(  *),INTENT(OUT) :: WindFileName
!rm !BJJ End of proposed change v12.7
!rm 
!rm    ! Local Variables:
!rm 
!rm !bjj rm:REAL(ReKi), SAVE           :: EndTime = 0.0
!rm 
!rm INTEGER(4)                 :: ElIndex
!rm INTEGER(4)                 :: IELM
!rm INTEGER(4)                 :: IERR
!rm INTEGER(4)                 :: IndPrint
!rm INTEGER(4)                 :: INF
!rm INTEGER                    :: IOS
!rm INTEGER(4)                 :: K
!rm INTEGER                    :: Sttus
!rm INTEGER(4)                 :: WndElIndex
!rm 
!rm !bjj: start of proposed change
!rm INTEGER                    :: ErrStat
!rm !bjj end of proposed change
!rm 
!rm !rmCHARACTER(100)             :: FileName
!rm !rm CHARACTER(140)             :: Frmt
!rm !rm CHARACTER( 80)             :: FrmtLead
!rm CHARACTER(150)             :: LINE
!rm CHARACTER(110)             :: MESAGE
!rm 
!rm 
!rm    ! Global Functions:
!rm 
!rm !bjj rm 12.70b-bjj CHARACTER( 15), EXTERNAL   :: Flt2LStr
!rm !bjj rm 12.70b-bjj CHARACTER( 11), EXTERNAL   :: Int2LStr
!rm 
!rm 
!rm 
!rm !bjj start of proposed change v12.70w
!rm !bjj: HUH?
!rm !RM ! Initialize wind parameters for cases when .wnd file not used
!rm !rm
!rm !rmVGUST   = 0.0
!rm !rmVLINSHR = 0.0
!rm !rmV       = 0.0
!rm !rmVZ      = 0.0
!rm !bjj end of proposed change
!rm 
!rm !bjj start of proposed change .... this is now in the AD_Init() subroutine
!rm !rm ! At this point we should know the number of blades
!rm !rmIF (NB <= 0) THEN
!rm !rm!BJJ START OF proposed change
!rm !rm!rm   MESAGE = ' This model has no blades.  Serious errors may result.'
!rm !rm!rm   Frmt   = '(A)'
!rm !rm!rm   CALL ErrLog( MESAGE, Frmt, 'ADIn', 1, 'WARN' )
!rm !rm!rm!bjj:  Ya' think? :-) Perhaps we should just abort the program here before we
!rm !rm!rm!bjj:  get those "serious errors". Of course, that might not be quite as fun.
!rm !rm   CALL ProgAbort( ' Cannot run AeroDyn without blades in the model.' )
!rm !rm!bjj end of proposed change
!rm !rmENDIF
!rm !bjj end of proposed change
!rm 
!rm !bjj Start of proposed change
!rm    ! Open main input file
!rm CALL OpenFInpFile(UnADin, TRIM(AeroInFile))
!rm !bjj End of proposed change
!rm 
!rm 
!rm 
!rm    ! Read in the title line
!rm 
!rm READ(UnADin,'( A )',IOSTAT=IOS) TITLE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'Title' )
!rm !BJJ START OF proposed change
!rm !rmMESAGE = TITLE
!rm !rmFrmt   = '(''Heading of the aerodyn.ipt file :'', /A)'
!rm !rm CALL ErrLog( MESAGE, Frmt, 'ADIn', 2, 'INFO' )
!rm 
!rm    CALL WrScr( ' Heading of the AeroDyn input file: '//TRIM(TITLE) )
!rm !bjj end of proposed change
!rm 
!rm 
!rm  ! Read in the units specifier
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'units option' )
!rm LINE = ADJUSTL( LINE )
!rm CALL Conv2UC(LINE(1:3))
!rm IF (LINE(1:3) == 'ENG')THEN
!rm   SIUNIT = .FALSE.
!rm !bjj start of proposed change
!rm    CALL ProgAbort( ' English units are no longer allowed in AeroDyn. Please modify your input files.')
!rm !bjj end of proposed change
!rm ELSEIF (LINE(1:2) == 'SI') THEN
!rm   SIUNIT = .TRUE.
!rm ELSE
!rm !bjj start of proposed change v12.70
!rm !rm  FrmtLead = '('' Error reading units option.  Expecting ENG or SI.'''
!rm !RM  GOTO 200
!rm    CALL WrScr    ( ' Error reading units option.  Expecting ENG or SI.' )
!rm    CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm    RETURN
!rm !bjj end of proposed change
!rm ENDIF
!rm 
!rm  ! Read in the stall model
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'stall model' )
!rm LINE = ADJUSTL( LINE )
!rm CALL Conv2UC(LINE(1:7))
!rm IF (LINE(1:6) == 'STEADY') THEN
!rm   DSTALL = .FALSE.
!rm ELSEIF (LINE(1:7) == 'BEDDOES') THEN
!rm   DSTALL = .TRUE.
!rm ELSE
!rm !BJJ start of proposed change
!rm !rm  FrmtLead = '('' Error reading stall model option.  Expecting STEADY or BEDDOES.'''
!rm !rm  GOTO 200
!rm    CALL WrScr    ( ' Error reading stall model option.  Expecting STEADY or BEDDOES.' )
!rm    CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm    RETURN
!rm !bjj end of proposed change
!rm ENDIF
!rm 
!rm  ! Read in the CM option
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'pitching moment option' )
!rm LINE = ADJUSTL( LINE )
!rm CALL Conv2UC(LINE(1:6))
!rm IF (LINE(1:6) == 'USE_CM') THEN
!rm   PMOMENT = .TRUE.
!rm ELSEIF (LINE(1:5) == 'NO_CM') THEN
!rm   PMOMENT = .FALSE.
!rm ELSE
!rm !BJJ start of proposed change
!rm !rm  FrmtLead = '('' Error reading pitching moment option.  Expecting USE_CM or NO_CM.'''
!rm !rm  GOTO 200
!rm    CALL WrScr    ( ' Error reading pitching moment option.  Expecting USE_CM or NO_CM.' )
!rm    CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm    RETURN
!rm !bjj end of proposed change
!rm ENDIF
!rm 
!rm  ! Read in the inflow model option
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'inflow model option' )
!rm LINE = ADJUSTL( LINE )
!rm CALL Conv2UC(LINE(1:7))
!rm IF (LINE(1:5) == 'EQUIL') THEN
!rm    DYNINFL = .FALSE.
!rm    DYNINIT = .FALSE.
!rm    IF (LINE(6:7) == 'DA') THEN
!rm       EqAIDmult = 1.0
!rm       EquilDA   = .TRUE.
!rm       EquilDT   = .FALSE.
!rm    ELSEIF (LINE(6:7) == 'DB') THEN
!rm       EqAIDmult = 1.0
!rm       EquilDA   = .TRUE.
!rm       EquilDT   = .TRUE.
!rm    ELSEIF (LINE(6:7) == 'DT') THEN
!rm       EqAIDmult = 0.0
!rm       EquilDA   = .FALSE.
!rm       EquilDT   = .TRUE.
!rm    ELSE
!rm       EqAIDmult = 0.0
!rm       EquilDA   = .FALSE.
!rm       EquilDT   = .FALSE.
!rm    ENDIF
!rm ELSEIF (LINE(1:5) == 'DYNIN') THEN
!rm    DYNINFL = .TRUE.
!rm    DYNINIT = .TRUE.
!rm ELSE
!rm !BJJ start of proposed change
!rm !rm  FrmtLead = '('' Error reading dynamic inflow model option.  Expecting EQUIL or DYNIN.'''
!rm !rm  GOTO 200
!rm    CALL WrScr    ( ' Error reading dynamic inflow model option.  Expecting EQUIL or DYNIN.' )
!rm    CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm    RETURN
!rm !bjj end of proposed change
!rm ENDIF
!rm 
!rm  ! Read in the wake model
!rm READ(UnADin,'( A )',IOSTAT=IOS)  LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'wake model' )
!rm LINE = ADJUSTL( LINE )
!rm CALL Conv2UC(LINE(1:5))
!rm IF (LINE(1:4) == 'NONE') THEN
!rm   WAKE = .FALSE.
!rm   SWIRL = .FALSE.
!rm ELSEIF (LINE(1:4) == 'WAKE') THEN
!rm   WAKE = .TRUE.
!rm   SWIRL = .FALSE.
!rm ELSEIF (LINE(1:5) == 'SWIRL') THEN
!rm   WAKE = .TRUE.
!rm   SWIRL = .TRUE.
!rm ELSE
!rm !BJJ start of proposed change
!rm !rm  FrmtLead = '('' Error reading wake model option.  Expecting NONE or WAKE or SWIRL.'''
!rm !rm  GOTO 200
!rm    CALL WrScr    ( ' Error reading wake model option.  Expecting NONE or WAKE or SWIRL.' )
!rm    CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm    RETURN
!rm !bjj end of proposed change
!rm 
!rm ENDIF
!rm 
!rm 
!rm !bjj Start of proposed change v12.70-bjj
!rm IF (WAKE) THEN
!rm    READ (UnADin, *, IOSTAT=IOS ) ATOLER
!rm    CALL CheckIOS (IOS, AeroInFile, 'ATOLER', NumType )
!rm ELSE
!rm    CALL ProgWarn( ' All wake calculations are turned off!  This option is only recommended for debugging or in high winds.' )
!rm    READ (UnADin, *, IOSTAT=IOS ) LINE
!rm    CALL CheckIOS (IOS, AeroInFile, 'Induction factor tolerance', StrType )
!rm ENDIF
!rm !RMIF ( .NOT. WAKE ) THEN
!rm !RM!bjj Start of proposed change v12.70-bjj
!rm !RM!rm   MESAGE = ' This option is only recommended for debugging or in high winds.'
!rm !RM!rm   Frmt = '('' All wake calculations are turned off!'',/2x,A)'
!rm !RM!rm   CALL ErrLog( MESAGE, Frmt, 'ADIn', 3, 'WARN' )
!rm !RM   CALL ProgWarn( ' All wake calculations are turned off!  This option is only recommended for debugging or in high winds.' )
!rm !RM!bjj end of proposed change
!rm !RMENDIF
!rm !RM
!rm !RM ! Read in the induction factor tolerance
!rm !RMREAD(UnADin,'( A )',IOSTAT=IOS) LINE
!rm !RMIF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'induction factor tolerance' )
!rm !RMIF (WAKE) READ(LINE,*,ERR=205) ATOLER
!rm !bjj end of proposed change
!rm 
!rm  ! Read in the tip-loss model
!rm READ(UnADin,'( A )',IOSTAT=IOS)  LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tip-loss model' )
!rm IF (.NOT. DYNINFL) THEN
!rm    LINE = ADJUSTL( LINE )
!rm    CALL Conv2UC(LINE(1:5))
!rm    IF (LINE(1:4) == 'NONE') THEN
!rm      TLOSS = .FALSE.
!rm    ELSEIF (LINE(1:5) == 'PRAND') THEN
!rm      TLOSS = .TRUE.
!rm      GTECH = .FALSE.
!rm    ELSEIF (LINE(1:5) == 'GTECH') THEN
!rm      TLOSS = .TRUE.
!rm      GTECH = .TRUE.
!rm    ELSE
!rm !BJJ start of proposed change
!rm !rm     FrmtLead = '('' Error reading tip-loss model option.  Expecting NONE or PRAND or GTECH.'''
!rm !rm     GOTO 200
!rm       CALL WrScr    ( ' Error reading tip-loss model option.  Expecting NONE or PRAND or GTECH.' )
!rm       CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm       RETURN
!rm !bjj end of proposed change
!rm    ENDIF
!rm ENDIF
!rm 
!rm  ! Read in the hub-loss model
!rm READ(UnADin,'( A )',IOSTAT=IOS)  LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'hub-loss model' )
!rm IF (.NOT. DYNINFL) THEN
!rm    LINE = ADJUSTL( LINE )
!rm    CALL Conv2UC(LINE(1:5))
!rm    IF (LINE(1:4) == 'NONE') THEN
!rm      HLOSS = .FALSE.
!rm    ELSEIF (LINE(1:5) == 'PRAND') THEN
!rm      HLOSS = .TRUE.
!rm    ELSE
!rm !BJJ start of proposed change
!rm !rm     FrmtLead = '('' Error reading hub-loss model option.  Expecting NONE or PRAND.'''
!rm !rm     GOTO 200
!rm       CALL WrScr    ( ' Error reading hub-loss model option.  Expecting NONE or PRAND.' )
!rm       CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm       RETURN
!rm !bjj end of proposed change
!rm    ENDIF
!rm ENDIF
!rm 
!rm  ! Read in the wind file name
!rm 
!rm !bjj start of proposed change v12.70w
!rm !rmREAD(UnADin,*,IOSTAT=IOS) FileName
!rm !rmIF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'wind file name' )
!rm !rm!bjj Start of proposed change AD_v12.70-bjj
!rm !rm!rmCALL CheckWindType ( TRIM(ADJUSTL(FileName)) )
!rm !rmFileName = ADJUSTL(FileName)          ! the only way to get whitespace to the left is if someone purposely put whitespace in quotation marks.  This is unnecessary.
!rm !rmCALL CheckWindType ( FileName )
!rm !rm!bjj end of proposed change AD_v12.70-bjj
!rm 
!rm CALL ReadVar( UnADin, TRIM(AeroInFile), WindFileName, 'WindFileName', 'Name of the wind file')
!rm 
!rm !bjj end of proposed change
!rm 
!rm 
!rm  ! Read in the wind reference (hub) height above ground
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'wind reference height' )
!rm READ(LINE,*,ERR=205) HH
!rm 
!rm !************bjj start of proposed change for pjm************************
!rm  ! Read in the tower shadow deficit
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower shadow deficit' )
!rm READ(LINE,*,ERR=205)  TWRSHAD
!rm 
!rm IF ( TWRSHAD .GE. 1.0 ) THEN ! Tower shadow deficit cannot be 1.
!rm !bjj start of proposed change v12.70-bjj
!rm !rm   MESAGE = ' Tower shadow deficit cannot be >= 1'
!rm !rm   Frmt   = '(36(''*''),/A,/2x,''Setting default deficit = 0.3'',/36(''*''))'
!rm !rm   CALL ErrLog(MESAGE, Frmt, 'ADIn', 4, 'WARN')
!rm    CALL ProgWarn( ' Tower shadow deficit cannot be >= 1.  Setting default deficit = 0.3' )
!rm !bjj end of proposed change
!rm    TWRSHAD = 0.3
!rm ENDIF
!rm 
!rm  ! Read in the tower shadow width
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower shadow width' )
!rm READ(LINE,*,ERR=205)  SHADHWID
!rm 
!rm IF ( SHADHWID .LE. 0.0 ) THEN ! Tower shadow width cannot be zero
!rm !bjj start of proposed change v12.70-bjj
!rm !rm   MESAGE = ' Tower shadow width cannot be <= zero.'
!rm !rm   Frmt   = '(38(''*''),/A,/2x,''Setting default half width = 1.0'',/38(''*''))'
!rm !rm   CALL ErrLog(MESAGE, Frmt, 'ADIn', 5, 'WARN')
!rm    CALL ProgWarn( ' Tower shadow width cannot be <= zero.  Setting default half width = 1.0' )
!rm !bjj end of proposed change v12.70-bjj
!rm    SHADHWID = 1.0
!rm ENDIF
!rm 
!rm  ! Read in the tower shadow reference point (distance from yaw axis to hub)
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower shadow reference point' )
!rm READ(LINE,*,ERR=205)  T_Shad_Refpt
!rm 
!rm  ! Constants used in tower shadow calculations
!rm TSHADC1 = SHADHWID / SQRT ( ABS( T_Shad_Refpt ) )
!rm TSHADC2 = TWRSHAD  * SQRT ( ABS( T_Shad_Refpt ) )
!rm 
!rm ! ! Read in the tower potential flow switch
!rm !READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm !IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower influence model' )
!rm !READ(LINE,*,ERR=205)  TwrPotent
!rm !
!rm ! ! Read in the tower shadow switch
!rm !READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm !IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower shadow model' )
!rm !READ(LINE,*,ERR=205)  TwrShadow
!rm 
!rm !bjj start: this seems superflous so I'm removing it
!rm !rm ! Read in the tower drag switch
!rm !rmREAD(UnADin,'( A )',IOSTAT=IOS) LINE
!rm !rmIF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower drag file logical flag' )
!rm !rmREAD(LINE,*,ERR=205)  TwrRead
!rm !bjj end
!rm 
!rm !!bjj rm:IF (TwrPotent .OR. TwrShadow .OR. TwrRead) THEN   !pjm change for 12.60f TwrInfl now a int switch
!rm !IF (TwrPotent .OR. TwrShadow) THEN   !pjm change for 12.60f TwrInfl now a int switch
!rm ! ! Read in the tower drag file name
!rm !   READ(UnADin,*,IOSTAT=IOS) TwrFile
!rm !   IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'tower data file name' )
!rm !   !BJJ: CALL READTwr
!rm !   CALL READTwr(UnTwr, TwrFile, ErrStat)   !bjj this should be done elsewhere, not in the middle of reading a different file!
!rm !   IF (ErrStat /= 0) RETURN
!rm !
!rm !ELSE ! Skip the next line
!rm !   READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm !ENDIF
!rm !End change v12.58pjm-ce
!rm 
!rm 
!rm !************bjj END of proposed change for pjm************************
!rm 
!rm  ! Read in the air density
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'air density' )
!rm READ(LINE,*,ERR=205)  RHO
!rm 
!rm  ! Turn off the GDW if RHO = 0.  It will crash
!rm IF (RHO == 0.0 .AND. DYNINFL) THEN
!rm !bjj start of proposed change
!rm !rm   MESAGE = 'Air Density is zero.  Dynamic Inflow will be turned off to avoid program crash.'
!rm !rm   Frmt   = '(A)'
!rm !rm   CALL ErrLog(MESAGE, Frmt, 'ADIn', 6, 'WARN')
!rm    CALL ProgWarn( 'Air Density is zero.  Dynamic Inflow will be turned off to avoid program crash.' )
!rm !bjj end of proposed change
!rm    DYNINFL = .FALSE.
!rm ENDIF
!rm 
!rm  ! Read in the kinematic viscosity
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'kinematic viscosity' )
!rm READ(LINE,*,ERR=205) KinVisc
!rm 
!rm  ! Aero calculation time interval is not used by YawDyn
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'aero calculation time step' )
!rm !bjj start of proposed change
!rm !rmSELECT CASE (TRIM(DynProg))
!rm !rm   CASE ('YawDyn') ! Don't read this line
!rm !rm   CASE DEFAULT
!rm !rm      READ(LINE,*,ERR=205) DTAERO
!rm !rmEND SELECT
!rm READ(LINE,*,ERR=205) DTAERO
!rm !bjj end of proposed change
!rm 
!rm  ! Read the number of airfoil files
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , '# of airfoil files' )
!rm READ(LINE,*,ERR=205) NUMFOIL
!rm 
!rm !BJJ REPLACE: ALLOCATE ( FOILNM( NUMFOIL ) , STAT=Sttus )
!rm IF (.NOT. ALLOCATED(FOILNM)) ALLOCATE ( FOILNM( NUMFOIL ) , STAT=Sttus )
!rm IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for FOILNM array.' )
!rm 
!rm 
!rm  ! Open and read airfoil data file(s)
!rm DO INF = 1, NUMFOIL
!rm READ(UnADin,*,IOSTAT=IOS) FOILNM( INF )
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'airfoil filenames' )
!rm ENDDO ! INF
!rm 
!rm  ! Read in the number of blade elements
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , '# of blade elements' )
!rm READ(LINE,*,ERR=205) NELM
!rm 
!rm 
!rm  ! Allocate arrays with dimension NELM
!rm 
!rm CALL AllocArrays ('Element')
!rm 
!rm ElIndex = 0 ! Initialize the element print array index
!rm 
!rm WndElIndex = 0
!rm 
!rm !bjj start of propsoed change
!rm !rmR = 0.0
!rm !bjj end of proposed change
!rm 
!rm  ! Read blade element data, check some inputs, convert twist to radians
!rm READ(UnADin,'( )',IOSTAT=IOS) ! The table header line
!rm IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'element table header line' )
!rm DO IELM = 1, NELM
!rm 
!rm    READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm    IF ( IOS < 0 ) CALL PremEOF ( AeroInFile , 'blade data' )
!rm    READ(LINE,*,ERR=205) RELM(IELM), TWIST(IELM), DR(IELM), C(IELM), NFOIL(IELM)
!rm    IF( C(IELM) <= 0.0 ) THEN
!rm !bjj start of proposed change v12.70-bjj
!rm !rm      MESAGE = ' Element '//TRIM(Int2LStr(  IELM))// ' chord length = '//  &
!rm !rm                            TRIM(Flt2LStr(C(IELM)))//' is less than 0.'
!rm !rm      Frmt   = '(''Error: chord length must be larger than 0.'',/A/,'// &
!rm !rm                 '''Please check the input file.'')'
!rm !rm      CALL ErrLog( MESAGE, Frmt, 'ADIn', 7, 'FAULT' )
!rm       CALL ProgAbort( ' Error: chord length must be larger than 0. '// &
!rm                 'Element '//TRIM(Int2LStr(  IELM))// ' chord length = '//  &
!rm                             TRIM(Flt2LStr(C(IELM)))//' is less than 0.'// &
!rm                 ' Please check the input file.'            )
!rm !bjj End of proposed change v12.70-bjj
!rm    ENDIF
!rm    IF( NFOIL(IELM) > NUMFOIL ) THEN
!rm !bjj start of proposed change
!rm !rm      MESAGE = ' Airfoil file ID #'//TRIM(Int2LStr(NFOIL(IELM)))// &
!rm !rm               ' does not exist.'
!rm !rm      Frmt   = '(A,/'' Please check the input file.'')'
!rm !rm      CALL ErrLog( MESAGE, Frmt, 'ADIn', 8, 'FAULT' )
!rm       CALL ProgAbort( ' Airfoil file ID #'//TRIM(Int2LStr(NFOIL(IELM)))//' does not exist.'// &
!rm                       ' Please check the input file.')
!rm !bjj end of proposed change
!rm    ENDIF
!rm 
!rm  ! Check if AeroDyn will print out the element data
!rm    CALL Conv2UC(LINE)
!rm    IndPrint = Index(LINE,"PRINT")
!rm !bjj Start of proposed change v12.70b
!rm !rm   If ((IndPrint > 0) .AND. &
!rm !rm       (LINE(IndPrint-2:IndPrint+4) /= "NOPRINT")) Then
!rm    IF (IndPrint > 0) THEN
!rm       IF ( IndPrint < 3 ) THEN
!rm          ElIndex = ElIndex + 1
!rm          ElPrList(IELM) = ElIndex
!rm       ELSE IF (LINE(IndPrint-2:IndPrint+4) /= "NOPRINT") Then
!rm !bjj End of proposed change
!rm          ElIndex = ElIndex + 1
!rm          ElPrList(IELM) = ElIndex
!rm !bjj Start of proposed change v12.70b
!rm       ENDIF
!rm !bjj End of proposed change v12.70b
!rm    Endif
!rm 
!rm !bjj Start of proposed change v12.70
!rm !rm   TWIST(IELM) = TWIST(IELM)*DtoR
!rm       TWIST(IELM) = TWIST(IELM)*D2R
!rm !bjj End of proposed change
!rm 
!rm !bjj start of propsoed change
!rm !rm!bjj start comment: R should be sent from the structural code during initialization; this should be unnecessary:
!rm !rm ! Estimate rotor radius (value used only during initialization)
!rm !rm   R = R + DR(IELM)
!rm !rm!bjj end comment
!rm !bjj end of proposed change
!rm 
!rm    IndPrint = Index(LINE,"WIND")
!rm !bjj Start of proposed change v12.70b
!rm !rm   IF ((IndPrint > 0) .AND. (LINE(IndPrint-2:IndPrint-1) /= "NO")) THEN
!rm    IF (IndPrint > 0) THEN
!rm       IF (IndPrint < 3) THEN     ! I DON'T COMBINE THESE STATEMENTS WITH "OR" BECAUSE THERE IS NO SHORTCUTTING
!rm           WndElIndex = WndElIndex + 1
!rm           WndElPrList(IELM) = WndElIndex
!rm       ELSE IF (LINE(IndPrint-2:IndPrint-1) /= "NO") THEN
!rm !bjj End of proposed change v12.70b
!rm           WndElIndex = WndElIndex + 1
!rm           WndElPrList(IELM) = WndElIndex
!rm !bjj Start of proposed change v12.70b
!rm       ENDIF
!rm !bjj eND of proposed change v12.70b
!rm    ENDIF
!rm 
!rm ENDDO ! IELM
!rm 
!rm 
!rm  ! Set flag if there are any element data to print out
!rm NumElOut = ElIndex
!rm IF ( NumElOut > 0 ) THEN
!rm    ELEMPRN = .TRUE.
!rm  ! Allocate arrays with dimension NumElOut
!rm    CALL AllocArrays ('ElPrint')
!rm ELSE
!rm    ELEMPRN = .FALSE.
!rm ENDIF
!rm 
!rm NumWndElOut = WndElIndex
!rm IF (NumWndElOut > 0 .AND. NumElOut <= 0 ) THEN
!rm    ELEMPRN = .TRUE.
!rm    CALL AllocArrays ('ElPrint')
!rm ENDIF
!rm 
!rm ElIndex = 0 ! Re-Initialize the element print array index for wind
!rm DO IELM = 1, NELM
!rm    IF (WndElPrList(IELM) > 0) THEN
!rm       ElIndex = ElIndex + 1
!rm       WndElPrNum(ElIndex) = IELM
!rm    ENDIF
!rm ENDDO ! IELM
!rm 
!rm 
!rm ElIndex = 0 ! Re-Initialize the element print array index
!rm DO IELM = 1, NELM
!rm    IF (ElPrList(IELM) > 0) THEN
!rm       ElIndex = ElIndex + 1
!rm       ElPrNum(ElIndex) = IELM
!rm    ENDIF
!rm ENDDO ! IELM
!rm 
!rm 
!rm  ! Moved DO loop into READFL
!rm CALL READFL
!rm 
!rm  ! Read in the type of airfoil data table in each file
!rm READ(UnADin,'( A )',IOSTAT=IOS) LINE
!rm IF ( IOS < 0 ) THEN
!rm    DO INF = 1, NUMFOIL
!rm       IF (NTables(INF) > 1) THEN
!rm !bjj start of proposed change v12.70-bjj
!rm !rm         MESAGE = ' Error reading multiple airfoil table option.'
!rm !rm         Frmt   = '(A,/''  Only one table for each file will be used.'')'
!rm !rm         CALL ErrLog( MESAGE, Frmt, 'ADIn', 9, 'WARN' )
!rm          CALL ProgWarn( ' Error reading multiple airfoil table option. Only one table for each file will be used.' )
!rm !bjj end of proposed change v12.70-bjj
!rm          EXIT !INF DO loop
!rm       ENDIF
!rm    END DO !INF
!rm ELSE
!rm    DO INF = 1, NUMFOIL
!rm       IF (NTables(INF) > 1) THEN
!rm          LINE = ADJUSTL( LINE )
!rm          CALL Conv2UC(LINE(1:6))
!rm          IF (LINE(1:4) == 'USER') THEN
!rm             MultiTab = .TRUE.
!rm             Reynolds = .FALSE.
!rm          ELSEIF (LINE(1:5) == 'RENUM') THEN
!rm             MultiTab = .TRUE.
!rm             Reynolds = .TRUE.
!rm          ELSEIF (LINE(1:6) == 'SINGLE') THEN
!rm             MultiTab = .FALSE.
!rm          ELSE
!rm !BJJ start of proposed change
!rm !rm            FrmtLead = '('' Error reading control model option.  Expecting SINGLE or MULTI.'''
!rm !rm            GOTO 200
!rm             CALL WrScr    ( ' Error reading control model option.  Expecting SINGLE or MULTI.' )
!rm             CALL ProgAbort( ' The offending line in the AeroDyn input file reads: "'//TRIM(LINE)//'"' )
!rm             RETURN
!rm !bjj end of proposed change
!rm          ENDIF
!rm          EXIT
!rm        ELSE
!rm          MultiTab = .FALSE.
!rm        ENDIF
!rm    ENDDO ! INF
!rm ENDIF
!rm  ! Set all interpolation values the same as the first table.
!rm IF (MultiTab .AND. .NOT. Reynolds) THEN
!rm  ! Check to see if initial interpolation value is out of airfoil table range.
!rm    DO K = 1, NUMFOIL
!rm       IF (NTables(K) > 1) THEN
!rm          IF ( ( MulTabLoc < MulTabMet(K,1) ) .OR. &
!rm               ( MulTabLoc > MulTabMet(K,NTables(K) ) ))THEN
!rm !bjj Start of proposed change v12.70-bjj
!rm !rm            MESAGE = ' Initial interpolation value = '//TRIM(Flt2LStr(MulTabLoc))// &
!rm !rm                     ' is outside table range of '//TRIM(Flt2LStr(MulTabMet(K,1)))// &
!rm !rm                     ' to '//TRIM(Flt2LStr(MulTabMet(K,NTables(K))))// &
!rm !rm                     ' in airfoil file #'//TRIM(Int2LStr(K))//'.'
!rm !rm            Frmt   = "('Error interpolating between airfoil tables.', /2x, A)"
!rm !rm            CALL ErrLog( MESAGE, Frmt, 'ADIn', 10, 'FAULT' )
!rm             CALL ProgAbort( 'Error interpolating between airfoil tables. '// &
!rm                      ' Initial interpolation value = '//TRIM(Flt2LStr(MulTabLoc))// &
!rm                      ' is outside table range of '//TRIM(Flt2LStr(MulTabMet(K,1)))// &
!rm                      ' to '//TRIM(Flt2LStr(MulTabMet(K,NTables(K))))// &
!rm                      ' in airfoil file #'//TRIM(Int2LStr(K))//'.' )
!rm !bjj end of proposed change v12.70-bjj
!rm          ENDIF
!rm       ENDIF
!rm    ENDDO ! K
!rm ENDIF
!rm 
!rm  ! Calculate BEDDOES dynamic stall data if desired
!rm 
!rm IF ( DSTALL ) CALL BEDDAT
!rm 
!rm !bjj start of proposed change v12.70w
!rm !rm ! Open and read the requested wind file(s)  For HH, LE, and CT files, read only the first two time steps.
!rm !rm
!rm !rm!This must be called first, in order to find the background wind file
!rm !rmIF ( CTWindFlag ) THEN
!rm !rm   CALL GetCTWind
!rm !rmENDIF
!rm !rm
!rm !rm
!rm !rmIF ( HHWindFlag )  THEN
!rm !rm   CALL GetHHWind
!rm !rmELSEIF ( FFWindFlag )  THEN
!rm !rm   CALL ReadFF ( EndTime )
!rm !rmELSEIF ( UsrWndFlag )  THEN
!rm !rm   CALL UserWind
!rm !rmELSE
!rm !rm   CALL GetFDWind
!rm !rmENDIF
!rm 
!rm !BJJ end of proposed change
!rm 
!rm CLOSE(UnADin)
!rm 
!rm 
!rm RETURN
!rm 
!rm !bjj start of proposed change v12.70
!rm ! this needs to be fixed so that the error log actually prints the frmt...
!rm !bjj end of proposed change v12.70-bjj
!rm 
!rm 
!rm 
!rm 
!rm !bjj start of proposed change
!rm !rm200 Frmt   = TRIM(FrmtLead)//'/, '' The offending line in aerodyn.ipt reads: '', /, 2x, A)'
!rm !rm    GOTO 215
!rm !rm
!rm !rm205 Frmt   = '('' Error reading input file line: '', /, 2x, A)'
!rm !rm    GOTO 215
!rm !rm
!rm !rm206 Frmt   = '('' AeroDyn expected a positive value on this line:'', /, 2x, A)'
!rm !rm    GOTO 215
!rm !rm
!rm !rm215 MESAGE = '"' // Trim(LINE) // '"'
!rm !bjj start of proposed change v12.70
!rm !rmGOTO 230
!rm !rm
!rm !rm ! Finished reading input data
!rm !rm
!rm !rm 230 CALL ErrLog( MESAGE, Frmt, 'ADIn', 11, 'FAULT' )
!rm !rm
!rm !bjj FIX THIS!!!! (No more GOTO statements or ERR=205!!!!)
!rm 205   CALL ProgAbort( ' Error reading input file line: "'//TRIM(Line)//'"' )
!rm 206   CALL ProgAbort( ' AeroDyn expected a positive value on this line: "'//TRIM(Line)//'"' )
!rm !bjj end of proposed change
!rm 
!rm 
!rm END SUBROUTINE ADIn
!rm 
!BJJ end of proposed change
 ! *****************************************************
!bjj start of proposed change for pjm
!rm   SUBROUTINE ADOut ( T_Shad_Refpt, TITLE )
   SUBROUTINE ADOut ( TITLE, HubRad, WindFileName )
!bjj end of proposed change for pjm
 !  used to output data pertinent
 !  to the yaw dynamics routines
 ! *****************************************************

USE                         AD_IOParams
USE                         ElOutParams
USE                         AeroTime
USE                         Airfoil
USE                         Blade
!bjj rm NWTC_Lib:USE                         Constant
!rmUSE                         CT_Wind
USE                         Element
!rmUSE                         FD_Wind
!rmUSE                         FF_Wind
!bjj rm:USE                         Identify
USE                         InducedVel
!bjj rm: USE                         Precision
USE                         Rotor
USE                         Switch
USE                         Wind

!bjj start of proposed change for pjm
USE                         TwrProps
!bjj end of proposed change for pjm



IMPLICIT                    NONE


   ! Passed Variables:
!BJJ Start of proposed change v12.7
!rmREAL(ReKi)               :: T_Shad_Refpt
!rm
!rmCHARACTER( 80)           :: TITLE
!bjj start of proposed change for pjm
!rmREAL(ReKi),INTENT(IN)    :: T_Shad_Refpt
!bjj end of proposed change for pjm

CHARACTER(*),  INTENT(IN):: TITLE
REAL(ReKi),    INTENT(IN):: HubRad
CHARACTER(*),  INTENT(IN):: WindFileName
!BJJ End of proposed change v12.7

   ! Local Variables:

INTEGER(4)               :: IElm
INTEGER(4)               :: IFoil
!rm not used:INTEGER(4)               :: Ipr

CHARACTER(  2)           :: Dst_Unit
CHARACTER(150)           :: Frmt
CHARACTER(  4)           :: Mass_Unit
CHARACTER( 35)           :: MESAGE
CHARACTER(  3)           :: Vel_Unit

!bjj start of propsoed change
CHARACTER(1)             :: Delim
!BJJ END of proposed chagne

   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER( 15), EXTERNAL :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER( 11), EXTERNAL :: Int2LStr


IF (SIUNIT) THEN
   Dst_Unit  = 'm'
   Mass_Unit = 'kg'
   Vel_Unit  = 'mps'
ELSE
   Dst_Unit  = 'ft'
   Mass_Unit = 'slug'
   Vel_Unit  = 'fps'
ENDIF

 ! Reiterate the input file
!bjj start of proposed change v13.00a
!rmWRITE(UnADopt,'(1X, /A)') 'Inputs read in from aerodyn.ipt:'
!RMWRITE(UnADopt,'(1X, /A)') TITLE
WRITE(UnADopt,'(/A)') 'Inputs read in from the AeroDyn input file:'
WRITE(UnADopt,'(A/)') TRIM(TITLE)
!bjj end of proposed change


MESAGE = 'Units for input and output'
IF ( SIUNIT ) THEN
   WRITE(UnADopt,'(A)') 'SI'//TAB//MESAGE
ELSE
   WRITE(UnADopt,'(A)') 'ENGLISH'//TAB//MESAGE
ENDIF

MESAGE = 'Dynamic stall model'
IF ( DSTALL ) THEN
   WRITE(UnADopt,'(A)') 'BEDDOES'//TAB//MESAGE//' [Beddoes]'
ELSE
   WRITE(UnADopt,'(A)') 'STEADY'//TAB//MESAGE//' [NO Dynamic stall]'
ENDIF

MESAGE = 'Aerodynamic pitching moment model'
IF ( PMOMENT ) THEN
   WRITE(UnADopt,'(A)') 'USE_CM'//TAB//MESAGE//' [Pitching Moments calculated]'
ELSE
   WRITE(UnADopt,'(A)') 'NO_CM'//TAB//MESAGE//' [NO Pitching Moments calculated]'
ENDIF

MESAGE = 'Inflow model'
IF ( DYNINFL ) THEN
   WRITE(UnADopt,'(A)') 'DYNIN'//TAB//MESAGE//' [Dynamic Inflow]'
ELSE
   IF ( EquilDA .AND. EquilDT )  THEN
      WRITE(UnADopt,'(A)') 'EQUILDB'//TAB//MESAGE//' [Equilibrium w/ axial and tangential drag]'
   ELSEIF ( EquilDA )  THEN
      WRITE(UnADopt,'(A)') 'EQUILDA'//TAB//MESAGE//' [Equilibrium w/ axial drag]'
   ELSEIF ( EquilDT )  THEN
      WRITE(UnADopt,'(A)') 'EQUILDA'//TAB//MESAGE//' [Equilibrium w/ tangential drag]'
   ELSE
      WRITE(UnADopt,'(A)') 'EQUIL'//TAB//MESAGE//' [Equilibrium]'
   ENDIF
ENDIF


MESAGE = 'Induction factor model'
IF ( WAKE ) THEN
   IF (SWIRL) THEN
      WRITE(UnADopt,'(A)') 'SWIRL'//TAB//MESAGE//' [Normal and Radial flow induction factors calculated]'
   ELSE
      WRITE(UnADopt,'(A)') 'WAKE'//TAB//MESAGE//' [Normal flow induction factors calculated]'
   ENDIF
   WRITE(UnADopt,'(A)') TRIM(Flt2LStr(ATOLER))//TAB// 'Convergence tolerance for induction factor'
ELSE
   WRITE(UnADopt,'(A)') 'NONE'//TAB//MESAGE//' [NO induction factors calculated]'
   WRITE(UnADopt,'(A)') '[Not Used]'//TAB//'Convergence tolerance for induction factor'
ENDIF

MESAGE = 'Tip-loss model'
IF (.NOT. DYNINFL) THEN
   IF ( TLOSS ) THEN
      IF (GTECH) THEN
         WRITE(UnADopt,'(A)') 'GTECH'//TAB//MESAGE//' [Georgia Tech correction to Prandtl model]'
      ELSE
         WRITE(UnADopt,'(A)') 'PRAND'//TAB//MESAGE//' [Prandtl model]'
      ENDIF
   ELSE
      WRITE(UnADopt,'(A)') 'NONE'//TAB//MESAGE//' [NO tip-loss calculated]'
   ENDIF
ELSE
      WRITE(UnADopt,'(A)') '[Not Used]'//TAB//MESAGE
ENDIF

MESAGE = 'Hub-loss model'
IF (.NOT. DYNINFL) THEN
   IF ( HLOSS ) THEN
      WRITE(UnADopt,'(A)') 'PRAND'//TAB//MESAGE//' [Prandtl model]'
   ELSE
      WRITE(UnADopt,'(A)') 'NONE'//TAB//MESAGE//' [NO hub-loss calculated]'
   ENDIF
ELSE
      WRITE(UnADopt,'(A)') '[Not Used]'//TAB//MESAGE
ENDIF



!bjj start of proposed change v12.70w
!rmIF ( FFWindFlag ) THEN
!rm   WRITE(UnADopt,'(A)') '"'//TRIM( FFWindFile )//'"'//TAB//'is the Full-field wind file root'
!rmELSEIF ( CTWindFlag ) THEN
!rm   WRITE(UnADopt,'(A)') '"'//TRIM( CTPFile  )//'"'//TAB//'is the coherent turbulence parameter file'
!rmELSEIF ( FDWindFlag ) THEN
!rm   WRITE(UnADopt,'(A)') '"'//TRIM( FDPFile )//'"'//TAB//'is the 4D-wind parameter file'
!rmELSEIF ( UsrWndFlag ) THEN
!rm   WRITE(UnADopt,'(A)') 'Using user-written wind routine, UserWind()'
!rmELSE ! If it isn't any of the above, then it is or was HH
!rm   WRITE(UnADopt,'(A)') '"'//TRIM( HHWindFile )//'"'//TAB//'is the Hub-height wind file'
!rmENDIF

WRITE(UnADopt, '(A)') '"'//TRIM(WindFileName)//'"'//TAB//'  Wind file name'
!bjj end of proposed change

WRITE(UnADopt,'(A)') TRIM(Flt2LStr(HH))//TAB// 'Wind reference (hub) height, '//TRIM(Dst_Unit)

!bjj start of proposed change for pjm
!rmWRITE(UnADopt,'(A)') TRIM(Flt2LStr(TWRSHAD))//TAB// 'Tower shadow centerline velocity deficit'
!rmWRITE(UnADopt,'(A)') TRIM(Flt2LStr(SHADHWID))//TAB// 'Tower shadow half width, '//TRIM(Dst_Unit)
!rmWRITE(UnADopt,'(A)') TRIM(Flt2LStr(T_Shad_Refpt))//TAB// 'Tower shadow reference point, '//TRIM(Dst_Unit)
IF ( PJM_Version ) THEN
   WRITE(UnADopt,'(L2, A)') TwrPotent, TAB//'Calculate tower potential flow [T or F]'
   WRITE(UnADopt,'(L2, A)') TwrShadow, TAB//'Calculate tower shadow [T or F]'
!bjj rm:WRITE(UnADopt,'(L2, A)') TwrRead, TAB//'Read in filename below (if False above; for tower drag in Dyn progs) [T or F]'
!bjj rm:IF ( TwrRead .OR. TwrPotent .OR. TwrShadow ) THEN
   IF ( TwrPotent .OR. TwrShadow ) THEN
      WRITE(UnADopt,'(A)') '"'//TRIM( TwrFile )//'"'//TAB//'Tower drag file name'
   ELSE
      WRITE(UnADopt,'(A)') '[none]'//TAB//'No tower drag properties file'
   ENDIF
ELSE
   WRITE(UnADopt,'(A)') TRIM(Flt2LStr(TwrShad))//TAB// 'Tower shadow centerline velocity deficit'
   WRITE(UnADopt,'(A)') TRIM(Flt2LStr(ShadHWid))//TAB// 'Tower shadow half width, '//TRIM(Dst_Unit)
   WRITE(UnADopt,'(A)') TRIM(Flt2LStr(T_Shad_Refpt))//TAB// 'Tower shadow reference point, '//TRIM(Dst_Unit)
END IF
!bjj end of proposed change for pjm


WRITE(UnADopt,'(A)') TRIM(Flt2LStr(RHO))//TAB// 'Air density, '//TRIM(Mass_Unit)//'/'//TRIM(Dst_Unit)//'^3'
!bjj start of proposed change
!rmWRITE(UnADopt,'(A)') TRIM(Flt2LStr(KinVisc))//TAB// 'Kinematic air viscosity, '//TRIM(Dst_Unit)//'^2/''sec'
WRITE(UnADopt,'(A)') TRIM(Flt2LStr(KinVisc))//TAB// 'Kinematic air viscosity, '//TRIM(Dst_Unit)//'^2/sec'
!bjj end of proposed change

!bjj start of proposed change
!rmSELECT CASE (TRIM(DynProg))
!rm   CASE ('YawDyn')
!rm      WRITE(UnADopt,'(A)')'[NOT USED]'//TAB//'Time interval for aerodynamic calculations, sec'
!rm   CASE DEFAULT
!rm      WRITE(UnADopt,'(A)') TRIM(Flt2LStr(DTAERO))//TAB// 'Time interval for aerodynamic calculations, sec'
!rmEND SELECT
WRITE(UnADopt,'(A)') TRIM(Flt2LStr(DTAERO))//TAB// 'Time interval for aerodynamic calculations, sec'
!bjj end of proposed change

WRITE(UnADopt,'(A)') TRIM(Int2LStr(NUMFOIL))//TAB// 'Number of airfoil files used. Files listed below:'
DO IFoil = 1, NUMFOIL
   WRITE(UnADopt,'(A)') '"'//TRIM(FOILNM(IFoil))//'"'
END DO ! IFoil

WRITE(UnADopt,'(A)') TRIM(Int2LStr(NELM))//TAB// 'Number of blade elements per blade'

!bjj start of proposed change
!rmSELECT CASE (TRIM(DynProg))
!rm   CASE ('ADAMS') ! Don't write this table !bjj: why not?
!rm   CASE DEFAULT
!rm   Frmt = '(13(A))'
!rm   WRITE(UnADopt,Frmt)'RELM('//TRIM(Dst_Unit)//')'  &
!rm           ,TAB, 'Twist(deg)'                  &
!rm         ,TAB, 'DR('//TRIM(Dst_Unit)//')'    &
!rm         ,TAB, 'Chord('//TRIM(Dst_Unit)//')' &
!rm         ,TAB, 'File ID'   &
!rm         ,TAB, 'Elem Data' &
!rm         ,TAB, 'RELM and Twist ignored by ADAMS (but placeholders must be present)'
!rm   MESAGE = ''
!rm   DO IElm = 1, NELM
!rm!      DO Ipr = 1, MIN(NumElOut,IElm)
!rm         IF (ElPrList(IElm) /= 0) THEN
!rm            MESAGE = 'PRINT'
!rm!        EXIT !DO
!rm         ELSE
!rm            MESAGE = ''
!rm         ENDIF
!rm!      END DO !Ipr
!rm      Frmt = '(11(A))'
!rm      WRITE(UnADopt,Frmt) TRIM(Flt2LStr(RELM(IElm)))      &
!rm!bjj Start of proposed change AeroDyn v12.70
!rm!rm               ,TAB, TRIM(Flt2LStr(REAL( TWIST(IElm)*RtoD, ReKi ))) &
!rm               ,TAB, TRIM(Flt2LStr(REAL( TWIST(IElm)*R2D, ReKi ))) &
!rm!bjj End of proposed change AeroDyn v12.70
!rm               ,TAB, TRIM(Flt2LStr(DR(IElm)))        &
!rm               ,TAB, TRIM(Flt2LStr(C(IElm)))         &
!rm               ,TAB, TRIM(Int2LStr(NFOIL(IElm)))     &
!rm               ,TAB, TRIM(MESAGE)
!rm   END DO !IElm
!rm!bjj start of proposed change
!rm!rmEND SELECT
!rm!bjj end of proposed change

   Delim = ' ' !or Delim = TAB

   !-------------------------------------------------------------------------------------------------
   ! write out element information
   !-------------------------------------------------------------------------------------------------
   Frmt = '(3X,A10,8("'//Delim//'",A10))'

   WRITE(UnADopt,'( )')

      ! column names

   WRITE(UnADopt,Frmt) '  Element ', &
                       '   RELM   ', &
                       '   Twist  ', &
                       '    DR    ', &
                       '   Chord  ', &
                       '   NFoil  ', &
                       '  Print?  ', &
                       ' Tip-loss ', &
                       ' Hub-loss '

      ! column units

   WRITE(UnADopt,Frmt) '    (-)   ', &
                       '    (m)   ', &
                       '   (deg)  ', &
                       '    (m)   ', &
                       '    (m)   ', &
                       '    (-)   ', &
                       ' (Yes/No) ', &
                       ' constant ', &
                       ' constant '

   WRITE(UnADopt,Frmt) '----------', &
                       '----------', &
                       '----------', &
                       '----------', &
                       '----------', &
                       '----------', &
                       '----------', &
                       '----------', &
                       '----------'

      ! column data
   Frmt = '(3X, I10, 4("'//Delim//'",F10.5),"'//Delim//'",I10,"'//Delim//'",A10, 2("'//Delim//'",F10.5) )'

   DO IElm = 1, NELM

      IF (ElPrList(IElm) /= 0) THEN
         MESAGE = 'Yes'
      ELSE
         MESAGE = 'No'
      ENDIF

      WRITE(UnADopt, Frmt) IElm, RELM(IElm), TWIST(IElm)*R2D, DR(IElm),  C(IElm), &
                           NFOIL(IElm), TRIM(Mesage), TLCNST(IElm), HLCNST(IElm)
   END DO

!bjj end of proposed change


IF ( MultiTab ) THEN
   WRITE(UnADopt,'(A)') 'MULTI    Multiple airfoil tables used'
ELSE
   WRITE(UnADopt,'( )')
ENDIF

!bjj start of proposed change v12.70w
!rm
!rm ! Write out other useful information
!rm
!rmIF ( CTWindFlag ) THEN
!rm   WRITE(UnADopt,'(/A)') ' Coherent turbulence wind file info:'
!rm   Frmt = "( /, '  Using a ', A, 'x', A, ' wind field with ', A, ' time steps.', / )"
!rm   WRITE(UnADopt, Frmt) TRIM( Int2LStr( NumCTyD  ) ), TRIM( Int2LStr( NumCTzD ) ), TRIM( Int2LStr( NumCTt ) )
!rm   Frmt = "( '  The wind data will start at ', A, ' seconds and end at ', A, ' seconds.', / )"
!rm   WRITE(UnADopt, Frmt ) TRIM( Flt2LStr( T_CT_St ) ), TRIM( Flt2LStr( T_CT_En ) )
!rm   WRITE(UnADopt,'(A)' ) '  CTDistSc   - Disturbance scale (ratio of wave height to rotor diameter)     = '//TRIM( Flt2LStr( CTDistSc ) )
!rm   WRITE(UnADopt,'(A)' ) '  CTLy       - Lateral location of tower centerline in the dataset            = '//TRIM( Flt2LStr( CTLy       ) )
!rm   WRITE(UnADopt,'(A)' ) '  CTLz       - Vertical location of tower centerline in the dataset           = '//TRIM( Flt2LStr( CTLz       ) )
!rm   WRITE(UnADopt,'(A)' ) '  CTScaleVel - Scaling velocity, U0 (m/s)                                     = '//TRIM( Flt2LStr( CTScaleVel ) )
!rm   WRITE(UnADopt,'(A)' ) '  CT_DF_Y    - Decimation factor for wind data in the y direction             = '//TRIM( Int2LStr( CT_DF_Y  ) )
!rm   WRITE(UnADopt,'(A)' ) '  CT_DF_Z    - Decimation factor for wind data in the z direction             = '//TRIM( Int2LStr( CT_DF_Z  ) )
!rm   WRITE(UnADopt,'(/A)') ' Background wind file: '
!rm
!rmENDIF
!rm
!rmIF ( FFWindFlag ) THEN
!rm   WRITE(UnADopt,'(/A)') ' Full-field wind file info:'
!rm   Frmt = "( '  Read in ' , A , 'x' , A , ' grid of ' , A, 1x, A ,' turbulence data.' )"
!rm   WRITE(UnADopt, Frmt) TRIM( Int2LStr( NZGrids  ) ) &
!rm                 , TRIM( Int2LStr( NYGrids  ) ) &
!rm                 , TRIM( Flt2LStr( MeanFFWS ) ) &
!rm                 ,     ( Vel_Unit )
!rm   Frmt = "( 3x, A, ' records processed with a time step of ', A, ' seconds per record.' )"
!rm   WRITE(UnADopt, Frmt) TRIM( Int2LStr( NFFSteps ) ) &
!rm                 , TRIM( Flt2LStr( FFDTime  ) )
!rm   Frmt = '( 3x, A, '' sec. total time duration in this turbulence file'')'
!rm   WRITE(UnADopt, Frmt) TRIM( Flt2LStr( FFDTime*( NFFSteps - 1 ) ) )
!rmELSEIF ( FDWindFlag )  THEN
!rm   WRITE(UnADopt,'(/A)') ' 4D-wind-field info:'
!rm   Frmt = "( /, '  Using a ', A, 'x', A, 'x', A, ' wind field with ', A, ' time steps.', / )"
!rm   WRITE(UnADopt, Frmt) TRIM( Int2LStr( Num4DxD  ) ), TRIM( Int2LStr( Num4DyD  ) ), TRIM( Int2LStr( Num4DzD ) ), TRIM( Int2LStr( Num4Dt ) )
!rm   Frmt = "( '  The wind data will start at ', A, ' seconds and end at ', A, ' seconds.', / )"
!rm   WRITE(UnADopt, Frmt) TRIM( Flt2LStr( T_4D_St ) ), TRIM( Flt2LStr( T_4D_En ) )
!rm   WRITE(UnADopt,'(A)') '  Ubot     - u-component, steady wind speed at the bottom of the wave (m/s) = '//TRIM( Flt2LStr( Ubot     ) )
!rm   WRITE(UnADopt,'(A)') '  DistScal - Disturbance scale (ratio of wave height to rotor diameter)     = '//TRIM( Flt2LStr( DistScal ) )
!rm   WRITE(UnADopt,'(A)') '  Lx       - Downwind location of tower centerline in the dataset           = '//TRIM( Flt2LStr( Lx       ) )
!rm   WRITE(UnADopt,'(A)') '  Ly       - Lateral location of tower centerline in the dataset            = '//TRIM( Flt2LStr( Ly       ) )
!rm   WRITE(UnADopt,'(A)') '  Lz       - Vertical location of tower centerline in the dataset           = '//TRIM( Flt2LStr( Lz       ) )
!rm   WRITE(UnADopt,'(A)') '  ScaleVel - Scaling velocity, U0 (m/s)                                     = '//TRIM( Flt2LStr( ScaleVel ) )
!rm   WRITE(UnADopt,'(A)') '  FD_DF_X  - Decimation factor for wind data in the x direction             = '//TRIM( Int2LStr( FD_DF_X  ) )
!rm   WRITE(UnADopt,'(A)') '  FD_DF_Y  - Decimation factor for wind data in the y direction             = '//TRIM( Int2LStr( FD_DF_Y  ) )
!rm   WRITE(UnADopt,'(A)') '  FD_DF_Z  - Decimation factor for wind data in the z direction             = '//TRIM( Int2LStr( FD_DF_Z  ) )
!rmELSEIF ( UsrWndFlag )  THEN
!rm   WRITE(UnADopt,'(/A)') ' Aerodyn is using a user-defined wind model.'
!rmELSE
!rm   WRITE(UnADopt,'(/A)') ' Hub-height wind file info:'
!rm   WRITE(UnADopt,'(A)') '  Initial horizontal wind speed             = '//TRIM(Flt2LStr(V))//' '//Vel_Unit
!rm!bjj Start of proposed change AeroDyn v12.70
!rm!rm   WRITE(UnADopt,'(A)') '  Initial wind direction                    = '//TRIM(Flt2LStr(REAL( DELTA*RtoD, ReKi )))//' deg'
!rm   WRITE(UnADopt,'(A)') '  Initial wind direction                    = '//TRIM(Flt2LStr(REAL( DELTA*R2D, ReKi )))//' deg'
!rm!bjj End of proposed change AeroDyn v12.70
!rm   WRITE(UnADopt,'(A)') '  Initial vertical wind speed               = '//TRIM(Flt2LStr(VZ))//' '//Vel_Unit
!rm   WRITE(UnADopt,'(A)') '  Initial horiz. wind shear coeff.          = '//TRIM(Flt2LStr(HSHR))
!rm   WRITE(UnADopt,'(A)') '  Initial power law vert. wind shear coeff. = '//TRIM(Flt2LStr(VSHR))
!rm   WRITE(UnADopt,'(A)') '  Initial linear vert. wind shear coeff.    = '//TRIM(Flt2LStr(VLinShr))
!rm   WRITE(UnADopt,'(A)') '  Initial gust wind speed                   = '//TRIM(Flt2LStr(VGUST))//' '//Vel_Unit
!rmENDIF
!bjj end of proposed change v12.70w

!bjj start of remove
!rem!bjj: why is this here?
!remSELECT CASE (TRIM(DynProg))
!rem   CASE ('ADAMS')
!rem      WRITE(UnADopt,'(/A)') ' Number of blades = '//TRIM(Int2LStr(NB))
!rem!bjj Start of proposed change AeroDyn v12.70
!rem!rm      WRITE(UnADopt,'( A)') ' Rotor tilt angle = '//TRIM(Flt2LStr(REAL( TILT*RtoD, ReKi )))//' deg'
!rem!bjj: really, why is this here? does TILT not change with time like in FAST?
!rem      WRITE(UnADopt,'( A)') ' Rotor tilt angle = '//TRIM(Flt2LStr(REAL( TILT*R2D, ReKi )))//' deg'
!rem!bjj End of proposed change AeroDyn v12.70
!remEND SELECT

!rm      WRITE(UnADopt,'(/A)') ' Number of blades = '//TRIM(Int2LStr(NB))

      WRITE(UnADopt,"(/' Rotor radius     = ',F7.3,' m')") R
      WRITE(UnADopt,"( ' Hub radius       = ',F7.3,' m')") HubRad
      WRITE(UnADopt,"( ' Number of blades = ',I3       )") NB
!bjj: end remove

IF ( DSTALL ) CALL BEDWRT

IF ( ELEMPRN ) WRITE(UnADopt,'(/A/)')'Blade element aerodynamic time series data written to file.' !bjj: what? isn't that what "Print? Y/N" is for?

!BJJ start of proposed change
CLOSE (UnADopt )
!bjj end of proposed change


RETURN
END SUBROUTINE ADOut

!bjj start of proposed change
!rm ! ****************************************************
!rm   SUBROUTINE GetVH ( VHMag, VHDir )
!rm !  Returns hub-height horizontal wind speed and
!rm !   direction (in radians).
!rm ! bjj: this subroutine doesn't seem to be used anywhere!
!rm ! ****************************************************
!rm
!rm!bjj start of proposed change v12.70w
!rm!rm!bjj rm: USE                  Precision
!rm!rmUSE                  Wind
!rmUSE                  AeroTime, ONLY: Time
!rmUSE                  Rotor,    ONLY: HH
!rm
!rm!bjj end of proposed change
!rm
!rmIMPLICIT             NONE
!rm
!rm
!rm   ! Passed Variables:
!rm!BJJ Start of proposed change v12.7
!rm!rmREAL(ReKi)        :: VHMag
!rm!rmREAL(ReKi)        :: VHDir
!rmREAL(ReKi),INTENT(OUT) :: VHMag        ! the magnitude of the horizontal (VX & VY) wind speed at X=0,Y=0,Z=HH
!rmREAL(ReKi),INTENT(OUT) :: VHDir        ! the direction of the wind speed (ccw from above) in radians between -pi and pi
!rm!BJJ End of proposed change v12.7
!rm
!rm!bjj start of proposed change v12.70w
!rm!rm   ! Local Variables:
!rm!rm
!rmREAL(ReKi)        :: VNROTOR2 ! Not used here
!rm   ! Local variables
!rmREAL(ReKi)           :: InputPosition(3)
!rmTYPE(InflIntrpOut)   :: InflowVel
!rmINTEGER              :: ErrStat
!rm
!rm!bjj end of proposed change
!rm
!rm
!rm!bjj start of proposed change v12.70w
!rm!rm ! Get the hub-height VX, VY, VZ.
!rm!rmCALL VWrel2G( VNROTOR2, .TRUE. )
!rm!rm
!rm!rmVHMag = SQRT( VX*VX + VY*VY )
!rm!rm!rmVHDir = ATAN2( -VY , VX )
!rm
!rmInputPosition = (/ 0.0, 0.0, HH /)  !the old "AT HUB" location, inside the nacelle
!rmInflowVel = WindInf_GetVelocity( REAL(Time, ReKi), InputPosition, ErrStat)
!rm
!rmIF (ErrStat /=0) CALL ProgAbort( ' Error getting velocity in AeroDyn/GetVH().' )
!rm
!rmVHMag = SQRT( InflowVel%Velocity(1)**2 + InflowVel%Velocity(2)**2 )
!rmVHDir = ATAN2( -1.0*InflowVel%Velocity(2) , InflowVel%Velocity(1) )
!rm
!rm!bjj end of proposed change
!rm
!rm
!rmRETURN
!rmEND SUBROUTINE GetVH
!bjj: this is replaced with AD_GetUndisturbedWind
!rm
!rm ! ****************************************************
!rm   SUBROUTINE GetHubWind ( WindVector )
!rm !  Returns hub-height wind vector in ground coordinates.
!rm ! ****************************************************
!rm
!rm!bjj rm: USE                  Precision
!rm!bjj start of proposed change v12.70w
!rm!rmUSE                  Wind
!rmUSE                  AeroTime, ONLY: Time
!rmUSE                  Rotor,    ONLY: HH
!rm!bjj end of proposed change
!rm
!rm
!rmIMPLICIT             NONE
!rm
!rm
!rm   ! Passed Variables:
!rm!BJJ Start of proposed change v12.7
!rm!rmREAL(ReKi)        :: WindVector(3)
!rmREAL(ReKi),INTENT(OUT)    :: WindVector(3)
!rm!BJJ End of proposed change v12.7
!rm
!rm   ! Local Variables:
!rm
!rm!bjj start of proposed change v12.70w
!rm!bjj rm: REAL(ReKi)        :: VNROTOR2 ! Not used here
!rm
!rmREAL(ReKi)           :: InputPosition(3)
!rmTYPE(InflIntrpOut)   :: InflowVel
!rmINTEGER              :: ErrStat
!rm
!rm!bjj end of proposed change v12.70w
!rm
!rm
!rm!bjj start of proposed change v12.70w
!rm!rm ! Get the hub-height VX, VY, VZ.
!rm!rm ! The .TRUE. gets the hub location values.
!rm!rmCALL VWrel2G( VNROTOR2, .TRUE. )
!rm!rm
!rm!rmWindVector(1) = VX
!rm!rmWindVector(2) = VY
!rm!rmWindVector(3) = VZ
!rm
!rm
!rmInputPosition = (/ 0.0, 0.0, HH /)  !the old "AT HUB" location, inside the nacelle
!rmInflowVel = WindInf_GetVelocity( REAL(Time, ReKi), InputPosition, ErrStat)
!rm
!rm!IF (ErrStat /=0) CALL ProgAbort( ' Error getting velocity in AeroDyn/GetHubWind().' )
!rmIF (ErrStat /=0) CALL ProgWarn( ' Error getting velocity in AeroDyn/GetHubWind().' )
!rm
!rmWindVector(:) = InflowVel%Velocity(:)
!rm
!rm!bjj end of proposed change
!rm
!rm
!rmRETURN
!rmEND SUBROUTINE GetHubWind
!bjj end of proposed change

 ! ****************************************************
   SUBROUTINE READFL
 !  Reads a data file containing airfoil angle of attack,
 !   CL and CD, and dynamic stall parameters
 ! ****************************************************

USE                             AD_IOParams
USE                             Airfoil
USE                             Bedoes
!bjj Start of proposed change v12.70-bjj
!rm USE                             Blade !bjj- NOT USED?
USE                             AeroGenSubs, ONLY: AllocArrays
!bjj End of proposed change
!bjj rm NWTC_Lib:USE                             Constant
!bjj rm: USE                             Precision
USE                             Switch


IMPLICIT                        NONE


   ! Local Variables:

REAL(ReKi), ALLOCATABLE      :: CDNegPI(:)
REAL(ReKi), ALLOCATABLE      :: CDPosPI(:)
REAL(ReKi), ALLOCATABLE      :: CLNegPI(:)
REAL(ReKi), ALLOCATABLE      :: CLPosPI(:)
REAL(ReKi), ALLOCATABLE      :: CMNegPI(:)
REAL(ReKi), ALLOCATABLE      :: CMPosPI(:)

INTEGER(4)                   :: IPHI
INTEGER(4)                   :: I
INTEGER(4)                   :: K
INTEGER                      :: Sttus
INTEGER(4)                   :: NFOILID
INTEGER(4)                   :: NumLines
INTEGER(4)                   :: NUNIT
!rm not used:INTEGER(4)                   :: IERR
INTEGER                      :: IOS

LOGICAL                      :: ALPosPI
LOGICAL                      :: ALNegPI

CHARACTER( 40)               :: TITLE  (2)
!rm not used:CHARACTER(110)               :: MESAGE
!rm not used:CHARACTER(140)               :: Frmt
!bjj start of proposed change
!rmCHARACTER(200)               :: LINE
CHARACTER(1024)              :: LINE
!bjj end of proposed change


   ! Global functions.

!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL      :: Int2LStr                                        ! A function to convert an interger to a left-justified string.



NUNIT    = UnAirfl
NumCL    = 0

 ! The first loop checks existence and file length to set NumCL
DO NFOILID = 1, NUMFOIL

 ! Open the file for reading # of lines
!bjj Start of proposed change v12.70b-bjj
!rm   CALL OpenInputFile (NUNIT, TRIM(Adjustl(FOILNM(NFOILID))), 'FORMATTED')
   CALL OpenFInpFile (NUNIT, TRIM(FOILNM(NFOILID)))
!bjj End of proposed change

 ! Determine the maximum number of aerodata points in all files

   NumLines = 0
   IOS = 0
   DO WHILE (IOS == 0)
      READ ( NUNIT, '()', IOSTAT=IOS )
      NumLines = NumLines + 1
   END DO

   NumCL = MAX(NumLines - 14, NumCL)

   CLOSE (NUNIT)

END DO ! NFOILID

 ! Allocate the arrays

Call AllocArrays ('Aerodata')

 ! The second loop reads the files
DO NFOILID = 1, NUMFOIL

 ! Open the file for reading inputs
!bjj Start of proposed change v12.70b-bjj
!rm   CALL OpenInputFile (NUNIT, TRIM(Adjustl(FOILNM(NFOILID))), 'FORMATTED')
   CALL OpenFInpFile (NUNIT, TRIM(Adjustl(FOILNM(NFOILID))) )
!bjj End of proposed change

 ! Set up the file to read the aerodata
   READ(NUNIT,'( A )') TITLE(1)
   READ(NUNIT,'( A )') TITLE(2)

 ! Read in airfoil table dimension parameters:
 !   NTables = number of airfoil data tables

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , '# of tables' )

   READ(LINE,*,ERR=205) NTables( NFOILID )

 ! Allocate local arrays with NTables dimension

   Sttus = 0
   !BJJ REPLACE: ALLOCATE ( CLPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CLPosPI)) ALLOCATE ( CLPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CLPosPI array.' )

   !BJJ REPLACE: ALLOCATE ( CDPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CDPosPI)) ALLOCATE ( CDPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CDPosPI array.' )

   !BJJ REPLACE: ALLOCATE ( CMPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CMPosPI)) ALLOCATE ( CMPosPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CMPosPI array.' )

   !BJJ REPLACE: ALLOCATE ( CLNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CLNegPI)) ALLOCATE ( CLNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CLNegPI array.' )

   !BJJ REPLACE: ALLOCATE ( CDNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CDNegPI)) ALLOCATE ( CDNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CDNegPI array.' )

   !BJJ REPLACE: ALLOCATE ( CMNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF (.NOT. ALLOCATED(CMNegPI)) ALLOCATE ( CMNegPI(NTables(NFOILID)) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for CMNegPI array.' )


 ! Read in airfoil data table identification array

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'multi-table metric' )
   READ(LINE,*,ERR=205)  (MulTabMet ( NFOILID, K ), K = 1, NTables(NFOILID))

 ! Read in four lines that are no longer used
 ! These are retained for future USE and backwards compatibility only

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , '5th line' )
   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , '6th line' )
   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , '7th line' )
   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , '8th line' )

 ! Read Beddoes stall parameters

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'Angle of zero lift (AOL)' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (AOL( NFOILID, K ), K = 1, NTables(NFOILID))

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'CNA' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (CNA   ( NFOILID, K ), K = 1, NTables(NFOILID))

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'CNS' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (CNS   ( NFOILID, K ), K = 1, NTables(NFOILID))

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'CNSL' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (CNSL  ( NFOILID, K ), K = 1, NTables(NFOILID))

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'AOD' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (AOD   ( NFOILID, K ), K = 1, NTables(NFOILID))

   READ(NUNIT,'( A )',IOSTAT=IOS) LINE
   IF ( IOS < 0 ) CALL PremEOF ( Trim(FOILNM(NFOILID)) , 'CDO' )
   IF (DSTALL) READ(LINE,*,ERR=205)  (CDO   ( NFOILID, K ), K = 1, NTables(NFOILID))

 ! Convert angles to radians
   IF (DSTALL) THEN
!bjj Start of proposed change v12.70
!rm   AOD   ( NFOILID, : ) = AOD( NFOILID, : )*DtoR
!rm   AOL   ( NFOILID, : ) = AOL( NFOILID, : )*DtoR
      AOD   ( NFOILID, : ) = AOD( NFOILID, : )*D2R
      AOL   ( NFOILID, : ) = AOL( NFOILID, : )*D2R
!bjj End of proposed change
   ENDIF


 ! Read airfoil data tables to end of file

   NLIFT(NFOILID) = 0
   ALPosPI = .FALSE.
   ALNegPI = .FALSE.

   DO I = 1, NumCL

      IF ( PMOMENT ) THEN

         READ( NUNIT,*,END=150 ) AL(NFOILID,I), &
             (CL(NFOILID,I,IPHI), CD(NFOILID,I,IPHI), &
              CM(NFOILID,I,IPHI), IPHI = 1, NTables(NFOILID))

      ELSE

         READ( NUNIT,*,END=150 ) AL(NFOILID,I), &
             (CL(NFOILID,I,IPHI), CD(NFOILID,I,IPHI), &
              IPHI = 1, NTables(NFOILID))

         CM(NFOILID,I,:) = 0.

      ENDIF

 ! Check to see if values look reasonable

      DO IPHI = 1, NTables(NFOILID)
        IF ( ABS( AL( NFOILID, I ) ) > 185.) THEN
!bjj start of proposed change
!rm           MESAGE = 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))
!rm           Frmt   = '(A,/,'' Angle of attack exceeds 185 degrees.'')'
!rm           CALL ErrLog( MESAGE, Frmt, 'READFL', 31, 'FAULT' )
           CALL ProgAbort( 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))// &
                           ' Angle of attack exceeds 185 degrees.')
!bjj end of proposed change
        ELSEIF (ABS( CL( NFOILID, I, IPHI ) ) > 3. ) THEN
!bjj start of proposed change
!rm           MESAGE = 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))
!rm           Frmt   = '(A,/,'' Coefficient of Lift exceeds 3.0.'')'
!rm           CALL ErrLog( MESAGE, Frmt, 'READFL', 32, 'FAULT' )
           CALL ProgAbort( 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))// &
                           ' Coefficient of Lift exceeds 3.0.')
!bjj end of proposed change
        ELSEIF (ABS( CD( NFOILID, I, IPHI ) ) > 3. ) THEN
!bjj start of proposed change
!rm           MESAGE = 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))
!rm           Frmt   = '(A,/,'' Coefficient of Drag exceeds 3.0.'')'
!rm           CALL ErrLog( MESAGE, Frmt, 'READFL', 33, 'FAULT' )
           CALL ProgAbort( 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))// &
                           ' Coefficient of Drag exceeds 3.0.')
!bjj end of proposed change
        ELSEIF (ABS( CM( NFOILID, I, IPHI ) ) > 3. ) THEN
!bjj start of proposed change
!rm           MESAGE = 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))
!rm           Frmt   = '(A,/,'' Coefficient of Moment exceeds 3.0.'')'
!rm           CALL ErrLog( MESAGE, Frmt, 'READFL', 34, 'FAULT' )
           CALL ProgAbort( 'Probable error in airfoil data table number '//TRIM(Int2LStr(NFOILID))// &
                           ' Coefficient of Moment exceeds 3.0.')
!bjj end of proposed change
        ENDIF
      ENDDO ! IPHI

 ! Store the values at 180 deg. and -180 deg. for check
      IF ( AL (NFOILID, I ) == 180. ) THEN
         ALPosPI = .TRUE.
         Do IPHI = 1, NTables(NFOILID)
            CLPosPI(IPHI) = CL(NFOILID,I,IPHI)
            CDPosPI(IPHI) = CD(NFOILID,I,IPHI)
            CMPosPI(IPHI) = CM(NFOILID,I,IPHI)
         END Do ! IPHI

      ELSEIF ( AL (NFOILID, I ) == -180. ) THEN
         ALNegPI = .TRUE.
         Do IPHI = 1, NTables(NFOILID)
            CLNegPI(IPHI) = CL(NFOILID,I,IPHI)
            CDNegPI(IPHI) = CD(NFOILID,I,IPHI)
            CMNegPI(IPHI) = CM(NFOILID,I,IPHI)
          END Do ! IPHI
      ENDIF

!bjj Start of proposed change v12.70
!rm      AL ( NFOILID, I ) = AL(NFOILID,I) * DtoR
      AL ( NFOILID, I ) = AL(NFOILID,I) * D2R
!bjj End of proposed change
      NLIFT ( NFOILID ) = NLIFT(NFOILID) + 1

   ENDDO ! I

   150 CLOSE( NUNIT )

 ! Check to see if values at 180 deg. equal those at -180 deg.
   IF (ALPosPI .AND. ALNegPI) THEN
      Do IPHI = 1, NTables(NFOILID)
         IF (CLPosPI(IPHI) /= CLNegPI(IPHI) .OR. &
             CDPosPI(IPHI) /= CDNegPI(IPHI) .OR. &
             CMPosPI(IPHI) /= CMNegPI(IPHI)) THEN
!bjj Start of proposed change v12.70
!rm            MESAGE = '"'//Trim(FOILNM(NFOILID))//'"'
!rm            Frmt   = "(' The airfoil data at +180 deg is different'/ ' from -180 deg in file :', /, 2x, A)"
!rm            CALL ErrLog( MESAGE, Frmt, 'READFL', 35, 'FAULT' )
            CALL ProgAbort( ' The airfoil data at +180 deg is different from -180 deg in file :'//Trim(FOILNM(NFOILID)) )
!bjj End of proposed change
         ENDIF
      END Do ! IPHI
   ENDIF

 ! Deallocate arrays to make them available for the next file
   !BJJ REPLACE: DEALLOCATE ( CLPosPI )
   !BJJ REPLACE: DEALLOCATE ( CDPosPI )
   !BJJ REPLACE: DEALLOCATE ( CMPosPI )
   !BJJ REPLACE: DEALLOCATE ( CLNegPI )
   !BJJ REPLACE: DEALLOCATE ( CDNegPI )
   !BJJ REPLACE: DEALLOCATE ( CMNegPI )

   IF ( ALLOCATED(CLPosPI) ) DEALLOCATE ( CLPosPI )
   IF ( ALLOCATED(CDPosPI) ) DEALLOCATE ( CDPosPI )
   IF ( ALLOCATED(CMPosPI) ) DEALLOCATE ( CMPosPI )
   IF ( ALLOCATED(CLNegPI) ) DEALLOCATE ( CLNegPI )
   IF ( ALLOCATED(CDNegPI) ) DEALLOCATE ( CDNegPI )
   IF ( ALLOCATED(CMNegPI) ) DEALLOCATE ( CMNegPI )


END DO !NUMFOIL
RETURN

!bjj start of proposed change
!
!bjj FIX THIS GOTO!!!!!!!!
!
!rm205 MESAGE = '"'// Trim(LINE)// '"'
!rmFrmt   = '(" Error reading line: ",/,2x,A/," in file :",/,2x, '
!rmWRITE(Frmt(52:135),'(A)')'"'//Trim(FOILNM(NFOILID))//'")'
!rmCALL ErrLog( MESAGE, Frmt, 'READFL', 42, 'FAULT' )
205 CALL ProgAbort( ' Error reading line: "'//TRIM(Line)//'" in file : "'//TRIM(FOILNM(NFOILID))//'"' )
!bjj end of proposed change


RETURN
END SUBROUTINE READFL

!bjj start of proposed change for pjm
!Begin change v12.58pjm-ce
!====================================================================================================
SUBROUTINE READTwr(UnIn, FilName, ErrStat)
! This subroutine reads the tower properties input file, allocating TwrProps variables to do so.
! The tower data file contains radius and Re vs CD data as well as the tower wake constant.
!====================================================================================================

   USE                             TwrProps

   IMPLICIT                        NONE

      ! Passed variables:

   INTEGER,      INTENT(IN)     :: UnIn      ! unit number for tower input file
   CHARACTER(*), INTENT(IN)     :: FilName   ! name of the tower input file
   INTEGER,      INTENT(OUT)    :: ErrStat   ! returns 0 if no errors were encountered; non-zero otherwise


      ! Local Variables:

   INTEGER                      :: I         ! loop counter for rows in the data tables
   INTEGER                      :: J         ! loop counter for columns in the data tables

   CHARACTER(99)                :: Fmt       ! format for printing to an echo file

   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnIn, TRIM(FilName), ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the heading, section 1
   !-------------------------------------------------------------------------------------------------

      ! Read in 2 header/comment lines
   CALL ReadCom( UnIn, FilName, 'Title line 1', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   CALL ReadCom( UnIn, FilName, 'Title line 2', ErrStat )
   IF ( ErrStat /= 0 ) RETURN


      ! Read in number of tower height entries, NTwrHt
   CALL ReadVar( UnIn, FilName, NTwrHt, 'NTwrHt', 'Number of tower stations', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   IF (NTwrHt < 1) THEN
      CALL ProgWarn( 'Number of tower height entries, NTwrHt, must be greater than zero.' )
      ErrStat = 1
      RETURN
   ENDIF

      ! Read in number of tower Reynolds number entries, NTwrRe
   CALL ReadVar( UnIn, FilName, NTwrRe, 'NTwrRe', 'Number of tower Reynolds number rows', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   IF (NTwrRe < 1) THEN
      CALL ProgWarn( 'Number of tower Reynolds number entries, NTwrRe, must be greater than zero.' )
      ErrStat = 1
      RETURN
   ENDIF


      ! Read in number of tower CD entries, NTwrCD
   CALL ReadVar( UnIn, FilName, NTwrCD, 'NTwrCD', 'Number of tower CD columns', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   IF (NTwrCD < 1) THEN
      CALL ProgWarn( 'Number of tower CD entries, NTwrCD, must be greater than zero.' )
      ErrStat = 1
      RETURN
   ENDIF


      ! Read in constant for tower wake model = 0 full potential flow = 0.1 model of Bak et al.
   CALL ReadVar( UnIn, FilName, Tower_Wake_Constant, 'Tower_Wake_Constant', 'Constant for tower wake model', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   ! bjj: should there be a sanity check here, too?

   !-------------------------------------------------------------------------------------------------
   ! Allocate TwrProps arrays with NTwrHt, NTwrRe, and NTwrCD dimensions; these arrays are
   ! read in the next 2 sections of this file.
   !-------------------------------------------------------------------------------------------------

   IF ( .NOT. ALLOCATED( TwrHtFr ) ) THEN
      ALLOCATE ( TwrHtFr(NTwrHt) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn( ' Error allocating memory for TwrHtFr array.' )
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( .NOT. ALLOCATED( TwrWid ) ) THEN
      ALLOCATE ( TwrWid(NTwrHt) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn( ' Error allocating memory for TwrWid array.' )
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( .NOT. ALLOCATED( NTwrCDCol ) ) THEN
      ALLOCATE ( NTwrCDCol(NTwrHt) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn( ' Error allocating memory for NTwrCDCol array.' )
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( .NOT. ALLOCATED( TwrRe ) ) THEN
      ALLOCATE ( TwrRe(NTwrRe) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn( ' Error allocating memory for TwrRe array.' )
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( .NOT. ALLOCATED( TwrCD ) ) THEN
      ALLOCATE ( TwrCD(NTwrRe, NTwrCD) , STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL ProgWarn( ' Error allocating memory for TwrCD array.' )
         ErrStat = 1
         RETURN
      END IF
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Read section 2, DISTRIBUTED TOWER PROPERTIES;
   ! section contains 2 heading lines in addition to NTwrHt rows of data with 3 columns
   !-------------------------------------------------------------------------------------------------
      ! Read in 2 header/comment lines
   CALL ReadCom( UnIn, FilName, 'Distributed Tower Properties header 1', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   CALL ReadCom( UnIn, FilName, 'Distributed Tower Properties header 2', ErrStat )
   IF ( ErrStat /= 0 ) RETURN


      ! Read tower radius data table

   DO I = 1, NTwrHt     ! 1 line per fraction of height


      READ( UnIn,*,IOSTAT=ErrStat ) TwrHtFr(I), TwrWid(I), NTwrCDCol(I)

      IF ( ErrStat == 0 ) THEN
         IF ( Echo ) THEN
            WRITE (UnEc,'(2X,ES11.4e2, 2X,ES11.4e2, 2X,I11)')  TwrHtFr(I), TwrWid(I), NTwrCDCol(I)
         END IF
      ELSE IF ( ErrStat < 0 ) THEN
         CALL ProgWarn( ' Premature end of file while reading line '//TRIM(Int2Lstr(I))// &
                     ' of the distributed tower properties in file "'//TRIM(FilName)//'."' )
         RETURN
      ELSE
         CALL ProgWarn( ' Error reading line '//TRIM(Int2Lstr(I))// &
                     ' of the distributed tower properties in file "'//TRIM(FilName)//'."' )
         RETURN
      END IF


      !..............................................................................................
      ! Check to see if values look reasonable
      !..............................................................................................

         ! Make sure tower height fractions are between 0 and 1
      IF ( TwrHtFr( I ) < 0.0 .OR. TwrHtFr( I ) > 1.0 ) THEN
         CALL ProgWarn( ' Error on line '//TRIM(Int2Lstr(I))//' of the distributed tower properties in file "' &
                           //TRIM(FilName)//'." Tower height fractions must be between 0.0 and 1.0.' )
         ErrStat = 1
         RETURN
      END IF


         ! Make sure the tower height increases for each entry
      IF (I > 1) THEN
         IF (TwrHtFr(I) <= TwrHtFr(I-1)) THEN
            CALL ProgWarn( ' Error on line '//TRIM(Int2Lstr(I))//' of the distributed tower properties in file "' &
                           //TRIM(FilName)//'." Tower height fraction entries must be in order of increasing height.' )
            ErrStat = 1
            RETURN
         ENDIF
      ENDIF

         ! Make sure tower width is positive
      IF ( TwrWid( I ) <= 0.0 ) THEN
         CALL ProgWarn( ' Error on line '//TRIM(Int2Lstr(I))//' of the distributed tower properties in file "' &
                           //TRIM(FilName)//'." Tower width must be positive.' )
         ErrStat = 1
         RETURN
      ENDIF

         ! Make sure the tower CD column is within range
      IF ( NTwrCDCol(I) < 1 .OR. NTwrCDCol(I) > NTwrCD ) THEN
         CALL ProgWarn( ' Error on line '//TRIM(Int2Lstr(I))//' of the distributed tower properties in file "' &
                           //TRIM(FilName)//'." Tower height CD column must be between 1 and '//TRIM(Int2Lstr(NTwrCD))//'.' )
         ErrStat = 1
         RETURN
      END IF

   END DO ! I

   !-------------------------------------------------------------------------------------------------
   ! Read section 3, Re vs CD PROPERTIES;
   ! this section has 2 header lines plus NTwrRe rows of data with NTwrCD+1 columns
   !-------------------------------------------------------------------------------------------------

      ! Read in 2 header/comment lines
   CALL ReadCom( UnIn, FilName, 'Re vs CD Properties header 1', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   CALL ReadCom( UnIn, FilName, 'Re vs CD Properties header 2', ErrStat )
   IF ( ErrStat /= 0 ) RETURN

   Fmt = '('//TRIM(Int2Lstr(NTwrCD+1))//'(2X,ES11.4e2))'

   DO I = 1, NTwrRe

      READ( UnIn,*,IOSTAT=ErrStat ) TwrRe(I), (TwrCD(I,J), J = 1, NTwrCD)

      IF ( ErrStat == 0 ) THEN
         IF ( Echo ) THEN
            WRITE (UnEc,Fmt)  TwrRe(I), (TwrCD(I,J), J = 1, NTwrCD)
         END IF
      ELSE IF ( ErrStat < 0 ) THEN
         CALL ProgWarn( ' Premature end of file while reading line '//TRIM(Int2Lstr(I))// &
                     ' of the tower Re vs CD properties in file "'//TRIM(FilName)//'."' )
         RETURN
      ELSE
         CALL ProgWarn( ' Error reading line '//TRIM(Int2Lstr(I))// &
                     ' of the tower Re vs CD properties in file "'//TRIM(FilName)//'."' )
         RETURN
      END IF

   END DO ! I

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------

   CLOSE( UnIn )

   RETURN

END SUBROUTINE READTwr
!End change v12.58pjm-ce
!====================================================================================================
!bjj end of proposed change for pjm


! Dynamics Program aerodynamics force interface gateway
!bjj start of proposed change
! ! **********************************************
!!bjj Start of proposed change v12.70
!!rm   SUBROUTINE AeroFrcIntrface( FirstLoop, JElem, DFN, DFT, PMA )
!!bjj test if the argument is the same as the value in Element
!   SUBROUTINE AeroFrcIntrface( FirstLoop, JElemt, DFN, DFT, PMA )
!!bjj End of propsoed change
! !  calculates the forces and moments for
! !   the blade at azimuth angle psi.
! !  FirstLoop = Logical passed in by ADAMS for USE in ELEMFRC
! !  JElem     = The current element number
! !  PSI       = the current azimuth angle where 0 = down (radians)
! ! returned values are forces in BLADE COORDINATE SYSTEM:
! !  DFN = Normal aero force on the element (+ toward suction side)
! !  DFT = Tangential aero force on the element (+ toward leading edge)
! !  PMA = Aero pitching moment (+ causes pitch toward stall)
! ! **********************************************
!
!!bjj rm: USE                           Precision
!USE                           Switch
!
!!BJJ Start of proposed change v12.7
!!for testing only:
!USE                           Element, ONLY: JElem
!!BJJ End of proposed change v12.7
!
!
!IMPLICIT                      NONE
!
!
!   ! Passed Variables:
!!BJJ Start of proposed change v12.7
!!rmREAL(ReKi)                 :: DFN
!!rmREAL(ReKi)                 :: DFT
!!rmREAL(ReKi)                 :: PMA
!!rm
!!rmINTEGER(4)                 :: JElem
!!rm
!!rmLOGICAL(1)                 :: FirstLoop
!REAL(ReKi),INTENT(OUT)     :: DFN
!REAL(ReKi),INTENT(OUT)     :: DFT
!REAL(ReKi),INTENT(OUT)     :: PMA
!INTEGER(4),INTENT(IN)      :: JElemt
!LOGICAL,   INTENT(IN)      :: FirstLoop
!!BJJ End of proposed change v12.7
!
!
!   ! Local Variables:
!
!REAL(ReKi)                 :: PSI
!REAL(ReKi)                 :: RLOCAL
!REAL(ReKi)                 :: VNB
!REAL(ReKi)                 :: VNROTOR2
!REAL(ReKi)                 :: VNW
!REAL(ReKi)                 :: VT
!
!
!!BJJ: GetVel() uses JElem from ELEMENT, not the value passed to AeroFrcIntrFace.  Where does it get set?
!!BJJ Start of proposed change v12.7
!!if (.not. JElem==JElemt ) then
!!    print *, JElemt, JElem
!!endif
!!bjj End of proposed change
!
! ! GetVel: PSI, RLOCAL are passed in; VNROTOR2, VNW, VNB and VT returned
!
!CALL GetVel (PSI, RLOCAL, VNROTOR2, VNW, VNB, VT)
!
! ! Get blade element forces and induced velocity
!!bjj Start of proposed change v12.70
!!rmCALL ELEMFRC( PSI, RLOCAL, JElem, VNROTOR2, VT, VNW, VNB,  &
!!rm              DFN, DFT, PMA, FirstLoop )
!CALL ELEMFRC( PSI, RLOCAL, JElemt, VNROTOR2, VT, VNW, VNB, DFN, DFT, PMA, FirstLoop )
!!bjj End of proposed change v12.70
!
!IF ( DYNINFL .OR. DYNINIT ) THEN
! ! Set up dynamic inflow parameters
!!bjj Start of proposed change v12.70
!!rm   CALL GetRM (rLocal, DFN, DFT, PSI, JElem)
!   CALL GetRM (rLocal, DFN, DFT, PSI, JElemt)
!!bjj End of proposed change v12.70
!ENDIF
!
!
!
!RETURN
!END SUBROUTINE AeroFrcIntrface
!
!bjj end of proposed change

!bjj start of proposed change
!rm ! **********************************************************
!rm   SUBROUTINE GetVel (PSI, RLOCAL, VNROTOR2, VNW, VNEl, VT)
!rm !  calculates velocity values
!rm !   PSI, RLOCAL are passed in            !BJJ: - not true;
!rm !   VNROTOR2, VNW, VNEl and VT returned
!rm ! **********************************************************
!rm
!rmUSE                           Airfoil ! for MulTabLoc
!rmUSE                           Blade
!rmUSE                           Element
!rm!bjj Start of proposed change v12.70
!rm!rmUSE                           FF_Wind !bjj Not used?
!rm!bjj End of proposed change
!rm!bjj rm: USE                           Precision
!rmUSE                           Wind
!rm!bjj rmUSE                           Identify ! for DynProg
!rm
!rm
!rmIMPLICIT                      NONE
!rm
!rm
!rm   ! Passed Variables:
!rm!bjj Start of proposed change v12.70
!rm!rmREAL(ReKi)                 :: PSI
!rm!rmREAL(ReKi)                 :: RLOCAL
!rm!rmREAL(ReKi)                 :: VNEl
!rm!rmREAL(ReKi)                 :: VNROTOR2
!rm!rmREAL(ReKi)                 :: VNW
!rm!rmREAL(ReKi)                 :: VT
!rmREAL(ReKi),INTENT(OUT)     :: PSI                  ! BJJ???
!rmREAL(ReKi),INTENT(OUT)     :: RLOCAL
!rmREAL(ReKi),INTENT(OUT)     :: VNEl
!rmREAL(ReKi),INTENT(OUT)     :: VNROTOR2
!rmREAL(ReKi),INTENT(OUT)     :: VNW
!rmREAL(ReKi),INTENT(OUT)     :: VT
!rm!bjj End of proposed change v12.70
!rm
!rm!bjj start of proposed change v13.00b
!rmREAL(ReKi)                 :: PositionVec(3)
!rmREAL(ReKi)                 :: VelocityVec(3)
!rm!bjj end of proposed change
!rm
!rm
!rm!bjj start of proposed change
!rm!rmSELECT CASE (TRIM(DynProg))
!rm!rm   CASE ('NONE') ! in case we ever encounter a code that works backwards
!rm!rm
!rm!rm    IF (JElem == NELM) THEN ! Blade dependent calculations
!rm!rm
!rm!rm       IF (IBLADE == NB ) THEN ! Rotor dependent calculations
!rm!rm    ! At blade NB, element NELM it is a new time step in FAST
!rm!rm    !  NewTime initializes stuff for a new time step.
!rm!rm    !   NOTE: it calls GetRotorParams in the dynamics code to provide
!rm!rm    !         rotor status information.
!rm!rm!rm          CALL NewTime
!rm!rm       ENDIF ! IBlade = NB - Rotor dependent calcs
!rm!rm
!rm!rm    ! Most programs USE this call to get the azimuth angle.  YawDyn sends it there.
!rm!rm!rm    !  PSI = azimuth angle measured from 0 down, positive clockwise looking downwind[rad]
!rm!rm       CALL GetBladeParams (PSI)
!rm!rm
!rm!rm    ENDIF ! JElem = 1 - Blade dependent calcs
!rm!rm
!rm!rm   CASE DEFAULT
!rm!bjj end of proposed change
!rm
!rm    IF (JElem == 1) THEN ! Blade dependent calculations
!rm
!rm       IF (IBLADE == 1 ) THEN ! Rotor dependent calculations
!rm    ! At blade 1, element 1 it is a new time step
!rm    !  NewTime initializes stuff for a new time step.
!rm    !   NOTE: it calls GetRotorParams in the dynamics code to provide
!rm    !         rotor status information.
!rm          CALL NewTime
!rm       ENDIF ! IBlade = 1 - Rotor dependent calcs
!rm
!rm    ! Most programs USE this call to get the azimuth angle.  YawDyn sends it there.
!rm    !  PSI = azimuth angle measured from 0 down, positive clockwise looking downwind[rad]
!rm       CALL GetBladeParams (PSI)
!rm
!rm    ENDIF ! JElem = 1 - Blade dependent calcs
!rm
!rm!bjj start of proposed change
!rm!rmEND SELECT
!rm!bjj end of proposed change
!rm
!rm ! ElemParams returns MulTabLoc, PITNOW, RLocal, and X, Y and Zgrnd
!rm !  MulTabLoc = anything you want it to be
!rm !  PITNOW    = element pitch angle relative to plane of rotation
!rm !              + leading edge into wind [rad]
!rm !  RLOCAL    = local element radius measured as perpendicular distance
!rm !              from axis of rotation to element aerodynamic reference point [m or ft]
!rm !  X/Y/ZGRND = Element location relative to the undeflected hub height in ground
!rm !              coordinate system at tower base (X downwind, Z vertical, Y lateral) [m or ft]
!rm!bjj start of proposed change v13.00b
!rm!rmCALL GetElemParams (MulTabLoc, PITNOW, RLOCAL, XGRND, YGRND, ZGRND)
!rmCALL GetElemParams (MulTabLoc, PITNOW, RLOCAL, PositionVec(:) )
!rm!bjj end of proposed change v13.00b
!rm
!rm ! Get velocities relative to blade element
!rm
!rm ! Get wind velocity components, apply tower shadow and shear,
!rm !  read turbulence files if desired
!rm!bjj start of proposed change v12.70w
!rm!rmCALL VWrel2G ( VNROTOR2, .FALSE. ) ! Formerly VEL
!rm!CALL VWrel2G ( PositionVec(:), VNROTOR2 ) ! Formerly VEL
!rm!VelocityVec(:) = AD_WindVelocityWithDisturbance( PositionVec(:), VNRotor2 )
!rmVelocityVec(:) = AD_WindVelocityWithDisturbance( PositionVec(:) )
!rm!VNRotor2 = ( VelocityVec(3) * STilt + (VelocityVec(1) * CYaw - VelocityVec(2) * SYaw) * CTilt )**2
!rm
!rm!bjj end of proposed change v12.70w
!rm
!rm
!rm ! Get normal and tangential velocity components from dynamics code
!rm !  treat wind and blade motions separately
!rm ! VNVT
!rm !  send
!rm !   VX, VY, VZ = wind component velocities in ground coordinate system
!rm !  returns wind components in the blade reference frame:
!rm !   VT   = Total tangential (to plane of rotation) wind velocity
!rm !          due to wind and blade motion [mps or fps]
!rm !   VNW  = Normal (to local blade span) wind velocity [mps or fps]
!rm !   VNEl = Normal (to local blade span) element velocity [mps or fps]
!rm!bjj start of proposed change v13.00c
!rm!rmCALL GetVNVT (VX, VY, VZ, VT, VNW, VNEl)
!rmCALL GetVNVT (VelocityVec(1), VelocityVec(2), VelocityVec(3), VT, VNW, VNEl)
!rm
!rmVX = VelocityVec(1)     ! save for printing in a file later
!rmVY = VelocityVec(2)
!rmVZ = VelocityVec(3)
!rm!bjj end of proposed change v13.00c
!rm
!rm
!rm
!rmRETURN
!rmEND SUBROUTINE GetVel
!bjj end of proposed change
!bjj start of proposed change
! ! **************************************
!   SUBROUTINE NEWTIME
!
! !  used to update several variables at a new time step
! !  Calls GetRotorParams which must be in the dynamics
! !   routines with 4 arguments to be returned in this order:
! !   1  REVS   - rotor speed [rad/sec]
! !   2  YawAng - nacelle yaw angle (+ clockwise from above) [rad]
! !   3  YawVel - hub velocity due solely to yaw rate (yaw rate * rotor sling) [m/sec]
! !               positive yaw rate (+ cw from above) leads to positive YawVel
! !   4  Tilt   - tilt angle of the rotor shaft to the horizontal plane [rad]
! !               (+ tilt lowers the upwind end of the nacelle)
! ! **************************************
!
!USE               Blade
!!bjj Start of proposed change v12.70a
!!rmUSE               Element !bjj:not used?
!!bjj End of proposed change
!!bjj rm:USE               Identify
!USE               InducedVel
!USE               Switch
!USE               Rotor
!
!
!IMPLICIT          NONE
!
!
!
! ! Initialize variables at start of new time step
! ! Get the rotor status (Rot speed, Yaw Ang, Hub vel due to yaw, and tilt ang).
!CALL GetRotorParams (REVS, YawAng, YAWVEL, TILT)
!
! ! Yaw Angle
!SYaw  = SIN( YawAng )
!CYaw  = COS( YawAng )
!
!!bjj start of proposed change
!!rmSELECT CASE (TRIM(DynProg))
!!rm   CASE ('YawDyn')! Tilt does not change in YawDyn
!!rm   CASE DEFAULT ! Tilt can change in other programs
!!bjj end of proposed change
!      CTILT  = COS ( TILT )
!      STILT  = SIN ( TILT )
!!bjj start of proposed change
!!rmEND SELECT
!!bjj end of proposed change
!
!!bjj start of proposed change v12.70w
!!rmIF ( HHWindFlag ) CALL GetHHWind
!!bjj end of proposed change v12.70w
!
!
! ! Compute average inflow from the previous time step
!!bjj start of proposed change. v13.00b
!!bjj I'm tired of looking at this:
!!rmAVGINFL = 0.0
!!rm
!!rmAVGINFL = SumInfl
!!rm
!!rmAVGINFL = AVGINFL * 2.0/R/R/B
!AVGINFL = SumInfl * 2.0 / (R*R*NB)
!!bjj end of proposed change
!
!SumInfl = 0.0
!
!CALL DiskVel ! Formerly VELD and GETSKEW
!
!IF (DSTALL) CALL BedUpdate
!
! ! Enter the dynamic inflow routines here
!IF ( Wake )  CALL Inflow
!
!
!
!RETURN
!END SUBROUTINE NEWTIME
!bjj end of proposed change
 ! ************************************************
!bjj start of proposed change
!rm   SUBROUTINE ELEMFRC (PSI, RLOCAL, J, VNROTOR2, VT, VNW, &
!rm                       VNB, DFN, DFT, PMA, Initial)
   SUBROUTINE ELEMFRC (PSI, RLOCAL, J, IBlade, VNROTOR2, VT, VNW, &
                       VNB, DFN, DFT, PMA, Initial)
!bjj end of proposed change
 !  calculates the aerodynamic forces on one
 !  blade element.  Inputs include all velocities.
 !  Normal and tangential forces and 'A' are returned.
 ! ************************************************

!bjj start of proposed change v12.70
!rm USE                           AeroTime !bjj not used?
!bjj end of proposed change
USE                           Airfoil
USE                           ElOutParams
USE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
USE                           Element
USE                           ElemInflow
USE                           InducedVel
!bjj rm: USE                           Precision
USE                           Rotor
USE                           Switch
USE                           Wind
!bjj start of proposed change v12.70
!rm USE                           DynInflow !bjj not used? only for DJL?
!bjj end of proposed change

IMPLICIT                      NONE


   ! Passed Variables:
!bjj start of proposed change v12.70
!rmREAL(ReKi)                 :: DFN
!rmREAL(ReKi)                 :: DFT
!rmREAL(ReKi)                 :: PMA
!rmREAL(ReKi)                 :: PSI
!rmREAL(ReKi)                 :: RLOCAL
!rmREAL(ReKi)                 :: VNB
!rmREAL(ReKi)                 :: VNROTOR2
!rmREAL(ReKi)                 :: VNW
!rmREAL(ReKi)                 :: VT
!rm
!rmINTEGER(4)                 :: J
!rm
!rmLOGICAL(1)                 :: Initial

REAL(ReKi),INTENT(OUT)     :: DFN
REAL(ReKi),INTENT(OUT)     :: DFT
REAL(ReKi),INTENT(OUT)     :: PMA
REAL(ReKi),INTENT(IN)      :: PSI
REAL(ReKi),INTENT(IN)      :: RLOCAL
REAL(ReKi),INTENT(IN)      :: VNB
REAL(ReKi),INTENT(IN)      :: VNROTOR2
REAL(ReKi),INTENT(IN)      :: VNW
REAL(ReKi),INTENT(INOUT)   :: VT

INTEGER, INTENT(IN)        :: J
INTEGER, INTENT(IN)        :: IBlade

LOGICAL,   INTENT(IN)      :: Initial
!bjj End of proposed change

   ! Local Variables:

!bjj start of proposed change v13.00b
!bjj these variables don't do anything
!rmREAL(ReKi)                 :: A2
!rmREAL(ReKi)                 :: A2P
INTEGER                    :: ErrStat
!bjj end of proposed change v13.00b
REAL(ReKi)                 :: CDA
REAL(ReKi)                 :: CLA
REAL(ReKi)                 :: CMA
REAL(ReKi)                 :: CPHI
REAL(ReKi)                 :: PHI
REAL(ReKi)                 :: QA
REAL(ReKi)                 :: ReNum
REAL(ReKi)                 :: SPHI
REAL(ReKi)                 :: Vinduced
REAL(ReKi)                 :: VN

!DJL Start of proposed change (commented out for release)
!DJL LOGICAL(1)                 :: DYN ! Flag used in debugging dyn-equil switch
!DJL LOGICAL(1)                 :: FirstPass = .TRUE.  ! Flag to indicate the first pass
!DJL LOGICAL(1)                 :: DYNwait   = .FALSE. ! Flag to wait for GDW reactivation

!DJL REAL(ReKi)                 :: SwitchTime = 0.0 ! The last time the GDW was switched on or off
!DJL REAL(ReKi)                 :: Dyn_WT     = 0.0 ! The last time we passed GDW on threshold

!DJL CHARACTER( 15)             :: Flt2LStr
!DJL CHARACTER(100)             :: MESAGE

!DJL SAVE ! We need to save values for the next time


! Inititalize the DYN flag
!DJL IF (FirstPass) THEN
!DJL    DYN = DYNINIT ! USE DYNINIT because DYNINFLOW may be FALSE on initialization
!DJL    FirstPass = .FALSE.
!DJL ENDIF
!DJL END of proposed change


 !-mlb  Check for being at the center of rotation.
 ! If we are at the center of rotation, the induction equations
 !  are undefined, so let's just USE zeros.


IF ( RLOCAL < 0.01 )  THEN
!bjj start of proposed change v13.00b
!rm   A2  = 0.0
!rm   A2P = 0.0
!bjj end of proposed change v13.00b
   A (J,IBLADE) = 0.0
   AP(J,IBLADE) = 0.0
ELSEIF( DYNINFL .AND. R * REVS < 2.0 )  THEN   !ACH 3/10/03 This block deals with dyn. inflow problems at low tip speed
!bjj start of proposed change v13.00b
!rm   A2  = 0.0
!rm   A2P = 0.0
!bjj end of proposed change v13.00b
   A (J,IBLADE) = 0.0
   AP(J,IBLADE) = 0.0
   DYNINIT = .TRUE.    !Re-initialize if we begin using dynamic inflow again
ELSE

 ! Turn wake off when using dynamic inflow and tip speed goes low.  Wake will remain off.
! Eliminated with the addtion of the ELSEIF above - ACH 3/10/03
!   IF( WAKE .AND. DYNINFL .AND. (TIME > 20D0) .AND. (R * REVS < 5.0) ) THEN
!      WAKE = .FALSE.
!      WRITE(*,*) 'Wake turned off because tip speed < 5'
!   ENDIF

 ! Get induction factor = A using static airfoil coefficients
   IF ( WAKE .AND. .NOT. Initial) THEN

!DJL Start of proposed change (commented out in release version)
!DJL Testing of possible fix to GDW problem at low wind speed - 05/30/03
!DJL       IF ( DYNINFL .AND. DYN) THEN ! The GDW routines are active

!DJL          IF ( TotalInf <= 0.1 ) THEN ! Deactivate GDW
!DJL             MESAGE = " TotalInf has dropped below 0.1; GDW is being turned off. Time = " &
!DJL                      //Flt2LStr(REAL(TIME, ReKi))
!DJL             CALL ErrLog ( MESAGE, '(A)', 'ELEMFRC', 301, 'WARN' )
!DJL        DYN = .FALSE.
!DJL             SwitchTime = REAL(TIME, ReKi)
!DJL          ENDIF

!DJL       ELSEIF ( DYNINFL .AND. .NOT. DYN ) THEN ! GDW inactivated

!DJL          IF ( TotalInf >= 0.1 ) THEN ! Passed threshold

!DJL             IF ( TIME - SwitchTime > 5.0 .AND. .NOT. DYNwait) THEN ! 5 seconds elapsed since last trigger - prepare to reactivate
!DJL                DYNwait = .TRUE.
!DJL                DYN_WT  = REAL(TIME, ReKi)
!DJL             ENDIF

!DJL          ELSE

!DJL             IF (DYNwait) DYNwait = .FALSE. ! dropped below threshold - no activation of GDW

!DJL          ENDIF
!DJL       ENDIF

!DJL       IF (DYNwait .AND. TIME - DYN_WT > 0.1) THEN ! Activate GDW
!DJL          MESAGE = " TotalInf has returned above 0.1; GDW is being turned on. Time = " &
!DJL                  //Flt2LStr(REAL(TIME, ReKi))
!DJL          CALL ErrLog ( MESAGE, '(A)', 'ELEMFRC', 302, 'WARN' )
!DJL          DYNwait = .FALSE.
!DJL          DYN = .TRUE.
!DJL          SwitchTime = REAL(TIME, ReKi)
!DJL       ENDIF

      IF ( DYNINFL ) THEN
!DJL USE statement below in place of above IF - Not yet ready for prime-time (commented out for release)
!DJL      IF ( DYN ) THEN
!DJL End of proposed change

 !       USE dynamic inflow model to find A
!bjj start of proposed change
!rm         CALL VINDINF( J, RLOCAL, VNW, VNB, VT, PSI ) !possibly changes VT
         CALL VINDINF( J, IBlade, RLOCAL, VNW, VNB, VT, PSI ) !possibly changes VT
!bjj end of proposed change
      ELSE
 !       USE momentum balance to find A
!bjj start of proposed change
!rm         CALL VIND( J, RLOCAL, VNROTOR2, VNW, VNB, VT )  !changes VT
         CALL VIND( J, IBlade, RLOCAL, VNROTOR2, VNW, VNB, VT )  !changes VT
!bjj end of proposed change
 !       Apply skewed-wake correction, if applicable
!bjj start of proposed change
!rm         IF( SKEW ) CALL VNMOD( J, RLOCAL, PSI )
         IF( SKEW ) CALL VNMOD( J, IBlade, RLOCAL, PSI )
!bjj end of proposee change
      ENDIF
   ELSE
 !    Ignore the wake calculation entirely
      A (J,IBLADE) = 0.0
      AP(J,IBLADE) = 0.0
   ENDIF

ENDIF

Vinduced = VNW  * A(J,IBLADE)
VN = VNW + VNB - Vinduced

SumInfl = SumInfl + Vinduced * RLOCAL * DR(J)

 ! Get the angle of attack

PHI   = ATAN2( VN, VT )
!bjj start of proposed change
!rmALPHA = PHI - PITNOW
!rm
!rmCALL MPI2PI ( ALPHA )
!rm
!rmW2    = VN * VN + VT * VT

ALPHA(J,IBlade) = PHI - PITNOW

CALL MPI2PI ( ALPHA(J,IBlade) )

W2(J,IBlade) = VN * VN + VT * VT
!bjj end of proposed change

 ! Get the Reynold's number for the element
 !  Returns Reynold's number x 10^6    !bjj: Reynold's number x 10^-6 ?
!bjj start of proposed change
!rmCALL GetReynolds( W2, C(J), RHO, KinVisc, ReNum )
ReNum = GetReynolds( SQRT(W2(J,IBlade)), C(J) )
!bjj end of proposed change
IF (Reynolds) MulTabLoc = ReNum

 ! Get lift coefficient from dynamic stall routine if desired
 !  note that the induced velocity was calculated
 !  using the static CL, not the dynamic CL

IF ( DSTALL ) THEN
 ! USE BEDDOES dynamic stall model
   IF (Initial) THEN ! USE static data on first pass
!BJJ START OF PROPOSED CHANGE
!rm      CALL BEDINIT (J, ALPHA)
!rm   CALL CLCD( ALPHA, CLA, CDA, CMA, J )
      CALL BEDINIT (J, IBlade, ALPHA(J,IBlade))
      CALL CLCD( ALPHA(J,IBlade), CLA, CDA, CMA, NFOIL(J), ErrStat )
!BJJ end of proposed change
   ELSE
!BJJ START OF PROPOSED CHANGE
!rm      CALL BEDDOES( W2, J, ALPHA, CLA, CDA, CMA)
      CALL BEDDOES( W2(J,IBlade), J, IBlade, ALPHA(J,IBlade), CLA, CDA, CMA)
!BJJ end of proposed change
   ENDIF
ELSE
 ! Don't USE dynamic stall model
!BJJ START OF PROPOSED CHANGE
!rm   CALL CLCD( ALPHA, CLA, CDA, CMA, J )
   CALL CLCD( ALPHA(J,IBlade), CLA, CDA, CMA, NFOIL(J), ErrStat )
!BJJ end OF PROPOSED CHANGE
ENDIF

!bjj start of proposed change
!rmQA       = 0.5 * RHO * W2 * DR(J) * C(J)
QA       = 0.5 * RHO * W2(J,IBlade) * DR(J) * C(J)
!bjj end of proposed change
CPHI     = COS( PHI )
SPHI     = SIN( PHI )
DFN      = ( CLA * CPHI + CDA * SPHI ) * QA
DFT      = ( CLA * SPHI - CDA * CPHI ) * QA

IF ( PMOMENT ) THEN
   PMA  = CMA * QA * C(J)
ELSE
   PMA  = 0.
   CMA  = 0.
ENDIF


 ! Save values at appropriate station

IF ( IBLADE == 1 ) THEN
   IF ( ElPrList(J) > 0 )  THEN
      AAA    ( ElPrList(J) )    = A (J,IBLADE)
      AAP    ( ElPrList(J) )    = AP(J,IBLADE)
!bjj Start of proposed change AeroDyn v12.70
!rm      ALF    ( ElPrList(J) )    = ALPHA * RtoD
      ALF    ( ElPrList(J) )    = ALPHA(J,IBlade) * R2D
!bjj End of proposed change AeroDyn v12.70
      CDD    ( ElPrList(J) )    = CDA
      CLL    ( ElPrList(J) )    = CLA
      CMM    ( ElPrList(J) )    = CMA
!bjj start of proposed change
!rm      CNN    ( ElPrList(J) )    = CLA * COS(ALPHA) + CDA * SIN(ALPHA)
!rm      CTT    ( ElPrList(J) )    =-CDA * COS(ALPHA) + CLA * SIN(ALPHA)
      CNN    ( ElPrList(J) )    = CLA * COS(ALPHA(J,IBlade)) + CDA * SIN(ALPHA(J,IBlade))
      CTT    ( ElPrList(J) )    =-CDA * COS(ALPHA(J,IBlade)) + CLA * SIN(ALPHA(J,IBlade))
!bjj end of proposed change
      DFNSAV ( ElPrList(J) )    = DFN
      DFTSAV ( ElPrList(J) )    = DFT
!BJJ START OF PROPOSED CHANGE
!RM      DynPres( ElPrList(J) )    = 0.5 * RHO * W2
      DynPres( ElPrList(J) )    = 0.5 * RHO * W2(J,IBlade)
!BJJ END OF PROPOSED CHANGE
!bjj Start of proposed change AeroDyn v12.70
!rm      PITSAV ( ElPrList(J) )    = PITNOW * RtoD
      PITSAV ( ElPrList(J) )    = PITNOW * R2D
!bjj End of proposed change AeroDyn v12.70
      PMM    ( ElPrList(J) )    = PMA
      ReyNum ( ElPrList(J) )    = ReNum
   ENDIF

!bjj rm with new AD_CalculateLoads:
!rm   IF ( J == NELM .AND. ELEMPRN ) THEN
!rm      VXSAV  = VX
!rm      VYSAV  = VY
!rm      VZSAV  = VZ
!rm   ENDIF
!bjj end rm
ENDIF

!bjj rm with new AD_CalculateLoads:
!rmIF ( WndElPrList(J) > 0 ) THEN
!rm    SaveVX( WndElPrList(J), IBlade ) = VX
!rm    SaveVY( WndElPrList(J), IBlade ) = VY
!rm    SaveVZ( WndElPrList(J), IBlade ) = VZ
!rmENDIF
!bjj end rm with new AD_CalculateLoads:


RETURN
END SUBROUTINE ELEMFRC

!======================================================

 ! ***************************************************
!bjj start of proposed change
!rm   SUBROUTINE VIND( J, RLOCAL, VNROTOR2, VNW, VNB, VT )
   SUBROUTINE VIND( J, IBlade, RLOCAL, VNROTOR2, VNW, VNB, VT )
!bjj end of proposed change
 !  calculates the axial induction factor for each
 !  annular segment and time step.
 ! ***************************************************

USE                              Blade
!bjj rm NWTC_Lib:USE                              Constant
USE                              Element
USE                              InducedVel
!bjj rm: USE                              Precision


IMPLICIT                         NONE


   ! Passed Variables:
!bjj Start of proposed change v12.7
!rmREAL(ReKi)                    :: RLOCAL
!rmREAL(ReKi)                    :: VNB
!rmREAL(ReKi)                    :: VNROTOR2
!rmREAL(ReKi)                    :: VNW
!rmREAL(ReKi)                    :: VT
!rm
!rmINTEGER(4)                    :: J
REAL(ReKi),INTENT(IN)         :: RLOCAL
REAL(ReKi),INTENT(IN)         :: VNB
REAL(ReKi),INTENT(IN)         :: VNROTOR2
REAL(ReKi),INTENT(IN)         :: VNW
REAL(ReKi),INTENT(INOUT)      :: VT

INTEGER, INTENT(IN)           :: J
INTEGER, INTENT(IN)           :: IBlade
!bjj End of proposed change

   ! Local Variables:

REAL(ReKi)                    :: A2
REAL(ReKi)                    :: A2P
REAL(ReKi)                    :: AI
REAL(ReKi)                    :: ALPHA
REAL(ReKi)                    :: ASTEP
REAL(ReKi)                    :: ATOLER2
REAL(ReKi)                    :: ATOLERBY10
REAL(ReKi)                    :: CDA
REAL(ReKi)                    :: CLA
REAL(ReKi)                    :: CMA
REAL(ReKi)                    :: DAI
REAL(ReKi)                    :: DAI1
REAL(ReKi)                    :: DELAI
REAL(ReKi)                    :: PHI
REAL(ReKi), ALLOCATABLE, SAVE :: OLD_A_NS  ( :, : )
REAL(ReKi), ALLOCATABLE, SAVE :: OLD_AP_NS ( :, : )
REAL(ReKi)                    :: SOLFACT
REAL(ReKi)                    :: VNA
REAL(ReKi)                    :: VT2_Inv
REAL(ReKi)                    :: VTA

!rm not used:INTEGER(4)                    :: IANSWER
INTEGER(4)                    :: ICOUNT
INTEGER(4)                    :: MAXICOUNT
INTEGER                       :: Sttus

!rm not used:CHARACTER(100)                :: Frmt
!rm not used:CHARACTER( 80)                :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER( 11), EXTERNAL      :: Int2LStr



 ! Allocate and initialize the local array on the first pass
IF ( .NOT. ALLOCATED (OLD_A_NS) ) THEN
   ALLOCATE ( OLD_A_NS ( NELM, NB) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for OLD_A_NS array.' )
   OLD_A_NS(:,:) = 0.0
ENDIF

 ! Allocate and initialize the local array on the first pass
IF ( .NOT. ALLOCATED (OLD_AP_NS) ) THEN
   ALLOCATE ( OLD_AP_NS ( NELM, NB) , STAT=Sttus )
   IF ( Sttus /= 0 ) CALL ProgAbort ( ' Error allocating memory for OLD_AP_NS array.' )
   OLD_AP_NS(:,:) = 0.0
ENDIF

 ! Set maximum iterations
MAXICOUNT = 1000     !bjj why isn't this a parameter?

 ! CH--  Alternate convergence criteria
ATOLER2    =  2.0 * ATOLER
ATOLERBY10 =  0.1 * ATOLER

 ! Bypass calculations for low wind speed, assume no induced velocity.

IF ( VNROTOR2 < 0.1 ) THEN
   A(J,IBLADE) = 0.0
   RETURN
ENDIF

 ! SOLFACT is solidity factor divided by 2*VNROTOR2
 ! VT2_Inv is 1./VT**2 to save computation time

IF ( RLOCAL == 0.0 ) THEN   ! Avoid div/0 in FAST2
   SOLFACT = 1.0/VNROTOR2
ELSE
!bjj start of proposed change
!rm   SOLFACT = B * C(J) / ( TWOPI * RLOCAL * VNROTOR2)
   SOLFACT = NB * C(J) / ( TWOPI * RLOCAL * VNROTOR2)
!bjj end of proposed change
ENDIF
VT2_Inv = 1. / ( VT * VT )

 !-mlb  Let's USE the old value of the A from before it was corrected for skew.
AI      = OLD_A_NS( J, IBLADE )
DAI1    = 0.05
A2P     = OLD_AP_NS( J, IBLADE )
ASTEP   = 0.5
ICOUNT  = 0

 ! Check for extremely high VN and bypass calculations if necessary

IF ( ABS( VNB ) > 100. ) THEN
   A( J, IBLADE ) = 0.0
   CALL VINDERR( VNW, VNB, 'VNB', J, IBLADE )
   RETURN
ELSEIF ( ABS( VT ) > 400. ) THEN
   A( J, IBLADE ) = 0.0
   CALL VINDERR( VNW, VT, 'VT', J, IBLADE )
   RETURN
ENDIF

A2 = AI

CALL AXIND ( VNW, VNB, VNA, VTA, VT, VT2_Inv, VNROTOR2, A2, A2P, &
            J, SOLFACT, ALPHA, PHI, CLA, CDA, CMA, RLOCAL )

DAI = A2  - AI

DELAI = ASTEP * DAI

 !CH--  Modification of mlb's proposed change
 ! Must pass two criteria. If we have crossed zero many times
 !  then the first criterion will be easier to meet than the second
 !  because ASTEP will be small (but the second is relaxed to ATOLER2)

DO WHILE ( ABS( DELAI ) > ATOLERBY10 .AND. ABS(DAI) > ATOLER2 )

   ICOUNT = ICOUNT + 1

   A2 = AI

   CALL AXIND ( VNW, VNB, VNA, VTA, VT, VT2_Inv, VNROTOR2, A2, A2P, &
             J, SOLFACT, ALPHA, PHI, CLA, CDA, CMA, RLOCAL )

   DAI = A2  - AI

   DELAI = ASTEP * DAI

 ! Test for convergence, program warning after 1000 iterations

   IF ( ICOUNT > MAXICOUNT ) THEN
!      WRITE(*,'(/A)') '****************** WARNING ******************* '
!      WRITE(*,*) 'Excessive iterations to find induction factor.'
!      WRITE(*,*) 'Possibly there is excessive blade motion or numerical instability'
!      WRITE(*,*) 'Element = ', J
!      WRITE(*,*) 'VNA = ', VNA,'   VTA = ', VTA
!      WRITE(*,*) 'ALPHA= ',ALPHA*RtoD,'  Phi= ',PHI*RtoD
!      WRITE(*,*) 'CL= ',CLA,'     CD= ',CDA
!      WRITE(*,*) 'AI= ', AI,'     DAI= ', DAI
!      WRITE(*,*) 'DAI1= ', DAI1,'   ASTEP=', ASTEP
!bjj start of proposed change v12.70
!rm      MESAGE = 'Induction factor calculation did not converge after'// &
!rm               TRIM(Int2LStr(MAXICOUNT))//' iterations.'
!rm      Frmt   = "(A,/,'  AeroDyn will continue using induction factors from previous successful time step.')"
!rm      CALL ErrLog( MESAGE, Frmt, 'VIND', 331, 'WARN' )
      CALL ProgWarn( 'Induction factor calculation did not converge after'//TRIM(Int2LStr(MAXICOUNT))// &
                     ' iterations. AeroDyn will continue using induction factors from previous successful time step.' )
!bjj end of proposed change v12.70
      A2  = OLD_A_NS (J,IBLADE)
      A2P = OLD_AP_NS(J,IBLADE)
      EXIT
   ENDIF

 ! Reduce step size after a zero crossing
 !CH--  Put floor under ASTEP to keep it reasonable after many zero crossings

   IF( NINT( SIGN(1., DAI) ) /= NINT( SIGN(1., DAI1) ) ) ASTEP = MAX( 1.0E-4, 0.5*ASTEP )

   AI   = AI + DELAI
   DAI1 = DELAI

END DO

 ! Passed test, we're done
A (J,IBLADE) = A2
AP(J,IBLADE) = A2P
VT = VT * ( 1. + A2P )  !bjj: why are we changing the total velocity?
OLD_A_NS  (J,IBLADE) = A2
OLD_AP_NS (J,IBLADE) = A2P



RETURN
END SUBROUTINE VIND



 ! ***************************************************
   SUBROUTINE VINDERR( VNW, VX, VID, J, IBLADE )
 !  used to write warning messages to the screen
 !  when VN or VT is high.
 ! ***************************************************


!bjj rm: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!BJJ Start of proposed change v12.7
!rmREAL(ReKi)                 :: VNW
!rmREAL(ReKi)                 :: VX
!rm
!rmINTEGER(4)                 :: IBLADE
!rmINTEGER(4)                 :: J
!rm
!rmCHARACTER(  *)             :: VID
REAL(ReKi),INTENT(IN)      :: VNW
REAL(ReKi),INTENT(IN)      :: VX

INTEGER(4),INTENT(IN)      :: IBLADE
INTEGER(4),INTENT(IN)      :: J

CHARACTER(  *),INTENT(IN)  :: VID
!BJJ End of proposed change

   ! Local Variables:

INTEGER(4), SAVE           :: NERRORS = 0

LOGICAL,    SAVE           :: AFLAG   = .FALSE.

!rm not used:CHARACTER(130)             :: Frmt
!rm not used:CHARACTER( 80)             :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER( 15), EXTERNAL   :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER( 11), EXTERNAL   :: Int2LStr



 ! Don't write messages if we've already done it 5 times

IF ( AFLAG ) RETURN

NERRORS = NERRORS + 1

!bjj start of proposed change
!rmMESAGE = ' High '//TRIM(VID)//' velocity encountered during induction factor calculation.'
!rmFrmt   = "(A, /2x,'Blade number     ', " &
!rm           //"/2x,'Element number   ', " &
!rm           //"/2x,'VNW =                     ', "&
!rm           //"/2x,'    =                     ')"
!rmWRITE(Frmt(25 :26 ),'(A2 )')TRIM(Int2LStr(IBLADE))
!rmWRITE(Frmt(50 :51 ),'(A2 )')TRIM(Int2LStr(J))
!rmWRITE(Frmt(66 :85 ),'(A20)')TRIM(Flt2LStr(VNW))
!rmWRITE(Frmt(94 :96 ),'(A3 )')VID
!rmWRITE(Frmt(100:119),'(A20)')TRIM(Flt2LStr(VX))
!rmCALL ErrLog( MESAGE, Frmt, 'VINDERR', 332, 'WARN' )
   CALL ProgWarn( ' High '//TRIM(VID)//' velocity encountered during induction factor calculation.' )
   CALL WrScr( '  Blade number '//TRIM(Int2LStr(IBLADE))//', Element number '//TRIM(Int2LStr(J )) )
   CALL WrScr( '  VNW = '       //TRIM(Flt2LStr(VNW))//', '//TRIM(VID)//' = '//TRIM(Flt2LStr(VX)) )
! bjj end of proposed change

IF ( NERRORS >= 5 ) THEN
   AFLAG = .TRUE.
!bjj start of proposed change
!rm   MESAGE = ' Induced velocity warning written 5 times.'
!rm   Frmt   = '(A, /2x,''The message will not be repeated, though the condition may persist.'')'
!rm   CALL ErrLog( MESAGE, Frmt, 'VINDERR', 333, 'WARN' )
   CALL ProgWarn( ' Induced velocity warning written 5 times. '//&
                 ' The message will not be repeated, though the condition may persist.' )
!bjj end of proposed change
ENDIF



RETURN
END SUBROUTINE VINDERR



 ! ******************************************************
   SUBROUTINE AXIND ( VNW, VNB, VNA, VTA, VT, VT2_Inv, VNROTOR2, A2, &
                      A2P, J, SOLFACT, ALPHA, PHI, CLA, CDA, CMA, RLOCAL )
 !  calculates a new axial induction factor from
 !   given values of velocities and geometry.  This routine
 !   is called by vind as part of the iteration process
 ! ******************************************************

USE                           Element
USE                           InducedVel
!bjj rm v12.70-bjj: USE                           Precision
!bjj start:
USE                           Airfoil, ONLY: NFoil
!bjj end
USE                           Switch


IMPLICIT                      NONE


   ! Passed Variables:
!BJJ Start of proposed change v12.7
!rmREAL(ReKi)                 :: A2
!rmREAL(ReKi)                 :: A2P
!rmREAL(ReKi)                 :: ALPHA
!rmREAL(ReKi)                 :: CDA
!rmREAL(ReKi)                 :: CLA
!rmREAL(ReKi)                 :: CMA
!rmREAL(ReKi)                 :: PHI
!rmREAL(ReKi)                 :: RLOCAL
!rmREAL(ReKi)                 :: SOLFACT
!rmREAL(ReKi)                 :: VNA
!rmREAL(ReKi)                 :: VNB
!rmREAL(ReKi)                 :: VNROTOR2
!rmREAL(ReKi)                 :: VNW
!rmREAL(ReKi)                 :: VT
!rmREAL(ReKi)                 :: VT2_Inv
!rmREAL(ReKi)                 :: VTA
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(INOUT)   :: A2
REAL(ReKi),INTENT(INOUT)   :: A2P
REAL(ReKi),INTENT(OUT)     :: ALPHA
REAL(ReKi),INTENT(OUT)     :: CDA
REAL(ReKi),INTENT(OUT)     :: CLA
REAL(ReKi),INTENT(OUT)     :: CMA
REAL(ReKi),INTENT(OUT)     :: PHI
REAL(ReKi),INTENT(IN)      :: RLOCAL
REAL(ReKi),INTENT(IN)      :: SOLFACT
REAL(ReKi),INTENT(OUT)     :: VNA
REAL(ReKi),INTENT(IN)      :: VNB
REAL(ReKi),INTENT(IN)      :: VNROTOR2
REAL(ReKi),INTENT(IN)      :: VNW
REAL(ReKi),INTENT(IN)      :: VT
REAL(ReKi),INTENT(IN)      :: VT2_Inv
REAL(ReKi),INTENT(OUT)     :: VTA

INTEGER(4),INTENT(IN)      :: J
!BJJ End of proposed change v12.7

   ! Local Variables:

REAL(ReKi)                 :: CH
REAL(ReKi)                 :: CPhi                                                     ! COS( PHI )
!bjj start of proposed change
!rmREAL(ReKi)                 :: HUBLOSS = 1
!rmREAL(ReKi)                 :: LOSS = 1
REAL(ReKi), SAVE           :: HUBLOSS = 1
REAL(ReKi), SAVE           :: LOSS = 1
!bjj end of proposed change
REAL(ReKi)                 :: SPHI
REAL(ReKi)                 :: SWRLARG
!bjj start of proposed change
!RMREAL(ReKi)                 :: TIPLOSS = 1
REAL(ReKi), SAVE           :: TIPLOSS = 1
!bjj END of proposed change
REAL(ReKi)                 :: W2

!bjj start of proposed change
INTEGER                    :: ErrStat
!bjj end of proposed change


VNA    = VNW * ( 1. - A2 ) + VNB
VTA    = VT  * ( 1. + A2P )

 ! Get airfoil CL and CD
PHI    = ATAN2( VNA, VTA )
ALPHA  = PHI - PITNOW

CALL MPI2PI ( ALPHA )

!BJJ START OF PROPOSED CHANGE
!rmCALL CLCD ( ALPHA, CLA, CDA, CMA, J )
CALL CLCD ( ALPHA, CLA, CDA, CMA, NFoil(J), ErrStat )
!BJJ end OF PROPOSED CHANGE

W2   = VNA * VNA + VTA * VTA
SPHI = VNA/SQRT( W2 )
CPhi = COS( Phi )

 ! Calculate new value of A.  Optionally include normal force due to drag.

CH = W2*SOLFACT*( CLA*CPhi + EqAIDmult*CDA*SPhi )


 ! Get the tip loss values for the element (if they change)
IF (TLOSS) CALL GetTipLoss (J, SPHI, TIPLOSS, RLOCAL)

 ! Get the hub loss values for the element (if they change)
IF (HLOSS) CALL GetPrandtlLoss (HLCNST(J), SPHI, HUBLOSS)

 ! Get the total loss for the element
LOSS = TIPLOSS * HUBLOSS

 ! Check for diverging CH and correct if necessary

IF ( ABS( CH ) > 2. ) CH = SIGN( 2., CH )

IF ( CH < 0.96*LOSS ) THEN
   A2 = 0.5*( 1 - SQRT( 1.0 - CH/LOSS ) )
ELSE
   A2 = 0.1432 + SQRT( -0.55106 + .6427*CH/LOSS)
ENDIF

 ! Calculate induced swirl (a') if desired.
 !  From C. Ross Harmon's paper on PROPX.

IF ( SWIRL ) THEN
   IF ( EquilDT )  THEN     ! USE PROP-PC style tangential induction equation with the addition of the drag term.
         ! Because of the singularity that occurs when phi approaches zero,
         ! let's test for small phi and set a' equal to a small, negative number.
      IF ( ( ABS( SPhi ) > 0.01 ) .AND. ( ABS( CPhi ) > 0.01 ) )  THEN
         A2P = SOLFACT*( CLA*SPhi - CDA*CPhi )*( 1.0 + A2P )*VNROTOR2/( 4.0*LOSS*SPhi*CPhi )
      ELSEIF ( ABS( SPhi ) > 0.01 )  THEN   ! Tangential velocity near zero, phi near 90 degrees.
         A2P = SOLFACT*( CLA*SPhi - CDA*SIGN( 0.01, CPhi ) )*( 1.0 + A2P )*VNROTOR2/( 4.0*LOSS*SPhi*SIGN( 0.01, CPhi ) )
      ELSE   ! Normal velocity near zero, phi near 0 degrees.
         A2P = SOLFACT*( CLA*SIGN( 0.01, SPhi ) - CDA*CPhi )*( 1.0 + A2P )*VNROTOR2/( 4.0*LOSS*SIGN( 0.01, SPhi )*CPhi )
      ENDIF
   ELSE
      SWRLARG = 1.0 + 4.0*LOSS*A2*VNW*VNA*VT2_Inv
      IF ( SWRLARG < 0.0 ) THEN
         A2P = 0.0
      ELSE
         A2P = 0.5*( -1.0 + SQRT( SWRLARG ) )
      ENDIF
   ENDIF
ELSE
   A2P = 0.0
ENDIF



RETURN
END SUBROUTINE AXIND


 ! ***************************************************
!bjj start of proposed change
!rm   SUBROUTINE GetReynolds( W2, Chord, Density, Viscosity, ReNum )
   FUNCTION GetReynolds( WindSpd, ChordLen )
!bjj end of proposed change
 !  computes the Reynolds number for the element, divided by 1.0E6
 ! ***************************************************

!bjj rm v12.70-bjj: USE                           Precision
   USE                           Wind,       ONLY: KinVisc
!bjj end

IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: Chord
!rmREAL(ReKi)                 :: Density
!rmREAL(ReKi)                 :: ReNum
!rmREAL(ReKi)                 :: Viscosity
!rmREAL(ReKi)                 :: W2

   ! Local Variables:
!RMREAL(ReKi)                 :: WindVel

REAL(ReKi),INTENT(IN)      :: WindSpd
REAL(ReKi),INTENT(IN)      :: ChordLen
!REAL(ReKi),INTENT(IN)      :: KinViscosity

   ! function definition
!bjj Start of proposed change v12.70
!REAL(ReKi)     :: ReNum
REAL(ReKi)     :: GetReynolds




!WindVel = SQRT(W2)

!bjj start of proposed change
!rmReNum = WindVel * Chord / Viscosity / 1.0E6
GetReynolds = 1.0E-6 * WindSpd * ChordLen / KinVisc
!bjj end of proposed change



RETURN
!bjj start of proposed change
!rmEND SUBROUTINE GetReynolds
END FUNCTION GetReynolds
!bjj end of proposed change

 ! ***************************************************
   SUBROUTINE GetTipLoss( J, SPHI, TIPLOSS, RLOCAL )
 !  computes the tip loss constant for element J
 !  TIPLOSS is returned to AXIND
 ! Uses the Prandtl tip loss model with a correction
 !  from Georgia Tech (2002 ASME Wind Energy Symposium)
 ! ***************************************************


USE                           Blade
!bjj Start of proposed change v12.70
!rmUSE                           Constant !bjj not used?
!bjj End of proposed change
USE                           Element
!bjj rm v12.70-bjj: USE                           Precision
USE                           Switch


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: SPHI
!rmREAL(ReKi)                 :: RLOCAL
!rmREAL(ReKi)                 :: TIPLOSS
!RM
!rmINTEGER(4)                 :: J
REAL(ReKi), INTENT(IN)     :: SPHI
REAL(ReKi), INTENT(IN)     :: RLOCAL
REAL(ReKi), INTENT(OUT)    :: TIPLOSS

INTEGER(4), INTENT(IN)     :: J
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: Dist2pt7 = 0.7 ! current element distance to r/R = 0.7
!rm not used:REAL(ReKi)                 :: F
REAL(ReKi)                 :: OLDDist7       ! previous element distance to r/R = 0.7
REAL(ReKi)                 :: percentR
REAL(ReKi), SAVE           :: TLpt7 ! Tiploss factor at r/R = 0.7

INTEGER(4)                 :: Jpt7 = 0 ! The element closest to r/R = 0.7

LOGICAL,    SAVE           :: FirstPass = .TRUE.



 ! Calculate PRANDTL tip loss model
CALL GetPrandtlLoss( TLCNST(J), SPHI, TIPLOSS )


 ! Apply Georgia Tech correction to Prandtl model if activated
IF (GTECH) THEN
   percentR = RLOCAL/R

 ! Search for the element closest to r/R = 0.7
   IF (FirstPass) THEN
    ! If the current element is closer than the previous, update values
      IF ( ABS(percentR - 0.7) < Dist2pt7 ) THEN
         OLDDist7 = Dist2pt7
         Dist2pt7 = ABS(percentR - 0.7)
         Jpt7 = J
         TLpt7 = TIPLOSS
      ENDIF
      IF (J == NELM) THEN ! We're done after one pass through the blades
         FirstPass = .FALSE.
      ELSE
         RETURN ! Don't do the correction until we calculate the correct TLpt7
      ENDIF
   ENDIF

   IF ( J == Jpt7 ) TLpt7 = TIPLOSS ! Update the value of TLpt7 at the proper element

 ! Do the actual Georgia Tech correction to the Prandtl model
   IF (percentR >= 0.7) THEN
      TIPLOSS = (TIPLOSS**0.85 + 0.5 ) / 2.0
   ELSE
      TIPLOSS = 1.0 - percentR*(1.0 - TLpt7)/0.7
   ENDIF
ENDIF



RETURN
END SUBROUTINE GetTipLoss


 ! ***************************************************

   SUBROUTINE GetPrandtlLoss( LCnst, SPHI, PrLOSS )
 !  computes the hub loss constant for element J
 !  HUBLOSS is returned to AXIND
 ! Uses the Prandtl loss model
 ! ***************************************************


!bjj Start of proposed change v12.70
!rmUSE                           Blade
!bjj End of proposed change
!bjj rm NWTC_Lib:USE                           Constant
!bjj Start of proposed change v12.70
!rmUSE                           Element
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision
!bjj Start of proposed change v12.70
!rmUSE                           Switch
!bjj End of proposed change

IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: LCnst
!rmREAL(ReKi)                 :: PrLOSS
!RMREAL(ReKi)                 :: SPHI
REAL(ReKi),INTENT(IN)      :: LCnst
REAL(ReKi),INTENT(OUT)     :: PrLOSS
REAL(ReKi),INTENT(IN)      :: SPHI
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: F
!rm not used:REAL(ReKi)                 :: percentR



 ! Calculate PRANDTL loss model
 !  Check values of SPHI to save runtime.
IF ( ABS( SPHI ) < 1.E-4 ) THEN
   PrLOSS = 1.0
ELSE
 ! USE ABS function to account for unusual PHI.
   F = ABS( LCnst / SPHI )
 !  Check values of F to avoid underflow of EXP function.
   IF ( F < 7. ) THEN
      PrLOSS = ACOS( EXP( -F ) ) / PIBY2
   ELSE
      PrLOSS = 1.0
   ENDIF
ENDIF


RETURN
END SUBROUTINE GetPrandtlLoss

! *************** bjj start of proposed change v13.00c FOR PJM ***************
!====================================================================================================
SUBROUTINE GetTwrInfluence (VX, VY, InputPosition)
!  Computes tower shadow or dam influence on the blade
!  Note that this routine assumes there are NO tower deflections.
!
!  Use the Riso tower dam model of Bak, Madsen and Johansen
!  This model is based on potential flow and is applicable in front of and behind the tower,
!  although in the wake we use the method of Powles
!  PJM, NREL
!
! bjj, jmj: this function should return the influence parameters, which will be based on some mean
!  wind direction (or possibly the direction at the tower) for a given height, instead of using the
!  local velocity/direction so that all points on a horizontal slice of air can use the same
!  deficit at each given time.  Will need the tower position, too.
!====================================================================================================

   USE                           TwrProps
   USE                           Rotor,      ONLY: HH


   IMPLICIT                      NONE


      ! Passed Variables:

   REAL(ReKi), INTENT(INOUT)  :: VX                   ! on input, U-velocity without tower effect; on output, U-velocity including tower effect
   REAL(ReKi), INTENT(INOUT)  :: VY                   ! on input, V-velocity without tower effect; on output, V-velocity including tower effect
   REAL(ReKi), INTENT(IN)     :: InputPosition(3)     !velocities in global coordinates with tower effect

      ! Local Variables:

   LOGICAL, SAVE              :: AFLAG   = .FALSE.    ! set to .TRUE. on possible tower strike

   REAL(ReKi)                 :: ANGLE                ! Angle determining whether blade is upwind or downwind of tower
   REAL(ReKi)                 :: CenterDist           ! Distance from blade element to wake centerline
   REAL(ReKi)                 :: phi                  ! Angle between x-axis and horizontal wind direction based upon instantaneous velocities VY and VX (at the blade element)
   REAL(ReKi)                 :: CosPhi               ! COS(phi)
   REAL(ReKi)                 :: SinPhi               ! SIN(phi)
   REAL(ReKi)                 :: Distance             ! Normalized horizontal distance from tower to blade element
   REAL(ReKi)                 :: SHADOW               ! Value of the tower shadow deficit at the blade element
!   REAL(ReKi)                 :: TEMP                 ! Temporary variable used in calculations
   REAL(ReKi)                 :: THETA                ! Angle between x-axis and line from tower to blade element
   REAL(ReKi)                 :: TwrCD_Station        ! Drag coefficient of the tower
   REAL(ReKi)                 :: TwrRad               ! Radius of the tower at the height of interest
   REAL(ReKi)                 :: WIDTH                ! Half width of the wake after accounting for wake expansion proportional to square root of Distance

   REAL(ReKi)                 :: V_total              ! total freestream wind speed
   REAL(ReKi)                 :: VX_wind              ! tower influenced wind speeds in wind coordinates
   REAL(ReKi)                 :: VY_wind              ! tower influenced wind speeds in wind coordinates
   REAL(ReKi)                 :: WindXInf             ! Influence of the tower on X wind velocity in wind reference frame
   REAL(ReKi)                 :: WindYInf             ! Influence of the tower on Y wind velocity in wind reference frame
   REAL(ReKi)                 :: Xtemp                ! Temporary variable used in tower dam calculations
   REAL(ReKi)                 :: Xtemp2               ! Temporary variable used in tower dam calculations
   REAL(ReKi)                 :: Xwind                ! X Location of element in a wind-based coordinate system
   REAL(ReKi)                 :: Yg                   ! Variable used to smooth dam effect above the tower
   REAL(ReKi)                 :: Ytemp2               ! Temporary variable used in tower dam calculations
   REAL(ReKi)                 :: Ywind                ! Y Location of element in a wind-based coordinate system

   REAL(ReKi)                 :: ZGrnd                ! distance between position and undeflected hub


   !-------------------------------------------------------------------------------------------------
   ! This subroutine is only valid for TwrPotent and TwrShadow features
   !-------------------------------------------------------------------------------------------------
   IF (.NOT. TwrPotent .AND. .NOT. TwrShadow) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Initialize some variables
   !-------------------------------------------------------------------------------------------------
   ZGrnd   = InputPosition(3) - HH                    ! distance between position and hub      !BJJ: this should really be the tower height (position), not HH
   V_total = SQRT( VX**2 + VY**2 )                    ! total wind speed

   !-------------------------------------------------------------------------------------------------
   ! Tower influence calculations aren't necessary for zero velocity
   !-------------------------------------------------------------------------------------------------
   IF ( V_total <= 0.0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! For the current element location, get the appropriate tower properties and calculate the
   ! element distance from from the tower.
   ! BJJ: If we're above the tower top, is the radius zero?
   !-------------------------------------------------------------------------------------------------

   CALL GetTwrSectProp (InputPosition(:), V_total, TwrRad, TwrCD_Station)     ! Get the tower properties for the current element location

   Distance = SQRT ( InputPosition(1)**2 + InputPosition(2)**2 ) / TwrRad     ! normalized distance to tower center

      ! Check for tower strike
   IF ( Distance < 1.0 ) THEN    ! potentially inside the tower            !bjj: only if we're not ABOVE the tower, though....

      IF (ZGrnd < 0.0) THEN      !bjj added this condition.... check that it's correct

         IF( .NOT. AFLAG) THEN
            CALL ProgWarn( ' Tower model temporarily disabled due to possible tower strike.'// &
                           ' This message will not be repeated though the condition may persist.' )
            AFLAG = .TRUE.
         ENDIF

         RETURN

      END IF

   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Store the wind direction for later
   !-------------------------------------------------------------------------------------------------

   phi    = ATAN2( VY, VX )                                 ! angle between x-axis and instantaneous horizontal wind direction
   CosPhi = COS( phi )
   SinPhi = SIN( phi )


   !-------------------------------------------------------------------------------------------------
   !  Calculate the influence due to potential flow around tower based on velocity at element
   !-------------------------------------------------------------------------------------------------

   IF ( TwrPotent ) THEN

         ! When above the tower, smooth the transition to the free-stream
      IF ( ZGrnd > 0 )  THEN
         Yg = SQRT( InputPosition(2)**2 + ZGrnd**2 )
      ELSE
         Yg = InputPosition(2)
      ENDIF

         ! Get the element location in the wind reference frame
      Xwind = InputPosition(1) * CosPhi + Yg                * SinPhi
      Ywind = Yg               * CosPhi - InputPosition(1)  * SinPhi

         ! Normalize the location coordinates
      Xwind = Xwind / TwrRad
      Ywind = Ywind / TwrRad


      Xtemp  = Xwind + Tower_Wake_Constant !PJM fixed this error 3/30/06
      Xtemp2 = Xtemp * Xtemp
      Ytemp2 = Ywind * Ywind


         ! Calculate the tower influence
      WindXInf =  1.0 - (Xtemp2 - Ytemp2)/( (Xtemp2 + Ytemp2)**2 ) &
                      + TwrCD_Station/TwoPi * Xtemp/(Xtemp2 + Ytemp2)
      WindYInf = -2.0 * (Xtemp * Ywind)/( (Xtemp2 + Ytemp2)**2 ) &   !PJM fixed sign error 3/30/06 added minus sign from Bak
                      + TwrCD_Station/TwoPi * Ywind/(Xtemp2 + Ytemp2)
   ELSE
      WindXInf = 1.0
      WindYInf = 0.0
   ENDIF

   !-------------------------------------------------------------------------------------------------
   ! Calculate the influence of tower shadow if user specifies and we are downwind of the tower
   !-------------------------------------------------------------------------------------------------

   IF ( TwrShadow ) THEN

      theta  = ATAN2( InputPosition(2), InputPosition(1) )     ! angle between x-axis and line from tower to blade element
      angle  = ABS( theta - phi )

      CALL mPi2Pi( angle )                                     ! angle difference between -pi and pi
      angle  = ABS(angle)        !BJJ: SHOULDN'T THIS BE ABS(angle)?  I'm adding it here....

      IF ( angle <= PiBy2 ) THEN ! We are downwind of the tower in shadow territory

         width = SQRT ( Distance )

            ! Calculate how far we are from the free-stream centerline
         CenterDist = Distance * SIN ( angle )                 ! bjj: non-negative because angle is non-negative (now)

            ! If above hub height apply shadow in arc above hub to maintain a continuous deficit function.  Somewhat of a nacelle deficit.
         IF ( ZGrnd > 0.0 )  THEN
            CenterDist = SQRT( CenterDist**2 + ZGrnd**2 )
         END IF

            ! See if we are in the wake. If not, then no velocity deficit

         IF ( CenterDist < width ) THEN                        ! We are in the wake

            shadow = ( COS( PiBy2 * CenterDist / width ) )**2 * TwrCD_Station / width
            WindXInf = 1.0 - shadow                               ! Overwrites the potential flow solution in the x direction only (BJJ: longitudinal? not x?)

            WindXInf = MAX( WindXInf, REAL(0.0, ReKi) )           ! Assume tower does not reverse flow direction

         END IF

      END IF ! angle <= PiBy2

   END IF !TwrShadow


   !-------------------------------------------------------------------------------------------------
   ! Apply the tower influence to the input wind speeds
   !-------------------------------------------------------------------------------------------------

   VX_wind = WindXInf*V_total
   VY_wind = WindYInf*V_total

      ! Need to transpose these back to the global reference frame
   VX = VX_wind * CosPhi - VY_wind * SinPhi
   VY = VY_wind * CosPhi + VX_wind * SinPhi

   RETURN

END SUBROUTINE GetTwrInfluence

!====================================================================================================
SUBROUTINE GetTwrSectProp (InputPosition, VelHor, TwrElRad, TwrElCD)
!  Returns the tower radius and CD for the vertical location
!   of the element currently being evaluated for tower influence.
!====================================================================================================

   USE                           Rotor,      ONLY: HH
   USE                           TwrProps

   IMPLICIT                      NONE


      ! Passed Variables:
   REAL(ReKi), INTENT(IN)     :: InputPosition(3)  ! Location where tower properties are desired
   REAL(ReKi), INTENT(IN)     :: VelHor            ! The horizontal wind speed, used to get Reynolds number, if necessary
   REAL(ReKi), INTENT(OUT)    :: TwrElRad          ! Radius of the tower element
   REAL(ReKi), INTENT(OUT)    :: TwrElCD           ! Drag coefficient of the tower element


      ! Local Variables:
   REAL(ReKi)                 :: P1        ! Interpolation weighting factor
   REAL(ReKi)                 :: P2        ! Interpolation weighting factor
   REAL(ReKi)                 :: TwrElCD1  ! Dummy variable for 2-D interpolation
   REAL(ReKi)                 :: TwrElCD2  ! Dummy variable for 2-D interpolation
   REAL(ReKi)                 :: TwrElHt   ! Non-dimensional height of the tower element
   REAL(ReKi)                 :: TwrElRe   ! Reynold's # of the tower element
!rm not used:   REAL(ReKi)                 :: VHor      ! Total horizontal wind velocity at the current element location

!rm not used:   INTEGER                    :: I
!rm not used:   INTEGER                    :: Indx
   INTEGER                    :: N1        ! Index position in table for interpolation
   INTEGER                    :: N2        ! Index position in table for interpolation
   INTEGER                    :: N1P1      ! Index position + 1 in table for interpolation
   INTEGER                    :: N2P1      ! Index position + 1 in table for interpolation


   !-------------------------------------------------------------------------------------------------
   ! Get the tower radius, TwrElRad, by interpolating into the TwrWid(:) array
   !-------------------------------------------------------------------------------------------------

   TwrElHt  = InputPosition(3) / HH                                  !!!!BJJ!!!! HH????
   TwrElRad = 0.5*InterpBin( TwrElHt, TwrHtFr, TwrWid, N2, NTwrHt )

   !-------------------------------------------------------------------------------------------------
   ! Get the section CD, TwrElCD, by interpolating into the TwrCD(:,:) array
   !-------------------------------------------------------------------------------------------------

   IF ( NTwrRe == 1 ) THEN                                  ! There is only one Re row

      IF ( NTwrCD == 1 ) THEN                               ! There is only one CD column
         TwrElCD = TwrCD(1,1)
      ELSE IF ( NTwrHt == 1 ) THEN                          ! There is more than one column of CD, but only one used
         TwrElCD = TwrCD(1,NTwrCDCol(1))
      ELSE                                                  ! Interpolate;  this will be the same Indx as before...
         TwrElCD = InterpStp( TwrElHt, TwrHtFr, TwrCD(1,:), N2, NTwrHt )
      END IF

   ELSE                                                     ! There are multiple Re rows

      TwrElRe = GetReynolds( VelHor, 2.0*TwrElRad )

      IF ( NTwrCD == 1 ) THEN                               ! There is only one CD column
         TwrElCD = InterpBin( TwrElRe, TwrRe, TwrCD(:,1), N1, NTwrRe )
      ELSE IF ( NTwrHt == 1 ) THEN                          ! Interpolate over Re only
         TwrElCD = InterpBin( TwrElRe, TwrRe, TwrCD(:,NTwrCDCol(1)), N1, NTwrRe )
      ELSE                                                  ! A 2-D interpolation is needed
         CALL LocateBin( TwrElRe, TwrRe, N1, NTwrRe )

            ! Let's use nearest-neighbor extrapolation with bi-linear interpolation:

         N1   = MIN( MAX( N1, 1 ), NTwrRe-1 )
         N1P1 = N1+1

         P1   = MIN( MAX( (TwrElRe - TwrRe(N1))   / (TwrRe(N1P1)   - TwrRe(N1))  , REAL(0.0, ReKi) ), REAL(1.0, ReKi) )

         N2P1 = N2 + 1
         P2   = MIN( MAX( (TwrElHt - TwrHtFr(N2)) / (TwrHtFr(N2P1) - TwrHtFr(N2)), REAL(0.0, ReKi) ), REAL(1.0, ReKi) )


         TwrElCD1 = TwrCD(N1,N2  ) + P1 * ( TwrCD(N1P1,N2  ) - TwrCD(N1,N2  ) )
         TwrElCD2 = TwrCD(N1,N2P1) + P1 * ( TwrCD(N1P1,N2P1) - TwrCD(N1,N2P1) )


         TwrElCD = TwrElCD1 + P2 * ( TwrElCD2 - TwrElCD1 )
      END IF

   END IF


RETURN
END SUBROUTINE GetTwrSectProp
!end changes v12.58pjm-ce
!bjj end of proposed change for pjm

!====================================================================================================
!FUNCTION AD_WindVelocityWithDisturbance( InputPosition, VelNormalToRotor2, ErrStat  )
FUNCTION AD_WindVelocityWithDisturbance( InputPosition, ErrStat  )
!  This function computes the (dimensional) wind velocity components at the location InputPosition
!  in the inertial frame of reference, including any tower shadow defecit.
!  ** Formerly SUBROUTINE VEL and later SUBROUTINE VWrel2G( VNRotor2, At_Hub ) **
!----------------------------------------------------------------------------------------------------

   USE                              AeroTime,   ONLY: Time  ! input time, used to get the wind speed
!   USE                              Rotor,      ONLY: HH,  CTilt, STilt, CYaw, SYaw
   USE                              Rotor,      ONLY: HH
   USE                              TwrProps,   ONLY: PJM_Version, TShadC1, TShadC2



   IMPLICIT                         NONE


      ! Passed Variables:

   REAL(ReKi),INTENT(IN)            :: InputPosition(3)
!  REAL(ReKi),INTENT(OUT),OPTIONAL  :: VelNormalToRotor2    ! The square of the wind velocity at InputPosition in the direction normal to the rotor plane (m^2/s^2);
   INTEGER,   INTENT(OUT),OPTIONAL  :: ErrStat


      ! function definition

   REAL(ReKi)                      :: AD_WindVelocityWithDisturbance(3)


      ! Local variables

   TYPE(InflIntrpOut)               :: InflowVel

   REAL(ReKi)                       :: angle    ! absolute difference between theta and phi
   REAL(ReKi)                       :: dist     ! distance from blade element to wake centerline
   REAL(ReKi)                       :: phi      ! angle between x-axis and instantaneous horizontal wind direction
   REAL(ReKi)                       :: RADIUS   ! horizontal distance from tower to blade element ** BJJ NOTE: in actuality, it's the distance from the undeflected tower centerline, not the actual tower
   REAL(ReKi)                       :: ROOTR    ! SQRT(radius)
   REAL(ReKi)                       :: SHADOW
   REAL(ReKi)                       :: TEMP
   REAL(ReKi)                       :: theta    ! Angle between x-axis and line from tower to blade element
   REAL(ReKi)                       :: width    ! half width of the wake after accounting for wake expansion proportional to square root of RADIUS

   INTEGER                          :: Sttus


      ! Get the undisturbed velocity

   InflowVel = WindInf_GetVelocity( REAL(Time, ReKi), InputPosition, Sttus)

   IF ( PRESENT(ErrStat) ) THEN  !BJJ: This is a hack job used for A2AD
      ErrStat = Sttus
      IF (Sttus /= 0) CALL ProgWarn( ' Error getting velocity in AeroDyn/AD_WindVelocityWithDisturbance().' )
   ELSE
      IF (Sttus /=0) CALL ProgAbort( ' Error getting velocity in AeroDyn/AD_WindVelocityWithDisturbance().' )
   END IF

   AD_WindVelocityWithDisturbance(:) = InflowVel%Velocity(:)


         ! Add the tower influence to the undisturbed velocity.

   IF ( PJM_Version ) THEN

      CALL GetTwrInfluence ( AD_WindVelocityWithDisturbance(1), AD_WindVelocityWithDisturbance(2), InputPosition(:) )

   ELSE !Old tower version

         ! Apply tower shadow if the blade element is in the wake

      IF ( TShadC2 > 0.0 ) THEN ! Perform calculations only if the wake strength is positive

            ! Bypass tower shadow for zero horizontal wind, check U-component first to save time.

         IF ( AD_WindVelocityWithDisturbance(1) /= 0.0 .OR. AD_WindVelocityWithDisturbance(2) /= 0.0 ) THEN

            phi    = ATAN2( AD_WindVelocityWithDisturbance(2), AD_WindVelocityWithDisturbance(1) )    ! angle between x-axis and instantaneous horizontal wind direction
            theta  = ATAN2( InputPosition(2),                  InputPosition(1)                  )    ! angle between x-axis and line from tower to blade element
            angle  = ABS( theta - phi )
!bjj:
            CALL MPi2Pi( angle )
            angle = ABS( angle )
!bjj end

            IF ( angle <= PiBy2 ) THEN  ! Skip cases where we are upwind of the tower -- bjj: DOES THIS ACTUALLY WORK? WHAT ABOUT

               radius = SQRT( InputPosition(1)**2 + InputPosition(2)**2 )                             ! bjj: shouldn't this be relative to the hub position?

               RootR  = SQRT( radius )
               width  = TShadC1 * RootR                                                               ! half width of the wake after accounting for wake expansion proportional to square root of RADIUS

               IF ( width > 0 ) THEN   ! Skip cases with zero width or radius so we don't divide by zero

                  dist = radius * SIN( angle )                                                        ! distance from blade element to wake centerline
                  IF ( InputPosition(3) > HH )  THEN                                                  ! Apply shadow in arc above hub to maintain a continuous deficit function.  Somewhat of a nacelle deficit.
                     dist = SQRT( dist**2 + (InputPosition(3)-HH)**2 )                                !bjj: I think this should use hub position, not HH
                  END IF

                  IF ( width > dist ) THEN   ! There is velocity deficit in the wake only.
                     temp   = COS ( PiBy2 * dist/width )
                     shadow = TShadC2/RootR * temp * temp

                        ! Adjust only the horizontal components; vertical wind is not changed

                     AD_WindVelocityWithDisturbance(1:2) = AD_WindVelocityWithDisturbance(1:2) * ( 1. - shadow )

                  END IF ! width > dist
               END IF ! width > 0

            END IF ! angle <= PiBy2

         END IF !AD_WindVelocityWithDisturbance(1) /= 0.0 .OR. AD_WindVelocityWithDisturbance(2) /= 0.0
      END IF ! TShadC2 > 0.0

   END IF

!   IF ( PRESENT( VelNormalToRotor2 ) ) THEN
!      VelNormalToRotor2  = ( AD_WindVelocityWithDisturbance(3) * STilt + &
!                            (AD_WindVelocityWithDisturbance(1) * CYaw - AD_WindVelocityWithDisturbance(2) * SYaw) * CTilt )**2
!   END IF

RETURN

END FUNCTION AD_WindVelocityWithDisturbance
!====================================================================================================
!RM ! ***************************************************
!RM!bjj start of proposed change v12.70w
!RM!rm   SUBROUTINE VWrel2G( VNROTOR2, AT_HUB )
!RM   FUNCTION VWrel2G( InputPosition, VNROTOR2, ErrStat  )
!RM!bjj end of proposed change
!RM !  computes the (dimensional) wind velocity components
!RM !  at the location (XGRND, YGRND, ZGRND)
!RM !  in the inertial frame of reference
!RM !  including any tower shadow defecit.
!RM ! Formerly SUBROUTINE VEL
!RM ! Formerly SUBROUTINE VWrel2G( VNRotor2, At_Hub )
!RM ! ***************************************************
!RM
!RM
!RMUSE                           Blade
!RM!bjj rm NWTC_Lib:USE                           Constant
!RM!rmUSE                           CT_Wind
!RM!rmUSE                           FF_Wind
!RM!rmUSE                           FD_Wind
!RM!bjj rm v12.70-bjj: USE                           Precision
!RMUSE                           Wind
!RMUSE                           Rotor
!RMUSE                           Switch
!RM
!RM!bjj start of proposed change v12.70w
!RMUSE                           AeroDyn
!RM
!RMUSE                           AeroTime, ONLY: Time  ! input time, used to get the wind speed
!RM!bjj start of proposed change v12.70w
!RM
!RM
!RM
!RMIMPLICIT                      NONE
!RM
!RM
!RM   ! Passed Variables:
!RM!bjj Start of proposed change v12.7
!RM!rmREAL(ReKi)                 :: VNROTOR2    ! An output variable
!RM!rm
!RM!rmLOGICAL(1)                 :: AT_HUB
!RM!BJJ: VNROTOR2 is not always needed as output.  Make this optional?  No- change GetHubWind to calculate velocity; VWrel2G calls GetHubWind and then calculates VNROTOR2
!RMREAL(ReKi),INTENT(OUT),OPTIONAL :: VNROTOR2    ! An output variable   ! The square of the wind velocity at InputPosition in the direction normal to the rotor plane (m^2/s^2);
!RM
!RMINTEGER,   INTENT(OUT),OPTIONAL :: ErrStat
!RM
!RM!LOGICAL,INTENT(IN)         :: AT_HUB
!RM!bjj end of proposed change v12.7
!RM
!RM
!RM   ! Local variables
!RM
!RM!bjj start of proposed change v12.70w
!RMREAL(ReKi), INTENT(IN)          :: InputPosition(3)
!RMTYPE(InflIntrpOut)              :: InflowVel
!RMINTEGER                         :: Sttus
!RM
!RM   ! function definition
!RMREAL(ReKi)                      :: AD_WindVelocityWithDisturbance(3)
!RM
!RM!bjj end of proposed change
!RM
!RMREAL(ReKi)                 :: ANGLE
!RM!BJJ RM 12.70w:REAL(ReKi)                 :: CDELTA   ! COS(DELTA)
!RMREAL(ReKi)                 :: DIST     ! DIST   = Distance from blade element to wake centerline
!RMREAL(ReKi)                 :: PHI      ! PHI    = Angle between x-axis and horizontal wind direction
!RMREAL(ReKi)                 :: RADIUS   ! RADIUS = horizontal distance from tower to blade element
!RMREAL(ReKi)                 :: ROOTR
!RM!BJJ RM 12.70w:REAL(ReKi)                 :: SDELTA   ! COS(DELTA)
!RMREAL(ReKi)                 :: SHADOW
!RMREAL(ReKi)                 :: TEMP
!RMREAL(ReKi)                 :: THETA    ! THETA  = Angle between x-axis and line from tower to blade element
!RM!BJJ RM 12.70w:REAL(ReKi)                 :: V1
!RMREAL(ReKi)                 :: VNROTOR
!RMREAL(ReKi)                 :: WIDTH    ! WIDTH  = Half width of the wake after accounting for wake expansion proportional to square root of RADIUS
!RM
!RM
!RM!bjj start of proposed change v12.70w
!RM!rmCDELTA = COS( DELTA )
!RM!rmSDELTA = SIN( DELTA )
!RM!rm
!RM!rmIF (AT_HUB) THEN
!RM!rm   XGRND = 0.0
!RM!rm   YGRND = 0.0
!RM!rm   ZGRND = 0.0
!RM!rmENDIF
!RM!rm
!RM!rm ! Apply wind shears only if using hub-height wind files.
!RM!rm
!RM!rmIF ( FFWindFlag ) THEN
!RM!rm
!RM!rm ! USE full-field wind data.
!RM!rm
!RM!rm ! These spatial coordinates are expressed in the
!RM!rm !  turbulence reference frame, X downwind, Z vertical up.
!RM!rm
!RM!rm   CALL FF_Interp
!RM!rm
!RM!rm   VX = FFWind( 1 )
!RM!rm   VY = FFWind( 2 )
!RM!rm   VZ = FFWind( 3 )
!RM!rm
!RM!rmELSEIF ( FDWindFlag )  THEN
!RM!rm
!RM!rm ! USE large-eddy wind data.
!RM!rm
!RM!rm ! These spatial coordinates are expressed in the
!RM!rm !  turbulence reference frame, X downwind, Z vertical up.
!RM!rm
!RM!rm   CALL FD_Interp
!RM!rm
!RM!rm   VX = FDWind( 1 )
!RM!rm   VY = FDWind( 2 )
!RM!rm   VZ = FDWind( 3 )
!RM!rm
!RM!rmELSEIF ( UsrWndFlag )  THEN
!RM!rm
!RM!rm   CALL UserWind
!RM!rm
!RM!rmELSE
!RM!rm
!RM!rm ! Apply wind shear
!RM!rm   V1 = V * ( ( 1. + ZGRND/HH ) ** VSHR &
!RM!rm        + ( HSHR * ( YGRND * CDELTA + XGRND * SDELTA ) &
!RM!rm        +   VLINSHR * ZGRND)/( 2.0 * R )  ) + VGUST
!RM!rm
!RM!rm   VY = -V1 * SDELTA
!RM!rm   VX =  V1 * CDELTA
!RM!rm
!RM!rm!bjj: VZ is read from the input file and not calculated here
!RM!rm
!RM!rmENDIF
!RM!rm
!RM!rmIF ( CTWindFlag ) THEN     ! add coherence to background, if necessary
!RM!rm
!RM!rm   CALL CT_Interp
!RM!rm
!RM!rm   VX = VX + CTWind( 1 )
!RM!rm   VY = VY + CTWind( 2 )
!RM!rm   VZ = VZ + CTWind( 3 )
!RM!rm
!RM!rmENDIF
!RM!rm
!RM
!RM!InputPosition = (/ XGrnd, YGrnd, HH+ZGrnd /)
!RMInflowVel = WindInf_GetVelocity( REAL(Time, ReKi), InputPosition, Sttus)
!RM
!RMIF ( PRESENT(ErrStat) ) THEN  !BJJ: This is a hack job used for A2AD
!RM   ErrStat = Sttus
!RM   IF (Sttus /= 0) CALL ProgWarn( ' Error getting velocity in AeroDyn/VWrel2G().' )
!RMELSE
!RM   IF (Sttus /=0) CALL ProgAbort( ' Error getting velocity in AeroDyn/VWrel2G().' )
!RMEND IF
!RM
!RMVX = InflowVel%Velocity(1)
!RMVY = InflowVel%Velocity(2)
!RMVZ = InflowVel%Velocity(3)
!RM!bjj end of proposed change
!RM
!RM
!RM ! Apply tower shadow if the blade element is in the wake
!RM
!RM ! Skip the calculations if the wake strength is not positive or if we are at the hub location
!RM
!RM!bjj start of proposed change v12.70w
!RM!rmIF ( TSHADC2 <= 0.0 .OR. AT_HUB ) GO TO 100
!RMIF ( TSHADC2 <= 0.0 ) GO TO 100
!RM!bjj end of proposed change v12.70w
!RM
!RM ! RADIUS = horizontal distance from tower to blade element
!RM ! DIST   = Distance from blade element to wake centerline
!RM ! THETA  = Angle between x-axis and line from tower to blade element
!RM ! PHI    = Angle between x-axis and horizontal wind direction
!RM ! WIDTH  = Half width of the wake after accounting for wake expansion proportional to square root of RADIUS
!RM ! In this version PHI is based upon instantaneous velocities VY and VX (at the blade element)
!RM
!RM ! Bypass tower shadow for zero horizontal wind, check VX first to save time.
!RM
!RM
!RMIF ( VX == 0.0 ) THEN  !bjj: round-off errors here????
!RM   IF ( VY == 0.0 ) GO TO 100
!RMENDIF
!RM
!RMPHI    = ATAN2 ( VY, VX )
!RM!BJJ START of proposed change v13.00b
!RM!rmTHETA  = ATAN2 ( YGRND,  XGRND )
!RMTHETA  = ATAN2 ( InputPosition(2),  InputPosition(1) )  !bjj: this should be relative to the tower position, yes?
!RM!BJJ end of proposed change v13.00b
!RMANGLE  = ABS ( THETA - PHI )
!RM
!RM ! Skip cases where we are upwind of the tower
!RM
!RMIF ( ANGLE > PIBY2 ) GO TO 100
!RM
!RM!BJJ START of proposed change v13.00b
!RM!rmRADIUS = SQRT ( XGRND * XGRND + YGRND * YGRND )
!RMRADIUS = SQRT ( InputPosition(1)**2 + InputPosition(2)**2 )
!RM!BJJ end of proposed change v13.00b
!RM
!RMROOTR  = SQRT ( RADIUS )
!RMWIDTH  = TSHADC1 * ROOTR
!RM
!RM ! Skip cases with zero width or radius so we don't divide by zero
!RM
!RMIF ( WIDTH == 0.0 ) GO TO 100
!RM
!RMDIST   = RADIUS * SIN ( ANGLE )
!RM
!RM ! If above hub height apply shadow in arc above hub to maintain
!RM !  a continuous deficit function.  Somewhat of a nacelle deficit.
!RM
!RM!BJJ START of proposed change v13.00b
!RM!rmIF ( ZGRND > 0.0 )  DIST = SQRT(DIST * DIST + ZGRND * ZGRND)
!RMIF ( InputPosition(3) > HH )  DIST = SQRT( DIST * DIST + (InputPosition(3)-HH)**2 )  !bjj: I think this should use hub position, not HH
!RM!BJJ end of proposed change v13.00b
!RM
!RM ! See if we are in the wake. If not, then no velocity deficit
!RM
!RMIF ( DIST > WIDTH ) GO TO 100
!RM
!RM ! We are in the wake
!RM
!RMTEMP   = COS ( PIBY2 * DIST/WIDTH )
!RM
!RMSHADOW = TSHADC2/ROOTR * TEMP * TEMP
!RM
!RM ! Adjust only the horizontal components, VZ not changed
!RM
!RMVX = VX * ( 1. - SHADOW )
!RMVY = VY * ( 1. - SHADOW )
!RM
!RM100   VNROTOR  = VZ * STILT + ( VX * CYaw - VY * SYaw ) * CTILT
!RM      VNROTOR2 = VNROTOR * VNROTOR
!RM
!RMRETURN
!RMEND SUBROUTINE VWrel2G
!bjj end of proposed change


 ! ********************************************
   SUBROUTINE DiskVel
 !  calculates the mean velocities relative to the rotor disk
 !  calls routine to get wind velocity at a specified location
 !
 !  Updated on 08/12/97 xyz-direction changed
 !  Combined VELD and GETSKEW 04/24/01
 !  Updated 12/1/09 to use new inflow module; WindInf_ADhack_diskVel MUST be replaced!
 ! ********************************************

!bjj Start of proposed change v12.7
!rmUSE                           Blade !bjj not used?
!bjj End of proposed change
!bjj Start of proposed change v12.70w
!rmUSE                           FD_Wind
!rmUSE                           FF_Wind
USE                           AeroTime, ONLY: time
USE                           InflowWind
!bjj end of proposed change
!bjj rm v12.70-bjj: USE                           Precision
USE                           Rotor
USE                           Switch
USE                           Wind


IMPLICIT                      NONE


REAL(ReKi)                 :: Vinplane
REAL(ReKi)                 :: VXY
!BJJ START of proposed change v12.70w
!rmREAL(ReKi)                 :: VXGBAR
!rmREAL(ReKi)                 :: VYGBAR
!rmREAL(ReKi)                 :: VZGBAR
REAL(ReKi)                 :: AvgInfVel(3)
REAL(ReKi)                 :: Position(3)
INTEGER                    :: ErrStat

!rm!bjj:    CHECK ABOUT CTWindFlag... The events should have zero mean in time, but that may not be true on the rotor disk.
!rm
!rmIF ( FFWindFlag ) THEN
!rm   VXGBAR = MeanFFWS
!rm   VYGBAR = 0.0
!rm   VZGBAR = 0.0
!rmELSEIF ( FDWindFlag ) THEN    ! Let's average the four corners surrounding the point at HH above the tower.
!rm
!rm   XGrnd = 0.0
!rm   YGrnd = 0.5*RotDiam
!rm   ZGrnd = 0.5*RotDiam
!rm   CALL FD_Interp
!rm   VXGBAR = FDWind( 1 )
!rm   VYGBAR = FDWind( 2 )
!rm   VZGBAR = FDWind( 3 )
!rm
!rm   XGrnd =  0.0
!rm   YGrnd = -0.5*RotDiam
!rm   ZGrnd =  0.5*RotDiam
!rm   CALL FD_Interp
!rm   VXGBAR = VXGBAR + FDWind( 1 )
!rm   VYGBAR = VYGBAR + FDWind( 2 )
!rm   VZGBAR = VZGBAR + FDWind( 3 )
!rm
!rm   XGrnd =  0.0
!rm   YGrnd = -0.5*RotDiam
!rm   ZGrnd = -0.5*RotDiam
!rm   CALL FD_Interp
!rm   VXGBAR = VXGBAR + FDWind( 1 )
!rm   VYGBAR = VYGBAR + FDWind( 2 )
!rm   VZGBAR = VZGBAR + FDWind( 3 )
!rm
!rm   XGrnd =  0.0
!rm   YGrnd =  0.5*RotDiam
!rm   ZGrnd = -0.5*RotDiam
!rm   CALL FD_Interp
!rm   VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!rm   VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!rm   VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )
!rm
!rmELSEIF ( UsrWndFlag ) THEN    ! These may be instantaneous, but don't have to be.
!rm   VXGBAR = UWmeanU
!rm   VYGBAR = UWmeanV
!rm   VZGBAR = UWmeanW
!rmELSE
!rm   VXGBAR =  V * COS( DELTA )
!rm   VYGBAR = -V * SIN( DELTA )
!rm   VZGBAR =  VZ
!rmENDIF
Position = (/0.0, 0.0, HH /)
AvgInfVel(:) = WindInf_ADhack_diskVel( REAL(Time, ReKi), Position, ErrStat )
!bjj end of proposed change

!BJJ START of proposed change v12.70w
!rmVXY   = VXGBAR * CYaw - VYGBAR * SYaw
VXY   = AvgInfVel(1) * CYaw - AvgInfVel(2) * SYaw
!BJJ end of proposed change v12.70w

 ! Mean velocities in rotor disk coord. Includes yaw rate.
 ! X = Normal to plane, parallel to axis of rotation DOWNWIND
 ! Y = Inplane, horizontal to left (looking downwind)
 ! Z = Inplane, vertical up

!BJJ START of proposed change v12.70w
!rmVROTORX = VXY * CTILT + VZGBAR * STILT
!rm
!rmVROTORY = VXGBAR * SYaw + VYGBAR * CYaw + YAWVEL
!rm
!rmVROTORZ = - VXY * STILT + VZGBAR * CTILT
VROTORX = VXY * CTILT + AvgInfVel(3) * STILT

VROTORY = AvgInfVel(1) * SYaw + AvgInfVel(2) * CYaw + YAWVEL

VROTORZ = -1.* VXY * STILT + AvgInfVel(3) * CTILT
!BJJ end of proposed change v12.70w

 ! Skewed wake correction not needed for GDW
IF (.NOT. DYNINFL) THEN
 !  Set SKEW flag and assign values to related parameters
 !   used in the skewed wake correction.

 ! Vinplane is the resultant in-plane velocity
   Vinplane = SQRT( VROTORY * VROTORY + VROTORZ * VROTORZ )

 ! SKEW is TRUE if there is a cross flow, FALSE otherwise.
   IF ( Vinplane >= 1.0E-3 ) THEN
      SKEW   = .TRUE.
      SDEL   =  VROTORY/Vinplane
      CDEL   = -VROTORZ/Vinplane
      ANGFLW = ATAN2( ABS( VROTORX - AVGINFL ), Vinplane )
   ELSE
      SKEW   = .FALSE.
   ENDIF

ENDIF



RETURN
END SUBROUTINE DiskVel


 ! ****************************************
!bjj start of proposed change
!rm   SUBROUTINE VNMOD( J, RLOCAL, PSI )
   SUBROUTINE VNMOD( J, IBlade, RLOCAL, PSI )
!bjj end of proposed change
 !  applies the skewed wake correction
 !   to the axial induction factor A.
 ! ****************************************

USE                           Blade
USE                           Element
!bjj rm v12.70-bjj: USE                           Precision
USE                           Wind


IMPLICIT                      NONE


   ! Passed Variables:

!bjj Start of proposed change v12.70
!rm REAL(ReKi)                 :: PSI
!rm REAL(ReKi)                 :: RLOCAL
!rm
!rm INTEGER                    :: J
REAL(ReKi),INTENT(IN)      :: PSI
REAL(ReKi),INTENT(IN)      :: RLOCAL

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!bjj End of proposed change v12.70

   ! Local Variables:

REAL(ReKi)                 :: BB
REAL(ReKi)                 :: SANG


SANG = SIN( ANGFLW )
BB   = 0.7363 * SQRT( ( 1. - SANG )/(1. + SANG) )

A(J,IBLADE) = A(J,IBLADE) * ( 1. + 2. * RLOCAL/R * BB *  &
             ( SDEL * SIN( PSI ) + CDEL * COS( PSI ) )  )



RETURN
END SUBROUTINE VNMOD


 ! **********************************************************
!bjj Start of proposed change
!rm   SUBROUTINE BEDINIT( J, ALPHA )
   SUBROUTINE BEDINIT( J, IBlade, ALPHA )
!bjj end of proposed change
 !  calculates initial values of Beddoes 'f' arrays
 ! **********************************************************

USE                           Airfoil
USE                           Bedoes
!bjj rm:USE                           Blade
!bjj Start of proposed change v12.70
!rmUSE                           Element !bjj not used
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: ALPHA
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(INOUT)   :: ALPHA

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: AOL1
REAL(ReKi)                 :: CNA1
REAL(ReKi)                 :: FSPA
REAL(ReKi)                 :: FSPB
REAL(ReKi)                 :: FSPCA
REAL(ReKi)                 :: FSPCB
REAL(ReKi)                 :: P
REAL(ReKi)                 :: P1
REAL(ReKi)                 :: P2
REAL(ReKi)                 :: SRFP
REAL(ReKi)                 :: TEMP

INTEGER(4)                 :: I
INTEGER(4)                 :: I1
INTEGER(4)                 :: I1P1
INTEGER(4)                 :: I2
INTEGER(4)                 :: I2P1
INTEGER(4)                 :: N
INTEGER(4)                 :: NP1


ANE(J,IBLADE) = ALPHA
AFE(J,IBLADE) = ALPHA

I = NFOIL(J)

IF ( NTables(I) > 1 ) THEN
!bjj start of proposed change
!rm   CALL LOCATE( MulTabMet,NTables(I),NumFoil,MAXTABLE,MulTabLoc,N,I )
   MulTabLoc = MIN( MAX( MulTabLoc, MulTabMet(I,1) ), MulTabMet(I,NTables(I)) )
   CALL LocateBin( MulTabLoc, MulTabMet(I,1:NTables(I)), N, NTables(I) )

   IF (N == 0 ) THEN
      CNA1 = CNA(I,1)
      AOL1 = AOL(I,1)
   ELSE IF( N == NTables(I) ) THEN
      CNA1 = CNA(I,N)
      AOL1 = AOL(I,N)
   ELSE
!bjj end of proposed change
      NP1   = N+1
      P     = (MulTabLoc-MulTabMet(I,N))/(MulTabMet(I,NP1)-MulTabMet(I,N))
      CNA1  = CNA(I,N) + P * ( CNA(I,NP1) - CNA(I,N) )
      AOL1  = AOL(I,N) + P * ( AOL(I,NP1) - AOL(I,N) )
!bjj start of proposed change
   END IF
!bjj end of proposed change
ELSE
   CNA1  = CNA(I,1)
   AOL1  = AOL(I,1)
ENDIF

CNPOT(J,IBLADE) = CNA1 * (ALPHA - AOL1)
CNP(J,IBLADE)   = CNPOT(J,IBLADE)

!bjj start of proposed change
!RM CALL LOCATE( AL, NLIFT(I), NumFoil, NumCL, ALPHA, I1, I )
!rm
!rm I1P1 = I1 + 1
!rm
!RM P1 = ( AL(I,I1) - ALPHA ) / ( AL(I,I1) - AL(I,I1P1) )

ALPHA = MIN( MAX( ALPHA, AL(I,1) ), AL(I,NLIFT(I)) )
CALL LocateBin( ALPHA, AL(I,1:NLIFT(I)), I1, NLIFT(I) )

IF ( I1 == 0 ) THEN
   I1   = 1
   I1P1 = 2
   P1   = 0.0
ELSEIF ( I1 == NLIFT(I) ) THEN
   I1P1 = I1
   I1   = I1 - 1
   P1   = 1.0
ELSE
   I1P1 = I1 + 1
   P1   = ( AL(I,I1) - ALPHA ) / ( AL(I,I1) - AL(I,I1P1) )
ENDIF
!bjj END of proposed change


IF ( NTables(I) > 1 ) THEN

 ! Locate the multiple airfoil table position in the table


!bjj start of proposed change
!rm   CALL LOCATE(MulTabMet,NTables(I),NumFoil,MAXTABLE,MulTabLoc,I2,I)
   MulTabLoc = MIN( MAX( MulTabLoc, MulTabMet(I,1) ), MulTabMet(I,NTables(I)) )
   CALL LocateBin( MulTabLoc, MulTabMet(I,1:NTables(I)), I2, NTables(I) )

   IF ( I2 == 0 ) THEN
      I2P1 = 2
      I2   = 1
      P2   = 0.0
   ELSE IF( I2 == NTables(I) ) THEN
      I2P1 = I2
      I2   = I2 - 1
      P2   = 1.0
   ELSE
      I2P1 = I2 + 1
      P2 = (MulTabLoc-MulTabMet(I,I2))/(MulTabMet(I,I2P1)-MulTabMet(I,I2))
   ENDIF
!bjj END of proposed change

 ! Interpolate the F-table values

!bjj start of proposed change
!rm   I2P1 = I2 + 1
!rm   P2=(MulTabLoc-MulTabMet(I,I2))/(MulTabMet(I,I2P1)-MulTabMet(I,I2))
!bjj END of proposed change
   FSPB  = FTB( I,I1,I2P1) - (FTB( I,I1,I2P1) - FTB( I,I1P1,I2P1))*P1
   FSPCB = FTBC(I,I1,I2P1) - (FTBC(I,I1,I2P1) - FTBC(I,I1P1,I2P1))*P1
   FSPA  = FTB( I,I1,I2  ) - (FTB( I,I1,I2  ) - FTB( I,I1P1,I2  ))*P1
   FSPCA = FTBC(I,I1,I2  ) - (FTBC(I,I1,I2  ) - FTBC(I,I1P1,I2  ))*P1

   FSP( J,IBLADE) = FSPA  + P2 * ( FSPB - FSPA )
   FSPC(J,IBLADE) = FSPCA + P2 * ( FSPCB - FSPCA )

ELSE

   FSP( J,IBLADE) = FTB( I,I1,1) - ( FTB( I,I1,1) - FTB( I,I1P1,1) )*P1
   FSPC(J,IBLADE) = FTBC(I,I1,1) - ( FTBC(I,I1,1) - FTBC(I,I1P1,1) )*P1

ENDIF

IF ( ABS( AFE(J,IBLADE) - AOL1 ) < 1.E-10 ) THEN

   FSP(J,IBLADE)  = 1.0
   FSPC(J,IBLADE) = 1.0

ELSE

   TEMP = 2.*SQRT(ABS(FSP(J,IBLADE)/(AFE(J,IBLADE)-AOL1)))-1.
   FSP(J,IBLADE) = TEMP * TEMP * SIGN ( 1., TEMP )
   IF ( FSP(J,IBLADE) >  1.0 ) FSP(J,IBLADE) =  1.0
   IF ( FSP(J,IBLADE) < -1.0 ) FSP(J,IBLADE) = -1.0

   IF ( ABS( AFE(J,IBLADE) ) < 1.E-10 ) THEN
      FSPC(J,IBLADE) = 1.0
   ELSE
      TEMP = FSPC(J,IBLADE)/((AFE(J,IBLADE)-AOL1)*AFE(J,IBLADE))
      FSPC(J,IBLADE) = TEMP * TEMP * SIGN ( 1., TEMP )
      IF ( FSPC(J,IBLADE) >  1.0 ) FSPC(J,IBLADE) =  1.0
      IF ( FSPC(J,IBLADE) < -1.0 ) FSPC(J,IBLADE) = -1.0
   ENDIF

ENDIF

SRFP = SQRT( ABS( FSP(J,IBLADE) ) ) * SIGN( 1., FSP(J,IBLADE) ) + 1.
FK   = 0.25 * SRFP * SRFP
CVN(J,IBLADE) = CNPOT(J,IBLADE) * ( 1. - FK )



RETURN
END SUBROUTINE BEDINIT


 ! *****************************************************
   SUBROUTINE BedUpdate
 !  Update old Beddoes parameters at new time step
 ! *****************************************************


USE            Bedoes


ANE1    = ANE
ADOT1   = ADOT
OLDXN   = XN
OLDYN   = YN
CNPOT1  = CNPOT
OLDDPP  = DPP
FSP1    = FSP
FSPC1   = FSPC
OLDTAU  = TAU
OLDDF   = DF
OLDDFC  = DFC
OLDDN   = DN
OLDCNV  = CNV
CVN1    = CVN
CNP1    = CNP
CNPD1   = CNPD
OLDSEP  = BEDSEP
QX1     = QX
OLDDQ   = DQ
AFE1    = AFE
DQP1    = DQP
DFAFE1  = DFAFE



RETURN
END SUBROUTINE BedUpdate


 ! *****************************************************
   SUBROUTINE BEDDAT
 !  USED TO INPUT PARAMETERS FOR THE
 !   BEDDOES DYNAMIC STALL MODEL
 ! *****************************************************


USE                           Airfoil
USE                           Bedoes
!bjj Start of proposed change v12.70
!rmUSE                           Blade
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision
USE                           Switch


IMPLICIT                      NONE


   ! Local Variables:

REAL(ReKi)                 :: ETA
REAL(ReKi)                 :: CA
REAL(ReKi)                 :: SA

INTEGER(4)                 :: I
INTEGER(4)                 :: J
INTEGER(4)                 :: K



 ! Empirical constants for the Beddoes model

 ! TVL   = Non-dimensional time of transit for the
 !          vortex moving across the airfoil surface
 ! TP    = Time constant for pressure lag
 ! TV    = Time constant for strength of shed vortex
 ! TF    = Time constant applied to location of
 !          the separation point
 ! AS    = Speed of sound for Mach number calculation

TVL   = 11.0
TP    = 1.7
TV    = 6.0
TF    = 3.0
ETA   = .99  !bjj: this doesn't seem to be used for anything....

IF ( SIUNIT ) THEN
 ! SI UNITS--m/sec
   AS = 335.
ELSE
 ! ENGLISH UNITS--ft/sec
   AS = 1100.
ENDIF

 ! Generate table of F values from airfoil data table

DO J =1,NUMFOIL
   DO K =1,NTables(J)
      DO I = 1, NLIFT(J)

         CA = COS( AL(J,I) )
         SA = SIN( AL(J,I) )
         CN = CL(J,I,K) * CA + ( CD(J,I,K) - CDO(J,K) ) * SA
         CC = CL(J,I,K) * SA - ( CD(J,I,K) - CDO(J,K) ) * CA

         IF ( ABS( CNA(J,K) ) .GT. 1.E-6 ) THEN
            FTB(J,I,K)  = CN / CNA(J,K)
            FTBC(J,I,K) = CC / CNA(J,K)
         ELSE
            FTB(J,I,K)  = 1.0
            FTBC(J,I,K) = 1.0
         ENDIF

      END DO !I
   END DO !K
END DO !J

VOR   = .FALSE.
SHIFT = .FALSE.

BEDSEP = .FALSE.
ANE1   = 0.
OLDCNV = 0.
CVN1   = 0.
CNPOT1 = 0.
CNP1   = 0.
CNPD1  = 0.
OLDDF  = 0.
OLDDFC = 0.
OLDDPP = 0.
FSP1   = 0.
FSPC1  = 0.
TAU    = 0.
OLDTAU = 0.
OLDXN  = 0.
OLDYN  = 0.



RETURN
END SUBROUTINE BEDDAT


 ! *****************************************************
   SUBROUTINE BEDWRT
 !  USED TO OUTPUT PARAMETERS FOR THE
 !   BEDDOES DYNAMIC STALL MODEL
 ! *****************************************************

USE                           AD_IOParams
USE                           Airfoil
USE                           Bedoes
!bjj rm NWTC_Lib:USE                           Constant
!BJJ Start of proposed change v12.7
!rmUSE                           Element
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision
!BJJ Start of proposed change v12.7
!rmUSE                           Switch
!bjj end of proposed change

IMPLICIT                      NONE


   ! Local Variables:
!BJJ Start of proposed change v12.7
!rm REAL(ReKi)                 :: ETA
!BJJ End of proposed change v12.7

INTEGER(4)                 :: I
INTEGER(4)                 :: K

CHARACTER(70)              :: Frmt

!bjj start of proposed change
Frmt = '(3X,A, 21(:F8.4,3X) )'
!bjj end of proposed change
DO K = 1, NTables(1)
   WRITE(UnADopt,'(/A/)') '  BEDDOES DYNAMIC STALL PARAMETERS:'
!bjj start of proposed change
!rm   Frmt = '(''   CN SLOPE         '', 20(:F7.4,3X) )'
!rm   WRITE(UnADopt,Frmt) ( CNA(I,K),      I = 1, NUMFOIL )
!rm   Frmt = '(''   STALL CN (UPPER) '', 20(:F7.4,3X) )'
!rm   WRITE(UnADopt,Frmt) ( CNS(I,K),      I = 1, NUMFOIL )
!rm   Frmt = '(''   STALL CN (LOWER) '', 20(:F7.4,3X) )'
!rm   WRITE(UnADopt,Frmt) ( CNSL(I,K),     I = 1, NUMFOIL )
!rm   Frmt = '(''   ZERO LIFT AOA    '', 20(:F7.4,3X) )'
!rm!bjj Start of proposed change AeroDyn v12.70
!rm!rm   WRITE(UnADopt,Frmt) ( AOL(I,K)*RtoD,  I = 1, NUMFOIL )
!rm   WRITE(UnADopt,Frmt) ( AOL(I,K)*R2D,  I = 1, NUMFOIL )
!rm!bjj End of proposed change AeroDyn v12.70
!rm   Frmt = '(''   MIN DRAG AOA     '', 20(:F7.4,3X) )'
!rm!bjj Start of proposed change AeroDyn v12.70
!rm!rm   WRITE(UnADopt,Frmt) ( AOD(I,K)*RtoD,  I = 1, NUMFOIL )
!rm   WRITE(UnADopt,Frmt) ( AOD(I,K)*R2D,  I = 1, NUMFOIL )
!rm!bjj End of proposed change AeroDyn v12.70
!rm   Frmt = '(''   MIN DRAG COEFF   '', 20(:F7.4,3X) )'
!rm   WRITE(UnADopt,Frmt) ( CDO(I,K),      I = 1, NUMFOIL )
!rm   WRITE(UnADopt,*) ' '

   WRITE(UnADopt, Frmt) 'CN SLOPE         ', ( CNA(I,K),      I = 1, NUMFOIL )
   WRITE(UnADopt, Frmt) 'STALL CN (UPPER) ', ( CNS(I,K),      I = 1, NUMFOIL )
   WRITE(UnADopt, Frmt) 'STALL CN (LOWER) ', ( CNSL(I,K),     I = 1, NUMFOIL )
   WRITE(UnADopt, Frmt) 'ZERO LIFT AOA    ', ( AOL(I,K)*R2D,  I = 1, NUMFOIL )
   WRITE(UnADopt, Frmt) 'MIN DRAG AOA     ', ( AOD(I,K)*R2D,  I = 1, NUMFOIL )
   WRITE(UnADopt, Frmt) 'MIN DRAG COEFF   ', ( CDO(I,K),      I = 1, NUMFOIL )
   WRITE(UnADopt,'(/)')
!bjj end of proposed change
ENDDO !K

WRITE(UnADopt,*) '    VORTEX TRANSIT TIME FROM LE TO TE ', TVL
WRITE(UnADopt,*) '    PRESSURE TIME CONSTANT            ', TP
WRITE(UnADopt,*) '    VORTEX TIME CONSTANT              ', TV
WRITE(UnADopt,*) '    F-PARAMETER TIME CONSTANT         ', TF



RETURN
END SUBROUTINE BEDWRT


 ! ******************************************************
!bjj start of proposed change
!rm   SUBROUTINE BEDDOES( W2, J, ALPHA, CLA, CDA ,CMA )
   SUBROUTINE BEDDOES( W2, J, IBlade, ALPHA, CLA, CDA ,CMA )
!bjj end of proposed change
 !  uses the Beddoes dynamic stall model
 !   the routine is entered with an angle of attack
 !   and returns CL and CD.
 !  This routine is used regardless of whether the element
 !   is actually in dynamic stall state.
 !
 !  VARIABLES:
 !   W2    = Relative velocity squared over blade element
 !   J     = Index which identifies the blade element
 !   ALPHA = Angle of attack in radians
 !   CLA   = Lift coeff. which is calculated by the routine
 !   CDA   = Drag coeff. which is calculated by the routine
 !   CMA   = Moment coeff. which is calculated by the routine
 ! ******************************************************

USE                           Airfoil
USE                           Bedoes
!BJJ Start of proposed change v12.7
!rmUSE                           Blade
!rmUSE                           Element
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!BJJ Start of proposed change v12.7
!rm REAL(ReKi)                 :: ALPHA
!rm REAL(ReKi)                 :: CDA
!rm REAL(ReKi)                 :: CLA
!rm REAL(ReKi)                 :: CMA
!rm REAL(ReKi)                 :: W2
!rm
!rm INTEGER(4)                 :: J
REAL(ReKi),INTENT(IN)      :: ALPHA
REAL(ReKi),INTENT(OUT)     :: CDA
REAL(ReKi),INTENT(OUT)     :: CLA
REAL(ReKi),INTENT(OUT)     :: CMA
REAL(ReKi),INTENT(IN)      :: W2

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!BJJ End of proposed change v12.7

   ! Local Variables:

REAL(ReKi)                 :: AE
REAL(ReKi)                 :: AOD1
REAL(ReKi)                 :: AOL1
REAL(ReKi)                 :: CA
REAL(ReKi)                 :: CDO1
REAL(ReKi)                 :: CNA1
REAL(ReKi)                 :: CNS1
REAL(ReKi)                 :: CNSL1
!BJJ Start of proposed change v12.7
!rmREAL(ReKi)                 :: ETA
!bjj End of proposed change
REAL(ReKi)                 :: P
REAL(ReKi)                 :: SA
REAL(ReKi)                 :: VREL

INTEGER(4)                 :: I
INTEGER(4)                 :: N
INTEGER(4)                 :: NP1



 ! Check to see if element has multiple airfoil tables, then interpolate values
 !  of constants based on the current location.

I = NFOIL(J)

IF (NTables(I) > 1)THEN
!bjj start of proposed change
!rm   CALL LOCATE( MulTabMet, NTables(I), NumFoil, MAXTABLE, MulTabLoc, N, I )
!rm   NP1   = N+1
!rm   P     = (MulTabLoc-MulTabMet(I,N))/(MulTabMet(I,NP1)-MulTabMet(I,N))
!rm
!RM   CNA1  = CNA(I,N) + P * ( CNA(I,NP1) - CNA(I,N) )
!rm   AOL1  = AOL(I,N) + P * ( AOL(I,NP1) - AOL(I,N) )
!rm   CNS1  = CNS(I,N) + P * ( CNS(I,NP1) - CNS(I,N) )
!rm   CNSL1 = CNSL(I,N)+ P * ( CNSL(I,NP1)- CNSL(I,N))
!rm   AOD1  = AOD(I,N) + P * ( AOD(I,NP1) - AOD(I,N) )
!rm   CDO1  = CDO(I,N) + P * ( CDO(I,NP1) - CDO(I,N) )

   MulTabLoc = MIN( MAX( MulTabLoc, MulTabMet(I,1) ), MulTabMet(I,NTables(I)) )
   CALL LocateBin( MulTabLoc, MulTabMet(I,1:NTables(I)), N, NTables(I) )

   IF ( N == 0 ) THEN
      CNA1  = CNA( I,1)
      AOL1  = AOL( I,1)
      CNS1  = CNS( I,1)
      CNSL1 = CNSL(I,1)
      AOD1  = AOD( I,1)
      CDO1  = CDO( I,1)
   ELSE IF ( N == NTables(I) ) THEN
      CNA1  = CNA( I,N)
      AOL1  = AOL( I,N)
      CNS1  = CNS( I,N)
      CNSL1 = CNSL(I,N)
      AOD1  = AOD( I,N)
      CDO1  = CDO( I,N)
   ELSE
      NP1   = N+1
      P     = (MulTabLoc-MulTabMet(I,N))/(MulTabMet(I,NP1)-MulTabMet(I,N))

      CNA1  = CNA(I,N) + P * ( CNA(I,NP1) - CNA(I,N) )
      AOL1  = AOL(I,N) + P * ( AOL(I,NP1) - AOL(I,N) )
      CNS1  = CNS(I,N) + P * ( CNS(I,NP1) - CNS(I,N) )
      CNSL1 = CNSL(I,N)+ P * ( CNSL(I,NP1)- CNSL(I,N))
      AOD1  = AOD(I,N) + P * ( AOD(I,NP1) - AOD(I,N) )
      CDO1  = CDO(I,N) + P * ( CDO(I,NP1) - CDO(I,N) )
   END IF
!bjj end of proposed change

ELSE
   CNA1  = CNA(I,1)
   AOL1  = AOL(I,1)
   CNS1  = CNS(I,1)
   CNSL1 = CNSL(I,1)
   AOD1  = AOD(I,1)
   CDO1  = CDO(I,1)
ENDIF

 ! Jump back if lift-curve slope is zero

IF ( CNA1 == 0.0 ) THEN
   CLA = 0.0
   CDA = CDO1
   RETURN
ENDIF

AN   = ALPHA
VREL = SQRT( W2 )

!bjj start of proopsed change
!rmCALL ATTACH( VREL, J, CNA1, AOL1, AE )
!rm
!rmCALL SEPAR( NLIFT(I), J, I, CNA1, AOL1, CNS1, CNSL1 )
!rm
!rmCALL VORTEX( J, AE )

CALL ATTACH( VREL, J, IBlade, CNA1, AOL1, AE )

CALL SEPAR( NLIFT(I), J, IBlade, I, CNA1, AOL1, CNS1, CNSL1 )

CALL VORTEX( J, IBlade, AE )
!bjj end of proposed change

CA  = COS( AN )
SA  = SIN( AN )
CLA = CN * CA + CC * SA
CDA = CN * SA - CC * CA + CDO1
CMA = PMC



RETURN
END SUBROUTINE BEDDOES


 ! ******************************************************
!bjj start of proposed change
!rm   SUBROUTINE ATTACH( VREL, J, CNA1, AOL1, AE )
   SUBROUTINE ATTACH( VREL, J, IBlade, CNA1, AOL1, AE )
!bjj end of proposed change
 !  PART OF THE BEDDOES DYNAMIC STALL MODEL.
 ! ******************************************************

USE                           AeroTime
USE                           Bedoes
USE                           Blade  !C
!bjj rm NWTC_Lib:USE                           Constant
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.7
!rmREAL(ReKi)                 :: AE
!rmREAL(ReKi)                 :: AOL1
!rmREAL(ReKi)                 :: CNA1
!rmREAL(ReKi)                 :: VREL
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(OUT)     :: AE
REAL(ReKi),INTENT(IN)      :: AOL1
REAL(ReKi),INTENT(IN)      :: CNA1
REAL(ReKi),INTENT(IN)      :: VREL

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: B2
REAL(ReKi)                 :: BS
REAL(ReKi)                 :: CNI
REAL(ReKi)                 :: CNQ
REAL(ReKi)                 :: CO
REAL(ReKi)                 :: DA
REAL(ReKi)                 :: PRP
!bjj rm v12.70-bjj REAL(ReKi)                 :: SAT
REAL(ReKi)                 :: X
REAL(ReKi)                 :: XKA
REAL(ReKi)                 :: XM

LOGICAL,    SAVE           :: SuperSonic = .FALSE.

!rm not used:CHARACTER( 80)             :: Frmt
!rm not used:CHARACTER(150)             :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER( 15), EXTERNAL   :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER( 11), EXTERNAL   :: Int2LStr



IF ( ABS( AN ) <= PIBY2 ) THEN
   ANE(J,IBLADE) = AN
ELSEIF ( AN > PiBy2 ) THEN
   ANE(J,IBLADE) = PI - AN
ELSE
   ANE(J,IBLADE) = - PI - AN
ENDIF


XM  = VREL / AS

 ! Check to see that the element is not supersonic
IF ( .NOT. SuperSonic .AND. XM >= 1.0 ) THEN
!bjj start of proposed change
!rm   MESAGE = ' Blade #'// TRIM(Int2LStr(IBLADE))// &
!rm            ' element #'//TRIM(Int2LStr(J))//' is supersonic! '// &
!rm            ' Other elements are likely supersonic as well.'
!rm   Frmt   = '(A,/,2x,'' Supersonic mach nos. will be set to 0.7 to attempt continuation.'')'
!rm   CALL ErrLog( MESAGE, Frmt, 'ATTACH', 361, 'WARN' )
!rm
!rm   XM = 0.7
!rm   SuperSonic = .TRUE.
   XM = 0.7
   SuperSonic = .TRUE.

   CALL ProgWarn( ' Blade #'//TRIM(Int2LStr(IBLADE))//' element #'//TRIM(Int2LStr(J))//' is supersonic! '//&
                  ' Other elements are likely supersonic as well. Supersonic mach nos. will be set to '//&
                  TRIM(Flt2LStr(XM))//' to attempt continuation.' )
!bjj end of proposed change
ELSEIF (SuperSonic .AND. XM < 1.0) THEN
!bjj start of proposed change
!rm   MESAGE = ' Supersonic condition has subsided with'//&
!rm            ' Blade #'// TRIM(Int2LStr(IBLADE))// &
!rm            ' element #'//TRIM(Int2LStr(J))//'.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog( MESAGE, Frmt, 'ATTACH', 362, 'WARN' )
!rm   SuperSonic = .FALSE.
   SuperSonic = .FALSE.
   CALL ProgWarn( ' Supersonic condition has subsided with Blade #'// TRIM(Int2LStr(IBLADE))// &
                  ' element #'//TRIM(Int2LStr(J))//'.')
!bjj end of proposed change
ENDIF

B2  = 1.0 - XM * XM
DS  = 2. * DT * VREL/C(J)
BS  = B2 * DS
XKA = .75/( ( 1. - XM ) + PI * B2 * XM * XM * 0.413 )
X   = DT * AS / C(J) / XKA
CO  = XKA * C(J) / AS / XM

DA  = ANE(J,IBLADE) - ANE1(J,IBLADE)
ADOT(J,IBLADE) = DA / DT

PRP = ADOT(J,IBLADE) * C(J) / VREL
PRP = SAT( PRP, 0.03, 0.1 )
ADOT(J,IBLADE) = PRP * VREL / C(J)

DN(J,IBLADE) = OLDDN(J,IBLADE) * EXP(-X) + &
               (ADOT(J,IBLADE) - ADOT1(J,IBLADE)) * EXP(-.5*X)
CNI = 4. * CO * ( ADOT(J,IBLADE) - DN(J,IBLADE) )
CMI = -.25 * CNI

QX(J,IBLADE) = (ADOT(J,IBLADE) - ADOT1(J,IBLADE)) * C(J)/VREL/DT
DQ(J,IBLADE) = OLDDQ(J,IBLADE)*EXP(-X) + &
               ( QX(J,IBLADE) - QX1(J,IBLADE) ) * EXP(-.5*X)
CNQ = -CO * (QX(J,IBLADE) - DQ(J,IBLADE))
DQP(J,IBLADE) = DQP1(J,IBLADE) * EXP(-X/XKA) + (QX(J,IBLADE) &
                - QX1(J,IBLADE)) * EXP(-.5*X/XKA)

CMQ = -.25 * CNQ - (XKA*CO/3.) * (QX(J,IBLADE) - DQP(J,IBLADE))

CNIQ = MIN( ABS( CNI+CNQ ), 1. ) * SIGN( 1., CNI+CNQ )

XN(J,IBLADE) = OLDXN(J,IBLADE)*EXP(-.14*BS) + .3*DA*EXP(-.07*BS)
YN(J,IBLADE) = OLDYN(J,IBLADE)*EXP(-.53*BS) + .7*DA*EXP(-.265*BS)

AE   = ANE(J,IBLADE) - YN(J,IBLADE) - XN(J,IBLADE)
CNCP = CNA1 * ( AE - AOL1 )
CNPOT(J,IBLADE) = CNCP + CNIQ
CC   =  CNPOT(J,IBLADE) * AE



RETURN
END SUBROUTINE ATTACH


 ! ******************************************************
!bjj start of proposed change
!rm   SUBROUTINE SEPAR( NFT, J, IFOIL, CNA1, AOL1, CNS1, CNSL1 )
   SUBROUTINE SEPAR( NFT, J, IBlade, IFOIL, CNA1, AOL1, CNS1, CNSL1 )
!bjj end of proposed change
 !  PART OF THE BEDDOES DYNAMIC STALL MODEL
 ! ******************************************************

USE                           Airfoil
USE                           Bedoes
!rmUSE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
!bjj Start of proposed change v12.7
!rmUSE                           Element
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.7
!rmREAL(ReKi)                 :: AOL1
!rmREAL(ReKi)                 :: CNA1
!rmREAL(ReKi)                 :: CNS1
!rmREAL(ReKi)                 :: CNSL1
!rm
!rmINTEGER(4)                 :: IFOIL
!rmINTEGER(4)                 :: J
!rmINTEGER(4)                 :: NFT
REAL(ReKi),INTENT(IN)      :: AOL1
REAL(ReKi),INTENT(IN)      :: CNA1
REAL(ReKi),INTENT(IN)      :: CNS1
REAL(ReKi),INTENT(IN)      :: CNSL1

INTEGER(4),INTENT(IN)      :: IFOIL
INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
INTEGER(4),INTENT(IN)      :: NFT
!bjj End of proposed change

   ! Local Variables:

REAL(ReKi)                 :: AFEP
REAL(ReKi)                 :: AFF
REAL(ReKi)                 :: CMPA
REAL(ReKi)                 :: CMPB
REAL(ReKi)                 :: FSPA
REAL(ReKi)                 :: FSPB
REAL(ReKi)                 :: FSPCA
REAL(ReKi)                 :: FSPCB
REAL(ReKi)                 :: P1
REAL(ReKi)                 :: P2
REAL(ReKi)                 :: SRFP
REAL(ReKi)                 :: SRFPC
REAL(ReKi)                 :: TEMP
REAL(ReKi)                 :: TFE

INTEGER(4)                 :: I1
INTEGER(4)                 :: I1P1
INTEGER(4)                 :: I2
INTEGER(4)                 :: I2P1

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(80)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(15), EXTERNAL    :: Flt2LStr



TFE  = TF
DPP(J,IBLADE)   = OLDDPP(J,IBLADE) * EXP(-DS/TP) &
                 + ( CNPOT(J,IBLADE) - CNPOT1(J,IBLADE) ) * EXP(-.5*DS/TP)
CNP(J,IBLADE)  = CNPOT(J,IBLADE) -   DPP(J,IBLADE)
CNPD(J,IBLADE) = CNP(J,IBLADE) - CNP1(J,IBLADE)

 ! USE CNPD to determine if AOA is increasing or decreasing.
 ! Vortex lift decays more rapidly for decreasing AOA.

IF ( ANE(J,IBLADE) * CNPD(J,IBLADE) < 0. ) THEN
   SHIFT = .TRUE.
ELSE
   SHIFT = .FALSE.
ENDIF

AFF = CNP(J,IBLADE)/CNA1 + AOL1

IF ( ABS( AN ) <= PIBY2 ) THEN
   AFE(J,IBLADE) =  AFF
ELSEIF ( AN > PIBY2 ) THEN
   AFE(J,IBLADE) = PI -  AFF
ELSE
   AFE(J,IBLADE) = -PI -  AFF
ENDIF

CALL MPI2PI ( AFE(J,IBLADE) )

IF ( ( AFE(J,IBLADE) < AL(IFOIL,1) ) .OR.  &
     ( AFE(J,IBLADE) > AL(IFOIL,NLIFT(IFOIL) ) ) ) THEN !bjj compare w/ MIN(MAX()) below.  Is NLIFT(IFOIL)=NFT ? yes!!!
!bjj Start of proposed change AeroDyn v12.70
!rm   MESAGE = ' Angle of attack = '//Flt2LStr(REAL( AFE(J,IBLADE)*RtoD, ReKi ))// &
!rm            ' is outside table.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog( MESAGE, Frmt, 'Separ', 401, 'FAULT' )
   CALL ProgAbort( ' Angle of attack = '//Flt2LStr(REAL( AFE(J,IBLADE)*R2D, ReKi ))// &
                   ' is outside table.' )
!bjj End of proposed change AeroDyn v12.70
ENDIF

!bjj start of proposed change
!rmCALL LOCATE( AL, NFT, NumFoil, NumCL, AFE(J,IBLADE), I1, IFOIL )
AFE(J,IBLADE) = MIN( MAX( AFE(J,IBLADE), AL(IFOIL,1) ), AL(IFOIL,NFT) )
CALL LocateBin( AFE(J,IBLADE), AL(IFOIL,1:NFT), I1, NFT )

IF (I1 == 0) THEN
   I1 = 1
ELSE IF ( I1 == NFT ) THEN
   I1 = I1 - 1
END IF

!bjj end of proposed change

I1P1 = I1 + 1

P1 = ( AL(IFOIL,I1) - AFE(J,IBLADE) ) / ( AL(IFOIL,I1) - AL(IFOIL,I1P1) )

IF ( NTables(IFOIL) > 1 ) THEN

 ! Locate the multiple airfoil position in the table

!bjj start of proposed change
!rm   CALL LOCATE (MulTabMet,NTables(IFOIL),NumFoil,MAXTABLE,MulTabLoc,I2,IFOIL)
!RM
!RM   I2P1 = I2 + 1
!RM
!RM   P2=(MulTabLoc-MulTabMet(IFOIL,I2))/(MulTabMet(IFOIL,I2P1)-MulTabMet(IFOIL,I2))

   MulTabLoc = MIN( MAX( MulTabLoc, MulTabMet(IFOIL,1) ), MulTabMet(IFOIL,NTables(IFOIL)) )
   CALL LocateBin( MulTabLoc, MulTabMet(IFOIL,1:NTables(IFOIL)),I2,NTables(IFOIL) )

   IF ( I2 == 0 ) THEN
      I2   = 1
      I2P1 = 2
      P2   = 0.0
   ELSE IF ( I2 == NTables(IFOIL) ) THEN
      I2P1 = I2
      I2   = I2 - 1

      P2   = 1.0
   ELSE
      I2P1 = I2 + 1

      P2=(MulTabLoc-MulTabMet(IFOIL,I2))/(MulTabMet(IFOIL,I2P1)-MulTabMet(IFOIL,I2))
   END IF
!bjj end of proposed change

 ! Interpolate the F-table values


   FSPB  = FTB( IFOIL,I1,I2P1) - (FTB( IFOIL,I1,I2P1) - FTB( IFOIL,I1P1,I2P1) ) * P1
   FSPCB = FTBC(IFOIL,I1,I2P1) - (FTBC(IFOIL,I1,I2P1) - FTBC(IFOIL,I1P1,I2P1) ) * P1
   FSPA  = FTB( IFOIL,I1,I2  ) - (FTB( IFOIL,I1,I2  ) - FTB( IFOIL,I1P1,I2  ) ) * P1
   FSPCA = FTBC(IFOIL,I1,I2  ) - (FTBC(IFOIL,I1,I2  ) - FTBC(IFOIL,I1P1,I2  ) ) * P1

   FSP(J,IBLADE) = FSPA  + P2 * (FSPB-FSPA)

   FSPC(J,IBLADE)= FSPCA + P2 * (FSPCB-FSPCA)

ELSE

   FSP(J,IBLADE) = FTB(IFOIL,I1,1) - (FTB(IFOIL,I1,1) - FTB(IFOIL,I1P1,1) ) * P1

   FSPC(J,IBLADE)= FTBC(IFOIL,I1,1) - (FTBC(IFOIL,I1,1) - FTBC(IFOIL,I1P1,1) ) * P1

ENDIF

IF ( ABS( AFE(J,IBLADE) - AOL1 ) < 1.E-10 ) THEN
   FSP(J,IBLADE)  = 1.0
   FSPC(J,IBLADE) = 1.0
ELSE
   TEMP = 2.*SQRT(ABS(FSP(J,IBLADE)/(AFE(J,IBLADE)-AOL1)))-1.
   FSP(J,IBLADE) = TEMP * TEMP * SIGN ( 1., TEMP )
   IF ( FSP(J,IBLADE) >  1.0 ) FSP(J,IBLADE) =  1.0
   IF ( FSP(J,IBLADE) < -1.0 ) FSP(J,IBLADE) = -1.0

   IF ( ABS( AFE(J,IBLADE) ) < 1.E-10 ) THEN
      FSPC(J,IBLADE) = 1.0
   ELSE
      TEMP = FSPC(J,IBLADE)/((AFE(J,IBLADE)-AOL1)*AFE(J,IBLADE))
      FSPC(J,IBLADE) = TEMP * TEMP * SIGN ( 1., TEMP )
      IF ( FSPC(J,IBLADE) >  1.0 ) FSPC(J,IBLADE) =  1.0
      IF ( FSPC(J,IBLADE) < -1.0 ) FSPC(J,IBLADE) = -1.0
   ENDIF

ENDIF

IF ( CNP(J,IBLADE) > CNS1  ) BEDSEP(J,IBLADE) = .TRUE.
IF ( CNP(J,IBLADE) < CNSL1 ) BEDSEP(J,IBLADE) = .TRUE.

IF ( BEDSEP(J,IBLADE) ) TAU(J,IBLADE) = OLDTAU(J,IBLADE) + DS/TVL

IF (SHIFT) TFE = 1.5*TFE

DF(J,IBLADE) = OLDDF(J,IBLADE) * EXP(-DS/TFE)  &
              + (FSP(J,IBLADE) - FSP1(J,IBLADE)) * EXP(-.5*DS/TFE)
DFC(J,IBLADE)= OLDDFC(J,IBLADE) * EXP(-DS/TFE) &
              + (FSPC(J,IBLADE) - FSPC1(J,IBLADE)) * EXP(-.5*DS/TFE)

FP   = FSP(J,IBLADE) - DF(J,IBLADE)
FPC  = FSPC(J,IBLADE) - DFC(J,IBLADE)
SRFP = SQRT( ABS(FP) )  * SIGN( 1., FP ) + 1.
SRFPC= SQRT( ABS(FPC) ) * SIGN( 1.,FPC )

FK   = 0.25 * SRFP * SRFP
CN   = CNCP * FK + CNIQ

CC   =  CC * SRFPC

DFAFE(J,IBLADE) = DFAFE1(J,IBLADE) * EXP(-DS/(.1*TFE)) &
                 + (AFE(J,IBLADE) - AFE1(J,IBLADE)) * EXP(-.5*DS/(.1*TFE))

AFEP=AFE(J,IBLADE) - DFAFE(J,IBLADE)

!BJJ start of proposed change
!rmCALL LOCATE( AL, NFT, NumFoil, NumCL, AFEP, I1, IFOIL )
!rm
!rmI1P1 = I1 + 1
!rm
!rmP1 = (AL(IFOIL,I1) - AFEP)/(AL(IFOIL,I1) - AL(IFOIL,I1P1))

AFEP = MIN( MAX( AFEP, AL(IFOIL,1) ), AL(IFOIL,NFT) )
CALL LocateBin( AFEP, AL(IFOIL,1:NFT), I1, NFT )

IF (I1 == 0) THEN
   I1   = 1
   I1P1 = 2
   P1   = 0.0
ELSEIF ( I1 == NFT ) THEN
   I1P1 = I1
   I1   = I1 - 1
   P1   = 1.0
ELSE
   I1P1 = I1 + 1
   P1 = (AL(IFOIL,I1) - AFEP)/(AL(IFOIL,I1) - AL(IFOIL,I1P1))
END IF
!bjj end of proposed change


IF (NTables(IFOIL) > 1) THEN

 ! Interpolate the F-table values

   CMPB = CM(IFOIL,I1,I2P1) - (CM(IFOIL,I1,I2P1) - CM(IFOIL,I1P1,I2P1) ) * P1

   CMPA = CM(IFOIL,I1,I2) - (CM(IFOIL,I1,I2) - CM(IFOIL,I1P1,I2) ) * P1

   PMC = CMPA  + P2*(CMPB-CMPA)

ELSE

   PMC = CM(IFOIL,I1,1) - ( (CM(IFOIL,I1,1) - CM(IFOIL,I1P1,1) ) * P1 )

ENDIF



RETURN
END SUBROUTINE SEPAR


 ! ******************************************************
!bjj start of proposed change
!rm   SUBROUTINE VORTEX( J, AE )
   SUBROUTINE VORTEX( J, IBlade, AE )
!bjj end of proposed change
 !  PART OF THE BEDDOES DYNAMIC STALL MODEL
 ! ******************************************************

USE                           Airfoil
USE                           Bedoes
!rmUSE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.7
!rmREAL(ReKi)                 :: AE
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(IN)      :: AE

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!bjj End of proposed change v12.7

   ! Local Variables:

REAL(ReKi)                 :: CMV
REAL(ReKi)                 :: TSH
REAL(ReKi)                 :: TVE



TVE = TV
CVN(J,IBLADE) = CNCP * ( 1. - FK )

IF ( TAU(J,IBLADE) < 1. ) THEN
   VOR = .TRUE.
   IF (SHIFT) VOR = .FALSE.
ELSE
   VOR = .FALSE.
ENDIF

IF (VOR) THEN
   CNV(J,IBLADE) = OLDCNV(J,IBLADE) * EXP(-DS/TVE)  &
                 + (CVN(J,IBLADE) - CVN1(J,IBLADE)) * EXP(-.5*DS/TVE)
ELSE
   CNV(J,IBLADE) = OLDCNV(J,IBLADE) * EXP(-DS/(TVE*.5))
ENDIF

CN  = CN + CNV(J,IBLADE)
CC  = CC + CNV(J,IBLADE) * AE * (1.- TAU(J,IBLADE))
CMV = -0.2 * (1. - COS(PI*TAU(J,IBLADE)) ) * CNV(J,IBLADE)
PMC = PMC + CMV + CMI + CMQ

TSH = 2.*(1.- FP)/.19

IF ( TAU(J,IBLADE) .GT. 1. + TSH/TVL .AND. .NOT. SHIFT) THEN
   TAU(J,IBLADE) = 0.
   BEDSEP(J,IBLADE) = .FALSE.
ENDIF

IF ( TAU(J,IBLADE) .GT. 1. ) THEN
   IF ( ANE(J,IBLADE) .LT. 0. ) THEN

      IF (CNPD(J,IBLADE) .LE. 0. .AND. CNPD1(J,IBLADE) .GE. 0.) THEN
         BEDSEP(J,IBLADE) = .FALSE.
         TAU(J,IBLADE) = 0.
      ENDIF

      IF (ANE1(J,IBLADE) .GT. 0.) THEN
         BEDSEP(J,IBLADE) = .FALSE.
         TAU(J,IBLADE) = 0.
      ENDIF

   ELSE

      IF (CNPD(J,IBLADE) .GE. 0. .AND. CNPD1(J,IBLADE) .LE. 0.) THEN
         BEDSEP(J,IBLADE) = .FALSE.
         TAU(J,IBLADE) = 0.
      ENDIF

      IF (ANE1(J,IBLADE) .LT. 0.) THEN
         BEDSEP(J,IBLADE) = .FALSE.
         TAU(J,IBLADE) = 0.
      ENDIF

   ENDIF
ENDIF



RETURN
END SUBROUTINE VORTEX


 ! ******************************************************
!bjj start of proposed change
!rm   SUBROUTINE CLCD( ALPHA, CLA, CDA, CMA, J )
   SUBROUTINE CLCD( ALPHA, CLA, CDA, CMA, I, ErrStat )
!bjj end of proposed change
 !  returns values of lift and drag coeffs.
 !   This subroutine interpolates airfoil coefficients
 !   from a table of airfoil data.  The table must consist
 !   of ALPHA, CL and CD over the entire range of angles
 !   that will be encountered.
 !
 ! VARIABLES:
 !    CLA      = Returned value of lift coefficient
 !    CDA      = Returned value of drag coeff
 !    CMA      = Returned value of pitching moment coeff
 !    ALPHA    = Angle of attack (radians)
 !    AL       = Array containing the angle of attack
 !    CL       = Array containing the lift coeffs. at AL(I)
 !    CD       = Array containing the drag coeffs. at AL(I)
 !    CM       = Array containing the moment coeffs. at AL(I)
!bjj replace: !    J        = Index identifying the blade element
!BJJ RM       !    NFOIL(J) = Airfoil ID for this element
 !    I        = Airfoil ID for this element, equal to NFoil(J), where J is the index identifying the blade element
 !    MulTabLoc= Multiple airfoil table location for this element
 !    MulTabMet= Array containing the multiple airfoil table metric
 ! ******************************************************


USE                           Airfoil
!rmUSE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
!bjj Start of proposed change v12.70
!rmUSE                           Element
!bjj End of proposed change
!bjj rm v12.70-bjj: USE                           Precision
!bjj Start of proposed change v12.70
!rmUSE                           Switch
!bjj End of proposed change v12.70


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: ALPHA
!rmREAL(ReKi)                 :: CDA
!rmREAL(ReKi)                 :: CLA
!rmREAL(ReKi)                 :: CMA
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(INOUT)   :: ALPHA
REAL(ReKi),INTENT(OUT)     :: CDA
REAL(ReKi),INTENT(OUT)     :: CLA
REAL(ReKi),INTENT(OUT)     :: CMA

INTEGER(4),INTENT(IN)      :: I      ! NFOIL(J)
INTEGER,   INTENT(OUT)     :: ErrStat
!bjj End of proposed change v12.70

   ! Local Variables:

REAL(ReKi)                 :: CDA1
REAL(ReKi)                 :: CDA2
REAL(ReKi)                 :: CLA1
REAL(ReKi)                 :: CLA2
REAL(ReKi)                 :: CMA1
REAL(ReKi)                 :: CMA2
REAL(ReKi)                 :: P1
REAL(ReKi)                 :: P2

!BJJ RM: INTEGER(4)                 :: I
INTEGER(4)                 :: N1
INTEGER(4)                 :: N1P1
INTEGER(4)                 :: N2
INTEGER(4)                 :: N2P1
INTEGER(4)                 :: NTAB

!bjj rm:CHARACTER(60)              :: Frmt
!bjj rm:CHARACTER(80)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(15), EXTERNAL    :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL    :: Int2LStr

!bjj Start of proposed change
IF (.NOT. ALLOCATED(NFoil) ) THEN
   CDA = 0
   CLA = 0
   CMA = 0
   ErrStat = 1
   RETURN
ELSE
   ErrStat = 0
END IF
!bjj end of proposed change

!BJJ RM: I    = NFOIL(J)
NTAB = NLIFT(I)

IF ( ( ALPHA < AL(I,1) ) .OR. ( ALPHA > AL(I,NTAB) ) )   THEN
!bjj Start of proposed change AeroDyn v12.70
!rm   MESAGE = ' Angle of attack = '//TRIM(Flt2LStr(REAL( ALPHA*RtoD, ReKi )))// &
!rm            ' is outside data table range.'
!rm   Frmt   = "(A, /2x,'Blade number     ', /2x,'Element number   ')"
!rm   WRITE(Frmt(25 :26 ),'(A2 )')TRIM(Int2LStr(IBLADE))
!rm   WRITE(Frmt(50 :51 ),'(A2 )')TRIM(Int2LStr(J))
!rm   CALL ErrLog( MESAGE, Frmt, 'CLCD', 431, 'FAULT' )
!bjj: This error message isn't necessarially accurate:
   CALL ProgAbort( ' Angle of attack = '//TRIM(Flt2LStr(ALPHA*R2D))// &
                   ' deg is outside data table range. '// & !Blade #'//TRIM(Int2LStr(IBLADE))//&
                   ' Airfoil '//TRIM(Int2LStr(I))//'.' )
!                   ' element '//TRIM(Int2LStr(J))//'.' )

   ErrStat = 1
!bjj End of proposed change AeroDyn v12.70
ENDIF

!BJJ start of proposed change
!rmCALL LOCATE (AL, NTAB, NumFoil, NumCL, ALPHA, N1, I )
!rm
!rmN1P1 = N1 + 1
!rm
!rmP1   = ( ALPHA - AL(I, N1) )/( AL(I, N1P1) - AL(I, N1) )

ALPHA = MIN( MAX( ALPHA, AL(I,1) ), AL(I,NTAB) )
CALL LocateBin (ALPHA, AL(I,1:NTAB), N1, NTAB )

IF (N1 == 0) THEN
   N1   = 1
   N1P1 = 2
   P1   = 0.0
ELSEIF(N1 == NTAB) THEN
   N1P1 = N1
   N1   = N1 - 1
   P1   = 1.0
ELSE
   N1P1 = N1 + 1
   P1   = ( ALPHA - AL(I, N1) )/( AL(I, N1P1) - AL(I, N1) )
END IF
!bjj end of proposed change

 ! If the element has multiple airfoil tables, do a 2-D linear interpolation
 !  for Cl and CD

IF (NTables(I) > 1) THEN

!BJJ start of proposed change
!RM   CALL LOCATE (MulTabMet,NTables(I),NumFoil,MAXTABLE,MulTabLoc,N2,I)
!RM
!RM   N2P1 = N2 + 1

   MulTabLoc = MIN( MAX( MulTabLoc, MulTabMet(I,1) ), MulTabMet(I,NTables(I)) )
   CALL LocateBin (MulTabLoc, MulTabMet(I,1:NTables(I)),N2,NTables(I))

   IF (N2 == 0) THEN
      N2   = 1
      N2P1 = 2
      P2   = 0.0
   ELSE IF ( N2 == NTables(I) ) THEN
      N2P1 = N2
      N2   = N2 - 1
      P2   = 1.0
   ELSE
      N2P1 = N2 + 1
      P2   = (MulTabLoc - MulTabMet(I,N2))/(MulTabMet(I,N2P1)-MulTabMet(I,N2))
   END IF
!BJJ END of proposed change

   CLA1 = CL(I,N1,N2) + P1 * ( CL(I,N1P1,N2) - CL(I,N1,N2) )
   CDA1 = CD(I,N1,N2) + P1 * ( CD(I,N1P1,N2) - CD(I,N1,N2) )
   CMA1 = CM(I,N1,N2) + P1 * ( CM(I,N1P1,N2) - CM(I,N1,N2) )

!BJJ start of proposed change
!RM   P2   = (MulTabLoc - MulTabMet(I,N2))/(MulTabMet(I,N2P1)-MulTabMet(I,N2))
!BJJ END of proposed change
   CLA2 = CL(I,N1,N2P1) + P1 * ( CL(I,N1P1,N2P1) - CL(I,N1,N2P1) )
   CDA2 = CD(I,N1,N2P1) + P1 * ( CD(I,N1P1,N2P1) - CD(I,N1,N2P1) )
   CMA2 = CM(I,N1,N2P1) + P1 * ( CM(I,N1P1,N2P1) - CM(I,N1,N2P1) )

   CLA = CLA1 + P2 * ( CLA2 - CLA1 )
   CDA = CDA1 + P2 * ( CDA2 - CDA1 )
   CMA = CMA1 + P2 * ( CMA2 - CMA1 )

ELSE

   CLA  = CL(I,N1,1) + P1 * ( CL(I,N1P1,1) - CL(I,N1,1) )
   CDA  = CD(I,N1,1) + P1 * ( CD(I,N1P1,1) - CD(I,N1,1) )
   CMA  = CM(I,N1,1) + P1 * ( CM(I,N1P1,1) - CM(I,N1,1) )

ENDIF


RETURN
END SUBROUTINE CLCD

!bjj start of proposed change
! replace with routine in NWTC library
! ! *************************************************
!   SUBROUTINE LOCATE( XX, N, MAXROW, MAXCOL, X, J, I )
! !  finds position in a table
! !
! !  See NUMERICAL RECIPES by PRESS, ET AL, page 89.
! !  Simplified to work only with monotonically increasing
! !   values of XX in the table. AC Hansen 10/88.
! !
! !  VARIABLES:
! !    XX      = Array (angles of attack in table)
! !    N       = Number of entries in the table
! !    X       = Given value of angle of attack
! !    I       = Index identifying the airfoil section table
! !    J       = Index position of X in table
! !  J is such that X is between XX(J) and XX(J+1)
! !
! ! *************************************************
!
!!bjj rm v12.70-bjj: USE                           Precision
!
!
!IMPLICIT                      NONE
!
!
!   ! Passed Variables:
!
!!bjj Start of proposed change v12.70
!!rm INTEGER(4)                 :: I
!!rm INTEGER(4)                 :: J
!!rm INTEGER(4)                 :: N
!!rm INTEGER(4)                 :: MAXCOL
!!rm INTEGER(4)                 :: MAXROW
!!rm
!!rm REAL(ReKi)                 :: X
!!rm REAL(ReKi)                 :: XX(MAXROW,MAXCOL)
!
!INTEGER(4), INTENT(IN)     :: I                    ! Index identifying the airfoil section table
!INTEGER(4), INTENT(OUT)    :: J                    ! Index position of X in table
!INTEGER(4), INTENT(IN)     :: N                    ! Number of entries in the table
!INTEGER(4), INTENT(IN)     :: MAXCOL               ! Size of XX array, dimension 2
!INTEGER(4), INTENT(IN)     :: MAXROW               ! Size of XX array, dimension 1
!
!REAL(ReKi), INTENT(INOUT)  :: X                    ! Given value of angle of attack
!REAL(ReKi), INTENT(IN)     :: XX(MAXROW,MAXCOL)    ! Array (angles of attack in table)
!!bjj end of proposed change
!
!   ! Local Variables:
!
!INTEGER(4)                 :: JL
!INTEGER(4)                 :: JM
!INTEGER(4)                 :: JU
!
!
!
!JL = 0
!JU = N+1
!
!DO WHILE ( JU - JL > 1 )
!   JM = ( JU + JL )/2
!
!   IF ( X >= XX(I,JM) ) THEN
!      JL = JM
!   ELSE
!      JU = JM
!   ENDIF
!
!END DO
!
!J = JL
!
!IF ( J <= 0 ) THEN
!   J = 1
!   X = XX(I,1)
!ELSEIF ( J >= N ) THEN
!   J = N-1
!   X = XX(I,N)
!ENDIF
!
!
!
!RETURN
!END SUBROUTINE LOCATE
!bjj end of proposed change

 ! **************************************************
   FUNCTION SAT( X, VAL, SLOPE )
 !  AOA saturation function 02/15/98
 ! **************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:

REAL(ReKi)                 :: SAT
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: SLOPE
!rmREAL(ReKi)                 :: VAL
!rmREAL(ReKi)                 :: X
REAL(ReKi),INTENT(IN)       :: SLOPE
REAL(ReKi),INTENT(IN)       :: VAL
REAL(ReKi),INTENT(IN)       :: X
!bjj End of proposed change v12.70


IF ( ABS(X) <= VAL )  THEN
    SAT = X
ELSEIF ( X > VAL)  THEN
    SAT = SLOPE * X + VAL * ( 1. - SLOPE )
ELSE
    SAT = SLOPE * X - VAL * ( 1. - SLOPE )
ENDIF


RETURN
END FUNCTION SAT


 ! **************** Dynamic Inflow Subroutines ***************
 !
 !  Generalized Dynamic Wake (GDW) Model replaced the Pitt &
 !   Peters model.
 !   A. Suzuki, 06/23/00

 ! Subroutine VG2ROTOR was added again to v11.31
 !  A. Suzuki, 01/24/00

 !
 !  Modified for FFWIND. Subroutine VG2ROTOR was added.
 !   A. Suzuki, 11/05/99.

 !  This model is based on Pitt & Peters model.
 !   AB predictor-corrector is used for integration.
 !   A. Suzuki, 07/22/98.
 !
 ! *************************************************************

 ! **************************************

   SUBROUTINE Inflow()

 ! Gateway to the dynamic inflow routines.
 ! Called by NEWTIME after a time step.
 ! **************************************


USE               AeroTime
USE               DynInflow
!bjj rm:USE               Identify
USE               Switch


IMPLICIT          NONE



!bjj start of proposed change
!rmSELECT CASE (TRIM(DynProg))
!rm   CASE ('YawDyn')
!rm
!rm ! Calculate the inflow distribution parameters.
!rm      IF ( DYNINFL ) THEN
!rm         CALL INFUPDT
!rm         CALL GetPhiLq
!rm         CALL INFDIST
!rm      ELSEIF (DYNINIT) THEN
!rm         CALL INFUPDT
!rm         CALL GetPhiLq
!rm      ENDIF
!rm
!rm   CASE DEFAULT
!bjj end of proposed change
      IF ( DYNINFL ) THEN

 ! INITIALIZE DYNAMIC INFLOW PARAMETERS
         IF ( DYNINIT .AND. ( TIME > 0.0D0 ) ) THEN
            CALL INFINIT
            !WRITE(*,*) 'Activating dynamic inflow calculation'
            old_Alph = 0.0
            old_Beta = 0.0
            DYNINIT = .FALSE.
            SKEW = .FALSE.
         ENDIF

 ! Update the dynamic inflow parameters
         CALL INFUPDT
         CALL GetPhiLq
 ! Calculate the dynamic inflow paremeters for the new time step
         IF( TIME > 1.0D0 ) CALL INFDIST

      ENDIF   ! DYNINFL

!bjj start of proposed change
!rmEND SELECT
!bjj end of proposed change



RETURN
END SUBROUTINE Inflow


 ! **************************************

!bjj start of proposed change
!rm   SUBROUTINE GetRM (rLocal, DFN, DFT, psi, J)
   SUBROUTINE GetRM (rLocal, DFN, DFT, psi, J, IBlade)
!bjj end of proposed change

 ! Returns RM(MODE), the [mode]-th moment of the blade normal force.
 !  Here, the force is in [N/m], while the moment arm is
 !  non-dimensional (RLOCAL/R).  Also see FUNCTION XPHI.
 ! Called as each element is processed by AeroDyn.
 ! **************************************


USE                           Blade
!bjj Start of proposed change 12.70
!rmUSE                           Constant
!bjj End of proposed change
USE                           DynInflow
!bjj rm v12.70-bjj: USE                           Precision
USE                           Switch


IMPLICIT                      NONE


   ! Passed Variables:
!BJJ Start of proposed change v12.7
!rmREAL(ReKi)                 :: DFN
!rmREAL(ReKi)                 :: DFT
!rmREAL(ReKi)                 :: psi
!rmREAL(ReKi)                 :: rLocal
!rm
!rmINTEGER(4)                 :: J
REAL(ReKi),INTENT(IN)      :: DFN
REAL(ReKi),INTENT(IN)      :: DFT
REAL(ReKi),INTENT(IN)      :: psi
REAL(ReKi),INTENT(IN)      :: rLocal

INTEGER,   INTENT(IN)      :: J
INTEGER,   INTENT(IN)      :: IBlade
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: fElem
! psiBar is Suzuki's, WindPsi is Shawler's
!REAL(ReKi)                :: psiBar
REAL(ReKi)                 :: Rzero
REAL(ReKi)                 :: WindPsi
!bjj rm v12.70-bjj: REAL(ReKi)                 :: XPHI

INTEGER(4)                 :: mode



IF ( SWIRL ) THEN
   fElem = SQRT( DFN * DFN + DFT * DFT )
ELSE
   fElem = DFN
ENDIF
fElem = fElem / R

Rzero = rLocal / R
! Suzukis inflow azimuth measure
!psiBar = - psi - piBy2
! Shawler: wind based inflow azimuth measure
CALL WindAzimuthZero (psi,WindPsi)

! Save values rotor loads for USE in Newtime (to accumulate rotor loads)
DO mode = 1, MAXINFL0
   RMC_SAVE(IBLADE, J, mode) = fElem * XPHI( Rzero, mode )
END DO ! mode

!+++++++++++++++++++++++++++++++++++++++++++++++++++++
!Suzuki's method
!DO mode = MAXINFL0+1, maxInfl
!   RMC_SAVE(IBLADE, J, mode) = fElem * XPHI( Rzero, mode )  * COS( REAL(MRvector(mode)) * psiBar )
!   RMS_SAVE(IBLADE, J, mode) = fElem * XPHI( Rzero, mode )  * SIN( REAL(MRvector(mode)) * psiBar )
!END DO ! mode
! Shawler's method
DO mode = MAXINFL0+1, maxInfl
   RMC_SAVE(IBLADE, J, mode) = fElem * XPHI( Rzero, mode )  * COS( REAL(MRvector(mode)) * Windpsi )
   RMS_SAVE(IBLADE, J, mode) = fElem * XPHI( Rzero, mode )  * SIN( REAL(MRvector(mode)) * Windpsi )
END DO ! mode
!++++++++++++++++++++++++++++++++++++++++++++++++++++++



RETURN
END SUBROUTINE GetRM


 ! **************************************

   SUBROUTINE GetPhiLq

 ! Accumulate the rotor forces for dynamic inflow calculations
 !  PhiLqC is Lq times PHI (shape function) in COS equation.
 !  PhiLqS is Lq times PHI (shape function) in SIN equation.
 !  RM?_SAVE, which were calculated for each element,
 !   are summed here after a time step.
 ! **************************************

USE            Blade
USE            DynInflow
USE            Element


IMPLICIT       NONE


INTEGER(4)  :: iblad
INTEGER(4)  :: ielem
INTEGER(4)  :: mode



PhiLqC = 0.
PhiLqS = 0.

DO mode = 1, maxInfl
   DO iblad = 1, NB
      DO ielem = 1, NELM
         PhiLqC(mode) = PhiLqC(mode) + RMC_SAVE(iblad, ielem, mode)
         IF (mode >= maxInfl0+1) &
         PhiLqS(mode) = PhiLqS(mode) + RMS_SAVE(iblad, ielem, mode)
      END DO !ielem
   END DO !iblad
END DO !mode



RETURN
END SUBROUTINE GetPhiLq


 ! *************************************************************
   SUBROUTINE infinit
 !  Initializes the variables in the dynamic inflow equation.
 !  Called only once to initialize the GDW parameters.
 ! *************************************************************


USE                           AeroTime
USE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
USE                           DynInflow
USE                           Element
!bjj rm v12.70-bjj: USE                           Precision
USE                           Rotor
USE                           Wind


IMPLICIT                      NONE


   ! Local Variables:

!bjj rm v12.70-bjj: REAL(ReKi)                 :: FGAMMA
!bjj rm v12.70-bjj: REAL(ReKi)                 :: HFUNC
REAL(ReKi)                 :: tauCos ( maxInfl )
REAL(ReKi)                 :: tauSin ( maxInfl0+1 : maxInfl )
REAL(ReKi)                 :: v1
REAL(ReKi)                 :: v2
REAL(ReKi)                 :: v3
REAL(ReKi)                 :: Vplane2

INTEGER(4)                 :: i
INTEGER(4)                 :: iElem
INTEGER(4)                 :: irow
INTEGER(4)                 :: jBlade
INTEGER(4)                 :: jcol
INTEGER(4)                 :: k
INTEGER(4)                 :: mode

!DJL Start of proposed change - 12.53b-djl
! Try normalizing by wind speed instead of TipSpeed
!REAL(ReKi)                 :: VH !horizontal wind speed
!REAL(ReKi)                 :: VD !horizontal wind direction - not used

 ! Get the hub-height horizontal wind speed, VH
!CALL GetVH (VH, VD)
!DJL End of proposed change



 ! Initialize the MRvector & NJVector.
 !  MRvector is the azimuthal mode of the inflow distribution.
 !  NJvector is the radial mode of the inflow distribution.

MRVector(:) = (/ 0, 0, 1, 1, 2, 3 /)  !bjj why aren't these parameters?
NJVector(:) = (/ 1, 3, 2, 4, 3, 4 /)

 ! For your reference,
 !  Marray(irow,jcol) = MRvector(jcol)
 !  Rarray(irow,jcol) = MRvector(irow)
 !  Narray(irow,jcol) = NJvector(jcol)
 !  Jarray(irow,jcol) = NJvector(irow)

 ! Initialize the time derivatives.
dAlph_dt(:,:) = 0.
dBeta_dt(:,:) = 0.

 ! Set up the constants.
 !  xMinv is [M]^-1.  Because [M]^-1 is just a diagonal matrix,
 !  it is stored as a column vector.
DO irow = 1, maxInfl
   xMinv(irow) = PIBY2 / hfunc(MRvector(irow), NJvector(irow))   !bjj: this is really just a parameter, too.
END DO !irow

 ! Set up the GAMMA matrix which is used to calculate [L] matrix.
 !  FUNCTION FGAMMA is called.
DO irow = 1, maxInfl
   DO jcol = 1, maxInfl
      gamma( irow, jcol )  &
           = fgamma( MRvector( irow ), NJvector( irow ),  &
                     MRvector( jcol ), NJvector( jcol )  )        !bjj: this is really just a parameter, too.
   END DO !jcol
END DO !irow

 ! calculate and store the M-R matrices, which are used in Subroutine LMATRIX.
DO irow = 1, maxInfl
   DO jcol = 1, maxInfl
      MminR  (irow,jcol) = MIN( MRvector(jcol) , MRvector(irow) ) !bjj: this is really just a parameter, too.
      MplusR (irow,jcol) =      MRvector(jcol) + MRvector(irow)   !bjj: this is really just a parameter, too.
      MminusR(irow,jcol) = ABS( MRvector(jcol) - MRvector(irow) ) !bjj: this is really just a parameter, too.
   END DO !jcol
END DO !irow

 ! Calculate the tip speed of the rotor. This isn't constant in ADAMS.
 !  Thus, it will be updated at every time step in ADAMS.
!DJL Start of proposed change - 12.53b-djl
! Try normalizing by horizontal wind speed instead of TipSpeed
TipSpeed = MAX(r * revs, 1.0e-6)
!TipSpeed = 1.0
!DJL TipSpeed = MAX(VH, 1.0e-6)
!DJL End of proposed change

 ! Calculate the disk loading normalization factor.
 !  This is not exactly pressure but let's call it P0.
 !  The actual unit is [N/m] or [Pa*m].
 !    Pzero = PI * AirDensity * (Rotational Speed)^2 * (Radius)^3
 !    Pzero = pi * rho * revs**2 * r**3
 !    Pzero = pi * rho * revs * revs * r * r * r
Pzero = pi * rho * TipSpeed * TipSpeed * r
 ! Non-dimensional time
DT0   = DT * REVS !bjj: this isn't used in this subroutine?

 ! Calculate the initial values of inflow distribution parameters

 ! Calculate the non-dimensional wind velocity components.

v1 =   VrotorZ / TipSpeed     !inplane, upward
v2 =   VrotorY / TipSpeed     !inplane, right looking downwind
v3 = - VrotorX / TipSpeed     !out-of-plane, normal to the rotor

 ! Calculate the initial value of lambda_m by taking the average
 !  of the induction factors(A). The A's are calculated by
 !  momentum balance during the first rotation of the trim solution.
xLambda_M = 0.
DO jBlade=1,nb
   DO iElem =1,nelm
      xLambda_M = xLambda_M + a(iElem,jBlade)
   END DO !iElem
END DO !jBlade
xLambda_M = xLambda_M / ( nb * nelm )

 ! A's are normalized by the normal wind speed, while Lambda's are
 !  mormalized by the tip speed. Make the conversion.
 !  xLambda_M = xLambda_M * (-VrotorX/TipSpeed)
xLambda_M = xLambda_M * v3

 ! totalInf is the non-dimensional total wind speed normal to the rotor.
totalInf = - v3 + xLambda_M
 ! Vplane2 is the square of in-plane component of the non-dimensional
 !  wind velocity.
Vplane2 = v1 * v1 + v2 * v2
 ! VTOTAL is the total wind speed at the rotor.
Vtotal  = SQRT( totalInf * totalInf + Vplane2 )
 ! VPARAM is the velocity parameter.
Vparam  =( Vplane2 + ( totalInf + old_LmdM ) * totalInf ) / Vtotal

 ! Calculate the disk skew angle function using the effective disk angle
 !  of attack.
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! Shawler - USE the single wake skew angle, squared variable means its always positive
 ! and because blade azimuth position is measured using windpsi the wake skew
 ! is defined in the right direction relative to the oncoming wind,
 ! ie directly downwind.
 !Suzuki:
!xKaiC = TAN( .5 * ATAN( -v2 / totalInf ) )
!xKaiS = TAN( .5 * ATAN(  v1 / totalInf ) )
 !xkai = TAN( .5 * SIGN( ATAN( SQRT( vplane2 ) / totalInf ), v2 ) )
 !Shawler:
xkai = TAN( .5 * ATAN( SQRT( Vplane2 ) / totalInf ) )
 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ! To calculate the initial values of xAlpha & xBeta, get [L] matrices
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! Suzuki:
!CALL LMATRIX ( xKaiC, 1 )
!CALL LMATRIX ( xKaiS, 2 )
 ! Shawler:
CALL LMATRIX ( xKai, 1 )
CALL LMATRIX ( xKai, 2 )
! CALL LMATRIX ( xkai )
 ! Here we need [L_cos] & [L_sin], not [L_***}^-1.
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ! Get TAU's (pressure coefficient). Refer to Subroutine INFDIST.
DO mode = 1, maxInfl0
   tauCos(mode) = - PhiLqC(mode) / Pzero * .5
END DO !mode

DO mode = maxInfl0+1, maxInfl
   tauCos(mode) = - PhiLqC(mode) / Pzero
   tauSin(mode) = - PhiLqS(mode) / Pzero
END DO !mode

 ! Get the steady values of alpha(1)
 !  If m=0 and n=1, USE VTOTAL.
xAlpha(1) = 0.
DO k = 1, maxInfl
   xAlpha(1) = xAlpha(1) + xLcos(1,k) * tauCos(k)
END DO !k
xAlpha(1) = .5 * xAlpha(1) / Vtotal

 ! If m=0 but NOT n=1, USE VPARAM.
DO i = 2, maxInfl0
   xAlpha(i) = 0.
   DO k = 1, maxInfl
      xAlpha(i) = xAlpha(i) + xLcos(i,k) * tauCos(k)
   END DO !k
   xAlpha(i) = .5 * xAlpha(i) / Vparam
END DO !i

 ! Get the steady values of alpha's & beta's
DO i = maxInfl0+1, maxInfl
   xAlpha(i) = 0.
 ! akihiro
!   DO k = 1, maxInfl
   DO k = maxInfl0+1, maxInfl
      xAlpha(i) = xAlpha(i) + xLcos(i,k) * tauCos(k)
   END DO !k
   xAlpha(i) = .5 * xAlpha(i) / Vparam

   xBeta (i) = 0.
   DO k = maxInfl0+1, maxInfl
      xBeta (i) = xBeta (i) + xLsin(i,k) * tauSin(k)
   END DO !k
   xBeta (i) = .5 * xBeta (i) / Vparam
END DO !i

 ! Invert [L_cos] & [L_sin] matrices in case the XKAI is constant
 !  and the same [L]'s are used later.
CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 1 )
CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 2 )



RETURN
END SUBROUTINE infinit


 ! **********************************************************************
   SUBROUTINE infupdt
 !  INFUPDT updates the OLD variables of inflow distribution parameters.
 !   The program must call this subroutine before calling
 !   the subroutine INFDIST.
 ! **********************************************************************


USE            DynInflow


IMPLICIT       NONE


INTEGER(4)  :: i
!rm not used:INTEGER(4)  :: mode



!+++++++++++++++++++++++++++
!Suzuki:
!oldKaiC     = xKaiC
!oldKaiS     = xKaiS
!Shawler:
oldKai = xKai
!+++++++++++++++++++++++++++

old_LmdM    = xLambda_M

DO i = 1, maxInfl
   old_Alph(i)   = xAlpha  (i)
   dAlph_dt(i,4) = dAlph_dt(i,3)
   dAlph_dt(i,3) = dAlph_dt(i,2)
   dAlph_dt(i,2) = dAlph_dt(i,1)
END DO !i

DO i = maxInfl0+1, maxInfl
   old_Beta(i)   = xBeta   (i)
   dBeta_dt(i,4) = dBeta_dt(i,3)
   dBeta_dt(i,3) = dBeta_dt(i,2)
   dBeta_dt(i,2) = dBeta_dt(i,1)
END DO !i



RETURN
END SUBROUTINE infupdt


 ! **********************************************************************
   SUBROUTINE DynDebug (RHScos, RHSsin)
 !  Write out debugging information
 ! **********************************************************************

USE                           AeroTime
!bjj rm NWTC_Lib:USE                           Constant
USE                           DynInflow
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:

REAL(ReKi)                 :: RHScos ( maxInfl )
REAL(ReKi)                 :: RHSsin ( maxInfl0+1:maxInfl )


   ! Local Variables:

INTEGER(4)                 :: i
INTEGER(4)                 :: NumOut
INTEGER(4)                 :: UnDyn = 80

LOGICAL                    :: OnePass = .TRUE.

CHARACTER(50)              :: Frmt

SAVE                                                   ! Save *all* local variables.  Is this necessary, or is OnePass enough.


NumOut = maxInfl+(maxInfl-maxInfl0) + 1

IF (OnePass) THEN

!bjj Start of proposed change v12.70b-bjj
!rm      Call OpenOutFile (UnDyn,'DynDebug.plt')
   CALL OpenFOutFile (UnDyn, 'DynDebug.plt')
!bjj End of proposed change

   Frmt = '( A4,    (: A1, A, I1.1 ) )'

   WRITE(Frmt(7:9), '(I3)') NumOut
   WRITE(UnDyn, Frmt) 'Time',                    &
            ( TAB,    'dAlph_dt',       i,         &
                       i = 1, maxInfl ),         &
            ( TAB,    'dBeta_dt',       i,         &
                     i = maxInfl0+1, maxInfl ),  &
              TAB,    'TotalInf'

   OnePass = .FALSE.

ENDIF

Frmt = '( F10.3,    ( : A1, ES12.5 ) )'

IF (TIME > 0.0D0) THEN

   WRITE(Frmt(10:12), '(I3)') NumOut
   WRITE(UnDyn,Frmt) TIME,                    &
        ( TAB,       dAlph_dt(i,1),               &
                   i = 1, maxInfl ),          &
        ( TAB,       dBeta_dt(i,1),               &
                   i = maxInfl0+1, maxInfl ), &
              TAB,   totalInf

ENDIF



RETURN
END SUBROUTINE DynDebug


 ! **********************************************************************
   SUBROUTINE infdist
 !  INFDIST calculates the inflow (induced flow) distribution
 !  parameters using Generalized Dynamic Wake Theory.
 ! **********************************************************************

USE                           AeroTime
USE                           Blade
!bjj rm NWTC_Lib:USE                           Constant
USE                           DynInflow
!bjj rm:USE                           Identify
!bjj rm v12.70-bjj: USE                           Precision
USE                           Rotor
USE                           Wind


IMPLICIT                      NONE


   ! Local Variables:

REAL(ReKi)                 :: RHScos ( maxInfl )                     ! The cosine terms go from 1 to 6.  The sine terms go from 3 to 6.
REAL(ReKi)                 :: RHSsin ( maxInfl0+1:maxInfl )          ! The right hand side of the governing equation.
REAL(ReKi)                 :: tauCos ( maxInfl )                     ! Forcing Functions
REAL(ReKi)                 :: tauSin ( maxInfl0+1:maxInfl )
REAL(ReKi)                 :: v1
REAL(ReKi)                 :: v2
REAL(ReKi)                 :: v3
REAL(ReKi)                 :: Vplane2

INTEGER(4)                 :: i
INTEGER(4)                 :: k
INTEGER(4)                 :: mode

!DJL Start of proposed change - 12.53b-djl
! Try normalizing by wind speed instead of TipSpeed
!REAL(ReKi)                 :: VH !horizontal wind speed
!REAL(ReKi)                 :: VD !horizontal wind direction - not used

 ! Get the hub-height horizontal wind speed, VH
!CALL GetVH (VH, VD)
!DJL End of proposed change


!bjj start of propsed change
!rm ! In ADAMS & SymDyn, the rotor speed may be variable. Update the tipspeed and p0.
!rm ! In YawDyn, they are constant and calculated only once in INFINIT.
!rmSELECT CASE (TRIM(DynProg))
!rm   CASE ('YawDyn') ! do nothing
!rm   CASE DEFAULT
!bjj end of proposed change

!DJL Start of proposed change - 12.53b-djl
! Try normalizing by horizontal wind speed instead of TipSpeed
      TipSpeed = MAX(r  * revs, 1.0e-6)   !bjj: why is this here AND in InfInit()?
!      TipSpeed = 1.0
!DJL      TipSpeed = MAX(VH, 1.0e-6)
!DJL End of proposed change

!      Pzero    = pi * rho * revs * revs * r * r * r
      Pzero    = pi * rho * TipSpeed * TipSpeed * r

 ! Non-dimensional time
      DT0      = DT * REVS
!bjj start of propsed change
!rmEND SELECT
!bjj end of propsed change

 ! Calculate the wind velocity components in rotor-fixed
 !  coordinates(1-2-3), which are normalized by the tipspeed.
v1 =   VrotorZ / TipSpeed     !inplane, upward
v2 =   VrotorY / TipSpeed     !inplane, right looking downwind
v3 = - VrotorX / TipSpeed     !out-of-plane (normal to the rotor)
 ! Vplane2 is the square of in-plane component of the non-dimensional
 !  wind velocity.
Vplane2  = v1 * v1 + v2 * v2

 ! Note: Direction of non-dimensional velocity (All normal to the rotor plane).
 !  totalInf:  positive downwind. This is the total inflow to the rotor.
 !        v3:        positive upwind (thus, in normal condition, v3 < 0 )
 ! xLambda_M: positive downwind (opposite to A(i,j) )
 !  old_LmdM:  positive downwind (opposite to A(i,j) )
totalInf = - v3 + old_LmdM
! if ( totalInf .le. 0. ) then
!     call usrmes( .true. , &
!        'In SUBROUTINE INFDIST. totalInf =< 0.', &
!        27, 'WARN' )
! endif

 !  VTOTAL is the speed of the total inflow to the rotor.
Vtotal = SQRT( totalInf * totalInf + Vplane2 )
IF (vtotal <= 1.0e-6) vtotal=1.0e-6

 ! VPARAM is the inflow velocity parameter.
Vparam = ( Vplane2 + ( totalInf + old_LmdM ) * totalInf ) / Vtotal
 ! Calculate the disk skew angle function
 !  using the effective disk angle of attack.
IF ( totalInf == 0. ) THEN
!   WRITE(*,*) v3, old_LmdM
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Suzuki:
!   xKaiC = 0.
!   xKaiS = 0.
! Shawler:
    xKai = 0
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ELSE
 ! Note the definition of Yaw Angle is around -Z axis.
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Suzuki:
!   xKaiC = TAN( .5 * ATAN( -v2 / totalInf ) )
!   xKaiS = TAN( .5 * ATAN(  v1 / totalInf ) )
!!   xKaiC = TAN( .5 * SIGN( ATAN( SQRT( vplane2 ) / totalInf ), v2 ) )
! Shawler:
   xkai  = TAN( .5 *       ATAN( SQRT( vplane2 ) / totalInf )       )
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ENDIF

 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Suzuki:
 ! Update [L_cos] and [L_sin] matrices only if 'xkai' has changed.
 !  Then invert [L_cos] & [L_sin] matrices.
!IF ( xKaiC /= oldKaiC ) THEN
!   CALL LMATRIX ( xKaiC, 1 )
!   CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 1 )
!ENDIF

!IF ( xKaiS /= oldKaiS ) THEN
!   CALL LMATRIX ( xKaiS, 2 )
!   CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 2 )
!ENDIF
! Shawler:
!IF ( xKai /= oldKai ) THEN
   CALL LMATRIX ( xKai, 1 )
   CALL LMATRIX ( xKai, 2 )
   CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 1 )
   CALL MATINV  ( xLcos, xLsin, maxInfl, maxInfl0, 2 )
!ENDIF
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 !  [L_***] is now [L_***]^-1.

 ! Calculate the forcing functions (lift or normal forces).
 !  In the generalized dynamic wake model, the normal forces on the blades
 !  are positve upwind (just like a helicopter rotor). On the other hand,
 !  they are positve downwind in YawDyn, which is normal in wind turbine rotor.
 !  Put a minus sign for each forcing function.

 ! The modes for r=0.
DO mode = 1, maxInfl0
   tauCos(mode) = - PhiLqC(mode) / Pzero * .5
END DO !mode

 ! The modes for r>0.
DO mode = maxInfl0+1, maxInfl
   tauCos(mode) = - PhiLqC(mode) / Pzero
   tauSin(mode) = - PhiLqS(mode) / Pzero
END DO !mode

 ! Solve for the time derivatives of xAlpha's, {d(alpha)_dt}.
 !  Calculate the right hand side of the governing equation.
 !  {rhs} = 0.5*{tau} - [V][L]^-1*{alpha}

 ! First, calculate {rhs} = V[L]^-1*{alpha}
 !  USE "VTOTAL" for the first row of r=0. Cosine Matrix only.
RHScos(1) = 0.
DO k = 1, maxInfl
   RHScos(1) = RHScos(1) + xLcos(1,k) * old_Alph(k)
END DO !k
RHScos(1) = .5 * tauCos(1) - vtotal * RHScos(1)

 ! USE "VPARAM" for the second row or higher of r=0.
DO i = 2, maxInfl0
   RHScos(i) = 0.
   DO k = 1, maxInfl
      RHScos(i) = RHScos(i) + xLcos(i,k) * old_Alph(k)
   END DO !k
   RHScos(i) = .5 * tauCos(i) - Vparam * RHScos(i)
END DO !i

 ! Rows with r=1 or greater. Both cosine and sine matrices.
DO i = maxInfl0+1, maxInfl
   RHScos(i) = 0.
   RHSsin(i) = 0.
 ! First, calculate {rhs} = V[L]^-1*{alpha}
   DO k = 1, maxInfl
!   DO 260 k = maxInfl0+1, maxInfl
      RHScos(i) = RHScos(i) + xLcos(i,k) * old_Alph(k)
   END DO !k
   DO k = maxInfl0+1, maxInfl
      RHSsin(i) = RHSsin(i) + xLsin(i,k) * old_Beta(k)
   END DO !k
 ! Second, calculate {rhs} = 0.5*{tau} - [V]{rhs}
 !                         = 0.5*{tau} - [V][L]^-1*{alpha}
 !  USE "VPARAM" for m>0
   RHScos(i) = .5 * tauCos(i) - Vparam * RHScos(i)
   RHSsin(i) = .5 * tauSin(i) - Vparam * RHSsin(i)
END DO !i

DO i = 1, maxInfl0
   dAlph_dt(i,1) = xMinv(i) * RHScos(i)
END DO !i
DO i = maxInfl0+1, maxInfl
   dAlph_dt(i,1) = xMinv(i) * RHScos(i)
   dBeta_dt(i,1) = xMinv(i) * RHSsin(i)
END DO !i

 ! Integration using Adams-Bashford predictor corrector method.
 !  Note: The time step is nondimensional. t0=Omega*t
 !  Thus, in YawDyn, DT0=DT*REVS=(DELPSI/REVS)*REVS=DELPSI
 ! USE DT*REVS for compatibility with AeroDyn (DT0 not constant).
 !  DT is in module 'Lift'
 ! Determines xAlpha and xBeta
CALL ABPRECOR ( xAlpha, old_Alph, dAlph_dt, DT0, maxInfl, 1 )
CALL ABPRECOR ( xBeta,  old_Beta, dBeta_dt, DT0, maxInfl, maxInfl0+1 )

 ! Calculate the new lambda_m.
xLambda_M= 0.
DO k = 1, maxInfl0-1
   xLambda_M = xLambda_M + xLcos(1,k) * xAlpha(k)
END DO !k
DO k = maxInfl0, maxInfl
   xLambda_M = xLambda_M + xLcos(1,k) * xAlpha(k)
END DO !k
! xLambda_M = 2. / sqrt(3.) * xLambda_M
xLambda_M = 1.1547005 * xLambda_M

! Added additional output for GDW debugging - comment out for distribution
!CALL DynDebug (RHScos, RHSsin)



RETURN
END SUBROUTINE infdist

 ! *************************************************************
!bjj start of porposed change
!rm   SUBROUTINE vindinf( iradius, rlocal, vnw, VNB, VT, psi )
   SUBROUTINE vindinf( iradius, iblade, rlocal, vnw, VNB, VT, psi )
!bjj end of propose dhcnage
 !  vindinf calculates the axial induction factor for each
 !   element position using the calculated inflow parameters.
 !  Called by ElemFrc for each element at a new time step.
 ! *************************************************************

USE                           Blade
!bjj Start of proposed change v12.70
!rmUSE                           Constant
!bjj End of proposed change
USE                           DynInflow
USE                           Element
!bjj rm v12.70-bjj: USE                           Precision
USE                           Switch


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: psi
!rmREAL(ReKi)                 :: rlocal
!rmREAL(ReKi)                 :: VNB
!rmREAL(ReKi)                 :: vnw
!rmREAL(ReKi)                 :: VT
!rm
!rmINTEGER(4)                 :: iradius
REAL(ReKi),INTENT(IN)      :: psi
REAL(ReKi),INTENT(IN)      :: rlocal
REAL(ReKi),INTENT(IN)      :: VNB
REAL(ReKi),INTENT(IN)      :: vnw
REAL(ReKi),INTENT(INOUT)   :: VT

INTEGER,   INTENT(IN)      :: iradius
INTEGER,   INTENT(IN)      :: iblade
!bjj End of proposed change

   ! Local Variables:

REAL(ReKi)                 :: A2P
!Suzuki uses psiBar, Shawler - WindPsi
!REAL(ReKi)                 :: psibar
REAL(ReKi)                 :: Rzero
REAL(ReKi)                 :: SWRLARG
REAL(ReKi)                 :: Windpsi
!bjj rm v12.70-bjj: REAL(ReKi)                 :: xphi    !bjj: a function

INTEGER(4)                 :: mode



 ! Rzero is the non-dimensional radius.
Rzero  = rlocal / r

 ! PSIBAR is the azimuth angle measured counterclockwise from
 !  the horizontal to the left looking downwind.  The directions
 !  of PSI and PSIBAR are opposite and there is 90 deg difference.
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!Suzuki:
! psiBar = - psi - piBy2
! Shawler:
CALL WindAzimuthZero (psi,WindPsi)
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ! Calculate the induction factor using the inflow parameters.
 !  Here it's normalized by the tipspeed.

A(iRadius,iBlade) =  0.

DO mode = 1, maxInfl0
   A(iRadius,iBlade) = A(iRadius,iBlade)  &
                     + xphi(Rzero,mode) * xAlpha(mode)
!  &  + phis(Rzero, MRvector(mode), NJvector(mode) )* xAlpha(mode)
END DO !mode

 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!Suzuki:
!DO mode = maxInfl0+1, maxInfl
!   A(iRadius,iBlade) = A(iRadius,iBlade) + xphi(Rzero,mode) *      &
!!  &    + phis(Rzero, MRvector(mode), NJvector(mode) ) *
!            ( xAlpha(mode) * COS( REAL(MRvector(MODE)) * psibar )  &
!            + xBeta (mode) * SIN( REAL(MRvector(MODE)) * psibar ) )
!END DO !mode
! Shawler:
DO mode = maxInfl0+1, maxInfl
   A(iRadius,iBlade) = A(iRadius,iBlade) + xphi(Rzero,mode) *      &
!  &     + phis(Rzero, MRvector(mode), NJvector(mode) ) *
            ( xAlpha(mode) * COS( REAL(MRvector(MODE)) * Windpsi )  &
            + xBeta (mode) * SIN( REAL(MRvector(MODE)) * Windpsi ) )
END DO !mode
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ! A is positive upwind, while alpha's & beta's are positve downwind.
 !  Also, they are normalized by different factors.
A(iRadius,iBlade) = - A(iRadius,iBlade) * TipSpeed / VNW

 ! Calculate induced swirl (a') if desired.

IF ( SWIRL ) THEN
 ! akihiro 10/26/99
   SWRLARG = 1.0 + 4.0 *  A(iradius,iblade) * VNW * &
!   SWRLARG = 1.0 + 4.0 * TIPLOSS * A(iradius,iblade) * VNW *
           ( (1.0 - A(iradius,iblade)) * VNW + VNB ) / VT / VT
   IF ( SWRLARG > 0.0 ) THEN
      A2P = 0.5 * ( -1.0 + SQRT( SWRLARG ) )
      VT  = VT * ( 1.0 + A2P)
   ENDIF

ENDIF



RETURN
END SUBROUTINE vindinf

 ! ***********************************************************************
   SUBROUTINE ABPRECOR( F, OLDF, DFDT, DT, N, N0 )
 !  Integrates Function F by Adams-Bashford Predictor and Adams-Moulton
 !   Corrector using four previous values of dF/dt.
 ! ***********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.7
!rmINTEGER(4)                 :: N
!rmINTEGER(4)                 :: N0
!rm
!rmREAL(ReKi)                 :: DT
!rmREAL(ReKi)                 :: DFDT ( N0:N, 4 )
!rmREAL(ReKi)                 :: F    ( N0:N )
!rmREAL(ReKi)                 :: OLDF ( N0:N )
INTEGER(4),INTENT(IN)      :: N
INTEGER(4),INTENT(IN)      :: N0

REAL(ReKi),INTENT(IN)      :: DT
REAL(ReKi),INTENT(IN)      :: DFDT ( N0:N, 4 )
REAL(ReKi),INTENT(OUT)     :: F    ( N0:N )
REAL(ReKi),INTENT(IN)      :: OLDF ( N0:N )
!bjj End of proposed change

   ! Local Variables:

REAL(ReKi)                 :: DFDT0

INTEGER(4)                 :: I



DO I = N0, N
 ! Adams-Bashford Predictor
   F(I) = OLDF(I) + ( 55. * DFDT(I,1) - 59. * DFDT(I,2)  &
                  + 37. * DFDT(I,3) -  9. * DFDT(I,4) ) * DT / 24.

 ! New time derivative for corrector
   DFDT0 = ( F(I) - OLDF(I) ) / DT

 ! Adams-Moulton Corrector
   F(I) = OLDF(I) + (  9. * DFDT0     + 19. * DFDT(I,1)  &
                  -  5. * DFDT(I,2) +       DFDT(I,3) ) * DT / 24.

END DO !I



RETURN
END SUBROUTINE ABPRECOR

 ! ***********************************************************************
   SUBROUTINE LMATRIX ( X, matrixMode )
 !  LMATRIX calculates the [L_***] matrix using Gamma matrix and xkai=X.
 !   matrixMode = 1 : Calculate [L_cos] matrix
 !   matrixMode = 2 : Calculate [L_sin] matrix
 ! ***********************************************************************

USE                           DynInflow
!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: X
!rm
!rmINTEGER(4)                 :: matrixMode
REAL(ReKi),INTENT(IN)      :: X

INTEGER(4),INTENT(IN)      :: matrixMode
!bjj End of proposed change


   ! Local Variables:

REAL(ReKi)                 :: XM

INTEGER                    :: IROW
INTEGER                    :: JCOL

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(60)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(15), EXTERNAL    :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL    :: Int2LStr



 ! Check the value of X
IF ( ( X < -1.) .OR. ( X > 1.) ) THEN
!   IF ( ( X < 0.) .OR. ( X > 1.) ) THEN
!bjj start of proposed change
!rm   MESAGE =  &
!rm            ' must be between -1 and 1.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'LMATRIX', 561, 'FAULT')
   CALL ProgAbort ( 'Value of X = '//TRIM(Flt2LStr(X))//' must be between -1 and 1.')
!bjj end of proposed change
ENDIF

SELECT CASE ( matrixMode )

 ! Calculate the rows for r=0 of [L_cos] matrix,
 !  which needs a separate formula.
   CASE (1)
    DO JCOL = 1, maxInfl
       XM = X ** MRvector(JCOL)
       DO IROW = 1, maxInfl0
          xLcos( IROW, JCOL ) = GAMMA( IROW, JCOL ) * XM
       END DO !IROW
    END DO !JCOL

 ! Calculate the [L_cos] matrix,
 !  the rows for r=1 and higher.
    DO IROW = maxInfl0+1, maxInfl
       DO JCOL = 1, maxInfl
          xLcos( IROW, JCOL ) = GAMMA( IROW, JCOL )  &
                  *(    X  ** MminusR( IROW, JCOL )  &
                      + X  ** MplusR ( IROW, JCOL )  &
                  *  (-1.) ** MminR  ( IROW, JCOL )  )
       END DO !JCOL
    END DO !IROW

 ! Calculate [L_sin] matrix.
   CASE (2)
    DO IROW = maxInfl0+1, maxInfl
       DO JCOL = maxInfl0+1, maxInfl
          xLsin( IROW, JCOL ) = GAMMA( IROW, JCOL )  &
                  *(    X  ** MminusR( IROW, JCOL )  &
                      - X  ** MplusR ( IROW, JCOL )  &
                  *  (-1.) ** MminR  ( IROW, JCOL )  )
      END DO !JCOL
    END DO !IROW

   CASE DEFAULT
!bjj start of proposed change
!rm    MESAGE = 'Value of matrixMode = '//TRIM(Int2LStr(matrixMode))// &
!rm             ' must be 1 or 2.'
!rm    Frmt   = '(A)'
!rm    CALL ErrLog ( MESAGE, Frmt, 'LMATRIX', 562, 'FAULT')
    CALL ProgAbort( 'Value of matrixMode = '//TRIM(Int2LStr(matrixMode))//' must be 1 or 2.')
!bjj end of proposed change
END SELECT



RETURN
END SUBROUTINE LMATRIX

 ! ***********************************************************************
   SUBROUTINE MATINV( A0, A1, N, N0, invMode )
 !  Inverts the [L_cos] and [L_sin] matrices.
 !   Subroutine GAUSSJ (modified) from "Numerical Recipe" is needed.
 !   invMode = 1 : Invert [L_cos] matrix
 !   invMode = 2 : Invert [L_sin] matrix
 !**********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmINTEGER(4)                 :: invMode
!rmINTEGER(4)                 :: N
!rmINTEGER(4)                 :: N0
!rm
!rmREAL(ReKi)                 :: A0   (      N   ,      N    )
!rmREAL(ReKi)                 :: A1   ( N0+1:N   , N0+1:N    )
INTEGER(4),INTENT(IN)      :: invMode
INTEGER(4),INTENT(IN)      :: N
INTEGER(4),INTENT(IN)      :: N0

REAL(ReKi),INTENT(INOUT)   :: A0   (      N   ,      N    )
REAL(ReKi),INTENT(INOUT)   :: A1   ( N0+1:N   , N0+1:N    )
!bjj End of proposed change

   ! Local Variables:

REAL(ReKi)                 :: DUMMY(      N-N0,      N-N0 )
!rm not used:REAL(ReKi)                 :: GAUSS

INTEGER(4)                 :: I
INTEGER(4)                 :: J

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(60)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL    :: Int2LStr



 ! Invert [L_cos] in all cases
 !  [L_cos] matrix can be inverted without a dummy.
 !  Invert the [A0]=[L_cos] matrix by Gauss-Jordan Method
SELECT CASE ( invMode )

   CASE (1)
    CALL GAUSSJ(A0,N)

 ! [L_sin] matrix needs a dummy array, because the index goes
 !  from maxInfl0(=N0) to maxInfl(=N),
 !  which is incompatible with SUBROUTINE GAUSSJ.
 !BJJ: IS THIS REALLY NECESSARY?  Aren't the indicies an abstraction?? if you pass an array (1:3) and use it as (0:2) in another subroutine, it's really okay???
   CASE (2)
    DO I=1,N-N0
       DO J=1,N-N0
          DUMMY(I,J) = A1(I+N0,J+N0)
       END DO !J
    END DO !I

 ! Invert the [A1]=[L_sin] matrix by Gauss-Jordan Method.
    CALL GAUSSJ(DUMMY,N-N0)

 ! Put the dummy back into [A1]=[L_sin].
    DO I=1,N-N0
       DO J=1,N-N0
          A1(I+N0,J+N0) = DUMMY(I,J)
       END DO !J
    END DO !I

   CASE DEFAULT
!bjj start of proposed change
!rm    MESAGE = 'Value of invMode = '//TRIM(Int2LStr(invMode))// &
!rm            ' must be 1 or 2.'
!rm    Frmt   = '(A)'
!rm    CALL ErrLog ( MESAGE, Frmt, 'MATINV', 601, 'FAULT')
   CALL ProgAbort( 'Value of invMode = '//TRIM(Int2LStr(invMode))//' must be 1 or 2.')
!bjj end of proposed change

END SELECT



RETURN
END SUBROUTINE MATINV

 ! ***********************************************************************
   SUBROUTINE gaussj(a,n)
 !  Invert a matrix by Gauss-Jordan Method. The original source code
 !   from "Numerical Recipe" was slightly modified.
 ! ***********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!BJJ start of proposed change v12.70
!rmINTEGER(4)                 :: n
!rm
!rmREAL(ReKi)                 :: a(n,n)
INTEGER(4),INTENT(IN)      :: n

REAL(ReKi),INTENT(INOUT)   :: a(n,n)
!bjj End of proposed change

   ! Local Variables:

INTEGER(4), PARAMETER      :: NMAX = 6

REAL(ReKi)                 :: big
REAL(ReKi)                 :: dum
REAL(ReKi)                 :: pivinv

INTEGER(4)                 :: i
INTEGER(4)                 :: icol
INTEGER(4)                 :: indxc(NMAX)
INTEGER(4)                 :: indxr(NMAX)
INTEGER(4)                 :: ipiv(NMAX)
INTEGER(4)                 :: irow
INTEGER(4)                 :: j
INTEGER(4)                 :: k
INTEGER(4)                 :: l
INTEGER(4)                 :: ll

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(30)              :: MESAGE



DO j=1,n
   ipiv(j)=0
END DO !j
DO i=1,n
   big=0.
   DO j=1,n
      IF (ipiv(j) /= 1) THEN
         DO k=1,n
            IF (ipiv(k) == 0) THEN
               IF (ABS(a(j,k)) >= big) THEN
                  big=ABS(a(j,k))
                  irow=j
                  icol=k
                ENDIF

            ELSE IF (ipiv(k) > 1) THEN
!bjj start of proposed change
!rm               MESAGE = 'Singular matrix encountered.'
!rm               Frmt   = '(A)'
!rm               CALL ErrLog ( MESAGE, Frmt, 'gaussj', 631, 'FAULT')
               CALL ProgAbort( 'Singular matrix encountered.' )
!bjj start of proposed change
            ENDIF
         END DO !k
      ENDIF
   END DO !j
   ipiv(icol)=ipiv(icol)+1
   IF (irow /= icol) THEN
      DO l=1,n
         dum=a(irow,l)
         a(irow,l)=a(icol,l)
         a(icol,l)=dum
      END DO !l
   ENDIF
   indxr(i)=irow
   indxc(i)=icol
   IF (a(icol,icol) == 0.) THEN
!bjj start of proposed change
!rm      MESAGE = 'Singular matrix encountered.'
!rm      Frmt   = '(A)'
!rm      CALL ErrLog ( MESAGE, Frmt, 'gaussj', 632, 'WARN')
!bjj: changed to abort instead of warn here!
      CALL ProgAbort( 'Singular matrix encountered.' )
!bjj start of proposed change
   ENDIF
   pivinv=1./a(icol,icol)
   a(icol,icol)=1.
   DO l=1,n
      a(icol,l)=a(icol,l)*pivinv
   END DO !l
   DO ll=1,n
      if (ll /= icol) THEN
         dum=a(ll,icol)
         a(ll,icol)=0.
         DO l=1,n
            a(ll,l)=a(ll,l)-a(icol,l)*dum
         END DO !l
      ENDIF
   END DO !ll
END DO !i
DO l=n,1,-1
   IF (indxr(l) /= indxc(l)) THEN

      DO k=1,n
         dum=a(k,indxr(l))
         a(k,indxr(l))=a(k,indxc(l))
         a(k,indxc(l))=dum
      END DO !k
   ENDIF
END DO !l



RETURN
END SUBROUTINE gaussj

! ***********************************************************************
  FUNCTION FGAMMA( R, J, M, N )
!  Calculate the GAMMA matrix. It is NOT the statistical function.
! ***********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:

REAL(ReKi)                  :: FGAMMA
!bjj Start of proposed change v12.70
!rmINTEGER(4)                  :: J
!rmINTEGER(4)                  :: M
!rmINTEGER(4)                  :: N
!rmINTEGER(4)                  :: R
INTEGER(4),INTENT(IN)       :: J
INTEGER(4),INTENT(IN)       :: M
INTEGER(4),INTENT(IN)       :: N
INTEGER(4),INTENT(IN)       :: R
!bjj End of proposed change v12.70

   ! Global Functions:

!bjj rm v12.70-bjj: REAL(ReKi)                  :: HFUNC



IF ( MOD(R+M,2) == 0 ) THEN
   FGAMMA = (-1)**((N+J-2*R)*.5) * 2.        &
          * SQRT( REAL( (2*N+1) * (2*J+1) ) ) &
          / SQRT( HFUNC(M,N) * HFUNC(R,J) )   &
          / REAL( (J+N) * (J+N+2) * ((J-N)*(J-N)-1) )

ELSE IF ( ABS(J-N) == 1 ) THEN  !bjj: why don't we use the pi() variable?
   FGAMMA = 3.14159265 * SIGN(1., REAL(R-M) ) * .5 &
          / SQRT( HFUNC(M,N) * HFUNC(R,J) )        &
          / SQRT( REAL( (2*N+1) * (2*J+1) ) )

ELSE
   FGAMMA = 0.

ENDIF



RETURN
END FUNCTION FGAMMA

 ! ***********************************************************************
   FUNCTION HFUNC( M, N )
 !  Calculates the value of function H(m,n).
 !   Warning: This subroutine is not optimized for large m or n.
 !   Although H(m,n) is a well behaving function, it may
 !   cause math overflow, if m or n is large.
 !bjj: we only call with with the MRvector and NJvector (parameter) values.  This could
 !  possibly increase performance if implemented differently....
 ! ***********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:

REAL(ReKi)                 :: HFUNC

!bjj Start of proposed change v12.70
!rmINTEGER(4)                 :: M
!rmINTEGER(4)                 :: N
INTEGER(4),INTENT(IN)      :: M
INTEGER(4),INTENT(IN)      :: N
!bjj End of proposed change


   ! Local Variables:

!bjj rm v12.70-bjj INTEGER(4)                 :: IDUBFACT
INTEGER(4)                 :: NMM   ! n minus M
INTEGER(4)                 :: NPM   ! N plus M

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(60)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL    :: Int2LStr



IF ( N <= M ) THEN
!bjj start of proposed change
!rm    MESAGE = 'Value of N = '//TRIM(Int2LStr(N))// &
!rm            ' must be geater than M = '//TRIM(Int2LStr(M))//'.'
!rm    Frmt   = '(A)'
!rm    CALL ErrLog ( MESAGE, Frmt, 'HFUNC', 661, 'FAULT')
   CALL ProgAbort( 'Value of N = '//TRIM(Int2LStr(N))//' must be geater than M = '//TRIM(Int2LStr(M))//'.' )
!bjj end of proposed change
ENDIF

NPM = N + M
NMM = N - M

HFUNC = ( REAL( IDUBFACT(NPM-1) ) / REAL( IDUBFACT(NPM) ) ) &
      * ( REAL( IDUBFACT(NMM-1) ) / REAL( IDUBFACT(NMM) ) )



RETURN
END FUNCTION HFUNC

 ! ***********************************************************************
   INTEGER FUNCTION IDUBFACT( I )
 !  Calculates the double factorial of an integer I
 !   IDUBFACT( I ) = I!! = I*(I-2)*(I-4)*...*4*2 for I = even
 !                    or = I*(I-2)*(I-4)*...*3*1 for I = odd
 ! ***********************************************************************


IMPLICIT                   NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmINTEGER(4)              :: I
INTEGER(4),INTENT(IN)   :: I
!bjj eND of proposed change v12.70

   ! Local Variables:

!rm not used:INTEGER(4)              :: IEND
INTEGER(4)              :: K

!rm not used:CHARACTER( 5)           :: Frmt
!rm not used:CHARACTER(45)           :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL :: Int2LStr



IF ( I >= 1 ) THEN
   IDUBFACT = 1

!bjj start of proposed change
!bjj: this seems really unnecessary to me!  Also, the case I==0 or I == -1 could be combined
!rm   IF ( MOD(I,2) == 0 ) THEN
!rm      IEND = 2
!rm   ELSE
!rm      IEND = 1
!rm   ENDIF
!rm
!rm   DO K = I, IEND, -2
   DO K = I, 1, -2
!bjj end of proposed change
      IDUBFACT = IDUBFACT * K
   END DO !K

ELSE IF ( I == 0 .OR. I == -1 ) THEN
   IDUBFACT = 1
ELSE IF ( I == -3 ) THEN  ! use definition of n!! for odd negative numbers
   IDUBFACT = -1
ELSE
!bjj start of proposed change
!rm   MESAGE = 'In FUNCTION IDUBFACT. Double Factorial NOT defined.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'IDUBFACT', 701, 'FAULT')
   CALL ProgAbort( 'Double factorial is NOT defined for '//TRIM(Int2LStr(I))//' in FUNCTION IDUBFACT.')
!bjj end of proposed change
ENDIF



RETURN
END FUNCTION IDUBFACT

 ! ***********************************************************************
   FUNCTION xphi( Rzero, mode )
 !  Set up the PHI coefficients. They are the results from Mathematica.
 !  phi(1)  = sqrt(   3.)                    ! m=0, n=1
 !  phi(2)  = 2*sqrt(7) (1.5 - 3.75 Rzero**2 ) / 3.! m=0, n=3
 !  phi(3)  = sqrt(  15./ 2.) *Rzero            ! m=1, n=2
 !  phi(4)  = 4*(15/4 * Rzero - 105/16 *Rzero**3 )/sqrt(5)! m=1, n=4
 !  phi(5)  = sqrt( 105./ 2.) / 2.  *Rzero**2      ! m=2, n=3
 !  phi(6)  = sqrt(  35.) *3. / 4.  *Rzero**3      ! m=3, n=4
 ! ***********************************************************************

!bjj rm v12.70-bjj: USE                           Precision


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!RMREAL(ReKi)                 :: Rzero
!RMREAL(ReKi)                 :: xphi
!RM
!RMINTEGER(4)                 :: mode
REAL(ReKi),INTENT(IN)      :: Rzero
REAL(ReKi)                 :: xphi

INTEGER(4),INTENT(IN)      :: mode
!bjj Start of proposed change v12.70


   ! Local Variables:

!rm not used:CHARACTER( 5)              :: Frmt
!rm not used:CHARACTER(60)              :: MESAGE


   ! Global Functions:

!bjj rm 12.70b-bjj CHARACTER(15), EXTERNAL    :: Flt2LStr
!bjj rm 12.70b-bjj CHARACTER(11), EXTERNAL    :: Int2LStr



IF ( Rzero < 0. ) THEN
!bjj start of proposed change
!rm   MESAGE = 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))// &
!rm            ' must be larger than 0.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'XPHI', 731, 'FAULT')
   CALL ProgAbort( 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))//' must be larger than 0.')
!bjj start of proposed change
ELSE IF ( Rzero > 1. ) THEN
!bjj start of proposed change
!rm   MESAGE = 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))// &
!rm            ' must be smaller than 1.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'XPHI', 732, 'FAULT')
   CALL ProgAbort( 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))//' must be smaller than 1.')
!bjj start of proposed change
ENDIF

SELECT CASE ( mode )
   CASE (1)
    xphi =   1.732051
   CASE (2)
    xphi =   2.645751 - 6.6143783 * Rzero * Rzero
   CASE (3)
    xphi =   2.738613 * Rzero
   CASE (4)
    xphi = ( 6.708204 - 11.73936 * Rzero * Rzero ) * Rzero
   CASE (5)
    xphi =   3.622844 * Rzero * Rzero
   CASE (6)
    xphi =   4.437060 * Rzero * Rzero * Rzero
   CASE DEFAULT
!bjj start of proposed change
!rm    MESAGE = 'Integer MODE = '//TRIM(Int2LStr(MODE))// &
!rm             ' must be 1 through 6.'
!rm    Frmt   = '(A)'
!rm    CALL ErrLog ( MESAGE, Frmt, 'XPHI', 733, 'FAULT')
      CALL ProgAbort('Integer MODE = '//TRIM(Int2LStr(MODE))//' must be 1 through 6.' )
!bjj end of proposed change
END SELECT



RETURN
END FUNCTION xphi

 !***********************************************************************
 ! akihiro 06/25/00
 ! This subroutine is not currently used, may be used in the future.
 !
   FUNCTION phis( Rzero, r, j )
 !  Calculates the PHI coefficients. This function is not used unless
 !   the # of inflow states is increased greater than 10 (Mode 7 and higher)
 ! ***********************************************************************

!bjj rm v12.70-bjj: USE                          Precision


IMPLICIT                     NONE


   ! Passed Variables:

REAL(ReKi)                :: phis
!bjj Start of proposed change v12.70
!RMREAL(ReKi)                :: Rzero
!RM
!RMINTEGER(4)                :: j
!RMINTEGER(4)                :: r
REAL(ReKi),INTENT(IN)     :: Rzero

INTEGER(4),INTENT(IN)     :: j
INTEGER(4),INTENT(IN)     :: r
!bjj End of proposed change v12.70

   ! Local Variables:

!bjj rm v12.70-bjj INTEGER(4)                :: idubfact
INTEGER(4)                :: q

!rm not used:CHARACTER( 5)             :: Frmt
!rm not used:CHARACTER(60)             :: MESAGE


   ! Global Functions:

!bjj rm v12.70-bjj: REAL(ReKi), EXTERNAL      :: hfunc

!bjj rm 12.70b-bjj CHARACTER(15), EXTERNAL   :: Flt2LStr


IF ( Rzero < 0. ) THEN
!bjj start of proposed change
!rm   MESAGE = 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))// &
!rm            ' must be larger than 0.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'PHIS', 761, 'FAULT')
   CALL ProgAbort('Value of Rzero = '//TRIM(Flt2LStr(Rzero))//' must be larger than 0.' )
!bjj end of proposed change
ELSE IF ( Rzero > 1. ) THEN
!bjj start of proposed change
!rm   MESAGE = 'Value of Rzero = '//TRIM(Flt2LStr(Rzero))// &
!rm            ' must be smaller than 1.'
!rm   Frmt   = '(A)'
!rm   CALL ErrLog ( MESAGE, Frmt, 'PHIS', 762, 'FAULT')
   CALL ProgAbort('Value of Rzero = '//TRIM(Flt2LStr(Rzero))//' must be smaller than 1.' )
!bjj end of proposed change
ENDIF

phis = 0.

DO q = r, j-1, 2
   phis = phis  &
        + Rzero ** q * (-1.) **((q-r)/2) * REAL( idubfact(j+q) ) &
        / REAL( idubfact(q-r) * idubfact(q+r) * idubfact(j-q-1) )
END DO !q

phis = phis * SQRT( REAL( 2*j+1 ) * hfunc(r,j) )


RETURN
END FUNCTION phis


!***********************************************************
SUBROUTINE WindAzimuthZero (psi,WindPsi)
! Subroutine added by JRS to define the zero azimuth datum in
! a wind based co-ordinate system, for USE in the dynamic inflow
! routines.
! Calculates the rotational measurement in radians
! of the resultant of two vectors, VrotorZ and VrotorY.
! VrotorZ is positive vertically upwards and negative vertically
! downwards, VrotorY is positive to the left and negative
! to the right, both when looking towards the rotor from upwind.
! Zero degrees azimuth is defined when veritically down
! and rises with a clockwise rotation.


!bjj Start of proposed change v12.70
!rmUSE                           Constant ! bjj: not used
!bjj end of proposed change
!bjj rm v12.70-bjj: USE                           Precision
USE                           Wind


IMPLICIT                      NONE


   ! Passed Variables:
!bjj Start of proposed change v12.70
!rmREAL(ReKi)                 :: psi
!rmREAL(ReKi)                 :: WindPsi
REAL(ReKi),INTENT(IN)      :: psi
REAL(ReKi),INTENT(OUT)     :: WindPsi
!bjj End of proposed change

WindPsi = psi - ATAN2(VrotorY,-VrotorZ)

RETURN
END SUBROUTINE WindAzimuthZero

 !     ************* END OF FILE ***************
!BJJ Start of propsoed change v12.70

! ********************************************************************
  SUBROUTINE AeroDyn_Terminate ( )
! ********************************************************************

   USE   AD_IOParams
   USE   Airfoil
   USE   Bedoes
   USE   Blade
!rm   USE   CT_Wind
   USE   DynInflow
   USE   Element
   USE   ElOutParams
   USE   ElemInflow
!rm   USE   FD_Wind
!rm   USE   FF_WIND

   USE                       TwrProps

      ! local variables

!   INTEGER                 :: ErrStat



      ! Deallocate memory for arrays stored in AeroDyn modules

        ! Airfoil
   IF ( ALLOCATED( FOILNM     ) )   DEALLOCATE( FOILNM      )
   IF ( ALLOCATED( AL         ) )   DEALLOCATE( AL          )
   IF ( ALLOCATED( CD         ) )   DEALLOCATE( CD          )
   IF ( ALLOCATED( CL         ) )   DEALLOCATE( CL          )
   IF ( ALLOCATED( CM         ) )   DEALLOCATE( CM          )
   IF ( ALLOCATED( MulTabMet  ) )   DEALLOCATE( MulTabMet   )
   IF ( ALLOCATED( NFOIL      ) )   DEALLOCATE( NFOIL       )
   IF ( ALLOCATED( NLIFT      ) )   DEALLOCATE( NLIFT       )
   IF ( ALLOCATED( NTables    ) )   DEALLOCATE( NTables     )
   IF ( ALLOCATED( FOILNM     ) )   DEALLOCATE( FOILNM      )


        ! Bedoes
   IF ( ALLOCATED( ADOT       ) )   DEALLOCATE( ADOT        )
   IF ( ALLOCATED( ADOT1      ) )   DEALLOCATE( ADOT1       )
   IF ( ALLOCATED( AFE        ) )   DEALLOCATE( AFE         )
   IF ( ALLOCATED( AFE1       ) )   DEALLOCATE( AFE1        )
   IF ( ALLOCATED( ANE        ) )   DEALLOCATE( ANE         )
   IF ( ALLOCATED( ANE1       ) )   DEALLOCATE( ANE1        )
   IF ( ALLOCATED( AOD        ) )   DEALLOCATE( AOD         )
   IF ( ALLOCATED( AOL        ) )   DEALLOCATE( AOL         )
   IF ( ALLOCATED( CDO        ) )   DEALLOCATE( CDO         )
   IF ( ALLOCATED( CNA        ) )   DEALLOCATE( CNA         )
   IF ( ALLOCATED( CNP        ) )   DEALLOCATE( CNP         )
   IF ( ALLOCATED( CNP1       ) )   DEALLOCATE( CNP1        )
   IF ( ALLOCATED( CNPD       ) )   DEALLOCATE( CNPD        )
   IF ( ALLOCATED( CNPD1      ) )   DEALLOCATE( CNPD1       )
   IF ( ALLOCATED( CNPOT      ) )   DEALLOCATE( CNPOT       )
   IF ( ALLOCATED( CNPOT1     ) )   DEALLOCATE( CNPOT1      )
   IF ( ALLOCATED( CNS        ) )   DEALLOCATE( CNS         )
   IF ( ALLOCATED( CNSL       ) )   DEALLOCATE( CNSL        )
   IF ( ALLOCATED( CNV        ) )   DEALLOCATE( CNV         )
   IF ( ALLOCATED( CVN        ) )   DEALLOCATE( CVN         )
   IF ( ALLOCATED( CVN1       ) )   DEALLOCATE( CVN1        )
   IF ( ALLOCATED( DF         ) )   DEALLOCATE( DF          )
   IF ( ALLOCATED( DFAFE      ) )   DEALLOCATE( DFAFE       )
   IF ( ALLOCATED( DFAFE1     ) )   DEALLOCATE( DFAFE1      )
   IF ( ALLOCATED( DFC        ) )   DEALLOCATE( DFC         )
   IF ( ALLOCATED( DN         ) )   DEALLOCATE( DN          )
   IF ( ALLOCATED( DPP        ) )   DEALLOCATE( DPP         )
   IF ( ALLOCATED( DQ         ) )   DEALLOCATE( DQ          )
   IF ( ALLOCATED( DQP        ) )   DEALLOCATE( DQP         )
   IF ( ALLOCATED( DQP1       ) )   DEALLOCATE( DQP1        )
   IF ( ALLOCATED( FSP        ) )   DEALLOCATE( FSP         )
   IF ( ALLOCATED( FSP1       ) )   DEALLOCATE( FSP1        )
   IF ( ALLOCATED( FSPC       ) )   DEALLOCATE( FSPC        )
   IF ( ALLOCATED( FSPC1      ) )   DEALLOCATE( FSPC1       )
   IF ( ALLOCATED( FTB        ) )   DEALLOCATE( FTB         )
   IF ( ALLOCATED( FTBC       ) )   DEALLOCATE( FTBC        )
   IF ( ALLOCATED( OLDCNV     ) )   DEALLOCATE( OLDCNV      )
   IF ( ALLOCATED( OLDDF      ) )   DEALLOCATE( OLDDF       )
   IF ( ALLOCATED( OLDDFC     ) )   DEALLOCATE( OLDDFC      )
   IF ( ALLOCATED( OLDDN      ) )   DEALLOCATE( OLDDN       )
   IF ( ALLOCATED( OLDDPP     ) )   DEALLOCATE( OLDDPP      )
   IF ( ALLOCATED( OLDDQ      ) )   DEALLOCATE( OLDDQ       )
   IF ( ALLOCATED( OLDTAU     ) )   DEALLOCATE( OLDTAU      )
   IF ( ALLOCATED( OLDXN      ) )   DEALLOCATE( OLDXN       )
   IF ( ALLOCATED( OLDYN      ) )   DEALLOCATE( OLDYN       )
   IF ( ALLOCATED( QX         ) )   DEALLOCATE( QX          )
   IF ( ALLOCATED( QX1        ) )   DEALLOCATE( QX1         )
   IF ( ALLOCATED( TAU        ) )   DEALLOCATE( TAU         )
   IF ( ALLOCATED( XN         ) )   DEALLOCATE( XN          )
   IF ( ALLOCATED( YN         ) )   DEALLOCATE( YN          )
   IF ( ALLOCATED( BEDSEP     ) )   DEALLOCATE( BEDSEP      )
   IF ( ALLOCATED( OLDSEP     ) )   DEALLOCATE( OLDSEP      )


        ! Blade
   IF ( ALLOCATED( C          ) )   DEALLOCATE( C           )
   IF ( ALLOCATED( DR         ) )   DEALLOCATE( DR          )

!bjj start of proposed change v12.70w
!rm        ! CT_Wind
!rm   IF ( ALLOCATED( CTu        ) )   DEALLOCATE( CTu         )
!rm   IF ( ALLOCATED( CTv        ) )   DEALLOCATE( CTv         )
!rm   IF ( ALLOCATED( CTw        ) )   DEALLOCATE( CTw         )
!rm   IF ( ALLOCATED( TimesCT    ) )   DEALLOCATE( TimesCT     )
!rm   IF ( ALLOCATED( TimeStpCT  ) )   DEALLOCATE( TimeStpCT   )
!bjj end of proposed change v12.70w


        ! DynInflow
   IF ( ALLOCATED( RMC_SAVE   ) )   DEALLOCATE( RMC_SAVE    )
   IF ( ALLOCATED( RMS_SAVE   ) )   DEALLOCATE( RMS_SAVE    )


        ! Element
   IF ( ALLOCATED( A          ) )   DEALLOCATE( A           )
   IF ( ALLOCATED( AP         ) )   DEALLOCATE( AP          )
   IF ( ALLOCATED( HLCNST     ) )   DEALLOCATE( HLCNST      )
   IF ( ALLOCATED( RELM       ) )   DEALLOCATE( RELM        )
   IF ( ALLOCATED( TLCNST     ) )   DEALLOCATE( TLCNST      )
   IF ( ALLOCATED( TWIST      ) )   DEALLOCATE( TWIST       )


        ! ElOutParams
   IF ( ALLOCATED( AAA        ) )   DEALLOCATE( AAA         )
   IF ( ALLOCATED( AAP        ) )   DEALLOCATE( AAP         )
   IF ( ALLOCATED( ALF        ) )   DEALLOCATE( ALF         )
   IF ( ALLOCATED( CDD        ) )   DEALLOCATE( CDD         )
   IF ( ALLOCATED( CLL        ) )   DEALLOCATE( CLL         )
   IF ( ALLOCATED( CMM        ) )   DEALLOCATE( CMM         )
   IF ( ALLOCATED( CNN        ) )   DEALLOCATE( CNN         )
   IF ( ALLOCATED( CTT        ) )   DEALLOCATE( CTT         )
   IF ( ALLOCATED( DFNSAV     ) )   DEALLOCATE( DFNSAV      )
   IF ( ALLOCATED( DFTSAV     ) )   DEALLOCATE( DFTSAV      )
   IF ( ALLOCATED( DynPres    ) )   DEALLOCATE( DynPres     )
   IF ( ALLOCATED( PITSAV     ) )   DEALLOCATE( PITSAV      )
   IF ( ALLOCATED( PMM        ) )   DEALLOCATE( PMM         )
   IF ( ALLOCATED( ReyNum     ) )   DEALLOCATE( ReyNum      )
   IF ( ALLOCATED( SaveVX     ) )   DEALLOCATE( SaveVX      )
   IF ( ALLOCATED( SaveVY     ) )   DEALLOCATE( SaveVY      )
   IF ( ALLOCATED( SaveVZ     ) )   DEALLOCATE( SaveVZ      )
   IF ( ALLOCATED( WndElPrList) )   DEALLOCATE( WndElPrList )
   IF ( ALLOCATED( WndElPrNum ) )   DEALLOCATE( WndElPrNum  )
   IF ( ALLOCATED( ElPrList   ) )   DEALLOCATE( ElPrList    )
   IF ( ALLOCATED( ElPrNum    ) )   DEALLOCATE( ElPrNum     )

      ! ElemInflow

   IF ( ALLOCATED( W2         ) )   DEALLOCATE( W2          )
   IF ( ALLOCATED( Alpha      ) )   DEALLOCATE( Alpha       )

!bjj start of proposed change v12.70w
!rm        ! FD_Wind
!rm   IF ( ALLOCATED( FDu        ) )   DEALLOCATE( FDu         )
!rm   IF ( ALLOCATED( FDv        ) )   DEALLOCATE( FDv         )
!rm   IF ( ALLOCATED( FDw        ) )   DEALLOCATE( FDw         )
!rm   IF ( ALLOCATED( FDuData    ) )   DEALLOCATE( FDuData     )
!rm   IF ( ALLOCATED( FDvData    ) )   DEALLOCATE( FDvData     )
!rm   IF ( ALLOCATED( FDwData    ) )   DEALLOCATE( FDwData     )
!rm   IF ( ALLOCATED( Times4D    ) )   DEALLOCATE( Times4D     )
!rm   IF ( ALLOCATED( Times4DIx  ) )   DEALLOCATE( Times4DIx   )
!rm   IF ( ALLOCATED( AdvFiles   ) )   DEALLOCATE( AdvFiles    )
!rm
!rm
!rm        ! FF_Wind
!rm   IF ( ALLOCATED( FFData     ) )   DEALLOCATE( FFData      )
!bjj end of proposed change

!bjj start of proposed change for pjm
         ! TwrProps
   IF ( ALLOCATED( TwrHtFr ) )      DEALLOCATE ( TwrHtFr    )
   IF ( ALLOCATED( TwrWid  ) )      DEALLOCATE ( TwrWid     )
   IF ( ALLOCATED( TwrCD  ) )       DEALLOCATE ( TwrCD      )
   IF ( ALLOCATED( TwrRe ) )        DEALLOCATE ( TwrRe      )
   IF ( ALLOCATED( NTwrCDCol ) )    DEALLOCATE ( NTwrCDCol  )
!bjj end of proposed change for pjm

   ! DEALLOCATE ( OLD_A_NS )     !FH these are local variables of SUBROUTINE VIND
   ! DEALLOCATE ( OLD_AP_NS )       !FH which cannot be DEALLOCATED here ... still a small memory leak ...

      ! Close files that were opened in AeroDyn

      ! AD_IOParams
!   CLOSE(UnADec)              ! Echo file
   CLOSE(UnADin)              ! ipt file
   CLOSE(UnADopt)             ! opt file
   CLOSE(UnAirfl)             ! Airfoil data file
   CLOSE(UnWind)              ! HH or FF wind file

!bjj start of proposed change for pjm
!   CLOSE(UnTwr)
!bjj end of proposed change

      ! NWTC_Library
   CLOSE(UnEc)                ! I/O unit number for the echo file.


!      ! Close wind inflow
!   CALL WindInf_Terminate( ErrStat )

   RETURN
END SUBROUTINE AeroDyn_Terminate
!====================================================================================================
SUBROUTINE CheckRComp( ADFile, HubRadius, TipRadius, ErrStat )
! This routine checks to see if RElm(:) and DR(:) are compatible within a millimeter;
!----------------------------------------------------------------------------------------------------

   USE                           Blade,      ONLY: DR
   USE                           Element,    ONLY: NElm, RElm

   IMPLICIT                      NONE

      ! Passed variables

   CHARACTER(*), INTENT(IN)   :: ADFile                     ! Name of the AeroDyn input file, used for printing error message
   REAL(ReKi),   INTENT(IN)   :: HubRadius                  ! Hub radius, used to verify that RElm and DR are input correctly
   REAL(ReKi),   INTENT(IN)   :: TipRadius                  ! Tip radius, used to verify that RElm and DR are input correctly
   INTEGER,      INTENT(OUT)  :: ErrStat


      ! Local variables.

   REAL(ReKi)                 :: DRNodesNew(NElm)           ! Length of variable-spaced blade elements--calculated from input RElm(:).
   REAL(ReKi)                 :: DRSum                      ! Sum of DRs--should be close to TipRadius
   REAL(ReKi), PARAMETER      :: EPS = EPSILON(HubRadius)   ! A small value used to compare two numbers

   INTEGER(4)                 :: I                          ! Generic index.

   CHARACTER(33)              :: DRChange                   ! A string showing how to change DR to get campatibility



      ! Initialize ErrStat to 0 (no error):

   ErrStat = 0


      ! Calculate DRNodesNew(:) based on input RElm(:) and compare to input DR(:):

!   AssumedHubRadius = RElm(1) - 0.5*DR(1)
   DRNodesNew(1)    = 2.0*( RElm(1) - HubRadius )
   DRSum            = DRNodesNew(1) + HubRadius

   IF ( DRNodesNew(1) <= EPS )  THEN                              ! Check to see if RElm(1) > HubRad; if not, ProgAbort program
      CALL WrScr(' RElm(1) must be larger than the hub radius (HubRadius = RElm(1) - 0.5*DR(1)). ')
      ErrStat = 1
      RETURN
   ELSEIF ( ABS( DRNodesNew(1) - DR(1) ) > 0.001 )  THEN     ! Check to see if the calculated DRNodes(1) is close to the inputted DRNodes(1); if not, set flag--this will cause the program to ProgAbort later.
      ErrStat = 1
   ENDIF

   DO I = 2,NElm ! Loop through all but the innermost blade element

      DRNodesNew(I) = 2.0*( RElm(I) - RElm(I-1) ) - DRNodesNew(I-1)
      DRSum         = DRSum + DRNodesNew(I)

      IF ( DRNodesNew(I) <= EPS )  THEN                           ! Check to see if it is possible to have compatible DR(:) with the input RElm(:); if not, abort program
         CALL WrScr( 'RElm('//TRIM( Int2LStr(I) )//') produces ill-conditioned DR(:)' )
         ErrStat = 1
         RETURN
      ELSEIF ( ABS( DRNodesNew(I) - DR(I) ) > 0.001 )  THEN  ! Check to see if the calculated DRNodes(I) is close to the inputted DRNodes(I); if not, set flag--this will cause the program to Abort later.
         ErrStat = 1
      ENDIF

   END DO             ! I - all but the innermost blade element


      ! Abort program if necessary

   IF ( ErrStat /= 0 )  THEN

         ! Write error message since the input DR(:) are not close to the calculated DRNodesNew(:)

      CALL WrScr1(' Input values for DR(:) are not compatible with input RElm(:). ')
      CALL WrScr (' To make them compatible, please modify DR in the AeroDyn input file, '// TRIM( ADFile ) //', as follows:')
      CALL WrScr1(' DR (Old) --> DR (New) ')

      DO I = 1,NElm
         WRITE( DRChange, "(' ', F13.4, ' --> ', F13.4, ' ')" ) DR(I), DRNodesNew(I)
         CALL WrScr( DRChange )
      ENDDO !I

      RETURN

   ELSEIF ( ABS( DRSum - TipRadius ) > 0.001 )  THEN

         ! Abort program since SUM( DRNodes(:) ) /= ( TipRadius - HubRadius)

      CALL WrScr(' TipRadius must be equal to HubRadius + SUM( DR(:) ). ')
      ErrStat = 1

      RETURN

   ENDIF


   RETURN
END SUBROUTINE CheckRComp


END MODULE
!BJJ End of proposed change v12.70
