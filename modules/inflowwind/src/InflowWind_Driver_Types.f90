!STARTOFREGISTRYGENERATEDFILE 'InflowWind_Driver_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! InflowWind_Driver_Types
!.................................................................................................................................
! This file is part of InflowWind_Driver.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in InflowWind_Driver. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE InflowWind_Driver_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  OutputFile  =======
  TYPE, PUBLIC :: OutputFile
    character(1024)  :: Name      !< Filename for output from points read in from points file [-]
    INTEGER(IntKi)  :: Unit = -1      !< Unit number for the output file for the Points file output [-]
    LOGICAL  :: Initialized = .false.      !< Flag indicating that file has been initialized [-]
  END TYPE OutputFile
! =======================
! =========  IfWDriver_Flags  =======
  TYPE, PUBLIC :: IfWDriver_Flags
    LOGICAL  :: DvrIptFile = .false.      !< Was an input file name given on the command line? [-]
    LOGICAL  :: IfWIptFile = .false.      !< Was an InflowWind input file requested? [-]
    LOGICAL  :: Summary = .false.      !< create a summary at command line? (data extents in the wind file) [-]
    LOGICAL  :: SummaryFile = .false.      !< create a summary file of the output? [-]
    LOGICAL  :: TStart = .false.      !< specified a start time [-]
    LOGICAL  :: NumTimeSteps = .false.      !< specified a number of timesteps to process [-]
    LOGICAL  :: NumTimeStepsDefault = .false.      !< specified a 'DEFAULT' for number of timesteps to process [-]
    LOGICAL  :: DT = .false.      !< specified a resolution in time [-]
    LOGICAL  :: DTDefault = .false.      !< specified a 'DEFAULT' for the time resolution [-]
    LOGICAL  :: FFTcalc = .false.      !< do an FFT [-]
    LOGICAL  :: WindGrid = .false.      !< Requested output of wind data on a grid -- input file option only [-]
    LOGICAL  :: XRange = .false.      !< specified a range of x      -- command line option only -- stored as GridCtrCoord and GridDelta [-]
    LOGICAL  :: YRange = .false.      !< specified a range of y      -- command line option only -- stored as GridCtrCoord and GridDelta [-]
    LOGICAL  :: ZRange = .false.      !< specified a range of z      -- command line option only -- stored as GridCtrCoord and GridDelta [-]
    LOGICAL  :: Dx = .false.      !< specified a resolution in x -- command line option only, 0.0 otherwise [-]
    LOGICAL  :: Dy = .false.      !< speficied a resolution in y [-]
    LOGICAL  :: Dz = .false.      !< specified a resolution in z [-]
    LOGICAL  :: PointsFile = .false.      !< points filename to read in [-]
    LOGICAL  :: OutputAccel = .false.      !< flag to calculate and output wind acceleration in addition to velocity [-]
    LOGICAL  :: Verbose = .false.      !< Verbose error reporting [-]
    LOGICAL  :: VVerbose = .false.      !< Very Verbose error reporting [-]
    LOGICAL  :: BoxExceedAllowF = .false.      !< set flag to allow exceeding wind box boundaries for FF files (for diagnostic purposes) [-]
    LOGICAL  :: WrHAWC = .false.      !< Requested file conversion to HAWC2 format? [-]
    LOGICAL  :: WrBladed = .false.      !< Requested file conversion to Bladed format? [-]
    LOGICAL  :: WrVTK = .false.      !< Requested file output as VTK? [-]
    LOGICAL  :: WrUniform = .false.      !< Requested file output as Uniform wind format? [-]
    LOGICAL  :: XYslice = .false.      !< Take XY slice at one elevation [-]
  END TYPE IfWDriver_Flags
! =======================
! =========  IfWDriver_Settings  =======
  TYPE, PUBLIC :: IfWDriver_Settings
    character(1024)  :: DvrIptFileName      !< Driver input file name [-]
    character(1024)  :: IfWIptFileName      !< Filename of InflowWind input file to read (if no driver input file) [-]
    character(1024)  :: SummaryFileName      !< Filename for the summary information output [-]
    character(1024)  :: PointsFileName      !< Filename of points file to read in [-]
    INTEGER(IntKi)  :: NumTimeSteps = 0      !< Number of timesteps [-]
    REAL(DbKi)  :: DT = 0.0_DbKi      !< resolution of time [s]
    REAL(DbKi)  :: TStart = 0.0_DbKi      !< range of time -- end time converted from TRange (command line option only) [s]
    REAL(ReKi)  :: FFTcoord(1:3) = 0.0_ReKi      !< (x,y,z) coordinate to do an FFT at [(m)]
    REAL(ReKi)  :: GridDelta(1:3) = 0.0_ReKi      !< (GridDx,GridDy,GridDz) -- grid point spacing [(m)]
    INTEGER(IntKi)  :: GridN(1:3) = 1_IntKi      !< (GridNx,GridNy,GridNz) -- number of grid points [-]
    REAL(ReKi)  :: XRange(1:2) = 0.0_ReKi      !< Range in the x-direction for the gridded data [(m)]
    REAL(ReKi)  :: YRange(1:2) = 0.0_ReKi      !< Range in the y-direction for the gridded data [(m)]
    REAL(ReKi)  :: ZRange(1:2) = 0.0_ReKi      !< Range in the z-direction for the gridded data [(m)]
    TYPE(ProgDesc)  :: ProgInfo      !< Program info [-]
    TYPE(OutputFile)  :: WindGridOutput      !< Wind grid file handling [-]
    TYPE(OutputFile)  :: FFTOutput      !< FFT file handling [-]
    TYPE(OutputFile)  :: PointsVelOutput      !< Points output velocity file handling [-]
    INTEGER(IntKi)  :: NOutWindXY = 0      !< Number of XY planes for output <RootName>.XY<loc>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutWindZ      !< Z coordinates of XY planes for output [1 to NOutWindXY] [unused for NOutWindXY=0] [(m)]
    INTEGER(IntKi)  :: NOutWindXZ = 0      !< Number of YZ planes for output <RootName>.YZ<loc>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutWindY      !< Y coordinates of YZ planes for output [1 to NOutWindYZ] [unused for NOutWindYZ=0] [(m)]
    INTEGER(IntKi)  :: NOutWindYZ = 0      !< Number of YZ planes for output <RootName>.YZ<loc>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutWindX      !< X coordinates of YZ planes for output [1 to NOutWindYZ] [unused for NOutWindYZ=0] [(m)]
  END TYPE IfWDriver_Settings
! =======================
CONTAINS

subroutine InflowWind_Driver_CopyOutputFile(SrcOutputFileData, DstOutputFileData, CtrlCode, ErrStat, ErrMsg)
   type(OutputFile), intent(in) :: SrcOutputFileData
   type(OutputFile), intent(inout) :: DstOutputFileData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_CopyOutputFile'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutputFileData%Name = SrcOutputFileData%Name
   DstOutputFileData%Unit = SrcOutputFileData%Unit
   DstOutputFileData%Initialized = SrcOutputFileData%Initialized
end subroutine

subroutine InflowWind_Driver_DestroyOutputFile(OutputFileData, ErrStat, ErrMsg)
   type(OutputFile), intent(inout) :: OutputFileData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_DestroyOutputFile'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine InflowWind_Driver_PackOutputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OutputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_Driver_PackOutputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Name)
   call RegPack(Buf, InData%Unit)
   call RegPack(Buf, InData%Initialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_Driver_UnPackOutputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OutputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_Driver_UnPackOutputFile'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Unit)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Initialized)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_Driver_CopyIfWDriver_Flags(SrcIfWDriver_FlagsData, DstIfWDriver_FlagsData, CtrlCode, ErrStat, ErrMsg)
   type(IfWDriver_Flags), intent(in) :: SrcIfWDriver_FlagsData
   type(IfWDriver_Flags), intent(inout) :: DstIfWDriver_FlagsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_CopyIfWDriver_Flags'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstIfWDriver_FlagsData%DvrIptFile = SrcIfWDriver_FlagsData%DvrIptFile
   DstIfWDriver_FlagsData%IfWIptFile = SrcIfWDriver_FlagsData%IfWIptFile
   DstIfWDriver_FlagsData%Summary = SrcIfWDriver_FlagsData%Summary
   DstIfWDriver_FlagsData%SummaryFile = SrcIfWDriver_FlagsData%SummaryFile
   DstIfWDriver_FlagsData%TStart = SrcIfWDriver_FlagsData%TStart
   DstIfWDriver_FlagsData%NumTimeSteps = SrcIfWDriver_FlagsData%NumTimeSteps
   DstIfWDriver_FlagsData%NumTimeStepsDefault = SrcIfWDriver_FlagsData%NumTimeStepsDefault
   DstIfWDriver_FlagsData%DT = SrcIfWDriver_FlagsData%DT
   DstIfWDriver_FlagsData%DTDefault = SrcIfWDriver_FlagsData%DTDefault
   DstIfWDriver_FlagsData%FFTcalc = SrcIfWDriver_FlagsData%FFTcalc
   DstIfWDriver_FlagsData%WindGrid = SrcIfWDriver_FlagsData%WindGrid
   DstIfWDriver_FlagsData%XRange = SrcIfWDriver_FlagsData%XRange
   DstIfWDriver_FlagsData%YRange = SrcIfWDriver_FlagsData%YRange
   DstIfWDriver_FlagsData%ZRange = SrcIfWDriver_FlagsData%ZRange
   DstIfWDriver_FlagsData%Dx = SrcIfWDriver_FlagsData%Dx
   DstIfWDriver_FlagsData%Dy = SrcIfWDriver_FlagsData%Dy
   DstIfWDriver_FlagsData%Dz = SrcIfWDriver_FlagsData%Dz
   DstIfWDriver_FlagsData%PointsFile = SrcIfWDriver_FlagsData%PointsFile
   DstIfWDriver_FlagsData%OutputAccel = SrcIfWDriver_FlagsData%OutputAccel
   DstIfWDriver_FlagsData%Verbose = SrcIfWDriver_FlagsData%Verbose
   DstIfWDriver_FlagsData%VVerbose = SrcIfWDriver_FlagsData%VVerbose
   DstIfWDriver_FlagsData%BoxExceedAllowF = SrcIfWDriver_FlagsData%BoxExceedAllowF
   DstIfWDriver_FlagsData%WrHAWC = SrcIfWDriver_FlagsData%WrHAWC
   DstIfWDriver_FlagsData%WrBladed = SrcIfWDriver_FlagsData%WrBladed
   DstIfWDriver_FlagsData%WrVTK = SrcIfWDriver_FlagsData%WrVTK
   DstIfWDriver_FlagsData%WrUniform = SrcIfWDriver_FlagsData%WrUniform
   DstIfWDriver_FlagsData%XYslice = SrcIfWDriver_FlagsData%XYslice
end subroutine

subroutine InflowWind_Driver_DestroyIfWDriver_Flags(IfWDriver_FlagsData, ErrStat, ErrMsg)
   type(IfWDriver_Flags), intent(inout) :: IfWDriver_FlagsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_DestroyIfWDriver_Flags'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine InflowWind_Driver_PackIfWDriver_Flags(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(IfWDriver_Flags), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_Driver_PackIfWDriver_Flags'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%DvrIptFile)
   call RegPack(Buf, InData%IfWIptFile)
   call RegPack(Buf, InData%Summary)
   call RegPack(Buf, InData%SummaryFile)
   call RegPack(Buf, InData%TStart)
   call RegPack(Buf, InData%NumTimeSteps)
   call RegPack(Buf, InData%NumTimeStepsDefault)
   call RegPack(Buf, InData%DT)
   call RegPack(Buf, InData%DTDefault)
   call RegPack(Buf, InData%FFTcalc)
   call RegPack(Buf, InData%WindGrid)
   call RegPack(Buf, InData%XRange)
   call RegPack(Buf, InData%YRange)
   call RegPack(Buf, InData%ZRange)
   call RegPack(Buf, InData%Dx)
   call RegPack(Buf, InData%Dy)
   call RegPack(Buf, InData%Dz)
   call RegPack(Buf, InData%PointsFile)
   call RegPack(Buf, InData%OutputAccel)
   call RegPack(Buf, InData%Verbose)
   call RegPack(Buf, InData%VVerbose)
   call RegPack(Buf, InData%BoxExceedAllowF)
   call RegPack(Buf, InData%WrHAWC)
   call RegPack(Buf, InData%WrBladed)
   call RegPack(Buf, InData%WrVTK)
   call RegPack(Buf, InData%WrUniform)
   call RegPack(Buf, InData%XYslice)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_Driver_UnPackIfWDriver_Flags(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(IfWDriver_Flags), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_Driver_UnPackIfWDriver_Flags'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%DvrIptFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%IfWIptFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Summary)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SummaryFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TStart)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTimeSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTimeStepsDefault)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DTDefault)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FFTcalc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WindGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%XRange)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%YRange)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ZRange)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Dx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Dy)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Dz)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PointsFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutputAccel)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Verbose)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VVerbose)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BoxExceedAllowF)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrHAWC)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrBladed)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrUniform)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%XYslice)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_Driver_CopyIfWDriver_Settings(SrcIfWDriver_SettingsData, DstIfWDriver_SettingsData, CtrlCode, ErrStat, ErrMsg)
   type(IfWDriver_Settings), intent(in) :: SrcIfWDriver_SettingsData
   type(IfWDriver_Settings), intent(inout) :: DstIfWDriver_SettingsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_CopyIfWDriver_Settings'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstIfWDriver_SettingsData%DvrIptFileName = SrcIfWDriver_SettingsData%DvrIptFileName
   DstIfWDriver_SettingsData%IfWIptFileName = SrcIfWDriver_SettingsData%IfWIptFileName
   DstIfWDriver_SettingsData%SummaryFileName = SrcIfWDriver_SettingsData%SummaryFileName
   DstIfWDriver_SettingsData%PointsFileName = SrcIfWDriver_SettingsData%PointsFileName
   DstIfWDriver_SettingsData%NumTimeSteps = SrcIfWDriver_SettingsData%NumTimeSteps
   DstIfWDriver_SettingsData%DT = SrcIfWDriver_SettingsData%DT
   DstIfWDriver_SettingsData%TStart = SrcIfWDriver_SettingsData%TStart
   DstIfWDriver_SettingsData%FFTcoord(1:3) = SrcIfWDriver_SettingsData%FFTcoord(1:3)
   DstIfWDriver_SettingsData%GridDelta(1:3) = SrcIfWDriver_SettingsData%GridDelta(1:3)
   DstIfWDriver_SettingsData%GridN(1:3) = SrcIfWDriver_SettingsData%GridN(1:3)
   DstIfWDriver_SettingsData%XRange(1:2) = SrcIfWDriver_SettingsData%XRange(1:2)
   DstIfWDriver_SettingsData%YRange(1:2) = SrcIfWDriver_SettingsData%YRange(1:2)
   DstIfWDriver_SettingsData%ZRange(1:2) = SrcIfWDriver_SettingsData%ZRange(1:2)
   call NWTC_Library_CopyProgDesc(SrcIfWDriver_SettingsData%ProgInfo, DstIfWDriver_SettingsData%ProgInfo, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_Driver_CopyOutputFile(SrcIfWDriver_SettingsData%WindGridOutput, DstIfWDriver_SettingsData%WindGridOutput, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_Driver_CopyOutputFile(SrcIfWDriver_SettingsData%FFTOutput, DstIfWDriver_SettingsData%FFTOutput, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_Driver_CopyOutputFile(SrcIfWDriver_SettingsData%PointsVelOutput, DstIfWDriver_SettingsData%PointsVelOutput, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstIfWDriver_SettingsData%NOutWindXY = SrcIfWDriver_SettingsData%NOutWindXY
   if (allocated(SrcIfWDriver_SettingsData%OutWindZ)) then
      LB(1:1) = lbound(SrcIfWDriver_SettingsData%OutWindZ)
      UB(1:1) = ubound(SrcIfWDriver_SettingsData%OutWindZ)
      if (.not. allocated(DstIfWDriver_SettingsData%OutWindZ)) then
         allocate(DstIfWDriver_SettingsData%OutWindZ(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIfWDriver_SettingsData%OutWindZ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstIfWDriver_SettingsData%OutWindZ = SrcIfWDriver_SettingsData%OutWindZ
   end if
   DstIfWDriver_SettingsData%NOutWindXZ = SrcIfWDriver_SettingsData%NOutWindXZ
   if (allocated(SrcIfWDriver_SettingsData%OutWindY)) then
      LB(1:1) = lbound(SrcIfWDriver_SettingsData%OutWindY)
      UB(1:1) = ubound(SrcIfWDriver_SettingsData%OutWindY)
      if (.not. allocated(DstIfWDriver_SettingsData%OutWindY)) then
         allocate(DstIfWDriver_SettingsData%OutWindY(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIfWDriver_SettingsData%OutWindY.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstIfWDriver_SettingsData%OutWindY = SrcIfWDriver_SettingsData%OutWindY
   end if
   DstIfWDriver_SettingsData%NOutWindYZ = SrcIfWDriver_SettingsData%NOutWindYZ
   if (allocated(SrcIfWDriver_SettingsData%OutWindX)) then
      LB(1:1) = lbound(SrcIfWDriver_SettingsData%OutWindX)
      UB(1:1) = ubound(SrcIfWDriver_SettingsData%OutWindX)
      if (.not. allocated(DstIfWDriver_SettingsData%OutWindX)) then
         allocate(DstIfWDriver_SettingsData%OutWindX(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIfWDriver_SettingsData%OutWindX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstIfWDriver_SettingsData%OutWindX = SrcIfWDriver_SettingsData%OutWindX
   end if
end subroutine

subroutine InflowWind_Driver_DestroyIfWDriver_Settings(IfWDriver_SettingsData, ErrStat, ErrMsg)
   type(IfWDriver_Settings), intent(inout) :: IfWDriver_SettingsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'InflowWind_Driver_DestroyIfWDriver_Settings'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyProgDesc(IfWDriver_SettingsData%ProgInfo, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_Driver_DestroyOutputFile(IfWDriver_SettingsData%WindGridOutput, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_Driver_DestroyOutputFile(IfWDriver_SettingsData%FFTOutput, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_Driver_DestroyOutputFile(IfWDriver_SettingsData%PointsVelOutput, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(IfWDriver_SettingsData%OutWindZ)) then
      deallocate(IfWDriver_SettingsData%OutWindZ)
   end if
   if (allocated(IfWDriver_SettingsData%OutWindY)) then
      deallocate(IfWDriver_SettingsData%OutWindY)
   end if
   if (allocated(IfWDriver_SettingsData%OutWindX)) then
      deallocate(IfWDriver_SettingsData%OutWindX)
   end if
end subroutine

subroutine InflowWind_Driver_PackIfWDriver_Settings(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(IfWDriver_Settings), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_Driver_PackIfWDriver_Settings'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%DvrIptFileName)
   call RegPack(Buf, InData%IfWIptFileName)
   call RegPack(Buf, InData%SummaryFileName)
   call RegPack(Buf, InData%PointsFileName)
   call RegPack(Buf, InData%NumTimeSteps)
   call RegPack(Buf, InData%DT)
   call RegPack(Buf, InData%TStart)
   call RegPack(Buf, InData%FFTcoord(1:3))
   call RegPack(Buf, InData%GridDelta(1:3))
   call RegPack(Buf, InData%GridN(1:3))
   call RegPack(Buf, InData%XRange(1:2))
   call RegPack(Buf, InData%YRange(1:2))
   call RegPack(Buf, InData%ZRange(1:2))
   call NWTC_Library_PackProgDesc(Buf, InData%ProgInfo) 
   call InflowWind_Driver_PackOutputFile(Buf, InData%WindGridOutput) 
   call InflowWind_Driver_PackOutputFile(Buf, InData%FFTOutput) 
   call InflowWind_Driver_PackOutputFile(Buf, InData%PointsVelOutput) 
   call RegPack(Buf, InData%NOutWindXY)
   call RegPack(Buf, allocated(InData%OutWindZ))
   if (allocated(InData%OutWindZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutWindZ), ubound(InData%OutWindZ))
      call RegPack(Buf, InData%OutWindZ)
   end if
   call RegPack(Buf, InData%NOutWindXZ)
   call RegPack(Buf, allocated(InData%OutWindY))
   if (allocated(InData%OutWindY)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutWindY), ubound(InData%OutWindY))
      call RegPack(Buf, InData%OutWindY)
   end if
   call RegPack(Buf, InData%NOutWindYZ)
   call RegPack(Buf, allocated(InData%OutWindX))
   if (allocated(InData%OutWindX)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutWindX), ubound(InData%OutWindX))
      call RegPack(Buf, InData%OutWindX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_Driver_UnPackIfWDriver_Settings(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(IfWDriver_Settings), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_Driver_UnPackIfWDriver_Settings'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%DvrIptFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%IfWIptFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SummaryFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PointsFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTimeSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TStart)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FFTcoord(1:3))
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%GridDelta(1:3))
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%GridN(1:3))
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%XRange(1:2))
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%YRange(1:2))
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ZRange(1:2))
   if (RegCheckErr(Buf, RoutineName)) return
   call NWTC_Library_UnpackProgDesc(Buf, OutData%ProgInfo) ! ProgInfo 
   call InflowWind_Driver_UnpackOutputFile(Buf, OutData%WindGridOutput) ! WindGridOutput 
   call InflowWind_Driver_UnpackOutputFile(Buf, OutData%FFTOutput) ! FFTOutput 
   call InflowWind_Driver_UnpackOutputFile(Buf, OutData%PointsVelOutput) ! PointsVelOutput 
   call RegUnpack(Buf, OutData%NOutWindXY)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutWindZ)) deallocate(OutData%OutWindZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutWindZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutWindZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutWindZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NOutWindXZ)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutWindY)) deallocate(OutData%OutWindY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutWindY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutWindY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutWindY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NOutWindYZ)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutWindX)) deallocate(OutData%OutWindX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutWindX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutWindX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutWindX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
END MODULE InflowWind_Driver_Types
!ENDOFREGISTRYGENERATEDFILE
