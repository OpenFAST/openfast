!STARTOFREGISTRYGENERATEDFILE 'IfW_FlowField_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! IfW_FlowField_Types
!.................................................................................................................................
! This file is part of IfW_FlowField.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in IfW_FlowField. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE IfW_FlowField_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Undef_FieldType = 0      ! This is the code for an undefined FieldType [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Uniform_FieldType = 1      ! Uniform FieldType from SteadyWind or Uniform Wind [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Grid3D_FieldType = 2      ! 3D Grid FieldType from TurbSim, Bladed, HAWC [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Grid4D_FieldType = 3      ! 4D Grid FieldType from FAST.Farm [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Point_FieldType = 4      ! Points FieldType from ExtInflow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: User_FieldType = 5      ! User FieldType configured by the user [-]
! =========  UniformFieldType  =======
  TYPE, PUBLIC :: UniformFieldType
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
    REAL(ReKi)  :: RefLength      !< reference length used to scale the linear shear [meters]
    INTEGER(IntKi)  :: DataSize      !< size of data in HH file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Time      !< HH time array [seconds]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelHDot      !< Derivative of HH horizontal wind speed wrt time [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelVDot      !< Derivative of HH vertical wind speed wrt time [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelGustDot      !< Derivative of HH wind gust speed wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleHDot      !< Derivative of HH wind direction angle wrt time [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleVDot      !< Derivative of HH upflow angle wrt time [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrHDot      !< Derivative of HH horizontal linear shear wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrVDot      !< Derivative of HH vertical shear exponent wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LinShrV      !< HH vertical linear shear [seconds]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LinShrVDot      !< Derivative of HH vertical linear shear wrt time [seconds]
  END TYPE UniformFieldType
! =======================
! =========  UniformField_Interp  =======
  TYPE, PUBLIC :: UniformField_Interp
    REAL(ReKi)  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi)  :: VelHDot      !< derivative of HH horizontal wind speed wrt Time [meters/sec]
    REAL(ReKi)  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi)  :: VelVDot      !< derivative of HH vertical wind speed wrt Time [meters/sec]
    REAL(ReKi)  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi)  :: VelGustDot      !< derivative of HH wind gust speed wrt Time [-]
    REAL(ReKi)  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi)  :: AngleHDot      !< derivative of HH wind direction angle wrt Time [degrees]
    REAL(ReKi)  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi)  :: AngleVDot      !< derivative of HH upflow angle wrt Time [degrees]
    REAL(ReKi)  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi)  :: ShrHDot      !< derivative of HH horizontal linear shear wrt Time [-]
    REAL(ReKi)  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi)  :: ShrVDot      !< derivative of HH vertical shear exponent wrt Time [-]
    REAL(ReKi)  :: LinShrV      !< HH vertical linear shear [seconds]
    REAL(ReKi)  :: LinShrVDot      !< derivative of HH vertical linear shear wrt Time [seconds]
    REAL(ReKi)  :: CosAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: SinAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: CosAngleV      !< Vertical angle components [-]
    REAL(ReKi)  :: SinAngleV      !< Vertical angle components [-]
  END TYPE UniformField_Interp
! =======================
! =========  Grid3DFieldType  =======
  TYPE, PUBLIC :: Grid3DFieldType
    INTEGER(IntKi)  :: WindFileFormat      !< Binary file format description number [-]
    INTEGER(IntKi)  :: WindProfileType = -1      !< Wind profile type (0=constant;1=logarithmic;2=power law) [-]
    LOGICAL  :: Periodic = .false.      !< Flag to indicate if the wind file is periodic [-]
    LOGICAL  :: InterpTower = .false.      !< Flag to indicate if we should interpolate wind speeds below the tower [-]
    LOGICAL  :: AddMeanAfterInterp = .false.      !< Add the mean wind speed after interpolating at a given height? [-]
    REAL(ReKi)  :: RefHeight = 0      !< Reference (hub) height of the grid [meters]
    REAL(ReKi)  :: RefLength = 1.0_ReKi      !< Reference (rotor) length of the grid (used for horizontal wind profile type only) [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vel      !< Array of field velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Acc      !< Array of field accelerations [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: VelTower      !< Array of tower velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccTower      !< Array of tower accelerations [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: VelAvg      !< Average velocity profile by Z and time [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccAvg      !< Average acceleration profile by Z and time [-]
    REAL(ReKi)  :: DTime = 0      !< Delta time [seconds]
    REAL(ReKi)  :: Rate = 0      !< Data rate (1/FFDTime) [Hertz]
    REAL(ReKi)  :: YHWid = 0      !< Half the grid width [meters]
    REAL(ReKi)  :: ZHWid = 0      !< Half the grid height [meters]
    REAL(ReKi)  :: GridBase = 0      !< the height of the bottom of the grid [meters]
    REAL(ReKi)  :: InitXPosition = 0      !< the initial x position of grid (distance in FF is offset) [meters]
    REAL(ReKi)  :: InvDY = 0      !< reciprocal of delta y [1/meters]
    REAL(ReKi)  :: InvDZ = 0      !< reciprocal of delta z [1/meters]
    REAL(ReKi)  :: MeanWS = 0      !< Mean wind speed (as defined in FF file), not necessarily of the portion used [meters/second]
    REAL(ReKi)  :: InvMWS = 0      !< reciprocal of mean wind speed (MeanFFWS) [seconds/meter]
    REAL(ReKi)  :: TotalTime = 0      !< The total time of the simulation [seconds]
    INTEGER(IntKi)  :: NComp = 3      !< Number of wind components [-]
    INTEGER(IntKi)  :: NYGrids = 0      !< Number of points in the lateral (y) direction of the grids [-]
    INTEGER(IntKi)  :: NZGrids = 0      !< Number of points in the vertical (z) direction of the grids [-]
    INTEGER(IntKi)  :: NTGrids = 0      !< Number of points in the vertical (z) direction on the tower (below the grids) [-]
    INTEGER(IntKi)  :: NSteps = 0      !< Number of time steps in the FF array [-]
    REAL(ReKi)  :: PLExp = 0      !< Power law exponent (used for PL wind profile type only) [-]
    REAL(ReKi)  :: Z0 = 0      !< Surface roughness length (used for LOG wind profile type only) [-]
    REAL(ReKi)  :: VLinShr = 0      !< Vertical linear wind shear coefficient (used for vertical linear wind profile type only) [-]
    REAL(ReKi)  :: HLinShr = 0      !< Horizontal linear wind shear coefficient (used for horizontal wind profile type only) [-]
    LOGICAL  :: BoxExceedAllowF = .FALSE.      !< Flag to allow Extrapolation winds outside box starting at this index (for OLAF wakes and LidarSim) [-]
    INTEGER(IntKi)  :: BoxExceedAllowIdx = -1      !< Extrapolate winds outside box starting at this index (for OLAF wakes and LidarSim) [-]
    LOGICAL  :: BoxExceedWarned = .FALSE.      !< Has a warning been issued for points extrapolated beyond FFWind grid [-]
  END TYPE Grid3DFieldType
! =======================
! =========  Grid4DFieldType  =======
  TYPE, PUBLIC :: Grid4DFieldType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of evenly-spaced grid points in the x, y, z, and t directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction [m,m,m,s]
    REAL(ReKi) , DIMENSION(1:3)  :: pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: Vel => NULL()      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt] [-]
    REAL(ReKi)  :: TimeStart      !< this is the time where the first time grid in m%V starts (i.e, the time associated with m%V(:,:,:,:,1)) [s]
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
  END TYPE Grid4DFieldType
! =======================
! =========  PointsFieldType  =======
  TYPE, PUBLIC :: PointsFieldType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vel      !< Point velocities populated by external driver [uvw,point] [-]
  END TYPE PointsFieldType
! =======================
! =========  UserFieldType  =======
  TYPE, PUBLIC :: UserFieldType
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
  END TYPE UserFieldType
! =======================
! =========  FlowFieldType  =======
  TYPE, PUBLIC :: FlowFieldType
    INTEGER(IntKi)  :: FieldType = 0      !< Switch for flow field type {1=Uniform, 2=Grid, 3=User, 4=External} [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RefPosition      !< Reference position (point where box is rotated) [meters]
    REAL(ReKi)  :: PropagationDir      !< Direction of wind propagation [radians]
    REAL(ReKi)  :: VFlowAngle      !< Vertical (upflow) angle [radians]
    LOGICAL  :: VelInterpCubic = .false.      !< Velocity interpolation order in time (1=linear; 3=cubic) [Used with WindType=2,3,4,5,7] [-]
    LOGICAL  :: RotateWindBox = .false.      !< flag indicating if the wind will be rotated [-]
    LOGICAL  :: AccFieldValid = .false.      !< flag indicating that acceleration field has been calculated [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotToWind      !< Rotation matrix for rotating from the global XYZ coordinate system to the wind coordinate system (wind along X') [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotFromWind      !< Rotation matrix for rotating from the wind coordinate system (wind along X') back to the global XYZ coordinate system.  Equal to TRANSPOSE(RotToWind) [-]
    TYPE(UniformFieldType)  :: Uniform      !< Uniform Flow Data [-]
    TYPE(Grid3DFieldType)  :: Grid3D      !< Grid Field Wind Data [-]
    TYPE(Grid4DFieldType)  :: Grid4D      !< External Grid Flow Data [-]
    TYPE(PointsFieldType)  :: Points      !< External Point Flow Data [-]
    TYPE(UserFieldType)  :: User      !< User Field Wind Data [-]
  END TYPE FlowFieldType
! =======================
CONTAINS

subroutine IfW_FlowField_CopyUniformFieldType(SrcUniformFieldTypeData, DstUniformFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(UniformFieldType), intent(in) :: SrcUniformFieldTypeData
   type(UniformFieldType), intent(inout) :: DstUniformFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyUniformFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstUniformFieldTypeData%RefHeight = SrcUniformFieldTypeData%RefHeight
   DstUniformFieldTypeData%RefLength = SrcUniformFieldTypeData%RefLength
   DstUniformFieldTypeData%DataSize = SrcUniformFieldTypeData%DataSize
   if (allocated(SrcUniformFieldTypeData%Time)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%Time)
      UB(1:1) = ubound(SrcUniformFieldTypeData%Time)
      if (.not. allocated(DstUniformFieldTypeData%Time)) then
         allocate(DstUniformFieldTypeData%Time(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%Time.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%Time = SrcUniformFieldTypeData%Time
   else if (allocated(DstUniformFieldTypeData%Time)) then
      deallocate(DstUniformFieldTypeData%Time)
   end if
   if (allocated(SrcUniformFieldTypeData%VelH)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelH)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelH)
      if (.not. allocated(DstUniformFieldTypeData%VelH)) then
         allocate(DstUniformFieldTypeData%VelH(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelH.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelH = SrcUniformFieldTypeData%VelH
   else if (allocated(DstUniformFieldTypeData%VelH)) then
      deallocate(DstUniformFieldTypeData%VelH)
   end if
   if (allocated(SrcUniformFieldTypeData%VelHDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelHDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelHDot)
      if (.not. allocated(DstUniformFieldTypeData%VelHDot)) then
         allocate(DstUniformFieldTypeData%VelHDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelHDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelHDot = SrcUniformFieldTypeData%VelHDot
   else if (allocated(DstUniformFieldTypeData%VelHDot)) then
      deallocate(DstUniformFieldTypeData%VelHDot)
   end if
   if (allocated(SrcUniformFieldTypeData%VelV)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelV)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelV)
      if (.not. allocated(DstUniformFieldTypeData%VelV)) then
         allocate(DstUniformFieldTypeData%VelV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelV = SrcUniformFieldTypeData%VelV
   else if (allocated(DstUniformFieldTypeData%VelV)) then
      deallocate(DstUniformFieldTypeData%VelV)
   end if
   if (allocated(SrcUniformFieldTypeData%VelVDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelVDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelVDot)
      if (.not. allocated(DstUniformFieldTypeData%VelVDot)) then
         allocate(DstUniformFieldTypeData%VelVDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelVDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelVDot = SrcUniformFieldTypeData%VelVDot
   else if (allocated(DstUniformFieldTypeData%VelVDot)) then
      deallocate(DstUniformFieldTypeData%VelVDot)
   end if
   if (allocated(SrcUniformFieldTypeData%VelGust)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelGust)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelGust)
      if (.not. allocated(DstUniformFieldTypeData%VelGust)) then
         allocate(DstUniformFieldTypeData%VelGust(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelGust.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelGust = SrcUniformFieldTypeData%VelGust
   else if (allocated(DstUniformFieldTypeData%VelGust)) then
      deallocate(DstUniformFieldTypeData%VelGust)
   end if
   if (allocated(SrcUniformFieldTypeData%VelGustDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%VelGustDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%VelGustDot)
      if (.not. allocated(DstUniformFieldTypeData%VelGustDot)) then
         allocate(DstUniformFieldTypeData%VelGustDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelGustDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%VelGustDot = SrcUniformFieldTypeData%VelGustDot
   else if (allocated(DstUniformFieldTypeData%VelGustDot)) then
      deallocate(DstUniformFieldTypeData%VelGustDot)
   end if
   if (allocated(SrcUniformFieldTypeData%AngleH)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%AngleH)
      UB(1:1) = ubound(SrcUniformFieldTypeData%AngleH)
      if (.not. allocated(DstUniformFieldTypeData%AngleH)) then
         allocate(DstUniformFieldTypeData%AngleH(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleH.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%AngleH = SrcUniformFieldTypeData%AngleH
   else if (allocated(DstUniformFieldTypeData%AngleH)) then
      deallocate(DstUniformFieldTypeData%AngleH)
   end if
   if (allocated(SrcUniformFieldTypeData%AngleHDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%AngleHDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%AngleHDot)
      if (.not. allocated(DstUniformFieldTypeData%AngleHDot)) then
         allocate(DstUniformFieldTypeData%AngleHDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleHDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%AngleHDot = SrcUniformFieldTypeData%AngleHDot
   else if (allocated(DstUniformFieldTypeData%AngleHDot)) then
      deallocate(DstUniformFieldTypeData%AngleHDot)
   end if
   if (allocated(SrcUniformFieldTypeData%AngleV)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%AngleV)
      UB(1:1) = ubound(SrcUniformFieldTypeData%AngleV)
      if (.not. allocated(DstUniformFieldTypeData%AngleV)) then
         allocate(DstUniformFieldTypeData%AngleV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%AngleV = SrcUniformFieldTypeData%AngleV
   else if (allocated(DstUniformFieldTypeData%AngleV)) then
      deallocate(DstUniformFieldTypeData%AngleV)
   end if
   if (allocated(SrcUniformFieldTypeData%AngleVDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%AngleVDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%AngleVDot)
      if (.not. allocated(DstUniformFieldTypeData%AngleVDot)) then
         allocate(DstUniformFieldTypeData%AngleVDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleVDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%AngleVDot = SrcUniformFieldTypeData%AngleVDot
   else if (allocated(DstUniformFieldTypeData%AngleVDot)) then
      deallocate(DstUniformFieldTypeData%AngleVDot)
   end if
   if (allocated(SrcUniformFieldTypeData%ShrH)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%ShrH)
      UB(1:1) = ubound(SrcUniformFieldTypeData%ShrH)
      if (.not. allocated(DstUniformFieldTypeData%ShrH)) then
         allocate(DstUniformFieldTypeData%ShrH(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrH.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%ShrH = SrcUniformFieldTypeData%ShrH
   else if (allocated(DstUniformFieldTypeData%ShrH)) then
      deallocate(DstUniformFieldTypeData%ShrH)
   end if
   if (allocated(SrcUniformFieldTypeData%ShrHDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%ShrHDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%ShrHDot)
      if (.not. allocated(DstUniformFieldTypeData%ShrHDot)) then
         allocate(DstUniformFieldTypeData%ShrHDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrHDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%ShrHDot = SrcUniformFieldTypeData%ShrHDot
   else if (allocated(DstUniformFieldTypeData%ShrHDot)) then
      deallocate(DstUniformFieldTypeData%ShrHDot)
   end if
   if (allocated(SrcUniformFieldTypeData%ShrV)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%ShrV)
      UB(1:1) = ubound(SrcUniformFieldTypeData%ShrV)
      if (.not. allocated(DstUniformFieldTypeData%ShrV)) then
         allocate(DstUniformFieldTypeData%ShrV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%ShrV = SrcUniformFieldTypeData%ShrV
   else if (allocated(DstUniformFieldTypeData%ShrV)) then
      deallocate(DstUniformFieldTypeData%ShrV)
   end if
   if (allocated(SrcUniformFieldTypeData%ShrVDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%ShrVDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%ShrVDot)
      if (.not. allocated(DstUniformFieldTypeData%ShrVDot)) then
         allocate(DstUniformFieldTypeData%ShrVDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrVDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%ShrVDot = SrcUniformFieldTypeData%ShrVDot
   else if (allocated(DstUniformFieldTypeData%ShrVDot)) then
      deallocate(DstUniformFieldTypeData%ShrVDot)
   end if
   if (allocated(SrcUniformFieldTypeData%LinShrV)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%LinShrV)
      UB(1:1) = ubound(SrcUniformFieldTypeData%LinShrV)
      if (.not. allocated(DstUniformFieldTypeData%LinShrV)) then
         allocate(DstUniformFieldTypeData%LinShrV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%LinShrV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%LinShrV = SrcUniformFieldTypeData%LinShrV
   else if (allocated(DstUniformFieldTypeData%LinShrV)) then
      deallocate(DstUniformFieldTypeData%LinShrV)
   end if
   if (allocated(SrcUniformFieldTypeData%LinShrVDot)) then
      LB(1:1) = lbound(SrcUniformFieldTypeData%LinShrVDot)
      UB(1:1) = ubound(SrcUniformFieldTypeData%LinShrVDot)
      if (.not. allocated(DstUniformFieldTypeData%LinShrVDot)) then
         allocate(DstUniformFieldTypeData%LinShrVDot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%LinShrVDot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstUniformFieldTypeData%LinShrVDot = SrcUniformFieldTypeData%LinShrVDot
   else if (allocated(DstUniformFieldTypeData%LinShrVDot)) then
      deallocate(DstUniformFieldTypeData%LinShrVDot)
   end if
end subroutine

subroutine IfW_FlowField_DestroyUniformFieldType(UniformFieldTypeData, ErrStat, ErrMsg)
   type(UniformFieldType), intent(inout) :: UniformFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyUniformFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(UniformFieldTypeData%Time)) then
      deallocate(UniformFieldTypeData%Time)
   end if
   if (allocated(UniformFieldTypeData%VelH)) then
      deallocate(UniformFieldTypeData%VelH)
   end if
   if (allocated(UniformFieldTypeData%VelHDot)) then
      deallocate(UniformFieldTypeData%VelHDot)
   end if
   if (allocated(UniformFieldTypeData%VelV)) then
      deallocate(UniformFieldTypeData%VelV)
   end if
   if (allocated(UniformFieldTypeData%VelVDot)) then
      deallocate(UniformFieldTypeData%VelVDot)
   end if
   if (allocated(UniformFieldTypeData%VelGust)) then
      deallocate(UniformFieldTypeData%VelGust)
   end if
   if (allocated(UniformFieldTypeData%VelGustDot)) then
      deallocate(UniformFieldTypeData%VelGustDot)
   end if
   if (allocated(UniformFieldTypeData%AngleH)) then
      deallocate(UniformFieldTypeData%AngleH)
   end if
   if (allocated(UniformFieldTypeData%AngleHDot)) then
      deallocate(UniformFieldTypeData%AngleHDot)
   end if
   if (allocated(UniformFieldTypeData%AngleV)) then
      deallocate(UniformFieldTypeData%AngleV)
   end if
   if (allocated(UniformFieldTypeData%AngleVDot)) then
      deallocate(UniformFieldTypeData%AngleVDot)
   end if
   if (allocated(UniformFieldTypeData%ShrH)) then
      deallocate(UniformFieldTypeData%ShrH)
   end if
   if (allocated(UniformFieldTypeData%ShrHDot)) then
      deallocate(UniformFieldTypeData%ShrHDot)
   end if
   if (allocated(UniformFieldTypeData%ShrV)) then
      deallocate(UniformFieldTypeData%ShrV)
   end if
   if (allocated(UniformFieldTypeData%ShrVDot)) then
      deallocate(UniformFieldTypeData%ShrVDot)
   end if
   if (allocated(UniformFieldTypeData%LinShrV)) then
      deallocate(UniformFieldTypeData%LinShrV)
   end if
   if (allocated(UniformFieldTypeData%LinShrVDot)) then
      deallocate(UniformFieldTypeData%LinShrVDot)
   end if
end subroutine

subroutine IfW_FlowField_PackUniformFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UniformFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUniformFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%RefHeight)
   call RegPack(Buf, InData%RefLength)
   call RegPack(Buf, InData%DataSize)
   call RegPack(Buf, allocated(InData%Time))
   if (allocated(InData%Time)) then
      call RegPackBounds(Buf, 1, lbound(InData%Time), ubound(InData%Time))
      call RegPack(Buf, InData%Time)
   end if
   call RegPack(Buf, allocated(InData%VelH))
   if (allocated(InData%VelH)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelH), ubound(InData%VelH))
      call RegPack(Buf, InData%VelH)
   end if
   call RegPack(Buf, allocated(InData%VelHDot))
   if (allocated(InData%VelHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelHDot), ubound(InData%VelHDot))
      call RegPack(Buf, InData%VelHDot)
   end if
   call RegPack(Buf, allocated(InData%VelV))
   if (allocated(InData%VelV)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelV), ubound(InData%VelV))
      call RegPack(Buf, InData%VelV)
   end if
   call RegPack(Buf, allocated(InData%VelVDot))
   if (allocated(InData%VelVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelVDot), ubound(InData%VelVDot))
      call RegPack(Buf, InData%VelVDot)
   end if
   call RegPack(Buf, allocated(InData%VelGust))
   if (allocated(InData%VelGust)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelGust), ubound(InData%VelGust))
      call RegPack(Buf, InData%VelGust)
   end if
   call RegPack(Buf, allocated(InData%VelGustDot))
   if (allocated(InData%VelGustDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelGustDot), ubound(InData%VelGustDot))
      call RegPack(Buf, InData%VelGustDot)
   end if
   call RegPack(Buf, allocated(InData%AngleH))
   if (allocated(InData%AngleH)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleH), ubound(InData%AngleH))
      call RegPack(Buf, InData%AngleH)
   end if
   call RegPack(Buf, allocated(InData%AngleHDot))
   if (allocated(InData%AngleHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleHDot), ubound(InData%AngleHDot))
      call RegPack(Buf, InData%AngleHDot)
   end if
   call RegPack(Buf, allocated(InData%AngleV))
   if (allocated(InData%AngleV)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleV), ubound(InData%AngleV))
      call RegPack(Buf, InData%AngleV)
   end if
   call RegPack(Buf, allocated(InData%AngleVDot))
   if (allocated(InData%AngleVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleVDot), ubound(InData%AngleVDot))
      call RegPack(Buf, InData%AngleVDot)
   end if
   call RegPack(Buf, allocated(InData%ShrH))
   if (allocated(InData%ShrH)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrH), ubound(InData%ShrH))
      call RegPack(Buf, InData%ShrH)
   end if
   call RegPack(Buf, allocated(InData%ShrHDot))
   if (allocated(InData%ShrHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrHDot), ubound(InData%ShrHDot))
      call RegPack(Buf, InData%ShrHDot)
   end if
   call RegPack(Buf, allocated(InData%ShrV))
   if (allocated(InData%ShrV)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrV), ubound(InData%ShrV))
      call RegPack(Buf, InData%ShrV)
   end if
   call RegPack(Buf, allocated(InData%ShrVDot))
   if (allocated(InData%ShrVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrVDot), ubound(InData%ShrVDot))
      call RegPack(Buf, InData%ShrVDot)
   end if
   call RegPack(Buf, allocated(InData%LinShrV))
   if (allocated(InData%LinShrV)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinShrV), ubound(InData%LinShrV))
      call RegPack(Buf, InData%LinShrV)
   end if
   call RegPack(Buf, allocated(InData%LinShrVDot))
   if (allocated(InData%LinShrVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinShrVDot), ubound(InData%LinShrVDot))
      call RegPack(Buf, InData%LinShrVDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUniformFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UniformFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUniformFieldType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DataSize)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%Time)) deallocate(OutData%Time)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Time(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Time.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Time)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelH)) deallocate(OutData%VelH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelHDot)) deallocate(OutData%VelHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelV)) deallocate(OutData%VelV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelVDot)) deallocate(OutData%VelVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelGust)) deallocate(OutData%VelGust)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelGust(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelGust.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelGust)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelGustDot)) deallocate(OutData%VelGustDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelGustDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelGustDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelGustDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AngleH)) deallocate(OutData%AngleH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AngleHDot)) deallocate(OutData%AngleHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AngleV)) deallocate(OutData%AngleV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AngleVDot)) deallocate(OutData%AngleVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ShrH)) deallocate(OutData%ShrH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ShrHDot)) deallocate(OutData%ShrHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ShrV)) deallocate(OutData%ShrV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ShrVDot)) deallocate(OutData%ShrVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%LinShrV)) deallocate(OutData%LinShrV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinShrV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinShrV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinShrV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%LinShrVDot)) deallocate(OutData%LinShrVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinShrVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinShrVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinShrVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine IfW_FlowField_CopyUniformField_Interp(SrcUniformField_InterpData, DstUniformField_InterpData, CtrlCode, ErrStat, ErrMsg)
   type(UniformField_Interp), intent(in) :: SrcUniformField_InterpData
   type(UniformField_Interp), intent(inout) :: DstUniformField_InterpData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyUniformField_Interp'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstUniformField_InterpData%VelH = SrcUniformField_InterpData%VelH
   DstUniformField_InterpData%VelHDot = SrcUniformField_InterpData%VelHDot
   DstUniformField_InterpData%VelV = SrcUniformField_InterpData%VelV
   DstUniformField_InterpData%VelVDot = SrcUniformField_InterpData%VelVDot
   DstUniformField_InterpData%VelGust = SrcUniformField_InterpData%VelGust
   DstUniformField_InterpData%VelGustDot = SrcUniformField_InterpData%VelGustDot
   DstUniformField_InterpData%AngleH = SrcUniformField_InterpData%AngleH
   DstUniformField_InterpData%AngleHDot = SrcUniformField_InterpData%AngleHDot
   DstUniformField_InterpData%AngleV = SrcUniformField_InterpData%AngleV
   DstUniformField_InterpData%AngleVDot = SrcUniformField_InterpData%AngleVDot
   DstUniformField_InterpData%ShrH = SrcUniformField_InterpData%ShrH
   DstUniformField_InterpData%ShrHDot = SrcUniformField_InterpData%ShrHDot
   DstUniformField_InterpData%ShrV = SrcUniformField_InterpData%ShrV
   DstUniformField_InterpData%ShrVDot = SrcUniformField_InterpData%ShrVDot
   DstUniformField_InterpData%LinShrV = SrcUniformField_InterpData%LinShrV
   DstUniformField_InterpData%LinShrVDot = SrcUniformField_InterpData%LinShrVDot
   DstUniformField_InterpData%CosAngleH = SrcUniformField_InterpData%CosAngleH
   DstUniformField_InterpData%SinAngleH = SrcUniformField_InterpData%SinAngleH
   DstUniformField_InterpData%CosAngleV = SrcUniformField_InterpData%CosAngleV
   DstUniformField_InterpData%SinAngleV = SrcUniformField_InterpData%SinAngleV
end subroutine

subroutine IfW_FlowField_DestroyUniformField_Interp(UniformField_InterpData, ErrStat, ErrMsg)
   type(UniformField_Interp), intent(inout) :: UniformField_InterpData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyUniformField_Interp'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine IfW_FlowField_PackUniformField_Interp(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UniformField_Interp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUniformField_Interp'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%VelH)
   call RegPack(Buf, InData%VelHDot)
   call RegPack(Buf, InData%VelV)
   call RegPack(Buf, InData%VelVDot)
   call RegPack(Buf, InData%VelGust)
   call RegPack(Buf, InData%VelGustDot)
   call RegPack(Buf, InData%AngleH)
   call RegPack(Buf, InData%AngleHDot)
   call RegPack(Buf, InData%AngleV)
   call RegPack(Buf, InData%AngleVDot)
   call RegPack(Buf, InData%ShrH)
   call RegPack(Buf, InData%ShrHDot)
   call RegPack(Buf, InData%ShrV)
   call RegPack(Buf, InData%ShrVDot)
   call RegPack(Buf, InData%LinShrV)
   call RegPack(Buf, InData%LinShrVDot)
   call RegPack(Buf, InData%CosAngleH)
   call RegPack(Buf, InData%SinAngleH)
   call RegPack(Buf, InData%CosAngleV)
   call RegPack(Buf, InData%SinAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUniformField_Interp(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UniformField_Interp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUniformField_Interp'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%VelH)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelGust)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelGustDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AngleHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AngleVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ShrH)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ShrHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%LinShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%LinShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CosAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SinAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CosAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SinAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_CopyGrid3DFieldType(SrcGrid3DFieldTypeData, DstGrid3DFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Grid3DFieldType), intent(in) :: SrcGrid3DFieldTypeData
   type(Grid3DFieldType), intent(inout) :: DstGrid3DFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyGrid3DFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstGrid3DFieldTypeData%WindFileFormat = SrcGrid3DFieldTypeData%WindFileFormat
   DstGrid3DFieldTypeData%WindProfileType = SrcGrid3DFieldTypeData%WindProfileType
   DstGrid3DFieldTypeData%Periodic = SrcGrid3DFieldTypeData%Periodic
   DstGrid3DFieldTypeData%InterpTower = SrcGrid3DFieldTypeData%InterpTower
   DstGrid3DFieldTypeData%AddMeanAfterInterp = SrcGrid3DFieldTypeData%AddMeanAfterInterp
   DstGrid3DFieldTypeData%RefHeight = SrcGrid3DFieldTypeData%RefHeight
   DstGrid3DFieldTypeData%RefLength = SrcGrid3DFieldTypeData%RefLength
   if (allocated(SrcGrid3DFieldTypeData%Vel)) then
      LB(1:4) = lbound(SrcGrid3DFieldTypeData%Vel)
      UB(1:4) = ubound(SrcGrid3DFieldTypeData%Vel)
      if (.not. allocated(DstGrid3DFieldTypeData%Vel)) then
         allocate(DstGrid3DFieldTypeData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%Vel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%Vel = SrcGrid3DFieldTypeData%Vel
   else if (allocated(DstGrid3DFieldTypeData%Vel)) then
      deallocate(DstGrid3DFieldTypeData%Vel)
   end if
   if (allocated(SrcGrid3DFieldTypeData%Acc)) then
      LB(1:4) = lbound(SrcGrid3DFieldTypeData%Acc)
      UB(1:4) = ubound(SrcGrid3DFieldTypeData%Acc)
      if (.not. allocated(DstGrid3DFieldTypeData%Acc)) then
         allocate(DstGrid3DFieldTypeData%Acc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%Acc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%Acc = SrcGrid3DFieldTypeData%Acc
   else if (allocated(DstGrid3DFieldTypeData%Acc)) then
      deallocate(DstGrid3DFieldTypeData%Acc)
   end if
   if (allocated(SrcGrid3DFieldTypeData%VelTower)) then
      LB(1:3) = lbound(SrcGrid3DFieldTypeData%VelTower)
      UB(1:3) = ubound(SrcGrid3DFieldTypeData%VelTower)
      if (.not. allocated(DstGrid3DFieldTypeData%VelTower)) then
         allocate(DstGrid3DFieldTypeData%VelTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%VelTower.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%VelTower = SrcGrid3DFieldTypeData%VelTower
   else if (allocated(DstGrid3DFieldTypeData%VelTower)) then
      deallocate(DstGrid3DFieldTypeData%VelTower)
   end if
   if (allocated(SrcGrid3DFieldTypeData%AccTower)) then
      LB(1:3) = lbound(SrcGrid3DFieldTypeData%AccTower)
      UB(1:3) = ubound(SrcGrid3DFieldTypeData%AccTower)
      if (.not. allocated(DstGrid3DFieldTypeData%AccTower)) then
         allocate(DstGrid3DFieldTypeData%AccTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%AccTower.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%AccTower = SrcGrid3DFieldTypeData%AccTower
   else if (allocated(DstGrid3DFieldTypeData%AccTower)) then
      deallocate(DstGrid3DFieldTypeData%AccTower)
   end if
   if (allocated(SrcGrid3DFieldTypeData%VelAvg)) then
      LB(1:3) = lbound(SrcGrid3DFieldTypeData%VelAvg)
      UB(1:3) = ubound(SrcGrid3DFieldTypeData%VelAvg)
      if (.not. allocated(DstGrid3DFieldTypeData%VelAvg)) then
         allocate(DstGrid3DFieldTypeData%VelAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%VelAvg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%VelAvg = SrcGrid3DFieldTypeData%VelAvg
   else if (allocated(DstGrid3DFieldTypeData%VelAvg)) then
      deallocate(DstGrid3DFieldTypeData%VelAvg)
   end if
   if (allocated(SrcGrid3DFieldTypeData%AccAvg)) then
      LB(1:3) = lbound(SrcGrid3DFieldTypeData%AccAvg)
      UB(1:3) = ubound(SrcGrid3DFieldTypeData%AccAvg)
      if (.not. allocated(DstGrid3DFieldTypeData%AccAvg)) then
         allocate(DstGrid3DFieldTypeData%AccAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%AccAvg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstGrid3DFieldTypeData%AccAvg = SrcGrid3DFieldTypeData%AccAvg
   else if (allocated(DstGrid3DFieldTypeData%AccAvg)) then
      deallocate(DstGrid3DFieldTypeData%AccAvg)
   end if
   DstGrid3DFieldTypeData%DTime = SrcGrid3DFieldTypeData%DTime
   DstGrid3DFieldTypeData%Rate = SrcGrid3DFieldTypeData%Rate
   DstGrid3DFieldTypeData%YHWid = SrcGrid3DFieldTypeData%YHWid
   DstGrid3DFieldTypeData%ZHWid = SrcGrid3DFieldTypeData%ZHWid
   DstGrid3DFieldTypeData%GridBase = SrcGrid3DFieldTypeData%GridBase
   DstGrid3DFieldTypeData%InitXPosition = SrcGrid3DFieldTypeData%InitXPosition
   DstGrid3DFieldTypeData%InvDY = SrcGrid3DFieldTypeData%InvDY
   DstGrid3DFieldTypeData%InvDZ = SrcGrid3DFieldTypeData%InvDZ
   DstGrid3DFieldTypeData%MeanWS = SrcGrid3DFieldTypeData%MeanWS
   DstGrid3DFieldTypeData%InvMWS = SrcGrid3DFieldTypeData%InvMWS
   DstGrid3DFieldTypeData%TotalTime = SrcGrid3DFieldTypeData%TotalTime
   DstGrid3DFieldTypeData%NComp = SrcGrid3DFieldTypeData%NComp
   DstGrid3DFieldTypeData%NYGrids = SrcGrid3DFieldTypeData%NYGrids
   DstGrid3DFieldTypeData%NZGrids = SrcGrid3DFieldTypeData%NZGrids
   DstGrid3DFieldTypeData%NTGrids = SrcGrid3DFieldTypeData%NTGrids
   DstGrid3DFieldTypeData%NSteps = SrcGrid3DFieldTypeData%NSteps
   DstGrid3DFieldTypeData%PLExp = SrcGrid3DFieldTypeData%PLExp
   DstGrid3DFieldTypeData%Z0 = SrcGrid3DFieldTypeData%Z0
   DstGrid3DFieldTypeData%VLinShr = SrcGrid3DFieldTypeData%VLinShr
   DstGrid3DFieldTypeData%HLinShr = SrcGrid3DFieldTypeData%HLinShr
   DstGrid3DFieldTypeData%BoxExceedAllowF = SrcGrid3DFieldTypeData%BoxExceedAllowF
   DstGrid3DFieldTypeData%BoxExceedAllowIdx = SrcGrid3DFieldTypeData%BoxExceedAllowIdx
   DstGrid3DFieldTypeData%BoxExceedWarned = SrcGrid3DFieldTypeData%BoxExceedWarned
end subroutine

subroutine IfW_FlowField_DestroyGrid3DFieldType(Grid3DFieldTypeData, ErrStat, ErrMsg)
   type(Grid3DFieldType), intent(inout) :: Grid3DFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyGrid3DFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Grid3DFieldTypeData%Vel)) then
      deallocate(Grid3DFieldTypeData%Vel)
   end if
   if (allocated(Grid3DFieldTypeData%Acc)) then
      deallocate(Grid3DFieldTypeData%Acc)
   end if
   if (allocated(Grid3DFieldTypeData%VelTower)) then
      deallocate(Grid3DFieldTypeData%VelTower)
   end if
   if (allocated(Grid3DFieldTypeData%AccTower)) then
      deallocate(Grid3DFieldTypeData%AccTower)
   end if
   if (allocated(Grid3DFieldTypeData%VelAvg)) then
      deallocate(Grid3DFieldTypeData%VelAvg)
   end if
   if (allocated(Grid3DFieldTypeData%AccAvg)) then
      deallocate(Grid3DFieldTypeData%AccAvg)
   end if
end subroutine

subroutine IfW_FlowField_PackGrid3DFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid3DFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackGrid3DFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%WindFileFormat)
   call RegPack(Buf, InData%WindProfileType)
   call RegPack(Buf, InData%Periodic)
   call RegPack(Buf, InData%InterpTower)
   call RegPack(Buf, InData%AddMeanAfterInterp)
   call RegPack(Buf, InData%RefHeight)
   call RegPack(Buf, InData%RefLength)
   call RegPack(Buf, allocated(InData%Vel))
   if (allocated(InData%Vel)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vel), ubound(InData%Vel))
      call RegPack(Buf, InData%Vel)
   end if
   call RegPack(Buf, allocated(InData%Acc))
   if (allocated(InData%Acc)) then
      call RegPackBounds(Buf, 4, lbound(InData%Acc), ubound(InData%Acc))
      call RegPack(Buf, InData%Acc)
   end if
   call RegPack(Buf, allocated(InData%VelTower))
   if (allocated(InData%VelTower)) then
      call RegPackBounds(Buf, 3, lbound(InData%VelTower), ubound(InData%VelTower))
      call RegPack(Buf, InData%VelTower)
   end if
   call RegPack(Buf, allocated(InData%AccTower))
   if (allocated(InData%AccTower)) then
      call RegPackBounds(Buf, 3, lbound(InData%AccTower), ubound(InData%AccTower))
      call RegPack(Buf, InData%AccTower)
   end if
   call RegPack(Buf, allocated(InData%VelAvg))
   if (allocated(InData%VelAvg)) then
      call RegPackBounds(Buf, 3, lbound(InData%VelAvg), ubound(InData%VelAvg))
      call RegPack(Buf, InData%VelAvg)
   end if
   call RegPack(Buf, allocated(InData%AccAvg))
   if (allocated(InData%AccAvg)) then
      call RegPackBounds(Buf, 3, lbound(InData%AccAvg), ubound(InData%AccAvg))
      call RegPack(Buf, InData%AccAvg)
   end if
   call RegPack(Buf, InData%DTime)
   call RegPack(Buf, InData%Rate)
   call RegPack(Buf, InData%YHWid)
   call RegPack(Buf, InData%ZHWid)
   call RegPack(Buf, InData%GridBase)
   call RegPack(Buf, InData%InitXPosition)
   call RegPack(Buf, InData%InvDY)
   call RegPack(Buf, InData%InvDZ)
   call RegPack(Buf, InData%MeanWS)
   call RegPack(Buf, InData%InvMWS)
   call RegPack(Buf, InData%TotalTime)
   call RegPack(Buf, InData%NComp)
   call RegPack(Buf, InData%NYGrids)
   call RegPack(Buf, InData%NZGrids)
   call RegPack(Buf, InData%NTGrids)
   call RegPack(Buf, InData%NSteps)
   call RegPack(Buf, InData%PLExp)
   call RegPack(Buf, InData%Z0)
   call RegPack(Buf, InData%VLinShr)
   call RegPack(Buf, InData%HLinShr)
   call RegPack(Buf, InData%BoxExceedAllowF)
   call RegPack(Buf, InData%BoxExceedAllowIdx)
   call RegPack(Buf, InData%BoxExceedWarned)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackGrid3DFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid3DFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackGrid3DFieldType'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%WindFileFormat)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WindProfileType)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Periodic)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InterpTower)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AddMeanAfterInterp)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Acc)) deallocate(OutData%Acc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Acc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Acc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Acc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelTower)) deallocate(OutData%VelTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AccTower)) deallocate(OutData%AccTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%VelAvg)) deallocate(OutData%VelAvg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelAvg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelAvg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AccAvg)) deallocate(OutData%AccAvg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccAvg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccAvg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%DTime)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Rate)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%YHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ZHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%GridBase)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InitXPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InvDY)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InvDZ)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MeanWS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InvMWS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TotalTime)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NComp)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NYGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NZGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NTGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Z0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BoxExceedAllowF)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BoxExceedAllowIdx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BoxExceedWarned)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_CopyGrid4DFieldType(SrcGrid4DFieldTypeData, DstGrid4DFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Grid4DFieldType), intent(in) :: SrcGrid4DFieldTypeData
   type(Grid4DFieldType), intent(inout) :: DstGrid4DFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(5), UB(5)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyGrid4DFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstGrid4DFieldTypeData%n = SrcGrid4DFieldTypeData%n
   DstGrid4DFieldTypeData%delta = SrcGrid4DFieldTypeData%delta
   DstGrid4DFieldTypeData%pZero = SrcGrid4DFieldTypeData%pZero
   DstGrid4DFieldTypeData%Vel => SrcGrid4DFieldTypeData%Vel
   DstGrid4DFieldTypeData%TimeStart = SrcGrid4DFieldTypeData%TimeStart
   DstGrid4DFieldTypeData%RefHeight = SrcGrid4DFieldTypeData%RefHeight
end subroutine

subroutine IfW_FlowField_DestroyGrid4DFieldType(Grid4DFieldTypeData, ErrStat, ErrMsg)
   type(Grid4DFieldType), intent(inout) :: Grid4DFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyGrid4DFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   nullify(Grid4DFieldTypeData%Vel)
end subroutine

subroutine IfW_FlowField_PackGrid4DFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid4DFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackGrid4DFieldType'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%n)
   call RegPack(Buf, InData%delta)
   call RegPack(Buf, InData%pZero)
   call RegPack(Buf, associated(InData%Vel))
   if (associated(InData%Vel)) then
      call RegPackBounds(Buf, 5, lbound(InData%Vel), ubound(InData%Vel))
      call RegPackPointer(Buf, c_loc(InData%Vel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%Vel)
      end if
   end if
   call RegPack(Buf, InData%TimeStart)
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackGrid4DFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid4DFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackGrid4DFieldType'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   if (associated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vel, UB(1:5)-LB(1:5))
         OutData%Vel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%Vel
      else
         allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%Vel)
         call RegUnpack(Buf, OutData%Vel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%Vel => null()
   end if
   call RegUnpack(Buf, OutData%TimeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_CopyPointsFieldType(SrcPointsFieldTypeData, DstPointsFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(PointsFieldType), intent(in) :: SrcPointsFieldTypeData
   type(PointsFieldType), intent(inout) :: DstPointsFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyPointsFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcPointsFieldTypeData%Vel)) then
      LB(1:2) = lbound(SrcPointsFieldTypeData%Vel)
      UB(1:2) = ubound(SrcPointsFieldTypeData%Vel)
      if (.not. allocated(DstPointsFieldTypeData%Vel)) then
         allocate(DstPointsFieldTypeData%Vel(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstPointsFieldTypeData%Vel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstPointsFieldTypeData%Vel = SrcPointsFieldTypeData%Vel
   else if (allocated(DstPointsFieldTypeData%Vel)) then
      deallocate(DstPointsFieldTypeData%Vel)
   end if
end subroutine

subroutine IfW_FlowField_DestroyPointsFieldType(PointsFieldTypeData, ErrStat, ErrMsg)
   type(PointsFieldType), intent(inout) :: PointsFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyPointsFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(PointsFieldTypeData%Vel)) then
      deallocate(PointsFieldTypeData%Vel)
   end if
end subroutine

subroutine IfW_FlowField_PackPointsFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(PointsFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackPointsFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%Vel))
   if (allocated(InData%Vel)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vel), ubound(InData%Vel))
      call RegPack(Buf, InData%Vel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackPointsFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(PointsFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackPointsFieldType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine IfW_FlowField_CopyUserFieldType(SrcUserFieldTypeData, DstUserFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(UserFieldType), intent(in) :: SrcUserFieldTypeData
   type(UserFieldType), intent(inout) :: DstUserFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyUserFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstUserFieldTypeData%RefHeight = SrcUserFieldTypeData%RefHeight
end subroutine

subroutine IfW_FlowField_DestroyUserFieldType(UserFieldTypeData, ErrStat, ErrMsg)
   type(UserFieldType), intent(inout) :: UserFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyUserFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine IfW_FlowField_PackUserFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UserFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUserFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUserFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UserFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUserFieldType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_CopyFlowFieldType(SrcFlowFieldTypeData, DstFlowFieldTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FlowFieldType), intent(in) :: SrcFlowFieldTypeData
   type(FlowFieldType), intent(inout) :: DstFlowFieldTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_CopyFlowFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFlowFieldTypeData%FieldType = SrcFlowFieldTypeData%FieldType
   DstFlowFieldTypeData%RefPosition = SrcFlowFieldTypeData%RefPosition
   DstFlowFieldTypeData%PropagationDir = SrcFlowFieldTypeData%PropagationDir
   DstFlowFieldTypeData%VFlowAngle = SrcFlowFieldTypeData%VFlowAngle
   DstFlowFieldTypeData%VelInterpCubic = SrcFlowFieldTypeData%VelInterpCubic
   DstFlowFieldTypeData%RotateWindBox = SrcFlowFieldTypeData%RotateWindBox
   DstFlowFieldTypeData%AccFieldValid = SrcFlowFieldTypeData%AccFieldValid
   DstFlowFieldTypeData%RotToWind = SrcFlowFieldTypeData%RotToWind
   DstFlowFieldTypeData%RotFromWind = SrcFlowFieldTypeData%RotFromWind
   call IfW_FlowField_CopyUniformFieldType(SrcFlowFieldTypeData%Uniform, DstFlowFieldTypeData%Uniform, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IfW_FlowField_CopyGrid3DFieldType(SrcFlowFieldTypeData%Grid3D, DstFlowFieldTypeData%Grid3D, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IfW_FlowField_CopyGrid4DFieldType(SrcFlowFieldTypeData%Grid4D, DstFlowFieldTypeData%Grid4D, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IfW_FlowField_CopyPointsFieldType(SrcFlowFieldTypeData%Points, DstFlowFieldTypeData%Points, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IfW_FlowField_CopyUserFieldType(SrcFlowFieldTypeData%User, DstFlowFieldTypeData%User, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine IfW_FlowField_DestroyFlowFieldType(FlowFieldTypeData, ErrStat, ErrMsg)
   type(FlowFieldType), intent(inout) :: FlowFieldTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'IfW_FlowField_DestroyFlowFieldType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine IfW_FlowField_PackFlowFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FlowFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackFlowFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%FieldType)
   call RegPack(Buf, InData%RefPosition)
   call RegPack(Buf, InData%PropagationDir)
   call RegPack(Buf, InData%VFlowAngle)
   call RegPack(Buf, InData%VelInterpCubic)
   call RegPack(Buf, InData%RotateWindBox)
   call RegPack(Buf, InData%AccFieldValid)
   call RegPack(Buf, InData%RotToWind)
   call RegPack(Buf, InData%RotFromWind)
   call IfW_FlowField_PackUniformFieldType(Buf, InData%Uniform) 
   call IfW_FlowField_PackGrid3DFieldType(Buf, InData%Grid3D) 
   call IfW_FlowField_PackGrid4DFieldType(Buf, InData%Grid4D) 
   call IfW_FlowField_PackPointsFieldType(Buf, InData%Points) 
   call IfW_FlowField_PackUserFieldType(Buf, InData%User) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackFlowFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FlowFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackFlowFieldType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%FieldType)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RefPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VFlowAngle)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VelInterpCubic)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RotateWindBox)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AccFieldValid)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RotToWind)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RotFromWind)
   if (RegCheckErr(Buf, RoutineName)) return
   call IfW_FlowField_UnpackUniformFieldType(Buf, OutData%Uniform) ! Uniform 
   call IfW_FlowField_UnpackGrid3DFieldType(Buf, OutData%Grid3D) ! Grid3D 
   call IfW_FlowField_UnpackGrid4DFieldType(Buf, OutData%Grid4D) ! Grid4D 
   call IfW_FlowField_UnpackPointsFieldType(Buf, OutData%Points) ! Points 
   call IfW_FlowField_UnpackUserFieldType(Buf, OutData%User) ! User 
end subroutine
END MODULE IfW_FlowField_Types
!ENDOFREGISTRYGENERATEDFILE
