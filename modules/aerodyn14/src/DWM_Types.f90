!STARTOFREGISTRYGENERATEDFILE 'DWM_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! DWM_Types
!.................................................................................................................................
! This file is part of DWM.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in DWM. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE DWM_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE InflowWind_Types
USE NWTC_Library
IMPLICIT NONE
! =========  CVSD  =======
  TYPE, PUBLIC :: CVSD
    INTEGER(IntKi)  :: counter = 0      !<  [-]
    REAL(ReKi)  :: Denominator = 0.0      !<  [-]
    REAL(ReKi)  :: Numerator = 0.0      !<  [-]
  END TYPE CVSD
! =======================
! =========  turbine_average_velocity_data  =======
  TYPE, PUBLIC :: turbine_average_velocity_data
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: average_velocity_array_temp      !< the average velocity of the whole blade sections in a specific time step [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: average_velocity_array      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: swept_area      !<  [m2]
    INTEGER(IntKi)  :: time_step_velocity = -1      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: time_step_velocity_array      !<  [-]
    INTEGER(IntKi)  :: time_step_pass_velocity = -1      !<  [-]
    INTEGER(IntKi)  :: time_step_force = -1      !<  [-]
  END TYPE turbine_average_velocity_data
! =======================
! =========  DWM_Wake_Deficit_Data  =======
  TYPE, PUBLIC :: DWM_Wake_Deficit_Data
    INTEGER(IntKi)  :: np_x = 0_IntKi      !< point per axial distance [-]
    REAL(ReKi)  :: X_length = 0.0_ReKi      !< normalized length in axial direction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Turb_Stress_DWM      !<  [-]
    INTEGER(IntKi)  :: n_x_vector = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: n_r_vector = 0_IntKi      !<  [-]
    REAL(ReKi)  :: ppR = 0.0_ReKi      !< Point_per_R_resoulution [-]
  END TYPE DWM_Wake_Deficit_Data
! =======================
! =========  MeanderData  =======
  TYPE, PUBLIC :: MeanderData
    INTEGER(IntKi)  :: scale_factor = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: moving_time = 0_IntKi      !<  [-]
  END TYPE MeanderData
! =======================
! =========  read_turbine_position_data  =======
  TYPE, PUBLIC :: read_turbine_position_data
    INTEGER(IntKi)  :: SimulationOrder_index = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Turbine_sort_order      !<  [-]
    INTEGER(IntKi)  :: WT_index = 0_IntKi      !< wind turbine index in the wind farm [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineInfluenceData      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_index      !< the upwind turbines that affecting this turbine [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_index      !<  [-]
    INTEGER(IntKi)  :: upwindturbine_number = 0_IntKi      !< the number of upwind turbines affecting the downwind turbine [-]
    INTEGER(IntKi)  :: downwindturbine_number = 0_IntKi      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: turbine_windorigin_length      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_projected_distance      !< the projected distance between two turbines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_projected_distance      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: turbine_angle      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_align_angle      !< the angle beween the line connecting the upwind turbine and this turbine and the wind direction vector [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_align_angle      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_Xcoor      !< the coordinate of the upwind turbine which affects this investigated turbine [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_Ycoor      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: wind_farm_Xcoor      !< the coordinates of all the turbines in the wind farm [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: wind_farm_Ycoor      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_Xcoor      !< the coordinate of the downwind turbine which is affected by this investigated turbine [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_Ycoor      !<  [-]
  END TYPE read_turbine_position_data
! =======================
! =========  WeiMethod  =======
  TYPE, PUBLIC :: WeiMethod
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: sweptarea      !<  [-]
    REAL(ReKi)  :: weighting_denominator = 0.0_ReKi      !<  [-]
  END TYPE WeiMethod
! =======================
! =========  TIDownstream  =======
  TYPE, PUBLIC :: TIDownstream
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI_downstream_matrix      !<  [-]
    INTEGER(IntKi)  :: i = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: j = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: k = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: cross_plane_position_ds = 0_IntKi      !< the cross plane position which to be investigated in term of the flying time [-]
    INTEGER(IntKi)  :: cross_plane_position_TI = 0_IntKi      !< the cross plane position which to be investigated in term of the n_x_vector [-]
    INTEGER(IntKi)  :: distance_index = 0_IntKi      !< the index of the distance in the TI axisymmetric array [-]
    INTEGER(IntKi)  :: counter1 = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: counter2 = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: initial_timestep = 0_IntKi      !<  [-]
    REAL(ReKi)  :: y_axis_turbine = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: z_axis_turbine = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: distance = 0.0_ReKi      !< the distance between one point to the meandered wake center [-]
    REAL(ReKi)  :: TI_downstream_node = 0.0_ReKi      !< the TI at a specfic point in the inbestigated cross plane [-]
    REAL(ReKi)  :: TI_node_temp = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: TI_node = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: TI_accumulation = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: TI_apprant_accumulation = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: TI_average = 0.0_ReKi      !< THE AVERAGE TI OF THE CROSS PLANE [-]
    REAL(ReKi)  :: TI_apprant = 0.0_ReKi      !< The TI due to the meadering [-]
    REAL(ReKi)  :: HubHt = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: wake_center_y = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: wake_center_z = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: Rscale = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: y = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: z = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: zero_spacing = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: temp1 = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: temp2 = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: temp3 = 0.0_ReKi      !<  [-]
  END TYPE TIDownstream
! =======================
! =========  TurbKaimal  =======
  TYPE, PUBLIC :: TurbKaimal
    INTEGER(IntKi)  :: fs = 0_IntKi      !< sample frequency [-]
    INTEGER(IntKi)  :: temp_n = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: i = 0_IntKi      !<  [-]
    REAL(ReKi)  :: low_f = 0.0_ReKi      !< lower bound of frequency range [-]
    REAL(ReKi)  :: high_f = 0.0_ReKi      !< upper bound of frequency range [-]
    REAL(ReKi)  :: lk_facor = 0.0_ReKi      !< turbulence length-scale [-]
    REAL(ReKi)  :: STD = 0.0_ReKi      !< standard deviation of the turbulence [-]
  END TYPE TurbKaimal
! =======================
! =========  Shinozuka  =======
  TYPE, PUBLIC :: Shinozuka
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: f_syn      !< frequency series [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: t_syn      !< time series [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: phi      !< random phase angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: p_k      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: a_k      !<  [-]
    INTEGER(IntKi)  :: num_points = 0_IntKi      !< total number of points [-]
    INTEGER(IntKi)  :: ILo = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: i = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: j = 0_IntKi      !<  [-]
    REAL(ReKi)  :: dt = 0.0_ReKi      !< time step [-]
    REAL(ReKi)  :: t_min = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: t_max = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: df = 0.0_ReKi      !< frequency step [-]
  END TYPE Shinozuka
! =======================
! =========  smooth_out_wake_data  =======
  TYPE, PUBLIC :: smooth_out_wake_data
    INTEGER(IntKi)  :: length_velocity_array = 0_IntKi      !< the length of velocity_array [-]
  END TYPE smooth_out_wake_data
! =======================
! =========  SWSV  =======
  TYPE, PUBLIC :: SWSV
    INTEGER(IntKi)  :: p1 = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: p2 = 0_IntKi      !<  [-]
    REAL(ReKi)  :: distance = 0.0_ReKi      !< the distance from the point to the meandered wake center [-]
    REAL(ReKi)  :: y0 = 0.0_ReKi      !< wake center position on y axis [-]
    REAL(ReKi)  :: z0 = 0.0_ReKi      !< wake center position on z axis [-]
    REAL(ReKi)  :: unit = 0.0_ReKi      !< single unit length  R/ppR [-]
  END TYPE SWSV
! =======================
! =========  read_upwind_result  =======
  TYPE, PUBLIC :: read_upwind_result
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: upwind_U      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: upwind_wakecenter      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_meanU      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_TI      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_small_TI      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: upwind_smoothWake      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: velocity_aerodyn      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TI_downstream      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: small_scale_TI_downstream      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: smoothed_velocity_array      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: vel_matrix      !< The smoothed out wake velocity matrix for n downwind turbine [-]
  END TYPE read_upwind_result
! =======================
! =========  wake_meandered_center  =======
  TYPE, PUBLIC :: wake_meandered_center
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: wake_width      !< wake width [-]
  END TYPE wake_meandered_center
! =======================
! =========  DWM_turbine_blade  =======
  TYPE, PUBLIC :: DWM_turbine_blade
    INTEGER(IntKi)  :: Aerodyn_turbine_num = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Blade_index = 0_IntKi      !<  the index of Aerodyn Blade [-]
    INTEGER(IntKi)  :: Element_index = 0_IntKi      !<  the index of Aerodyn Element [-]
  END TYPE DWM_turbine_blade
! =======================
! =========  DWM_ParameterType  =======
  TYPE, PUBLIC :: DWM_ParameterType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: velocityU      !< the wake velocity profile @ the downstream turbine plane [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: smoothed_wake      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WakePosition      !< meandered wake center [-]
    INTEGER(IntKi)  :: WakePosition_1 = 0_IntKi      !< size of the WakePosition [-]
    INTEGER(IntKi)  :: WakePosition_2 = 0_IntKi      !< size of the WakePosition [-]
    INTEGER(IntKi)  :: smooth_flag = 0_IntKi      !< Whether or not use the smoothed out upstream wake profile (1-yes, 0-no) [-]
    INTEGER(IntKi)  :: p_p_r = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NumWT = 0_IntKi      !< Number of wind turbines [-]
    INTEGER(IntKi)  :: Tinfluencer = 0_IntKi      !<  [-]
    REAL(ReKi)  :: RotorR = 0.0_ReKi      !< Rotor radius [-]
    REAL(ReKi)  :: r_domain = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: x_domain = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: Uambient = 0.0_ReKi      !< The ambient wind velocity [-]
    REAL(ReKi)  :: TI_amb = 0.0_ReKi      !< Ambient turbulence intensity [%]
    REAL(ReKi)  :: TI_wake = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: hub_height = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: length_velocityU = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: WFLowerBd = 0.0_ReKi      !< The lower bound height of the wind file [-]
    REAL(ReKi)  :: Wind_file_Mean_u = 0.0_ReKi      !< The mean velocity of the first turbine [-]
    REAL(ReKi)  :: Winddir = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: air_density = 0.0_ReKi      !< air density [-]
    REAL(ReKi)  :: RR = 0.0_ReKi      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ElementRad      !<  the element node radius [-]
    INTEGER(IntKi)  :: Bnum = 0_IntKi      !<  the number of blade [-]
    INTEGER(IntKi)  :: ElementNum = 0_IntKi      !<  the number of element [-]
    TYPE(read_turbine_position_data)  :: RTPD 
    TYPE(InflowWind_ParameterType)  :: IfW 
  END TYPE DWM_ParameterType
! =======================
! =========  DWM_OtherStateType  =======
  TYPE, PUBLIC :: DWM_OtherStateType
    TYPE(InflowWind_OtherStateType)  :: IfW 
  END TYPE DWM_OtherStateType
! =======================
! =========  DWM_MiscVarType  =======
  TYPE, PUBLIC :: DWM_MiscVarType
    TYPE(InflowWind_MiscVarType)  :: IfW 
    REAL(ReKi)  :: position_y = 0.0_ReKi      !< the y position of the blade node [-]
    REAL(ReKi)  :: position_z = 0.0_ReKi      !< the z position of the blade node [-]
    REAL(ReKi)  :: velocity_wake_mean = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: shifted_velocity_Aerodyn = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: U_velocity = 0.0_ReKi      !<  the u component velocity of blade [-]
    REAL(ReKi)  :: V_velocity = 0.0_ReKi      !<  the v component velocity of blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nforce      !<  the normal force [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: blade_dr      !<  blade dr [-]
    REAL(ReKi)  :: NacYaw = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: TI_original = 0.0_ReKi      !<  [-]
    TYPE(turbine_average_velocity_data)  :: TAVD 
    TYPE(CVSD)  :: CalVelScale_data 
    TYPE(MeanderData)  :: meandering_data 
    TYPE(WeiMethod)  :: weighting_method 
    TYPE(TIDownstream)  :: TI_downstream_data 
    TYPE(TurbKaimal)  :: Turbulence_KS 
    TYPE(Shinozuka)  :: shinozuka_data 
    TYPE(smooth_out_wake_data)  :: SmoothOut 
    TYPE(SWSV)  :: smooth_wake_shifted_velocity_data 
    TYPE(DWM_Wake_Deficit_Data)  :: DWDD 
    REAL(ReKi)  :: ct_tilde = 0.0_ReKi      !< the tilde Ct [-]
    REAL(ReKi)  :: FAST_Time = 0.0_ReKi      !< FAST simulation time [-]
    INTEGER(IntKi)  :: SDtimestep = 0      !<  [-]
    TYPE(DWM_turbine_blade)  :: DWM_tb 
    TYPE(wake_meandered_center)  :: WMC 
  END TYPE DWM_MiscVarType
! =======================
! =========  DWM_InputType  =======
  TYPE, PUBLIC :: DWM_InputType
    TYPE(read_upwind_result)  :: Upwind_result 
    TYPE(InflowWind_InputType)  :: IfW 
  END TYPE DWM_InputType
! =======================
! =========  DWM_OutputType  =======
  TYPE, PUBLIC :: DWM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: turbine_thrust_force      !<  [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: induction_factor      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: r_initial      !< scaled rotor radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_initial      !< scaled velocity at the rotor [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Mean_FFWS_array      !< Mean velocity of each section on the blade [-]
    REAL(ReKi)  :: Mean_FFWS = 0.0_ReKi      !< Mean (total) wind speed at the hub height [m/s]
    REAL(ReKi)  :: TI = 0.0_ReKi      !< the turbulence intensity of the turbine [-]
    REAL(ReKi)  :: TI_downstream = 0.0_ReKi      !< the TI of a downstream turbine before normalization [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: wake_u      !< wake velocity [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: wake_position      !< wake center position [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: smoothed_velocity_array      !< smoothed out upstream axisymetric wake profile [-]
    REAL(ReKi)  :: AtmUscale = 0.0_ReKi      !< atmospheric velocity scale before introducing TI [-]
    REAL(ReKi)  :: du_dz_ABL = 0.0_ReKi      !< atmosperic shear gradient [-]
    REAL(ReKi)  :: total_SDgenpwr = 0.0      !<  [-]
    REAL(ReKi)  :: mean_SDgenpwr = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: avg_ct = 0.0_ReKi      !< average Ct over the rotor [-]
    TYPE(InflowWind_OutputType)  :: IfW 
  END TYPE DWM_OutputType
! =======================
! =========  DWM_ContinuousStateType  =======
  TYPE, PUBLIC :: DWM_ContinuousStateType
    REAL(ReKi)  :: dummy = 0.0_ReKi      !<  [-]
    TYPE(InflowWind_ContinuousStateType)  :: IfW 
  END TYPE DWM_ContinuousStateType
! =======================
! =========  DWM_DiscreteStateType  =======
  TYPE, PUBLIC :: DWM_DiscreteStateType
    REAL(ReKi)  :: dummy = 0.0_ReKi      !<  [-]
    TYPE(InflowWind_DiscreteStateType)  :: IfW 
  END TYPE DWM_DiscreteStateType
! =======================
! =========  DWM_ConstraintStateType  =======
  TYPE, PUBLIC :: DWM_ConstraintStateType
    REAL(ReKi)  :: dummy = 0.0_ReKi      !<  [-]
    TYPE(InflowWind_ConstraintStateType)  :: IfW 
  END TYPE DWM_ConstraintStateType
! =======================
! =========  DWM_InitInputType  =======
  TYPE, PUBLIC :: DWM_InitInputType
    REAL(ReKi)  :: dummy = 0.0_ReKi      !<  [-]
    TYPE(InflowWind_InitInputType)  :: IfW 
  END TYPE DWM_InitInputType
! =======================
! =========  DWM_InitOutputType  =======
  TYPE, PUBLIC :: DWM_InitOutputType
    REAL(ReKi)  :: dummy = 0.0_ReKi      !<  [-]
    TYPE(InflowWind_InitOutputType)  :: IfW 
  END TYPE DWM_InitOutputType
! =======================
CONTAINS

subroutine DWM_CopyCVSD(SrcCVSDData, DstCVSDData, CtrlCode, ErrStat, ErrMsg)
   type(CVSD), intent(in) :: SrcCVSDData
   type(CVSD), intent(inout) :: DstCVSDData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_CopyCVSD'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstCVSDData%counter = SrcCVSDData%counter
   DstCVSDData%Denominator = SrcCVSDData%Denominator
   DstCVSDData%Numerator = SrcCVSDData%Numerator
end subroutine

subroutine DWM_DestroyCVSD(CVSDData, ErrStat, ErrMsg)
   type(CVSD), intent(inout) :: CVSDData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyCVSD'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_PackCVSD(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(CVSD), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackCVSD'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%counter)
   call RegPack(RF, InData%Denominator)
   call RegPack(RF, InData%Numerator)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackCVSD(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(CVSD), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackCVSD'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%counter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Denominator); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Numerator); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copyturbine_average_velocity_data(Srcturbine_average_velocity_dataData, Dstturbine_average_velocity_dataData, CtrlCode, ErrStat, ErrMsg)
   type(turbine_average_velocity_data), intent(in) :: Srcturbine_average_velocity_dataData
   type(turbine_average_velocity_data), intent(inout) :: Dstturbine_average_velocity_dataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_Copyturbine_average_velocity_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Srcturbine_average_velocity_dataData%average_velocity_array_temp)) then
      LB(1:1) = lbound(Srcturbine_average_velocity_dataData%average_velocity_array_temp, kind=B8Ki)
      UB(1:1) = ubound(Srcturbine_average_velocity_dataData%average_velocity_array_temp, kind=B8Ki)
      if (.not. allocated(Dstturbine_average_velocity_dataData%average_velocity_array_temp)) then
         allocate(Dstturbine_average_velocity_dataData%average_velocity_array_temp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstturbine_average_velocity_dataData%average_velocity_array_temp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstturbine_average_velocity_dataData%average_velocity_array_temp = Srcturbine_average_velocity_dataData%average_velocity_array_temp
   end if
   if (allocated(Srcturbine_average_velocity_dataData%average_velocity_array)) then
      LB(1:1) = lbound(Srcturbine_average_velocity_dataData%average_velocity_array, kind=B8Ki)
      UB(1:1) = ubound(Srcturbine_average_velocity_dataData%average_velocity_array, kind=B8Ki)
      if (.not. allocated(Dstturbine_average_velocity_dataData%average_velocity_array)) then
         allocate(Dstturbine_average_velocity_dataData%average_velocity_array(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstturbine_average_velocity_dataData%average_velocity_array.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstturbine_average_velocity_dataData%average_velocity_array = Srcturbine_average_velocity_dataData%average_velocity_array
   end if
   if (allocated(Srcturbine_average_velocity_dataData%swept_area)) then
      LB(1:1) = lbound(Srcturbine_average_velocity_dataData%swept_area, kind=B8Ki)
      UB(1:1) = ubound(Srcturbine_average_velocity_dataData%swept_area, kind=B8Ki)
      if (.not. allocated(Dstturbine_average_velocity_dataData%swept_area)) then
         allocate(Dstturbine_average_velocity_dataData%swept_area(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstturbine_average_velocity_dataData%swept_area.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstturbine_average_velocity_dataData%swept_area = Srcturbine_average_velocity_dataData%swept_area
   end if
   Dstturbine_average_velocity_dataData%time_step_velocity = Srcturbine_average_velocity_dataData%time_step_velocity
   if (allocated(Srcturbine_average_velocity_dataData%time_step_velocity_array)) then
      LB(1:1) = lbound(Srcturbine_average_velocity_dataData%time_step_velocity_array, kind=B8Ki)
      UB(1:1) = ubound(Srcturbine_average_velocity_dataData%time_step_velocity_array, kind=B8Ki)
      if (.not. allocated(Dstturbine_average_velocity_dataData%time_step_velocity_array)) then
         allocate(Dstturbine_average_velocity_dataData%time_step_velocity_array(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstturbine_average_velocity_dataData%time_step_velocity_array.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstturbine_average_velocity_dataData%time_step_velocity_array = Srcturbine_average_velocity_dataData%time_step_velocity_array
   end if
   Dstturbine_average_velocity_dataData%time_step_pass_velocity = Srcturbine_average_velocity_dataData%time_step_pass_velocity
   Dstturbine_average_velocity_dataData%time_step_force = Srcturbine_average_velocity_dataData%time_step_force
end subroutine

subroutine DWM_Destroyturbine_average_velocity_data(turbine_average_velocity_dataData, ErrStat, ErrMsg)
   type(turbine_average_velocity_data), intent(inout) :: turbine_average_velocity_dataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroyturbine_average_velocity_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(turbine_average_velocity_dataData%average_velocity_array_temp)) then
      deallocate(turbine_average_velocity_dataData%average_velocity_array_temp)
   end if
   if (allocated(turbine_average_velocity_dataData%average_velocity_array)) then
      deallocate(turbine_average_velocity_dataData%average_velocity_array)
   end if
   if (allocated(turbine_average_velocity_dataData%swept_area)) then
      deallocate(turbine_average_velocity_dataData%swept_area)
   end if
   if (allocated(turbine_average_velocity_dataData%time_step_velocity_array)) then
      deallocate(turbine_average_velocity_dataData%time_step_velocity_array)
   end if
end subroutine

subroutine DWM_Packturbine_average_velocity_data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(turbine_average_velocity_data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packturbine_average_velocity_data'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%average_velocity_array_temp)
   call RegPackAlloc(RF, InData%average_velocity_array)
   call RegPackAlloc(RF, InData%swept_area)
   call RegPack(RF, InData%time_step_velocity)
   call RegPackAlloc(RF, InData%time_step_velocity_array)
   call RegPack(RF, InData%time_step_pass_velocity)
   call RegPack(RF, InData%time_step_force)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackturbine_average_velocity_data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(turbine_average_velocity_data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackturbine_average_velocity_data'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%average_velocity_array_temp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%average_velocity_array); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%swept_area); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time_step_velocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%time_step_velocity_array); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time_step_pass_velocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time_step_force); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyWake_Deficit_Data(SrcWake_Deficit_DataData, DstWake_Deficit_DataData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_Wake_Deficit_Data), intent(in) :: SrcWake_Deficit_DataData
   type(DWM_Wake_Deficit_Data), intent(inout) :: DstWake_Deficit_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_CopyWake_Deficit_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWake_Deficit_DataData%np_x = SrcWake_Deficit_DataData%np_x
   DstWake_Deficit_DataData%X_length = SrcWake_Deficit_DataData%X_length
   if (allocated(SrcWake_Deficit_DataData%Turb_Stress_DWM)) then
      LB(1:2) = lbound(SrcWake_Deficit_DataData%Turb_Stress_DWM, kind=B8Ki)
      UB(1:2) = ubound(SrcWake_Deficit_DataData%Turb_Stress_DWM, kind=B8Ki)
      if (.not. allocated(DstWake_Deficit_DataData%Turb_Stress_DWM)) then
         allocate(DstWake_Deficit_DataData%Turb_Stress_DWM(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWake_Deficit_DataData%Turb_Stress_DWM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWake_Deficit_DataData%Turb_Stress_DWM = SrcWake_Deficit_DataData%Turb_Stress_DWM
   end if
   DstWake_Deficit_DataData%n_x_vector = SrcWake_Deficit_DataData%n_x_vector
   DstWake_Deficit_DataData%n_r_vector = SrcWake_Deficit_DataData%n_r_vector
   DstWake_Deficit_DataData%ppR = SrcWake_Deficit_DataData%ppR
end subroutine

subroutine DWM_DestroyWake_Deficit_Data(Wake_Deficit_DataData, ErrStat, ErrMsg)
   type(DWM_Wake_Deficit_Data), intent(inout) :: Wake_Deficit_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyWake_Deficit_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Wake_Deficit_DataData%Turb_Stress_DWM)) then
      deallocate(Wake_Deficit_DataData%Turb_Stress_DWM)
   end if
end subroutine

subroutine DWM_PackWake_Deficit_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_Wake_Deficit_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackWake_Deficit_Data'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%np_x)
   call RegPack(RF, InData%X_length)
   call RegPackAlloc(RF, InData%Turb_Stress_DWM)
   call RegPack(RF, InData%n_x_vector)
   call RegPack(RF, InData%n_r_vector)
   call RegPack(RF, InData%ppR)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackWake_Deficit_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_Wake_Deficit_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackWake_Deficit_Data'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%np_x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%X_length); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Turb_Stress_DWM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_x_vector); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_r_vector); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ppR); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyMeanderData(SrcMeanderDataData, DstMeanderDataData, CtrlCode, ErrStat, ErrMsg)
   type(MeanderData), intent(in) :: SrcMeanderDataData
   type(MeanderData), intent(inout) :: DstMeanderDataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_CopyMeanderData'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMeanderDataData%scale_factor = SrcMeanderDataData%scale_factor
   DstMeanderDataData%moving_time = SrcMeanderDataData%moving_time
end subroutine

subroutine DWM_DestroyMeanderData(MeanderDataData, ErrStat, ErrMsg)
   type(MeanderData), intent(inout) :: MeanderDataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyMeanderData'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_PackMeanderData(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeanderData), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackMeanderData'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%scale_factor)
   call RegPack(RF, InData%moving_time)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackMeanderData(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeanderData), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackMeanderData'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%scale_factor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%moving_time); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copyread_turbine_position_data(Srcread_turbine_position_dataData, Dstread_turbine_position_dataData, CtrlCode, ErrStat, ErrMsg)
   type(read_turbine_position_data), intent(in) :: Srcread_turbine_position_dataData
   type(read_turbine_position_data), intent(inout) :: Dstread_turbine_position_dataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_Copyread_turbine_position_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   Dstread_turbine_position_dataData%SimulationOrder_index = Srcread_turbine_position_dataData%SimulationOrder_index
   if (allocated(Srcread_turbine_position_dataData%Turbine_sort_order)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%Turbine_sort_order, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%Turbine_sort_order, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%Turbine_sort_order)) then
         allocate(Dstread_turbine_position_dataData%Turbine_sort_order(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%Turbine_sort_order.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%Turbine_sort_order = Srcread_turbine_position_dataData%Turbine_sort_order
   end if
   Dstread_turbine_position_dataData%WT_index = Srcread_turbine_position_dataData%WT_index
   if (allocated(Srcread_turbine_position_dataData%TurbineInfluenceData)) then
      LB(1:2) = lbound(Srcread_turbine_position_dataData%TurbineInfluenceData, kind=B8Ki)
      UB(1:2) = ubound(Srcread_turbine_position_dataData%TurbineInfluenceData, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%TurbineInfluenceData)) then
         allocate(Dstread_turbine_position_dataData%TurbineInfluenceData(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%TurbineInfluenceData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%TurbineInfluenceData = Srcread_turbine_position_dataData%TurbineInfluenceData
   end if
   if (allocated(Srcread_turbine_position_dataData%upwind_turbine_index)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%upwind_turbine_index, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%upwind_turbine_index, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%upwind_turbine_index)) then
         allocate(Dstread_turbine_position_dataData%upwind_turbine_index(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%upwind_turbine_index.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%upwind_turbine_index = Srcread_turbine_position_dataData%upwind_turbine_index
   end if
   if (allocated(Srcread_turbine_position_dataData%downwind_turbine_index)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%downwind_turbine_index, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%downwind_turbine_index, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%downwind_turbine_index)) then
         allocate(Dstread_turbine_position_dataData%downwind_turbine_index(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%downwind_turbine_index.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%downwind_turbine_index = Srcread_turbine_position_dataData%downwind_turbine_index
   end if
   Dstread_turbine_position_dataData%upwindturbine_number = Srcread_turbine_position_dataData%upwindturbine_number
   Dstread_turbine_position_dataData%downwindturbine_number = Srcread_turbine_position_dataData%downwindturbine_number
   if (allocated(Srcread_turbine_position_dataData%turbine_windorigin_length)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%turbine_windorigin_length, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%turbine_windorigin_length, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%turbine_windorigin_length)) then
         allocate(Dstread_turbine_position_dataData%turbine_windorigin_length(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%turbine_windorigin_length.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%turbine_windorigin_length = Srcread_turbine_position_dataData%turbine_windorigin_length
   end if
   if (allocated(Srcread_turbine_position_dataData%upwind_turbine_projected_distance)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%upwind_turbine_projected_distance, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%upwind_turbine_projected_distance, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%upwind_turbine_projected_distance)) then
         allocate(Dstread_turbine_position_dataData%upwind_turbine_projected_distance(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%upwind_turbine_projected_distance.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%upwind_turbine_projected_distance = Srcread_turbine_position_dataData%upwind_turbine_projected_distance
   end if
   if (allocated(Srcread_turbine_position_dataData%downwind_turbine_projected_distance)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%downwind_turbine_projected_distance, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%downwind_turbine_projected_distance, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%downwind_turbine_projected_distance)) then
         allocate(Dstread_turbine_position_dataData%downwind_turbine_projected_distance(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%downwind_turbine_projected_distance.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%downwind_turbine_projected_distance = Srcread_turbine_position_dataData%downwind_turbine_projected_distance
   end if
   if (allocated(Srcread_turbine_position_dataData%turbine_angle)) then
      LB(1:2) = lbound(Srcread_turbine_position_dataData%turbine_angle, kind=B8Ki)
      UB(1:2) = ubound(Srcread_turbine_position_dataData%turbine_angle, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%turbine_angle)) then
         allocate(Dstread_turbine_position_dataData%turbine_angle(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%turbine_angle.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%turbine_angle = Srcread_turbine_position_dataData%turbine_angle
   end if
   if (allocated(Srcread_turbine_position_dataData%upwind_align_angle)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%upwind_align_angle, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%upwind_align_angle, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%upwind_align_angle)) then
         allocate(Dstread_turbine_position_dataData%upwind_align_angle(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%upwind_align_angle.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%upwind_align_angle = Srcread_turbine_position_dataData%upwind_align_angle
   end if
   if (allocated(Srcread_turbine_position_dataData%downwind_align_angle)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%downwind_align_angle, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%downwind_align_angle, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%downwind_align_angle)) then
         allocate(Dstread_turbine_position_dataData%downwind_align_angle(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%downwind_align_angle.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%downwind_align_angle = Srcread_turbine_position_dataData%downwind_align_angle
   end if
   if (allocated(Srcread_turbine_position_dataData%upwind_turbine_Xcoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%upwind_turbine_Xcoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%upwind_turbine_Xcoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%upwind_turbine_Xcoor)) then
         allocate(Dstread_turbine_position_dataData%upwind_turbine_Xcoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%upwind_turbine_Xcoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%upwind_turbine_Xcoor = Srcread_turbine_position_dataData%upwind_turbine_Xcoor
   end if
   if (allocated(Srcread_turbine_position_dataData%upwind_turbine_Ycoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%upwind_turbine_Ycoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%upwind_turbine_Ycoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%upwind_turbine_Ycoor)) then
         allocate(Dstread_turbine_position_dataData%upwind_turbine_Ycoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%upwind_turbine_Ycoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%upwind_turbine_Ycoor = Srcread_turbine_position_dataData%upwind_turbine_Ycoor
   end if
   if (allocated(Srcread_turbine_position_dataData%wind_farm_Xcoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%wind_farm_Xcoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%wind_farm_Xcoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%wind_farm_Xcoor)) then
         allocate(Dstread_turbine_position_dataData%wind_farm_Xcoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%wind_farm_Xcoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%wind_farm_Xcoor = Srcread_turbine_position_dataData%wind_farm_Xcoor
   end if
   if (allocated(Srcread_turbine_position_dataData%wind_farm_Ycoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%wind_farm_Ycoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%wind_farm_Ycoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%wind_farm_Ycoor)) then
         allocate(Dstread_turbine_position_dataData%wind_farm_Ycoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%wind_farm_Ycoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%wind_farm_Ycoor = Srcread_turbine_position_dataData%wind_farm_Ycoor
   end if
   if (allocated(Srcread_turbine_position_dataData%downwind_turbine_Xcoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%downwind_turbine_Xcoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%downwind_turbine_Xcoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%downwind_turbine_Xcoor)) then
         allocate(Dstread_turbine_position_dataData%downwind_turbine_Xcoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%downwind_turbine_Xcoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%downwind_turbine_Xcoor = Srcread_turbine_position_dataData%downwind_turbine_Xcoor
   end if
   if (allocated(Srcread_turbine_position_dataData%downwind_turbine_Ycoor)) then
      LB(1:1) = lbound(Srcread_turbine_position_dataData%downwind_turbine_Ycoor, kind=B8Ki)
      UB(1:1) = ubound(Srcread_turbine_position_dataData%downwind_turbine_Ycoor, kind=B8Ki)
      if (.not. allocated(Dstread_turbine_position_dataData%downwind_turbine_Ycoor)) then
         allocate(Dstread_turbine_position_dataData%downwind_turbine_Ycoor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_turbine_position_dataData%downwind_turbine_Ycoor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_turbine_position_dataData%downwind_turbine_Ycoor = Srcread_turbine_position_dataData%downwind_turbine_Ycoor
   end if
end subroutine

subroutine DWM_Destroyread_turbine_position_data(read_turbine_position_dataData, ErrStat, ErrMsg)
   type(read_turbine_position_data), intent(inout) :: read_turbine_position_dataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroyread_turbine_position_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(read_turbine_position_dataData%Turbine_sort_order)) then
      deallocate(read_turbine_position_dataData%Turbine_sort_order)
   end if
   if (allocated(read_turbine_position_dataData%TurbineInfluenceData)) then
      deallocate(read_turbine_position_dataData%TurbineInfluenceData)
   end if
   if (allocated(read_turbine_position_dataData%upwind_turbine_index)) then
      deallocate(read_turbine_position_dataData%upwind_turbine_index)
   end if
   if (allocated(read_turbine_position_dataData%downwind_turbine_index)) then
      deallocate(read_turbine_position_dataData%downwind_turbine_index)
   end if
   if (allocated(read_turbine_position_dataData%turbine_windorigin_length)) then
      deallocate(read_turbine_position_dataData%turbine_windorigin_length)
   end if
   if (allocated(read_turbine_position_dataData%upwind_turbine_projected_distance)) then
      deallocate(read_turbine_position_dataData%upwind_turbine_projected_distance)
   end if
   if (allocated(read_turbine_position_dataData%downwind_turbine_projected_distance)) then
      deallocate(read_turbine_position_dataData%downwind_turbine_projected_distance)
   end if
   if (allocated(read_turbine_position_dataData%turbine_angle)) then
      deallocate(read_turbine_position_dataData%turbine_angle)
   end if
   if (allocated(read_turbine_position_dataData%upwind_align_angle)) then
      deallocate(read_turbine_position_dataData%upwind_align_angle)
   end if
   if (allocated(read_turbine_position_dataData%downwind_align_angle)) then
      deallocate(read_turbine_position_dataData%downwind_align_angle)
   end if
   if (allocated(read_turbine_position_dataData%upwind_turbine_Xcoor)) then
      deallocate(read_turbine_position_dataData%upwind_turbine_Xcoor)
   end if
   if (allocated(read_turbine_position_dataData%upwind_turbine_Ycoor)) then
      deallocate(read_turbine_position_dataData%upwind_turbine_Ycoor)
   end if
   if (allocated(read_turbine_position_dataData%wind_farm_Xcoor)) then
      deallocate(read_turbine_position_dataData%wind_farm_Xcoor)
   end if
   if (allocated(read_turbine_position_dataData%wind_farm_Ycoor)) then
      deallocate(read_turbine_position_dataData%wind_farm_Ycoor)
   end if
   if (allocated(read_turbine_position_dataData%downwind_turbine_Xcoor)) then
      deallocate(read_turbine_position_dataData%downwind_turbine_Xcoor)
   end if
   if (allocated(read_turbine_position_dataData%downwind_turbine_Ycoor)) then
      deallocate(read_turbine_position_dataData%downwind_turbine_Ycoor)
   end if
end subroutine

subroutine DWM_Packread_turbine_position_data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(read_turbine_position_data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packread_turbine_position_data'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SimulationOrder_index)
   call RegPackAlloc(RF, InData%Turbine_sort_order)
   call RegPack(RF, InData%WT_index)
   call RegPackAlloc(RF, InData%TurbineInfluenceData)
   call RegPackAlloc(RF, InData%upwind_turbine_index)
   call RegPackAlloc(RF, InData%downwind_turbine_index)
   call RegPack(RF, InData%upwindturbine_number)
   call RegPack(RF, InData%downwindturbine_number)
   call RegPackAlloc(RF, InData%turbine_windorigin_length)
   call RegPackAlloc(RF, InData%upwind_turbine_projected_distance)
   call RegPackAlloc(RF, InData%downwind_turbine_projected_distance)
   call RegPackAlloc(RF, InData%turbine_angle)
   call RegPackAlloc(RF, InData%upwind_align_angle)
   call RegPackAlloc(RF, InData%downwind_align_angle)
   call RegPackAlloc(RF, InData%upwind_turbine_Xcoor)
   call RegPackAlloc(RF, InData%upwind_turbine_Ycoor)
   call RegPackAlloc(RF, InData%wind_farm_Xcoor)
   call RegPackAlloc(RF, InData%wind_farm_Ycoor)
   call RegPackAlloc(RF, InData%downwind_turbine_Xcoor)
   call RegPackAlloc(RF, InData%downwind_turbine_Ycoor)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackread_turbine_position_data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(read_turbine_position_data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackread_turbine_position_data'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SimulationOrder_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Turbine_sort_order); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WT_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TurbineInfluenceData); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_turbine_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%downwind_turbine_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%upwindturbine_number); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%downwindturbine_number); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%turbine_windorigin_length); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_turbine_projected_distance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%downwind_turbine_projected_distance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%turbine_angle); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_align_angle); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%downwind_align_angle); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_turbine_Xcoor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_turbine_Ycoor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%wind_farm_Xcoor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%wind_farm_Ycoor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%downwind_turbine_Xcoor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%downwind_turbine_Ycoor); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyWeiMethod(SrcWeiMethodData, DstWeiMethodData, CtrlCode, ErrStat, ErrMsg)
   type(WeiMethod), intent(in) :: SrcWeiMethodData
   type(WeiMethod), intent(inout) :: DstWeiMethodData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_CopyWeiMethod'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcWeiMethodData%sweptarea)) then
      LB(1:1) = lbound(SrcWeiMethodData%sweptarea, kind=B8Ki)
      UB(1:1) = ubound(SrcWeiMethodData%sweptarea, kind=B8Ki)
      if (.not. allocated(DstWeiMethodData%sweptarea)) then
         allocate(DstWeiMethodData%sweptarea(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstWeiMethodData%sweptarea.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstWeiMethodData%sweptarea = SrcWeiMethodData%sweptarea
   end if
   DstWeiMethodData%weighting_denominator = SrcWeiMethodData%weighting_denominator
end subroutine

subroutine DWM_DestroyWeiMethod(WeiMethodData, ErrStat, ErrMsg)
   type(WeiMethod), intent(inout) :: WeiMethodData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyWeiMethod'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(WeiMethodData%sweptarea)) then
      deallocate(WeiMethodData%sweptarea)
   end if
end subroutine

subroutine DWM_PackWeiMethod(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(WeiMethod), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackWeiMethod'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%sweptarea)
   call RegPack(RF, InData%weighting_denominator)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackWeiMethod(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(WeiMethod), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackWeiMethod'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%sweptarea); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%weighting_denominator); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyTIDownstream(SrcTIDownstreamData, DstTIDownstreamData, CtrlCode, ErrStat, ErrMsg)
   type(TIDownstream), intent(in) :: SrcTIDownstreamData
   type(TIDownstream), intent(inout) :: DstTIDownstreamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_CopyTIDownstream'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcTIDownstreamData%TI_downstream_matrix)) then
      LB(1:2) = lbound(SrcTIDownstreamData%TI_downstream_matrix, kind=B8Ki)
      UB(1:2) = ubound(SrcTIDownstreamData%TI_downstream_matrix, kind=B8Ki)
      if (.not. allocated(DstTIDownstreamData%TI_downstream_matrix)) then
         allocate(DstTIDownstreamData%TI_downstream_matrix(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTIDownstreamData%TI_downstream_matrix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTIDownstreamData%TI_downstream_matrix = SrcTIDownstreamData%TI_downstream_matrix
   end if
   DstTIDownstreamData%i = SrcTIDownstreamData%i
   DstTIDownstreamData%j = SrcTIDownstreamData%j
   DstTIDownstreamData%k = SrcTIDownstreamData%k
   DstTIDownstreamData%cross_plane_position_ds = SrcTIDownstreamData%cross_plane_position_ds
   DstTIDownstreamData%cross_plane_position_TI = SrcTIDownstreamData%cross_plane_position_TI
   DstTIDownstreamData%distance_index = SrcTIDownstreamData%distance_index
   DstTIDownstreamData%counter1 = SrcTIDownstreamData%counter1
   DstTIDownstreamData%counter2 = SrcTIDownstreamData%counter2
   DstTIDownstreamData%initial_timestep = SrcTIDownstreamData%initial_timestep
   DstTIDownstreamData%y_axis_turbine = SrcTIDownstreamData%y_axis_turbine
   DstTIDownstreamData%z_axis_turbine = SrcTIDownstreamData%z_axis_turbine
   DstTIDownstreamData%distance = SrcTIDownstreamData%distance
   DstTIDownstreamData%TI_downstream_node = SrcTIDownstreamData%TI_downstream_node
   DstTIDownstreamData%TI_node_temp = SrcTIDownstreamData%TI_node_temp
   DstTIDownstreamData%TI_node = SrcTIDownstreamData%TI_node
   DstTIDownstreamData%TI_accumulation = SrcTIDownstreamData%TI_accumulation
   DstTIDownstreamData%TI_apprant_accumulation = SrcTIDownstreamData%TI_apprant_accumulation
   DstTIDownstreamData%TI_average = SrcTIDownstreamData%TI_average
   DstTIDownstreamData%TI_apprant = SrcTIDownstreamData%TI_apprant
   DstTIDownstreamData%HubHt = SrcTIDownstreamData%HubHt
   DstTIDownstreamData%wake_center_y = SrcTIDownstreamData%wake_center_y
   DstTIDownstreamData%wake_center_z = SrcTIDownstreamData%wake_center_z
   DstTIDownstreamData%Rscale = SrcTIDownstreamData%Rscale
   DstTIDownstreamData%y = SrcTIDownstreamData%y
   DstTIDownstreamData%z = SrcTIDownstreamData%z
   DstTIDownstreamData%zero_spacing = SrcTIDownstreamData%zero_spacing
   DstTIDownstreamData%temp1 = SrcTIDownstreamData%temp1
   DstTIDownstreamData%temp2 = SrcTIDownstreamData%temp2
   DstTIDownstreamData%temp3 = SrcTIDownstreamData%temp3
end subroutine

subroutine DWM_DestroyTIDownstream(TIDownstreamData, ErrStat, ErrMsg)
   type(TIDownstream), intent(inout) :: TIDownstreamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyTIDownstream'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(TIDownstreamData%TI_downstream_matrix)) then
      deallocate(TIDownstreamData%TI_downstream_matrix)
   end if
end subroutine

subroutine DWM_PackTIDownstream(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TIDownstream), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackTIDownstream'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%TI_downstream_matrix)
   call RegPack(RF, InData%i)
   call RegPack(RF, InData%j)
   call RegPack(RF, InData%k)
   call RegPack(RF, InData%cross_plane_position_ds)
   call RegPack(RF, InData%cross_plane_position_TI)
   call RegPack(RF, InData%distance_index)
   call RegPack(RF, InData%counter1)
   call RegPack(RF, InData%counter2)
   call RegPack(RF, InData%initial_timestep)
   call RegPack(RF, InData%y_axis_turbine)
   call RegPack(RF, InData%z_axis_turbine)
   call RegPack(RF, InData%distance)
   call RegPack(RF, InData%TI_downstream_node)
   call RegPack(RF, InData%TI_node_temp)
   call RegPack(RF, InData%TI_node)
   call RegPack(RF, InData%TI_accumulation)
   call RegPack(RF, InData%TI_apprant_accumulation)
   call RegPack(RF, InData%TI_average)
   call RegPack(RF, InData%TI_apprant)
   call RegPack(RF, InData%HubHt)
   call RegPack(RF, InData%wake_center_y)
   call RegPack(RF, InData%wake_center_z)
   call RegPack(RF, InData%Rscale)
   call RegPack(RF, InData%y)
   call RegPack(RF, InData%z)
   call RegPack(RF, InData%zero_spacing)
   call RegPack(RF, InData%temp1)
   call RegPack(RF, InData%temp2)
   call RegPack(RF, InData%temp3)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackTIDownstream(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TIDownstream), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackTIDownstream'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%TI_downstream_matrix); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%j); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%k); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%cross_plane_position_ds); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%cross_plane_position_TI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%distance_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%counter1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%counter2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%initial_timestep); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%y_axis_turbine); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%z_axis_turbine); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%distance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_downstream_node); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_node_temp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_node); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_accumulation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_apprant_accumulation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_average); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_apprant); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubHt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%wake_center_y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%wake_center_z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Rscale); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%zero_spacing); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%temp1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%temp2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%temp3); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyTurbKaimal(SrcTurbKaimalData, DstTurbKaimalData, CtrlCode, ErrStat, ErrMsg)
   type(TurbKaimal), intent(in) :: SrcTurbKaimalData
   type(TurbKaimal), intent(inout) :: DstTurbKaimalData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_CopyTurbKaimal'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbKaimalData%fs = SrcTurbKaimalData%fs
   DstTurbKaimalData%temp_n = SrcTurbKaimalData%temp_n
   DstTurbKaimalData%i = SrcTurbKaimalData%i
   DstTurbKaimalData%low_f = SrcTurbKaimalData%low_f
   DstTurbKaimalData%high_f = SrcTurbKaimalData%high_f
   DstTurbKaimalData%lk_facor = SrcTurbKaimalData%lk_facor
   DstTurbKaimalData%STD = SrcTurbKaimalData%STD
end subroutine

subroutine DWM_DestroyTurbKaimal(TurbKaimalData, ErrStat, ErrMsg)
   type(TurbKaimal), intent(inout) :: TurbKaimalData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyTurbKaimal'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_PackTurbKaimal(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TurbKaimal), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackTurbKaimal'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%fs)
   call RegPack(RF, InData%temp_n)
   call RegPack(RF, InData%i)
   call RegPack(RF, InData%low_f)
   call RegPack(RF, InData%high_f)
   call RegPack(RF, InData%lk_facor)
   call RegPack(RF, InData%STD)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackTurbKaimal(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TurbKaimal), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackTurbKaimal'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%fs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%temp_n); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%low_f); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%high_f); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%lk_facor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%STD); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyShinozuka(SrcShinozukaData, DstShinozukaData, CtrlCode, ErrStat, ErrMsg)
   type(Shinozuka), intent(in) :: SrcShinozukaData
   type(Shinozuka), intent(inout) :: DstShinozukaData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_CopyShinozuka'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcShinozukaData%f_syn)) then
      LB(1:1) = lbound(SrcShinozukaData%f_syn, kind=B8Ki)
      UB(1:1) = ubound(SrcShinozukaData%f_syn, kind=B8Ki)
      if (.not. allocated(DstShinozukaData%f_syn)) then
         allocate(DstShinozukaData%f_syn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstShinozukaData%f_syn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstShinozukaData%f_syn = SrcShinozukaData%f_syn
   end if
   if (allocated(SrcShinozukaData%t_syn)) then
      LB(1:1) = lbound(SrcShinozukaData%t_syn, kind=B8Ki)
      UB(1:1) = ubound(SrcShinozukaData%t_syn, kind=B8Ki)
      if (.not. allocated(DstShinozukaData%t_syn)) then
         allocate(DstShinozukaData%t_syn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstShinozukaData%t_syn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstShinozukaData%t_syn = SrcShinozukaData%t_syn
   end if
   if (allocated(SrcShinozukaData%phi)) then
      LB(1:1) = lbound(SrcShinozukaData%phi, kind=B8Ki)
      UB(1:1) = ubound(SrcShinozukaData%phi, kind=B8Ki)
      if (.not. allocated(DstShinozukaData%phi)) then
         allocate(DstShinozukaData%phi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstShinozukaData%phi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstShinozukaData%phi = SrcShinozukaData%phi
   end if
   if (allocated(SrcShinozukaData%p_k)) then
      LB(1:1) = lbound(SrcShinozukaData%p_k, kind=B8Ki)
      UB(1:1) = ubound(SrcShinozukaData%p_k, kind=B8Ki)
      if (.not. allocated(DstShinozukaData%p_k)) then
         allocate(DstShinozukaData%p_k(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstShinozukaData%p_k.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstShinozukaData%p_k = SrcShinozukaData%p_k
   end if
   if (allocated(SrcShinozukaData%a_k)) then
      LB(1:1) = lbound(SrcShinozukaData%a_k, kind=B8Ki)
      UB(1:1) = ubound(SrcShinozukaData%a_k, kind=B8Ki)
      if (.not. allocated(DstShinozukaData%a_k)) then
         allocate(DstShinozukaData%a_k(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstShinozukaData%a_k.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstShinozukaData%a_k = SrcShinozukaData%a_k
   end if
   DstShinozukaData%num_points = SrcShinozukaData%num_points
   DstShinozukaData%ILo = SrcShinozukaData%ILo
   DstShinozukaData%i = SrcShinozukaData%i
   DstShinozukaData%j = SrcShinozukaData%j
   DstShinozukaData%dt = SrcShinozukaData%dt
   DstShinozukaData%t_min = SrcShinozukaData%t_min
   DstShinozukaData%t_max = SrcShinozukaData%t_max
   DstShinozukaData%df = SrcShinozukaData%df
end subroutine

subroutine DWM_DestroyShinozuka(ShinozukaData, ErrStat, ErrMsg)
   type(Shinozuka), intent(inout) :: ShinozukaData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroyShinozuka'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ShinozukaData%f_syn)) then
      deallocate(ShinozukaData%f_syn)
   end if
   if (allocated(ShinozukaData%t_syn)) then
      deallocate(ShinozukaData%t_syn)
   end if
   if (allocated(ShinozukaData%phi)) then
      deallocate(ShinozukaData%phi)
   end if
   if (allocated(ShinozukaData%p_k)) then
      deallocate(ShinozukaData%p_k)
   end if
   if (allocated(ShinozukaData%a_k)) then
      deallocate(ShinozukaData%a_k)
   end if
end subroutine

subroutine DWM_PackShinozuka(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Shinozuka), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackShinozuka'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%f_syn)
   call RegPackAlloc(RF, InData%t_syn)
   call RegPackAlloc(RF, InData%phi)
   call RegPackAlloc(RF, InData%p_k)
   call RegPackAlloc(RF, InData%a_k)
   call RegPack(RF, InData%num_points)
   call RegPack(RF, InData%ILo)
   call RegPack(RF, InData%i)
   call RegPack(RF, InData%j)
   call RegPack(RF, InData%dt)
   call RegPack(RF, InData%t_min)
   call RegPack(RF, InData%t_max)
   call RegPack(RF, InData%df)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackShinozuka(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Shinozuka), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackShinozuka'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%f_syn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%t_syn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%phi); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%p_k); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%a_k); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%num_points); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ILo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%j); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%t_min); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%t_max); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%df); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copysmooth_out_wake_data(Srcsmooth_out_wake_dataData, Dstsmooth_out_wake_dataData, CtrlCode, ErrStat, ErrMsg)
   type(smooth_out_wake_data), intent(in) :: Srcsmooth_out_wake_dataData
   type(smooth_out_wake_data), intent(inout) :: Dstsmooth_out_wake_dataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Copysmooth_out_wake_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   Dstsmooth_out_wake_dataData%length_velocity_array = Srcsmooth_out_wake_dataData%length_velocity_array
end subroutine

subroutine DWM_Destroysmooth_out_wake_data(smooth_out_wake_dataData, ErrStat, ErrMsg)
   type(smooth_out_wake_data), intent(inout) :: smooth_out_wake_dataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroysmooth_out_wake_data'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_Packsmooth_out_wake_data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(smooth_out_wake_data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packsmooth_out_wake_data'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%length_velocity_array)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPacksmooth_out_wake_data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(smooth_out_wake_data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPacksmooth_out_wake_data'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%length_velocity_array); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopySWSV(SrcSWSVData, DstSWSVData, CtrlCode, ErrStat, ErrMsg)
   type(SWSV), intent(in) :: SrcSWSVData
   type(SWSV), intent(inout) :: DstSWSVData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_CopySWSV'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstSWSVData%p1 = SrcSWSVData%p1
   DstSWSVData%p2 = SrcSWSVData%p2
   DstSWSVData%distance = SrcSWSVData%distance
   DstSWSVData%y0 = SrcSWSVData%y0
   DstSWSVData%z0 = SrcSWSVData%z0
   DstSWSVData%unit = SrcSWSVData%unit
end subroutine

subroutine DWM_DestroySWSV(SWSVData, ErrStat, ErrMsg)
   type(SWSV), intent(inout) :: SWSVData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_DestroySWSV'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_PackSWSV(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SWSV), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackSWSV'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%p1)
   call RegPack(RF, InData%p2)
   call RegPack(RF, InData%distance)
   call RegPack(RF, InData%y0)
   call RegPack(RF, InData%z0)
   call RegPack(RF, InData%unit)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackSWSV(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SWSV), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackSWSV'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%p1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%p2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%distance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%y0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%z0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%unit); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copyread_upwind_result(Srcread_upwind_resultData, Dstread_upwind_resultData, CtrlCode, ErrStat, ErrMsg)
   type(read_upwind_result), intent(in) :: Srcread_upwind_resultData
   type(read_upwind_result), intent(inout) :: Dstread_upwind_resultData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_Copyread_upwind_result'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Srcread_upwind_resultData%upwind_U)) then
      LB(1:2) = lbound(Srcread_upwind_resultData%upwind_U, kind=B8Ki)
      UB(1:2) = ubound(Srcread_upwind_resultData%upwind_U, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_U)) then
         allocate(Dstread_upwind_resultData%upwind_U(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_U.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_U = Srcread_upwind_resultData%upwind_U
   end if
   if (allocated(Srcread_upwind_resultData%upwind_wakecenter)) then
      LB(1:4) = lbound(Srcread_upwind_resultData%upwind_wakecenter, kind=B8Ki)
      UB(1:4) = ubound(Srcread_upwind_resultData%upwind_wakecenter, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_wakecenter)) then
         allocate(Dstread_upwind_resultData%upwind_wakecenter(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_wakecenter.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_wakecenter = Srcread_upwind_resultData%upwind_wakecenter
   end if
   if (allocated(Srcread_upwind_resultData%upwind_meanU)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%upwind_meanU, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%upwind_meanU, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_meanU)) then
         allocate(Dstread_upwind_resultData%upwind_meanU(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_meanU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_meanU = Srcread_upwind_resultData%upwind_meanU
   end if
   if (allocated(Srcread_upwind_resultData%upwind_TI)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%upwind_TI, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%upwind_TI, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_TI)) then
         allocate(Dstread_upwind_resultData%upwind_TI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_TI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_TI = Srcread_upwind_resultData%upwind_TI
   end if
   if (allocated(Srcread_upwind_resultData%upwind_small_TI)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%upwind_small_TI, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%upwind_small_TI, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_small_TI)) then
         allocate(Dstread_upwind_resultData%upwind_small_TI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_small_TI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_small_TI = Srcread_upwind_resultData%upwind_small_TI
   end if
   if (allocated(Srcread_upwind_resultData%upwind_smoothWake)) then
      LB(1:2) = lbound(Srcread_upwind_resultData%upwind_smoothWake, kind=B8Ki)
      UB(1:2) = ubound(Srcread_upwind_resultData%upwind_smoothWake, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%upwind_smoothWake)) then
         allocate(Dstread_upwind_resultData%upwind_smoothWake(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%upwind_smoothWake.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%upwind_smoothWake = Srcread_upwind_resultData%upwind_smoothWake
   end if
   if (allocated(Srcread_upwind_resultData%velocity_aerodyn)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%velocity_aerodyn, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%velocity_aerodyn, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%velocity_aerodyn)) then
         allocate(Dstread_upwind_resultData%velocity_aerodyn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%velocity_aerodyn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%velocity_aerodyn = Srcread_upwind_resultData%velocity_aerodyn
   end if
   if (allocated(Srcread_upwind_resultData%TI_downstream)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%TI_downstream, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%TI_downstream, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%TI_downstream)) then
         allocate(Dstread_upwind_resultData%TI_downstream(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%TI_downstream.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%TI_downstream = Srcread_upwind_resultData%TI_downstream
   end if
   if (allocated(Srcread_upwind_resultData%small_scale_TI_downstream)) then
      LB(1:1) = lbound(Srcread_upwind_resultData%small_scale_TI_downstream, kind=B8Ki)
      UB(1:1) = ubound(Srcread_upwind_resultData%small_scale_TI_downstream, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%small_scale_TI_downstream)) then
         allocate(Dstread_upwind_resultData%small_scale_TI_downstream(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%small_scale_TI_downstream.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%small_scale_TI_downstream = Srcread_upwind_resultData%small_scale_TI_downstream
   end if
   if (allocated(Srcread_upwind_resultData%smoothed_velocity_array)) then
      LB(1:2) = lbound(Srcread_upwind_resultData%smoothed_velocity_array, kind=B8Ki)
      UB(1:2) = ubound(Srcread_upwind_resultData%smoothed_velocity_array, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%smoothed_velocity_array)) then
         allocate(Dstread_upwind_resultData%smoothed_velocity_array(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%smoothed_velocity_array.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%smoothed_velocity_array = Srcread_upwind_resultData%smoothed_velocity_array
   end if
   if (allocated(Srcread_upwind_resultData%vel_matrix)) then
      LB(1:3) = lbound(Srcread_upwind_resultData%vel_matrix, kind=B8Ki)
      UB(1:3) = ubound(Srcread_upwind_resultData%vel_matrix, kind=B8Ki)
      if (.not. allocated(Dstread_upwind_resultData%vel_matrix)) then
         allocate(Dstread_upwind_resultData%vel_matrix(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstread_upwind_resultData%vel_matrix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstread_upwind_resultData%vel_matrix = Srcread_upwind_resultData%vel_matrix
   end if
end subroutine

subroutine DWM_Destroyread_upwind_result(read_upwind_resultData, ErrStat, ErrMsg)
   type(read_upwind_result), intent(inout) :: read_upwind_resultData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroyread_upwind_result'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(read_upwind_resultData%upwind_U)) then
      deallocate(read_upwind_resultData%upwind_U)
   end if
   if (allocated(read_upwind_resultData%upwind_wakecenter)) then
      deallocate(read_upwind_resultData%upwind_wakecenter)
   end if
   if (allocated(read_upwind_resultData%upwind_meanU)) then
      deallocate(read_upwind_resultData%upwind_meanU)
   end if
   if (allocated(read_upwind_resultData%upwind_TI)) then
      deallocate(read_upwind_resultData%upwind_TI)
   end if
   if (allocated(read_upwind_resultData%upwind_small_TI)) then
      deallocate(read_upwind_resultData%upwind_small_TI)
   end if
   if (allocated(read_upwind_resultData%upwind_smoothWake)) then
      deallocate(read_upwind_resultData%upwind_smoothWake)
   end if
   if (allocated(read_upwind_resultData%velocity_aerodyn)) then
      deallocate(read_upwind_resultData%velocity_aerodyn)
   end if
   if (allocated(read_upwind_resultData%TI_downstream)) then
      deallocate(read_upwind_resultData%TI_downstream)
   end if
   if (allocated(read_upwind_resultData%small_scale_TI_downstream)) then
      deallocate(read_upwind_resultData%small_scale_TI_downstream)
   end if
   if (allocated(read_upwind_resultData%smoothed_velocity_array)) then
      deallocate(read_upwind_resultData%smoothed_velocity_array)
   end if
   if (allocated(read_upwind_resultData%vel_matrix)) then
      deallocate(read_upwind_resultData%vel_matrix)
   end if
end subroutine

subroutine DWM_Packread_upwind_result(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(read_upwind_result), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packread_upwind_result'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%upwind_U)
   call RegPackAlloc(RF, InData%upwind_wakecenter)
   call RegPackAlloc(RF, InData%upwind_meanU)
   call RegPackAlloc(RF, InData%upwind_TI)
   call RegPackAlloc(RF, InData%upwind_small_TI)
   call RegPackAlloc(RF, InData%upwind_smoothWake)
   call RegPackAlloc(RF, InData%velocity_aerodyn)
   call RegPackAlloc(RF, InData%TI_downstream)
   call RegPackAlloc(RF, InData%small_scale_TI_downstream)
   call RegPackAlloc(RF, InData%smoothed_velocity_array)
   call RegPackAlloc(RF, InData%vel_matrix)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackread_upwind_result(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(read_upwind_result), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackread_upwind_result'
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%upwind_U); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_wakecenter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_meanU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_TI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_small_TI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%upwind_smoothWake); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%velocity_aerodyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TI_downstream); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%small_scale_TI_downstream); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%smoothed_velocity_array); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%vel_matrix); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copywake_meandered_center(Srcwake_meandered_centerData, Dstwake_meandered_centerData, CtrlCode, ErrStat, ErrMsg)
   type(wake_meandered_center), intent(in) :: Srcwake_meandered_centerData
   type(wake_meandered_center), intent(inout) :: Dstwake_meandered_centerData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'DWM_Copywake_meandered_center'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Srcwake_meandered_centerData%wake_width)) then
      LB(1:1) = lbound(Srcwake_meandered_centerData%wake_width, kind=B8Ki)
      UB(1:1) = ubound(Srcwake_meandered_centerData%wake_width, kind=B8Ki)
      if (.not. allocated(Dstwake_meandered_centerData%wake_width)) then
         allocate(Dstwake_meandered_centerData%wake_width(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating Dstwake_meandered_centerData%wake_width.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      Dstwake_meandered_centerData%wake_width = Srcwake_meandered_centerData%wake_width
   end if
end subroutine

subroutine DWM_Destroywake_meandered_center(wake_meandered_centerData, ErrStat, ErrMsg)
   type(wake_meandered_center), intent(inout) :: wake_meandered_centerData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroywake_meandered_center'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(wake_meandered_centerData%wake_width)) then
      deallocate(wake_meandered_centerData%wake_width)
   end if
end subroutine

subroutine DWM_Packwake_meandered_center(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(wake_meandered_center), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packwake_meandered_center'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%wake_width)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackwake_meandered_center(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(wake_meandered_center), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackwake_meandered_center'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%wake_width); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_Copyturbine_blade(Srcturbine_bladeData, Dstturbine_bladeData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_turbine_blade), intent(in) :: Srcturbine_bladeData
   type(DWM_turbine_blade), intent(inout) :: Dstturbine_bladeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Copyturbine_blade'
   ErrStat = ErrID_None
   ErrMsg  = ''
   Dstturbine_bladeData%Aerodyn_turbine_num = Srcturbine_bladeData%Aerodyn_turbine_num
   Dstturbine_bladeData%Blade_index = Srcturbine_bladeData%Blade_index
   Dstturbine_bladeData%Element_index = Srcturbine_bladeData%Element_index
end subroutine

subroutine DWM_Destroyturbine_blade(turbine_bladeData, ErrStat, ErrMsg)
   type(DWM_turbine_blade), intent(inout) :: turbine_bladeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'DWM_Destroyturbine_blade'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine DWM_Packturbine_blade(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_turbine_blade), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_Packturbine_blade'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Aerodyn_turbine_num)
   call RegPack(RF, InData%Blade_index)
   call RegPack(RF, InData%Element_index)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackturbine_blade(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_turbine_blade), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackturbine_blade'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Aerodyn_turbine_num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Blade_index); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Element_index); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_ParameterType), intent(in) :: SrcParamData
   type(DWM_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcParamData%velocityU)) then
      LB(1:1) = lbound(SrcParamData%velocityU, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%velocityU, kind=B8Ki)
      if (.not. allocated(DstParamData%velocityU)) then
         allocate(DstParamData%velocityU(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%velocityU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%velocityU = SrcParamData%velocityU
   end if
   if (allocated(SrcParamData%smoothed_wake)) then
      LB(1:1) = lbound(SrcParamData%smoothed_wake, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%smoothed_wake, kind=B8Ki)
      if (.not. allocated(DstParamData%smoothed_wake)) then
         allocate(DstParamData%smoothed_wake(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%smoothed_wake.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%smoothed_wake = SrcParamData%smoothed_wake
   end if
   if (allocated(SrcParamData%WakePosition)) then
      LB(1:3) = lbound(SrcParamData%WakePosition, kind=B8Ki)
      UB(1:3) = ubound(SrcParamData%WakePosition, kind=B8Ki)
      if (.not. allocated(DstParamData%WakePosition)) then
         allocate(DstParamData%WakePosition(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WakePosition.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WakePosition = SrcParamData%WakePosition
   end if
   DstParamData%WakePosition_1 = SrcParamData%WakePosition_1
   DstParamData%WakePosition_2 = SrcParamData%WakePosition_2
   DstParamData%smooth_flag = SrcParamData%smooth_flag
   DstParamData%p_p_r = SrcParamData%p_p_r
   DstParamData%NumWT = SrcParamData%NumWT
   DstParamData%Tinfluencer = SrcParamData%Tinfluencer
   DstParamData%RotorR = SrcParamData%RotorR
   DstParamData%r_domain = SrcParamData%r_domain
   DstParamData%x_domain = SrcParamData%x_domain
   DstParamData%Uambient = SrcParamData%Uambient
   DstParamData%TI_amb = SrcParamData%TI_amb
   DstParamData%TI_wake = SrcParamData%TI_wake
   DstParamData%hub_height = SrcParamData%hub_height
   DstParamData%length_velocityU = SrcParamData%length_velocityU
   DstParamData%WFLowerBd = SrcParamData%WFLowerBd
   DstParamData%Wind_file_Mean_u = SrcParamData%Wind_file_Mean_u
   DstParamData%Winddir = SrcParamData%Winddir
   DstParamData%air_density = SrcParamData%air_density
   DstParamData%RR = SrcParamData%RR
   if (allocated(SrcParamData%ElementRad)) then
      LB(1:1) = lbound(SrcParamData%ElementRad, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%ElementRad, kind=B8Ki)
      if (.not. allocated(DstParamData%ElementRad)) then
         allocate(DstParamData%ElementRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ElementRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%ElementRad = SrcParamData%ElementRad
   end if
   DstParamData%Bnum = SrcParamData%Bnum
   DstParamData%ElementNum = SrcParamData%ElementNum
   call DWM_Copyread_turbine_position_data(SrcParamData%RTPD, DstParamData%RTPD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyParam(SrcParamData%IfW, DstParamData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(DWM_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%velocityU)) then
      deallocate(ParamData%velocityU)
   end if
   if (allocated(ParamData%smoothed_wake)) then
      deallocate(ParamData%smoothed_wake)
   end if
   if (allocated(ParamData%WakePosition)) then
      deallocate(ParamData%WakePosition)
   end if
   if (allocated(ParamData%ElementRad)) then
      deallocate(ParamData%ElementRad)
   end if
   call DWM_Destroyread_turbine_position_data(ParamData%RTPD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyParam(ParamData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%velocityU)
   call RegPackAlloc(RF, InData%smoothed_wake)
   call RegPackAlloc(RF, InData%WakePosition)
   call RegPack(RF, InData%WakePosition_1)
   call RegPack(RF, InData%WakePosition_2)
   call RegPack(RF, InData%smooth_flag)
   call RegPack(RF, InData%p_p_r)
   call RegPack(RF, InData%NumWT)
   call RegPack(RF, InData%Tinfluencer)
   call RegPack(RF, InData%RotorR)
   call RegPack(RF, InData%r_domain)
   call RegPack(RF, InData%x_domain)
   call RegPack(RF, InData%Uambient)
   call RegPack(RF, InData%TI_amb)
   call RegPack(RF, InData%TI_wake)
   call RegPack(RF, InData%hub_height)
   call RegPack(RF, InData%length_velocityU)
   call RegPack(RF, InData%WFLowerBd)
   call RegPack(RF, InData%Wind_file_Mean_u)
   call RegPack(RF, InData%Winddir)
   call RegPack(RF, InData%air_density)
   call RegPack(RF, InData%RR)
   call RegPackAlloc(RF, InData%ElementRad)
   call RegPack(RF, InData%Bnum)
   call RegPack(RF, InData%ElementNum)
   call DWM_Packread_turbine_position_data(RF, InData%RTPD) 
   call InflowWind_PackParam(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackParam'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%velocityU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%smoothed_wake); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WakePosition); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WakePosition_1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WakePosition_2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%smooth_flag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%p_p_r); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumWT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Tinfluencer); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RotorR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%r_domain); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%x_domain); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Uambient); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_amb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_wake); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%hub_height); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%length_velocityU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WFLowerBd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Wind_file_Mean_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Winddir); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%air_density); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ElementRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Bnum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ElementNum); if (RegCheckErr(RF, RoutineName)) return
   call DWM_Unpackread_turbine_position_data(RF, OutData%RTPD) ! RTPD 
   call InflowWind_UnpackParam(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_OtherStateType), intent(in) :: SrcOtherStateData
   type(DWM_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_CopyOtherState(SrcOtherStateData%IfW, DstOtherStateData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(DWM_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyOtherState(OtherStateData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call InflowWind_PackOtherState(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackOtherState'
   if (RF%ErrStat /= ErrID_None) return
   call InflowWind_UnpackOtherState(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_MiscVarType), intent(in) :: SrcMiscData
   type(DWM_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_CopyMisc(SrcMiscData%IfW, DstMiscData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%position_y = SrcMiscData%position_y
   DstMiscData%position_z = SrcMiscData%position_z
   DstMiscData%velocity_wake_mean = SrcMiscData%velocity_wake_mean
   DstMiscData%shifted_velocity_Aerodyn = SrcMiscData%shifted_velocity_Aerodyn
   DstMiscData%U_velocity = SrcMiscData%U_velocity
   DstMiscData%V_velocity = SrcMiscData%V_velocity
   if (allocated(SrcMiscData%Nforce)) then
      LB(1:2) = lbound(SrcMiscData%Nforce, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%Nforce, kind=B8Ki)
      if (.not. allocated(DstMiscData%Nforce)) then
         allocate(DstMiscData%Nforce(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Nforce.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%Nforce = SrcMiscData%Nforce
   end if
   if (allocated(SrcMiscData%blade_dr)) then
      LB(1:1) = lbound(SrcMiscData%blade_dr, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%blade_dr, kind=B8Ki)
      if (.not. allocated(DstMiscData%blade_dr)) then
         allocate(DstMiscData%blade_dr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%blade_dr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%blade_dr = SrcMiscData%blade_dr
   end if
   DstMiscData%NacYaw = SrcMiscData%NacYaw
   DstMiscData%TI_original = SrcMiscData%TI_original
   call DWM_Copyturbine_average_velocity_data(SrcMiscData%TAVD, DstMiscData%TAVD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyCVSD(SrcMiscData%CalVelScale_data, DstMiscData%CalVelScale_data, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyMeanderData(SrcMiscData%meandering_data, DstMiscData%meandering_data, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyWeiMethod(SrcMiscData%weighting_method, DstMiscData%weighting_method, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyTIDownstream(SrcMiscData%TI_downstream_data, DstMiscData%TI_downstream_data, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyTurbKaimal(SrcMiscData%Turbulence_KS, DstMiscData%Turbulence_KS, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyShinozuka(SrcMiscData%shinozuka_data, DstMiscData%shinozuka_data, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_Copysmooth_out_wake_data(SrcMiscData%SmoothOut, DstMiscData%SmoothOut, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopySWSV(SrcMiscData%smooth_wake_shifted_velocity_data, DstMiscData%smooth_wake_shifted_velocity_data, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyWake_Deficit_Data(SrcMiscData%DWDD, DstMiscData%DWDD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%ct_tilde = SrcMiscData%ct_tilde
   DstMiscData%FAST_Time = SrcMiscData%FAST_Time
   DstMiscData%SDtimestep = SrcMiscData%SDtimestep
   call DWM_Copyturbine_blade(SrcMiscData%DWM_tb, DstMiscData%DWM_tb, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_Copywake_meandered_center(SrcMiscData%WMC, DstMiscData%WMC, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(DWM_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyMisc(MiscData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%Nforce)) then
      deallocate(MiscData%Nforce)
   end if
   if (allocated(MiscData%blade_dr)) then
      deallocate(MiscData%blade_dr)
   end if
   call DWM_Destroyturbine_average_velocity_data(MiscData%TAVD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyCVSD(MiscData%CalVelScale_data, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyMeanderData(MiscData%meandering_data, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyWeiMethod(MiscData%weighting_method, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyTIDownstream(MiscData%TI_downstream_data, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyTurbKaimal(MiscData%Turbulence_KS, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyShinozuka(MiscData%shinozuka_data, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_Destroysmooth_out_wake_data(MiscData%SmoothOut, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroySWSV(MiscData%smooth_wake_shifted_velocity_data, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyWake_Deficit_Data(MiscData%DWDD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_Destroyturbine_blade(MiscData%DWM_tb, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_Destroywake_meandered_center(MiscData%WMC, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call InflowWind_PackMisc(RF, InData%IfW) 
   call RegPack(RF, InData%position_y)
   call RegPack(RF, InData%position_z)
   call RegPack(RF, InData%velocity_wake_mean)
   call RegPack(RF, InData%shifted_velocity_Aerodyn)
   call RegPack(RF, InData%U_velocity)
   call RegPack(RF, InData%V_velocity)
   call RegPackAlloc(RF, InData%Nforce)
   call RegPackAlloc(RF, InData%blade_dr)
   call RegPack(RF, InData%NacYaw)
   call RegPack(RF, InData%TI_original)
   call DWM_Packturbine_average_velocity_data(RF, InData%TAVD) 
   call DWM_PackCVSD(RF, InData%CalVelScale_data) 
   call DWM_PackMeanderData(RF, InData%meandering_data) 
   call DWM_PackWeiMethod(RF, InData%weighting_method) 
   call DWM_PackTIDownstream(RF, InData%TI_downstream_data) 
   call DWM_PackTurbKaimal(RF, InData%Turbulence_KS) 
   call DWM_PackShinozuka(RF, InData%shinozuka_data) 
   call DWM_Packsmooth_out_wake_data(RF, InData%SmoothOut) 
   call DWM_PackSWSV(RF, InData%smooth_wake_shifted_velocity_data) 
   call DWM_PackWake_Deficit_Data(RF, InData%DWDD) 
   call RegPack(RF, InData%ct_tilde)
   call RegPack(RF, InData%FAST_Time)
   call RegPack(RF, InData%SDtimestep)
   call DWM_Packturbine_blade(RF, InData%DWM_tb) 
   call DWM_Packwake_meandered_center(RF, InData%WMC) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackMisc'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call InflowWind_UnpackMisc(RF, OutData%IfW) ! IfW 
   call RegUnpack(RF, OutData%position_y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%position_z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%velocity_wake_mean); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%shifted_velocity_Aerodyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%U_velocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%V_velocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Nforce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%blade_dr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NacYaw); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_original); if (RegCheckErr(RF, RoutineName)) return
   call DWM_Unpackturbine_average_velocity_data(RF, OutData%TAVD) ! TAVD 
   call DWM_UnpackCVSD(RF, OutData%CalVelScale_data) ! CalVelScale_data 
   call DWM_UnpackMeanderData(RF, OutData%meandering_data) ! meandering_data 
   call DWM_UnpackWeiMethod(RF, OutData%weighting_method) ! weighting_method 
   call DWM_UnpackTIDownstream(RF, OutData%TI_downstream_data) ! TI_downstream_data 
   call DWM_UnpackTurbKaimal(RF, OutData%Turbulence_KS) ! Turbulence_KS 
   call DWM_UnpackShinozuka(RF, OutData%shinozuka_data) ! shinozuka_data 
   call DWM_Unpacksmooth_out_wake_data(RF, OutData%SmoothOut) ! SmoothOut 
   call DWM_UnpackSWSV(RF, OutData%smooth_wake_shifted_velocity_data) ! smooth_wake_shifted_velocity_data 
   call DWM_UnpackWake_Deficit_Data(RF, OutData%DWDD) ! DWDD 
   call RegUnpack(RF, OutData%ct_tilde); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FAST_Time); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SDtimestep); if (RegCheckErr(RF, RoutineName)) return
   call DWM_Unpackturbine_blade(RF, OutData%DWM_tb) ! DWM_tb 
   call DWM_Unpackwake_meandered_center(RF, OutData%WMC) ! WMC 
end subroutine

subroutine DWM_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_InputType), intent(in) :: SrcInputData
   type(DWM_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_Copyread_upwind_result(SrcInputData%Upwind_result, DstInputData%Upwind_result, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyInput(SrcInputData%IfW, DstInputData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyInput(InputData, ErrStat, ErrMsg)
   type(DWM_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_Destroyread_upwind_result(InputData%Upwind_result, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyInput(InputData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackInput'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_Packread_upwind_result(RF, InData%Upwind_result) 
   call InflowWind_PackInput(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackInput'
   if (RF%ErrStat /= ErrID_None) return
   call DWM_Unpackread_upwind_result(RF, OutData%Upwind_result) ! Upwind_result 
   call InflowWind_UnpackInput(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_OutputType), intent(in) :: SrcOutputData
   type(DWM_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%turbine_thrust_force)) then
      LB(1:1) = lbound(SrcOutputData%turbine_thrust_force, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%turbine_thrust_force, kind=B8Ki)
      if (.not. allocated(DstOutputData%turbine_thrust_force)) then
         allocate(DstOutputData%turbine_thrust_force(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%turbine_thrust_force.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%turbine_thrust_force = SrcOutputData%turbine_thrust_force
   end if
   if (allocated(SrcOutputData%induction_factor)) then
      LB(1:1) = lbound(SrcOutputData%induction_factor, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%induction_factor, kind=B8Ki)
      if (.not. allocated(DstOutputData%induction_factor)) then
         allocate(DstOutputData%induction_factor(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%induction_factor.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%induction_factor = SrcOutputData%induction_factor
   end if
   if (allocated(SrcOutputData%r_initial)) then
      LB(1:1) = lbound(SrcOutputData%r_initial, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%r_initial, kind=B8Ki)
      if (.not. allocated(DstOutputData%r_initial)) then
         allocate(DstOutputData%r_initial(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%r_initial.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%r_initial = SrcOutputData%r_initial
   end if
   if (allocated(SrcOutputData%U_initial)) then
      LB(1:1) = lbound(SrcOutputData%U_initial, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%U_initial, kind=B8Ki)
      if (.not. allocated(DstOutputData%U_initial)) then
         allocate(DstOutputData%U_initial(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%U_initial.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%U_initial = SrcOutputData%U_initial
   end if
   if (allocated(SrcOutputData%Mean_FFWS_array)) then
      LB(1:1) = lbound(SrcOutputData%Mean_FFWS_array, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%Mean_FFWS_array, kind=B8Ki)
      if (.not. allocated(DstOutputData%Mean_FFWS_array)) then
         allocate(DstOutputData%Mean_FFWS_array(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Mean_FFWS_array.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Mean_FFWS_array = SrcOutputData%Mean_FFWS_array
   end if
   DstOutputData%Mean_FFWS = SrcOutputData%Mean_FFWS
   DstOutputData%TI = SrcOutputData%TI
   DstOutputData%TI_downstream = SrcOutputData%TI_downstream
   if (allocated(SrcOutputData%wake_u)) then
      LB(1:2) = lbound(SrcOutputData%wake_u, kind=B8Ki)
      UB(1:2) = ubound(SrcOutputData%wake_u, kind=B8Ki)
      if (.not. allocated(DstOutputData%wake_u)) then
         allocate(DstOutputData%wake_u(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%wake_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%wake_u = SrcOutputData%wake_u
   end if
   if (allocated(SrcOutputData%wake_position)) then
      LB(1:3) = lbound(SrcOutputData%wake_position, kind=B8Ki)
      UB(1:3) = ubound(SrcOutputData%wake_position, kind=B8Ki)
      if (.not. allocated(DstOutputData%wake_position)) then
         allocate(DstOutputData%wake_position(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%wake_position.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%wake_position = SrcOutputData%wake_position
   end if
   if (allocated(SrcOutputData%smoothed_velocity_array)) then
      LB(1:2) = lbound(SrcOutputData%smoothed_velocity_array, kind=B8Ki)
      UB(1:2) = ubound(SrcOutputData%smoothed_velocity_array, kind=B8Ki)
      if (.not. allocated(DstOutputData%smoothed_velocity_array)) then
         allocate(DstOutputData%smoothed_velocity_array(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%smoothed_velocity_array.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%smoothed_velocity_array = SrcOutputData%smoothed_velocity_array
   end if
   DstOutputData%AtmUscale = SrcOutputData%AtmUscale
   DstOutputData%du_dz_ABL = SrcOutputData%du_dz_ABL
   DstOutputData%total_SDgenpwr = SrcOutputData%total_SDgenpwr
   DstOutputData%mean_SDgenpwr = SrcOutputData%mean_SDgenpwr
   DstOutputData%avg_ct = SrcOutputData%avg_ct
   call InflowWind_CopyOutput(SrcOutputData%IfW, DstOutputData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(DWM_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%turbine_thrust_force)) then
      deallocate(OutputData%turbine_thrust_force)
   end if
   if (allocated(OutputData%induction_factor)) then
      deallocate(OutputData%induction_factor)
   end if
   if (allocated(OutputData%r_initial)) then
      deallocate(OutputData%r_initial)
   end if
   if (allocated(OutputData%U_initial)) then
      deallocate(OutputData%U_initial)
   end if
   if (allocated(OutputData%Mean_FFWS_array)) then
      deallocate(OutputData%Mean_FFWS_array)
   end if
   if (allocated(OutputData%wake_u)) then
      deallocate(OutputData%wake_u)
   end if
   if (allocated(OutputData%wake_position)) then
      deallocate(OutputData%wake_position)
   end if
   if (allocated(OutputData%smoothed_velocity_array)) then
      deallocate(OutputData%smoothed_velocity_array)
   end if
   call InflowWind_DestroyOutput(OutputData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%turbine_thrust_force)
   call RegPackAlloc(RF, InData%induction_factor)
   call RegPackAlloc(RF, InData%r_initial)
   call RegPackAlloc(RF, InData%U_initial)
   call RegPackAlloc(RF, InData%Mean_FFWS_array)
   call RegPack(RF, InData%Mean_FFWS)
   call RegPack(RF, InData%TI)
   call RegPack(RF, InData%TI_downstream)
   call RegPackAlloc(RF, InData%wake_u)
   call RegPackAlloc(RF, InData%wake_position)
   call RegPackAlloc(RF, InData%smoothed_velocity_array)
   call RegPack(RF, InData%AtmUscale)
   call RegPack(RF, InData%du_dz_ABL)
   call RegPack(RF, InData%total_SDgenpwr)
   call RegPack(RF, InData%mean_SDgenpwr)
   call RegPack(RF, InData%avg_ct)
   call InflowWind_PackOutput(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackOutput'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%turbine_thrust_force); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%induction_factor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%r_initial); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%U_initial); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Mean_FFWS_array); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Mean_FFWS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TI_downstream); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%wake_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%wake_position); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%smoothed_velocity_array); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AtmUscale); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%du_dz_ABL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%total_SDgenpwr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mean_SDgenpwr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%avg_ct); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackOutput(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_ContinuousStateType), intent(in) :: SrcContStateData
   type(DWM_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstContStateData%dummy = SrcContStateData%dummy
   call InflowWind_CopyContState(SrcContStateData%IfW, DstContStateData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(DWM_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyContState(ContStateData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackContState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackContState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   call InflowWind_PackContState(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackContState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackContState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackContState(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(DWM_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDiscStateData%dummy = SrcDiscStateData%dummy
   call InflowWind_CopyDiscState(SrcDiscStateData%IfW, DstDiscStateData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(DWM_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyDiscState(DiscStateData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackDiscState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackDiscState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   call InflowWind_PackDiscState(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackDiscState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackDiscState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackDiscState(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(DWM_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstConstrStateData%dummy = SrcConstrStateData%dummy
   call InflowWind_CopyConstrState(SrcConstrStateData%IfW, DstConstrStateData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(DWM_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyConstrState(ConstrStateData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackConstrState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackConstrState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   call InflowWind_PackConstrState(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackConstrState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackConstrState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackConstrState(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_InitInputType), intent(in) :: SrcInitInputData
   type(DWM_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%dummy = SrcInitInputData%dummy
   call InflowWind_CopyInitInput(SrcInitInputData%IfW, DstInitInputData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(DWM_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyInitInput(InitInputData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackInitInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   call InflowWind_PackInitInput(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackInitInput'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackInitInput(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(DWM_InitOutputType), intent(in) :: SrcInitOutputData
   type(DWM_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitOutputData%dummy = SrcInitOutputData%dummy
   call InflowWind_CopyInitOutput(SrcInitOutputData%IfW, DstInitOutputData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine DWM_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(DWM_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'DWM_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call InflowWind_DestroyInitOutput(InitOutputData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine DWM_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DWM_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'DWM_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   call InflowWind_PackInitOutput(RF, InData%IfW) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine DWM_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DWM_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'DWM_UnPackInitOutput'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
   call InflowWind_UnpackInitOutput(RF, OutData%IfW) ! IfW 
end subroutine

subroutine DWM_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
   ! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(DWM_InputType), intent(in)  :: u(:) ! Input at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Inputs
   type(DWM_InputType), intent(inout)  :: u_out ! Input at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'DWM_Input_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(u)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(u)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(u) - 1
   select case (order)
   case (0)
      call DWM_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call DWM_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call DWM_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(u) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE DWM_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

   TYPE(DWM_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
   TYPE(DWM_InputType), INTENT(IN)  :: u2    ! Input at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
   TYPE(DWM_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'DWM_Input_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i02      ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i03      ! dim3 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i04      ! dim4 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   INTEGER                                    :: i2       ! dim2 counter variable for arrays
   INTEGER                                    :: i3       ! dim3 counter variable for arrays
   INTEGER                                    :: i4       ! dim4 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(u_out%Upwind_result%upwind_U) .AND. ALLOCATED(u1%Upwind_result%upwind_U)) THEN
      u_out%Upwind_result%upwind_U = a1*u1%Upwind_result%upwind_U + a2*u2%Upwind_result%upwind_U
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_wakecenter) .AND. ALLOCATED(u1%Upwind_result%upwind_wakecenter)) THEN
      u_out%Upwind_result%upwind_wakecenter = a1*u1%Upwind_result%upwind_wakecenter + a2*u2%Upwind_result%upwind_wakecenter
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_meanU) .AND. ALLOCATED(u1%Upwind_result%upwind_meanU)) THEN
      u_out%Upwind_result%upwind_meanU = a1*u1%Upwind_result%upwind_meanU + a2*u2%Upwind_result%upwind_meanU
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_TI) .AND. ALLOCATED(u1%Upwind_result%upwind_TI)) THEN
      u_out%Upwind_result%upwind_TI = a1*u1%Upwind_result%upwind_TI + a2*u2%Upwind_result%upwind_TI
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_small_TI) .AND. ALLOCATED(u1%Upwind_result%upwind_small_TI)) THEN
      u_out%Upwind_result%upwind_small_TI = a1*u1%Upwind_result%upwind_small_TI + a2*u2%Upwind_result%upwind_small_TI
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_smoothWake) .AND. ALLOCATED(u1%Upwind_result%upwind_smoothWake)) THEN
      u_out%Upwind_result%upwind_smoothWake = a1*u1%Upwind_result%upwind_smoothWake + a2*u2%Upwind_result%upwind_smoothWake
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%velocity_aerodyn) .AND. ALLOCATED(u1%Upwind_result%velocity_aerodyn)) THEN
      u_out%Upwind_result%velocity_aerodyn = a1*u1%Upwind_result%velocity_aerodyn + a2*u2%Upwind_result%velocity_aerodyn
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%TI_downstream) .AND. ALLOCATED(u1%Upwind_result%TI_downstream)) THEN
      u_out%Upwind_result%TI_downstream = a1*u1%Upwind_result%TI_downstream + a2*u2%Upwind_result%TI_downstream
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%small_scale_TI_downstream) .AND. ALLOCATED(u1%Upwind_result%small_scale_TI_downstream)) THEN
      u_out%Upwind_result%small_scale_TI_downstream = a1*u1%Upwind_result%small_scale_TI_downstream + a2*u2%Upwind_result%small_scale_TI_downstream
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%smoothed_velocity_array) .AND. ALLOCATED(u1%Upwind_result%smoothed_velocity_array)) THEN
      u_out%Upwind_result%smoothed_velocity_array = a1*u1%Upwind_result%smoothed_velocity_array + a2*u2%Upwind_result%smoothed_velocity_array
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%vel_matrix) .AND. ALLOCATED(u1%Upwind_result%vel_matrix)) THEN
      u_out%Upwind_result%vel_matrix = a1*u1%Upwind_result%vel_matrix + a2*u2%Upwind_result%vel_matrix
   END IF ! check if allocated
   CALL InflowWind_Input_ExtrapInterp1( u1%IfW, u2%IfW, tin, u_out%IfW, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE

SUBROUTINE DWM_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

   TYPE(DWM_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
   TYPE(DWM_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
   TYPE(DWM_InputType), INTENT(IN)  :: u3      ! Input at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
   TYPE(DWM_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'DWM_Input_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   INTEGER                                    :: i2    ! dim2 counter variable for arrays
   INTEGER                                    :: i3    ! dim3 counter variable for arrays
   INTEGER                                    :: i4    ! dim4 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(u_out%Upwind_result%upwind_U) .AND. ALLOCATED(u1%Upwind_result%upwind_U)) THEN
      u_out%Upwind_result%upwind_U = a1*u1%Upwind_result%upwind_U + a2*u2%Upwind_result%upwind_U + a3*u3%Upwind_result%upwind_U
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_wakecenter) .AND. ALLOCATED(u1%Upwind_result%upwind_wakecenter)) THEN
      u_out%Upwind_result%upwind_wakecenter = a1*u1%Upwind_result%upwind_wakecenter + a2*u2%Upwind_result%upwind_wakecenter + a3*u3%Upwind_result%upwind_wakecenter
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_meanU) .AND. ALLOCATED(u1%Upwind_result%upwind_meanU)) THEN
      u_out%Upwind_result%upwind_meanU = a1*u1%Upwind_result%upwind_meanU + a2*u2%Upwind_result%upwind_meanU + a3*u3%Upwind_result%upwind_meanU
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_TI) .AND. ALLOCATED(u1%Upwind_result%upwind_TI)) THEN
      u_out%Upwind_result%upwind_TI = a1*u1%Upwind_result%upwind_TI + a2*u2%Upwind_result%upwind_TI + a3*u3%Upwind_result%upwind_TI
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_small_TI) .AND. ALLOCATED(u1%Upwind_result%upwind_small_TI)) THEN
      u_out%Upwind_result%upwind_small_TI = a1*u1%Upwind_result%upwind_small_TI + a2*u2%Upwind_result%upwind_small_TI + a3*u3%Upwind_result%upwind_small_TI
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%upwind_smoothWake) .AND. ALLOCATED(u1%Upwind_result%upwind_smoothWake)) THEN
      u_out%Upwind_result%upwind_smoothWake = a1*u1%Upwind_result%upwind_smoothWake + a2*u2%Upwind_result%upwind_smoothWake + a3*u3%Upwind_result%upwind_smoothWake
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%velocity_aerodyn) .AND. ALLOCATED(u1%Upwind_result%velocity_aerodyn)) THEN
      u_out%Upwind_result%velocity_aerodyn = a1*u1%Upwind_result%velocity_aerodyn + a2*u2%Upwind_result%velocity_aerodyn + a3*u3%Upwind_result%velocity_aerodyn
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%TI_downstream) .AND. ALLOCATED(u1%Upwind_result%TI_downstream)) THEN
      u_out%Upwind_result%TI_downstream = a1*u1%Upwind_result%TI_downstream + a2*u2%Upwind_result%TI_downstream + a3*u3%Upwind_result%TI_downstream
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%small_scale_TI_downstream) .AND. ALLOCATED(u1%Upwind_result%small_scale_TI_downstream)) THEN
      u_out%Upwind_result%small_scale_TI_downstream = a1*u1%Upwind_result%small_scale_TI_downstream + a2*u2%Upwind_result%small_scale_TI_downstream + a3*u3%Upwind_result%small_scale_TI_downstream
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%smoothed_velocity_array) .AND. ALLOCATED(u1%Upwind_result%smoothed_velocity_array)) THEN
      u_out%Upwind_result%smoothed_velocity_array = a1*u1%Upwind_result%smoothed_velocity_array + a2*u2%Upwind_result%smoothed_velocity_array + a3*u3%Upwind_result%smoothed_velocity_array
   END IF ! check if allocated
   IF (ALLOCATED(u_out%Upwind_result%vel_matrix) .AND. ALLOCATED(u1%Upwind_result%vel_matrix)) THEN
      u_out%Upwind_result%vel_matrix = a1*u1%Upwind_result%vel_matrix + a2*u2%Upwind_result%vel_matrix + a3*u3%Upwind_result%vel_matrix
   END IF ! check if allocated
   CALL InflowWind_Input_ExtrapInterp2( u1%IfW, u2%IfW, u3%IfW, tin, u_out%IfW, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE

subroutine DWM_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
   ! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(DWM_OutputType), intent(in)  :: y(:) ! Output at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Outputs
   type(DWM_OutputType), intent(inout)  :: y_out ! Output at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'DWM_Output_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(y)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(y)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(y) - 1
   select case (order)
   case (0)
      call DWM_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call DWM_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call DWM_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(y) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE DWM_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

   TYPE(DWM_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
   TYPE(DWM_OutputType), INTENT(IN)  :: y2    ! Output at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
   TYPE(DWM_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'DWM_Output_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i02      ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i03      ! dim3 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   INTEGER                                    :: i2       ! dim2 counter variable for arrays
   INTEGER                                    :: i3       ! dim3 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(y_out%turbine_thrust_force) .AND. ALLOCATED(y1%turbine_thrust_force)) THEN
      y_out%turbine_thrust_force = a1*y1%turbine_thrust_force + a2*y2%turbine_thrust_force
   END IF ! check if allocated
   IF (ALLOCATED(y_out%induction_factor) .AND. ALLOCATED(y1%induction_factor)) THEN
      y_out%induction_factor = a1*y1%induction_factor + a2*y2%induction_factor
   END IF ! check if allocated
   IF (ALLOCATED(y_out%r_initial) .AND. ALLOCATED(y1%r_initial)) THEN
      y_out%r_initial = a1*y1%r_initial + a2*y2%r_initial
   END IF ! check if allocated
   IF (ALLOCATED(y_out%U_initial) .AND. ALLOCATED(y1%U_initial)) THEN
      y_out%U_initial = a1*y1%U_initial + a2*y2%U_initial
   END IF ! check if allocated
   IF (ALLOCATED(y_out%Mean_FFWS_array) .AND. ALLOCATED(y1%Mean_FFWS_array)) THEN
      y_out%Mean_FFWS_array = a1*y1%Mean_FFWS_array + a2*y2%Mean_FFWS_array
   END IF ! check if allocated
   y_out%Mean_FFWS = a1*y1%Mean_FFWS + a2*y2%Mean_FFWS
   y_out%TI = a1*y1%TI + a2*y2%TI
   y_out%TI_downstream = a1*y1%TI_downstream + a2*y2%TI_downstream
   IF (ALLOCATED(y_out%wake_u) .AND. ALLOCATED(y1%wake_u)) THEN
      y_out%wake_u = a1*y1%wake_u + a2*y2%wake_u
   END IF ! check if allocated
   IF (ALLOCATED(y_out%wake_position) .AND. ALLOCATED(y1%wake_position)) THEN
      y_out%wake_position = a1*y1%wake_position + a2*y2%wake_position
   END IF ! check if allocated
   IF (ALLOCATED(y_out%smoothed_velocity_array) .AND. ALLOCATED(y1%smoothed_velocity_array)) THEN
      y_out%smoothed_velocity_array = a1*y1%smoothed_velocity_array + a2*y2%smoothed_velocity_array
   END IF ! check if allocated
   y_out%AtmUscale = a1*y1%AtmUscale + a2*y2%AtmUscale
   y_out%du_dz_ABL = a1*y1%du_dz_ABL + a2*y2%du_dz_ABL
   y_out%total_SDgenpwr = a1*y1%total_SDgenpwr + a2*y2%total_SDgenpwr
   y_out%mean_SDgenpwr = a1*y1%mean_SDgenpwr + a2*y2%mean_SDgenpwr
   y_out%avg_ct = a1*y1%avg_ct + a2*y2%avg_ct
   CALL InflowWind_Output_ExtrapInterp1( y1%IfW, y2%IfW, tin, y_out%IfW, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE

SUBROUTINE DWM_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

   TYPE(DWM_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
   TYPE(DWM_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
   TYPE(DWM_OutputType), INTENT(IN)  :: y3      ! Output at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
   TYPE(DWM_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'DWM_Output_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   INTEGER                                    :: i2    ! dim2 counter variable for arrays
   INTEGER                                    :: i3    ! dim3 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(y_out%turbine_thrust_force) .AND. ALLOCATED(y1%turbine_thrust_force)) THEN
      y_out%turbine_thrust_force = a1*y1%turbine_thrust_force + a2*y2%turbine_thrust_force + a3*y3%turbine_thrust_force
   END IF ! check if allocated
   IF (ALLOCATED(y_out%induction_factor) .AND. ALLOCATED(y1%induction_factor)) THEN
      y_out%induction_factor = a1*y1%induction_factor + a2*y2%induction_factor + a3*y3%induction_factor
   END IF ! check if allocated
   IF (ALLOCATED(y_out%r_initial) .AND. ALLOCATED(y1%r_initial)) THEN
      y_out%r_initial = a1*y1%r_initial + a2*y2%r_initial + a3*y3%r_initial
   END IF ! check if allocated
   IF (ALLOCATED(y_out%U_initial) .AND. ALLOCATED(y1%U_initial)) THEN
      y_out%U_initial = a1*y1%U_initial + a2*y2%U_initial + a3*y3%U_initial
   END IF ! check if allocated
   IF (ALLOCATED(y_out%Mean_FFWS_array) .AND. ALLOCATED(y1%Mean_FFWS_array)) THEN
      y_out%Mean_FFWS_array = a1*y1%Mean_FFWS_array + a2*y2%Mean_FFWS_array + a3*y3%Mean_FFWS_array
   END IF ! check if allocated
   y_out%Mean_FFWS = a1*y1%Mean_FFWS + a2*y2%Mean_FFWS + a3*y3%Mean_FFWS
   y_out%TI = a1*y1%TI + a2*y2%TI + a3*y3%TI
   y_out%TI_downstream = a1*y1%TI_downstream + a2*y2%TI_downstream + a3*y3%TI_downstream
   IF (ALLOCATED(y_out%wake_u) .AND. ALLOCATED(y1%wake_u)) THEN
      y_out%wake_u = a1*y1%wake_u + a2*y2%wake_u + a3*y3%wake_u
   END IF ! check if allocated
   IF (ALLOCATED(y_out%wake_position) .AND. ALLOCATED(y1%wake_position)) THEN
      y_out%wake_position = a1*y1%wake_position + a2*y2%wake_position + a3*y3%wake_position
   END IF ! check if allocated
   IF (ALLOCATED(y_out%smoothed_velocity_array) .AND. ALLOCATED(y1%smoothed_velocity_array)) THEN
      y_out%smoothed_velocity_array = a1*y1%smoothed_velocity_array + a2*y2%smoothed_velocity_array + a3*y3%smoothed_velocity_array
   END IF ! check if allocated
   y_out%AtmUscale = a1*y1%AtmUscale + a2*y2%AtmUscale + a3*y3%AtmUscale
   y_out%du_dz_ABL = a1*y1%du_dz_ABL + a2*y2%du_dz_ABL + a3*y3%du_dz_ABL
   y_out%total_SDgenpwr = a1*y1%total_SDgenpwr + a2*y2%total_SDgenpwr + a3*y3%total_SDgenpwr
   y_out%mean_SDgenpwr = a1*y1%mean_SDgenpwr + a2*y2%mean_SDgenpwr + a3*y3%mean_SDgenpwr
   y_out%avg_ct = a1*y1%avg_ct + a2*y2%avg_ct + a3*y3%avg_ct
   CALL InflowWind_Output_ExtrapInterp2( y1%IfW, y2%IfW, y3%IfW, tin, y_out%IfW, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE
END MODULE DWM_Types
!ENDOFREGISTRYGENERATEDFILE
