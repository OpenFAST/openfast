!STARTOFREGISTRYGENERATEDFILE 'AeroDyn14_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn14_Types
!.................................................................................................................................
! This file is part of AeroDyn14.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn14. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn14_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE DWM_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD14_u_InputMarkers              = 1      ! Mesh number for AD14 AD14_u_InputMarkers mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD14_u_Twr_InputMarkers          = 2      ! Mesh number for AD14 AD14_u_Twr_InputMarkers mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD14_y_OutputLoads               = 3      ! Mesh number for AD14 AD14_y_OutputLoads mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD14_y_Twr_OutputLoads           = 4      ! Mesh number for AD14 AD14_y_Twr_OutputLoads mesh [-]
! =========  Marker  =======
  TYPE, PUBLIC :: Marker
    REAL(ReKi) , DIMENSION(1:3)  :: Position = 0.0 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orientation = 0.0 
    REAL(ReKi) , DIMENSION(1:3)  :: TranslationVel = 0.0 
    REAL(ReKi) , DIMENSION(1:3)  :: RotationVel = 0.0 
  END TYPE Marker
! =======================
! =========  AeroConfig  =======
  TYPE, PUBLIC :: AeroConfig
    TYPE(Marker) , DIMENSION(:), ALLOCATABLE  :: Blade 
    TYPE(Marker)  :: Hub 
    TYPE(Marker)  :: RotorFurl 
    TYPE(Marker)  :: Nacelle 
    TYPE(Marker)  :: TailFin 
    TYPE(Marker)  :: Tower 
    TYPE(Marker)  :: SubStructure 
    TYPE(Marker)  :: Foundation 
    REAL(ReKi)  :: BladeLength = 0.0_ReKi 
  END TYPE AeroConfig
! =======================
! =========  AirFoil  =======
  TYPE, PUBLIC :: AirFoil
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CD 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CM 
    REAL(ReKi)  :: PMC = 0.0_ReKi 
    REAL(ReKi)  :: MulTabLoc = 0.0_ReKi 
  END TYPE AirFoil
! =======================
! =========  AirFoilParms  =======
  TYPE, PUBLIC :: AirFoilParms
    INTEGER(IntKi)  :: MaxTable = 20 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTables 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NLift 
    INTEGER(IntKi)  :: NumCL = 0_IntKi 
    INTEGER(IntKi)  :: NumFoil = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NFoil 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabMet 
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: FoilNm 
  END TYPE AirFoilParms
! =======================
! =========  Beddoes  =======
  TYPE, PUBLIC :: Beddoes
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE1 
    REAL(ReKi)  :: AN = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOL 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: BEDSEP 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: OLDSEP 
    REAL(ReKi)  :: CC = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CDO 
    REAL(ReKi)  :: CMI = 0.0_ReKi 
    REAL(ReKi)  :: CMQ = 0.0_ReKi 
    REAL(ReKi)  :: CN = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNA 
    REAL(ReKi)  :: CNCP = 0.0_ReKi 
    REAL(ReKi)  :: CNIQ = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP1 
    REAL(ReKi)  :: DS = 0.0_ReKi 
    REAL(ReKi)  :: FK = 0.0_ReKi 
    REAL(ReKi)  :: FP = 0.0_ReKi 
    REAL(ReKi)  :: FPC = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC1 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTB 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTBC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDCNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDTAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDXN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDYN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: YN 
    LOGICAL  :: SHIFT = .false. 
    LOGICAL  :: VOR = .false. 
  END TYPE Beddoes
! =======================
! =========  BeddoesParms  =======
  TYPE, PUBLIC :: BeddoesParms
    REAL(ReKi)  :: AS = 0.0_ReKi      !< Speed of sound for mach num calc [-]
    REAL(ReKi)  :: TF = 0.0_ReKi      !< Time constant applied to loc of separation pt [-]
    REAL(ReKi)  :: TP = 0.0_ReKi      !< Time constant for pressure lag [-]
    REAL(ReKi)  :: TV = 0.0_ReKi      !< Time constant for strength and shed of vortex [-]
    REAL(ReKi)  :: TVL = 0.0_ReKi      !< Nondim time of transit of vort moving across airfoil surf [-]
  END TYPE BeddoesParms
! =======================
! =========  BladeParms  =======
  TYPE, PUBLIC :: BladeParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: C      !< Chord of each blade element from input file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DR      !< Span-wise width of elem (len of elem ctred at RELM(i) [-]
    REAL(ReKi)  :: R = 0.0_ReKi      !< Rotor radius [-]
    REAL(ReKi)  :: BladeLength = 0.0_ReKi      !< Blade Length [-]
  END TYPE BladeParms
! =======================
! =========  DynInflow  =======
  TYPE, PUBLIC :: DynInflow
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: dAlph_dt = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(3:6,1:4)  :: dBeta_dt = 0.0_ReKi 
    REAL(ReKi)  :: DTO = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:6)  :: old_Alph = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(3:6)  :: old_Beta = 0.0_ReKi 
    REAL(ReKi)  :: old_LmdM = 0.0_ReKi 
    REAL(ReKi)  :: oldKai = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:6)  :: PhiLqC = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(3:6)  :: PhiLqS = 0.0_ReKi 
    REAL(ReKi)  :: Pzero = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMC_SAVE 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMS_SAVE 
    REAL(ReKi)  :: TipSpeed = 0.0_ReKi 
    REAL(ReKi)  :: totalInf = 0.0_ReKi 
    REAL(ReKi)  :: Vparam = 0.0_ReKi 
    REAL(ReKi)  :: Vtotal = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:6)  :: xAlpha = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(3:6)  :: xBeta = 0.0_ReKi 
    REAL(ReKi)  :: xKai = 0.0_ReKi 
    REAL(ReKi)  :: XLAMBDA_M = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: xLcos = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(3:6,3:6)  :: xLsin = 0.0_ReKi 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminR = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminusR = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MplusR = 0_IntKi 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: GAMMA = 0.0_ReKi 
  END TYPE DynInflow
! =======================
! =========  DynInflowParms  =======
  TYPE, PUBLIC :: DynInflowParms
    INTEGER(IntKi)  :: MAXINFLO = 2 
    REAL(ReKi) , DIMENSION(1:6)  :: xMinv = 0.0_ReKi 
  END TYPE DynInflowParms
! =======================
! =========  Element  =======
  TYPE, PUBLIC :: Element
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A      !< - [Axial induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AP      !< - [Tangential induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ALPHA      !< - [Angle of attack]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W2      !< - [Relative velocity norm ]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_A_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_AP_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PITNOW      !< - [Current pitch angle - Based on blade orientation (to verify)]
  END TYPE Element
! =======================
! =========  ElementParms  =======
  TYPE, PUBLIC :: ElementParms
    INTEGER(IntKi)  :: NELM = 0_IntKi      !< - [Number of elements (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TWIST      !< - [Airfoil twist angle (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RELM      !< - [Radius of element (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HLCNST      !< - [Hub loss constant B/2*(r-rh)/rh (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TLCNST      !< - [Tip loss constant B/2*(R-r)/R (constant) ]
  END TYPE ElementParms
! =======================
! =========  ElOutParms  =======
  TYPE, PUBLIC :: ElOutParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ALF 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CDD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CLL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CNN 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CTT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFNSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFTSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DynPres 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PITSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ReyNum 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Gamma      !< - [Circulation along the span, 1/2 c Vrel Cl]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVZ 
    REAL(ReKi)  :: VXSAV = 0.0_ReKi 
    REAL(ReKi)  :: VYSAV = 0.0_ReKi 
    REAL(ReKi)  :: VZSAV = 0.0_ReKi 
    INTEGER(IntKi)  :: NumWndElOut = 0_IntKi      !< Number of Blade Elements [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrNum 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    INTEGER(IntKi)  :: NumElOut = 0_IntKi      !< Number of Blade Elements [-]
  END TYPE ElOutParms
! =======================
! =========  InducedVel  =======
  TYPE, PUBLIC :: InducedVel
    REAL(ReKi)  :: SumInFl = 0 
  END TYPE InducedVel
! =======================
! =========  InducedVelParms  =======
  TYPE, PUBLIC :: InducedVelParms
    REAL(ReKi)  :: AToler = 0.0_ReKi      !< Convergence tolerance for induction factor [-]
    REAL(ReKi)  :: EqAIDmult = 0.0_ReKi      !< Multiplier for drag term in axial-induction equation. [-]
    LOGICAL  :: EquilDA = .false.      !< False unless DB or DA appended to EQUIL [-]
    LOGICAL  :: EquilDT = .false.      !< False unless DB or DT appended to EQUIL [-]
    LOGICAL  :: TLoss = .false.      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: GTech = .false.      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: HLoss = .false.      !< Hub-loss model (EQUIL only) [PRANDtl or NONE] [-]
  END TYPE InducedVelParms
! =======================
! =========  Rotor  =======
  TYPE, PUBLIC :: Rotor
    REAL(ReKi)  :: AVGINFL = 0.0_ReKi      !< average induced velocity at the previous time [-]
    REAL(ReKi)  :: CTILT = 0.0_ReKi 
    REAL(ReKi)  :: CYaw = 0.0_ReKi 
    REAL(ReKi)  :: REVS = 0.0_ReKi 
    REAL(ReKi)  :: STILT = 0.0_ReKi 
    REAL(ReKi)  :: SYaw = 0.0_ReKi 
    REAL(ReKi)  :: TILT = 0.0_ReKi 
    REAL(ReKi)  :: YawAng = 0.0_ReKi 
    REAL(ReKi)  :: YawVEL = 0.0_ReKi 
  END TYPE Rotor
! =======================
! =========  RotorParms  =======
  TYPE, PUBLIC :: RotorParms
    REAL(ReKi)  :: HH = 0.0_ReKi 
  END TYPE RotorParms
! =======================
! =========  TwrPropsParms  =======
  TYPE, PUBLIC :: TwrPropsParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrHtFr 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrWid 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRe 
    REAL(ReKi) , DIMENSION(1:3)  :: VTwr = 0.0_ReKi 
    REAL(ReKi)  :: Tower_Wake_Constant = 0.0_ReKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTwrCDCol      !< The tower CD column that represents a particular twr ht [-]
    INTEGER(IntKi)  :: NTwrHT = 0_IntKi      !< The number of tower height rows in the table [-]
    INTEGER(IntKi)  :: NTwrRe = 0_IntKi      !< The number of tower Re entry rows in the table [-]
    INTEGER(IntKi)  :: NTwrCD = 0_IntKi      !< The number of tower CD columns in the table [-]
    LOGICAL  :: TwrPotent = .false.      !< Tower influence model [-]
    LOGICAL  :: TwrShadow = .false.      !< Tower shadow model [-]
    REAL(ReKi)  :: ShadHWid = 0.0_ReKi      !< Tower-shadow half width [m]
    REAL(ReKi)  :: TShadC1 = 0.0_ReKi      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TShadC2 = 0.0_ReKi      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TwrShad = 0.0_ReKi      !< Tower-shadow velocity deficit [-]
    LOGICAL  :: PJM_Version = .false.      !< Only true if new tower influence model, by PJM [-]
    CHARACTER(1024)  :: TwrFile      !< Tower data file name [-]
    REAL(ReKi)  :: T_Shad_Refpt = 0.0_ReKi      !< Tower-shadow reference point [m]
    LOGICAL  :: CalcTwrAero = .false.      !< Flag to tell AeroDyn to calculate drag on the tower [m]
    INTEGER(IntKi)  :: NumTwrNodes = 0_IntKi      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrNodeWidth      !< The width (diameter) of the tower at the ElastoDyn node locations. [-]
  END TYPE TwrPropsParms
! =======================
! =========  Wind  =======
  TYPE, PUBLIC :: Wind
    REAL(ReKi)  :: ANGFLW = 0.0_ReKi 
    REAL(ReKi)  :: CDEL = 0.0_ReKi 
    REAL(ReKi)  :: VROTORX = 0.0_ReKi 
    REAL(ReKi)  :: VROTORY = 0.0_ReKi 
    REAL(ReKi)  :: VROTORZ = 0.0_ReKi 
    REAL(ReKi)  :: SDEL = 0.0_ReKi 
  END TYPE Wind
! =======================
! =========  WindParms  =======
  TYPE, PUBLIC :: WindParms
    REAL(ReKi)  :: Rho = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc = 0.0_ReKi      !< Kinematic air viscosity [(m^2/sec)]
  END TYPE WindParms
! =======================
! =========  PositionType  =======
  TYPE, PUBLIC :: PositionType
    REAL(ReKi) , DIMENSION(1:3)  :: Pos = 0.0_ReKi      !< X,Y,Z coordinate of a point [-]
  END TYPE PositionType
! =======================
! =========  OrientationType  =======
  TYPE, PUBLIC :: OrientationType
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orient = 0.0_ReKi      !< Direction Cosine Matrix [-]
  END TYPE OrientationType
! =======================
! =========  AD14_InitInputType  =======
  TYPE, PUBLIC :: AD14_InitInputType
    CHARACTER(1024)  :: Title      !< Title [-]
    CHARACTER(1024)  :: OutRootName 
    CHARACTER(1024)  :: ADFileName      !< AeroDyn file name [-]
    LOGICAL  :: WrSumFile = .false.      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: NumBl = 0_IntKi      !< Number of Blades [-]
    REAL(ReKi)  :: BladeLength = 0.0_ReKi      !< Blade Length [-]
    LOGICAL  :: LinearizeFlag = .false. 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    TYPE(AeroConfig)  :: TurbineComponents 
    INTEGER(IntKi)  :: NumTwrNodes = 0_IntKi      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrNodeLocs      !< Location of ElastoDyn tower nodes with respect to the inertial origin. [-]
    REAL(ReKi)  :: HubHt = 0.0_ReKi      !< hub height wrt inertial origin [m]
    TYPE(DWM_InitInputType)  :: DWM 
  END TYPE AD14_InitInputType
! =======================
! =========  AD14_InitOutputType  =======
  TYPE, PUBLIC :: AD14_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< version information [-]
    TYPE(DWM_InitOutputType)  :: DWM 
    REAL(ReKi)  :: AirDens = 0.0_ReKi      !< Air density [kg/m^3]
  END TYPE AD14_InitOutputType
! =======================
! =========  AD14_ContinuousStateType  =======
  TYPE, PUBLIC :: AD14_ContinuousStateType
    TYPE(DWM_ContinuousStateType)  :: DWM 
  END TYPE AD14_ContinuousStateType
! =======================
! =========  AD14_DiscreteStateType  =======
  TYPE, PUBLIC :: AD14_DiscreteStateType
    TYPE(DWM_DiscreteStateType)  :: DWM 
  END TYPE AD14_DiscreteStateType
! =======================
! =========  AD14_ConstraintStateType  =======
  TYPE, PUBLIC :: AD14_ConstraintStateType
    TYPE(DWM_ConstraintStateType)  :: DWM 
  END TYPE AD14_ConstraintStateType
! =======================
! =========  AD14_OtherStateType  =======
  TYPE, PUBLIC :: AD14_OtherStateType
    TYPE(DWM_OtherStateType)  :: DWM      !< variables for DWM module [-]
  END TYPE AD14_OtherStateType
! =======================
! =========  AD14_MiscVarType  =======
  TYPE, PUBLIC :: AD14_MiscVarType
    TYPE(DWM_MiscVarType)  :: DWM      !< variables for DWM module [-]
    TYPE(DWM_InputType)  :: DWM_Inputs 
    TYPE(DWM_OutputType)  :: DWM_Outputs 
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< actual Time step [seconds]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    REAL(DbKi)  :: OldTime = 0.0_R8Ki 
    REAL(ReKi)  :: HubLoss = 1 
    REAL(ReKi)  :: Loss = 1 
    REAL(ReKi)  :: TipLoss = 1 
    REAL(ReKi)  :: TLpt7 = 0.0_ReKi 
    LOGICAL  :: FirstPassGTL = .TRUE. 
    LOGICAL  :: SuperSonic = .FALSE. 
    LOGICAL  :: AFLAGVinderr = .FALSE. 
    LOGICAL  :: AFLAGTwrInflu = .FALSE. 
    LOGICAL  :: OnePassDynDbg = .TRUE. 
    LOGICAL  :: NoLoadsCalculated = .TRUE. 
    INTEGER(IntKi)  :: NERRORS = 0 
    TYPE(AirFoil)  :: AirFoil 
    TYPE(Beddoes)  :: Beddoes 
    TYPE(DynInflow)  :: DynInflow 
    TYPE(Element)  :: Element 
    TYPE(Rotor)  :: Rotor 
    TYPE(Wind)  :: Wind 
    TYPE(InducedVel)  :: InducedVel 
    TYPE(ElOutParms)  :: ElOut 
    LOGICAL  :: Skew = .false. 
    LOGICAL  :: DynInit = .false.      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: FirstWarn = .false.      !< If it's the first warning about AeroDyn not recalculating loads [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredForces 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredMoments 
  END TYPE AD14_MiscVarType
! =======================
! =========  AD14_ParameterType  =======
  TYPE, PUBLIC :: AD14_ParameterType
    CHARACTER(1024)  :: Title      !< Title [-]
    LOGICAL  :: SIUnit = .false. 
    LOGICAL  :: Echo = .FALSE. 
    LOGICAL  :: MultiTab = .false. 
    LOGICAL  :: LinearizeFlag = .false. 
    LOGICAL  :: OutputPlottingInfo = .FALSE. 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    REAL(ReKi)  :: TwoPiNB = 0.0_ReKi      !< 2*pi/num of blades [-]
    INTEGER(IntKi)  :: NumBl = 0_IntKi      !< Number of Blades [-]
    INTEGER(IntKi)  :: NBlInpSt = 0_IntKi      !< Number of Blade Input Stations [-]
    LOGICAL  :: ElemPrn = .false. 
    LOGICAL  :: DStall = .false.      !< FALSE=Steady, TRUE=BEDDOES [-]
    LOGICAL  :: PMoment = .false.      !< FALSE=NO_CM, TRUE=USE_CM [-]
    LOGICAL  :: Reynolds = .false. 
    LOGICAL  :: DynInfl = .false.      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: Wake = .false.      !< False unless WAKE or SWIRL [-]
    LOGICAL  :: Swirl = .false.      !< False unless WAKE or SWIRL [-]
    REAL(DbKi)  :: DtAero = 0.0_R8Ki      !< Time interval for aerodynamic calculations [-]
    REAL(ReKi)  :: HubRad = 0.0_ReKi      !< Hub radius [m]
    INTEGER(IntKi)  :: UnEc = -1 
    INTEGER(IntKi)  :: UnElem = -1 
    INTEGER(IntKi)  :: UnWndOut = -1 
    INTEGER(IntKi)  :: MAXICOUNT = 1000 
    LOGICAL  :: WrOptFile = .TRUE.      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: DEFAULT_Wind = -1 
    TYPE(AirFoilParms)  :: AirFoil 
    TYPE(BladeParms)  :: Blade 
    TYPE(BeddoesParms)  :: Beddoes 
    TYPE(DynInflowParms)  :: DynInflow 
    TYPE(ElementParms)  :: Element 
    TYPE(TwrPropsParms)  :: TwrProps 
    TYPE(InducedVelParms)  :: InducedVel 
    TYPE(WindParms)  :: Wind 
    TYPE(RotorParms)  :: Rotor 
    TYPE(DWM_ParameterType)  :: DWM 
  END TYPE AD14_ParameterType
! =======================
! =========  AD14_InputType  =======
  TYPE, PUBLIC :: AD14_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: InputMarkers      !< Input Forces and positions for the blades (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_InputMarkers      !< Input Forces and positions for the tower (mesh) [-]
    TYPE(AeroConfig)  :: TurbineComponents      !< Current locations of components [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabLoc 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowVelocity      !< U,V,W wind inflow speeds at all locations on the Inputmarker and Twr_InputMarker meshes [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgInfVel = 0.0_ReKi      !< an average disk velocity (depends on wind type and should be removed) [m/s]
  END TYPE AD14_InputType
! =======================
! =========  AD14_OutputType  =======
  TYPE, PUBLIC :: AD14_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: OutputLoads      !< Output Loads (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_OutputLoads      !< Tower Output Loads (mesh) [-]
  END TYPE AD14_OutputType
! =======================
CONTAINS

subroutine AD14_CopyMarker(SrcMarkerData, DstMarkerData, CtrlCode, ErrStat, ErrMsg)
   type(Marker), intent(in) :: SrcMarkerData
   type(Marker), intent(inout) :: DstMarkerData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyMarker'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMarkerData%Position = SrcMarkerData%Position
   DstMarkerData%Orientation = SrcMarkerData%Orientation
   DstMarkerData%TranslationVel = SrcMarkerData%TranslationVel
   DstMarkerData%RotationVel = SrcMarkerData%RotationVel
end subroutine

subroutine AD14_DestroyMarker(MarkerData, ErrStat, ErrMsg)
   type(Marker), intent(inout) :: MarkerData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyMarker'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackMarker(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Marker), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMarker'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Position)
   call RegPack(RF, InData%Orientation)
   call RegPack(RF, InData%TranslationVel)
   call RegPack(RF, InData%RotationVel)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackMarker(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Marker), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMarker'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Position); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Orientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TranslationVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RotationVel); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyAeroConfig(SrcAeroConfigData, DstAeroConfigData, CtrlCode, ErrStat, ErrMsg)
   type(AeroConfig), intent(in) :: SrcAeroConfigData
   type(AeroConfig), intent(inout) :: DstAeroConfigData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyAeroConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAeroConfigData%Blade)) then
      LB(1:1) = lbound(SrcAeroConfigData%Blade, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroConfigData%Blade, kind=B8Ki)
      if (.not. allocated(DstAeroConfigData%Blade)) then
         allocate(DstAeroConfigData%Blade(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroConfigData%Blade.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD14_CopyMarker(SrcAeroConfigData%Blade(i1), DstAeroConfigData%Blade(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call AD14_CopyMarker(SrcAeroConfigData%Hub, DstAeroConfigData%Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%RotorFurl, DstAeroConfigData%RotorFurl, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Nacelle, DstAeroConfigData%Nacelle, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%TailFin, DstAeroConfigData%TailFin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Tower, DstAeroConfigData%Tower, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%SubStructure, DstAeroConfigData%SubStructure, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Foundation, DstAeroConfigData%Foundation, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstAeroConfigData%BladeLength = SrcAeroConfigData%BladeLength
end subroutine

subroutine AD14_DestroyAeroConfig(AeroConfigData, ErrStat, ErrMsg)
   type(AeroConfig), intent(inout) :: AeroConfigData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyAeroConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AeroConfigData%Blade)) then
      LB(1:1) = lbound(AeroConfigData%Blade, kind=B8Ki)
      UB(1:1) = ubound(AeroConfigData%Blade, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call AD14_DestroyMarker(AeroConfigData%Blade(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroConfigData%Blade)
   end if
   call AD14_DestroyMarker(AeroConfigData%Hub, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%RotorFurl, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%Nacelle, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%TailFin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%Tower, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%SubStructure, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyMarker(AeroConfigData%Foundation, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackAeroConfig(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AeroConfig), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAeroConfig'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%Blade))
   if (allocated(InData%Blade)) then
      call RegPackBounds(RF, 1, lbound(InData%Blade, kind=B8Ki), ubound(InData%Blade, kind=B8Ki))
      LB(1:1) = lbound(InData%Blade, kind=B8Ki)
      UB(1:1) = ubound(InData%Blade, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call AD14_PackMarker(RF, InData%Blade(i1)) 
      end do
   end if
   call AD14_PackMarker(RF, InData%Hub) 
   call AD14_PackMarker(RF, InData%RotorFurl) 
   call AD14_PackMarker(RF, InData%Nacelle) 
   call AD14_PackMarker(RF, InData%TailFin) 
   call AD14_PackMarker(RF, InData%Tower) 
   call AD14_PackMarker(RF, InData%SubStructure) 
   call AD14_PackMarker(RF, InData%Foundation) 
   call RegPack(RF, InData%BladeLength)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackAeroConfig(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AeroConfig), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAeroConfig'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%Blade)) deallocate(OutData%Blade)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Blade(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Blade.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD14_UnpackMarker(RF, OutData%Blade(i1)) ! Blade 
      end do
   end if
   call AD14_UnpackMarker(RF, OutData%Hub) ! Hub 
   call AD14_UnpackMarker(RF, OutData%RotorFurl) ! RotorFurl 
   call AD14_UnpackMarker(RF, OutData%Nacelle) ! Nacelle 
   call AD14_UnpackMarker(RF, OutData%TailFin) ! TailFin 
   call AD14_UnpackMarker(RF, OutData%Tower) ! Tower 
   call AD14_UnpackMarker(RF, OutData%SubStructure) ! SubStructure 
   call AD14_UnpackMarker(RF, OutData%Foundation) ! Foundation 
   call RegUnpack(RF, OutData%BladeLength); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyAirFoil(SrcAirFoilData, DstAirFoilData, CtrlCode, ErrStat, ErrMsg)
   type(AirFoil), intent(in) :: SrcAirFoilData
   type(AirFoil), intent(inout) :: DstAirFoilData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyAirFoil'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAirFoilData%AL)) then
      LB(1:2) = lbound(SrcAirFoilData%AL, kind=B8Ki)
      UB(1:2) = ubound(SrcAirFoilData%AL, kind=B8Ki)
      if (.not. allocated(DstAirFoilData%AL)) then
         allocate(DstAirFoilData%AL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%AL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%AL = SrcAirFoilData%AL
   end if
   if (allocated(SrcAirFoilData%CD)) then
      LB(1:3) = lbound(SrcAirFoilData%CD, kind=B8Ki)
      UB(1:3) = ubound(SrcAirFoilData%CD, kind=B8Ki)
      if (.not. allocated(DstAirFoilData%CD)) then
         allocate(DstAirFoilData%CD(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CD = SrcAirFoilData%CD
   end if
   if (allocated(SrcAirFoilData%CL)) then
      LB(1:3) = lbound(SrcAirFoilData%CL, kind=B8Ki)
      UB(1:3) = ubound(SrcAirFoilData%CL, kind=B8Ki)
      if (.not. allocated(DstAirFoilData%CL)) then
         allocate(DstAirFoilData%CL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CL = SrcAirFoilData%CL
   end if
   if (allocated(SrcAirFoilData%CM)) then
      LB(1:3) = lbound(SrcAirFoilData%CM, kind=B8Ki)
      UB(1:3) = ubound(SrcAirFoilData%CM, kind=B8Ki)
      if (.not. allocated(DstAirFoilData%CM)) then
         allocate(DstAirFoilData%CM(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CM = SrcAirFoilData%CM
   end if
   DstAirFoilData%PMC = SrcAirFoilData%PMC
   DstAirFoilData%MulTabLoc = SrcAirFoilData%MulTabLoc
end subroutine

subroutine AD14_DestroyAirFoil(AirFoilData, ErrStat, ErrMsg)
   type(AirFoil), intent(inout) :: AirFoilData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyAirFoil'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AirFoilData%AL)) then
      deallocate(AirFoilData%AL)
   end if
   if (allocated(AirFoilData%CD)) then
      deallocate(AirFoilData%CD)
   end if
   if (allocated(AirFoilData%CL)) then
      deallocate(AirFoilData%CL)
   end if
   if (allocated(AirFoilData%CM)) then
      deallocate(AirFoilData%CM)
   end if
end subroutine

subroutine AD14_PackAirFoil(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AirFoil), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoil'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%AL)
   call RegPackAlloc(RF, InData%CD)
   call RegPackAlloc(RF, InData%CL)
   call RegPackAlloc(RF, InData%CM)
   call RegPack(RF, InData%PMC)
   call RegPack(RF, InData%MulTabLoc)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoil(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AirFoil), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoil'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%AL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PMC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MulTabLoc); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyAirFoilParms(SrcAirFoilParmsData, DstAirFoilParmsData, CtrlCode, ErrStat, ErrMsg)
   type(AirFoilParms), intent(in) :: SrcAirFoilParmsData
   type(AirFoilParms), intent(inout) :: DstAirFoilParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyAirFoilParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstAirFoilParmsData%MaxTable = SrcAirFoilParmsData%MaxTable
   if (allocated(SrcAirFoilParmsData%NTables)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NTables, kind=B8Ki)
      UB(1:1) = ubound(SrcAirFoilParmsData%NTables, kind=B8Ki)
      if (.not. allocated(DstAirFoilParmsData%NTables)) then
         allocate(DstAirFoilParmsData%NTables(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NTables.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NTables = SrcAirFoilParmsData%NTables
   end if
   if (allocated(SrcAirFoilParmsData%NLift)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NLift, kind=B8Ki)
      UB(1:1) = ubound(SrcAirFoilParmsData%NLift, kind=B8Ki)
      if (.not. allocated(DstAirFoilParmsData%NLift)) then
         allocate(DstAirFoilParmsData%NLift(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NLift.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NLift = SrcAirFoilParmsData%NLift
   end if
   DstAirFoilParmsData%NumCL = SrcAirFoilParmsData%NumCL
   DstAirFoilParmsData%NumFoil = SrcAirFoilParmsData%NumFoil
   if (allocated(SrcAirFoilParmsData%NFoil)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NFoil, kind=B8Ki)
      UB(1:1) = ubound(SrcAirFoilParmsData%NFoil, kind=B8Ki)
      if (.not. allocated(DstAirFoilParmsData%NFoil)) then
         allocate(DstAirFoilParmsData%NFoil(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NFoil.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NFoil = SrcAirFoilParmsData%NFoil
   end if
   if (allocated(SrcAirFoilParmsData%MulTabMet)) then
      LB(1:2) = lbound(SrcAirFoilParmsData%MulTabMet, kind=B8Ki)
      UB(1:2) = ubound(SrcAirFoilParmsData%MulTabMet, kind=B8Ki)
      if (.not. allocated(DstAirFoilParmsData%MulTabMet)) then
         allocate(DstAirFoilParmsData%MulTabMet(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%MulTabMet.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%MulTabMet = SrcAirFoilParmsData%MulTabMet
   end if
   if (allocated(SrcAirFoilParmsData%FoilNm)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%FoilNm, kind=B8Ki)
      UB(1:1) = ubound(SrcAirFoilParmsData%FoilNm, kind=B8Ki)
      if (.not. allocated(DstAirFoilParmsData%FoilNm)) then
         allocate(DstAirFoilParmsData%FoilNm(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%FoilNm.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%FoilNm = SrcAirFoilParmsData%FoilNm
   end if
end subroutine

subroutine AD14_DestroyAirFoilParms(AirFoilParmsData, ErrStat, ErrMsg)
   type(AirFoilParms), intent(inout) :: AirFoilParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyAirFoilParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AirFoilParmsData%NTables)) then
      deallocate(AirFoilParmsData%NTables)
   end if
   if (allocated(AirFoilParmsData%NLift)) then
      deallocate(AirFoilParmsData%NLift)
   end if
   if (allocated(AirFoilParmsData%NFoil)) then
      deallocate(AirFoilParmsData%NFoil)
   end if
   if (allocated(AirFoilParmsData%MulTabMet)) then
      deallocate(AirFoilParmsData%MulTabMet)
   end if
   if (allocated(AirFoilParmsData%FoilNm)) then
      deallocate(AirFoilParmsData%FoilNm)
   end if
end subroutine

subroutine AD14_PackAirFoilParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AirFoilParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoilParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MaxTable)
   call RegPackAlloc(RF, InData%NTables)
   call RegPackAlloc(RF, InData%NLift)
   call RegPack(RF, InData%NumCL)
   call RegPack(RF, InData%NumFoil)
   call RegPackAlloc(RF, InData%NFoil)
   call RegPackAlloc(RF, InData%MulTabMet)
   call RegPackAlloc(RF, InData%FoilNm)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoilParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AirFoilParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoilParms'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MaxTable); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NTables); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NLift); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumCL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumFoil); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NFoil); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MulTabMet); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FoilNm); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyBeddoes(SrcBeddoesData, DstBeddoesData, CtrlCode, ErrStat, ErrMsg)
   type(Beddoes), intent(in) :: SrcBeddoesData
   type(Beddoes), intent(inout) :: DstBeddoesData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyBeddoes'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBeddoesData%ADOT)) then
      LB(1:2) = lbound(SrcBeddoesData%ADOT, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%ADOT, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%ADOT)) then
         allocate(DstBeddoesData%ADOT(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ADOT = SrcBeddoesData%ADOT
   end if
   if (allocated(SrcBeddoesData%ADOT1)) then
      LB(1:2) = lbound(SrcBeddoesData%ADOT1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%ADOT1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%ADOT1)) then
         allocate(DstBeddoesData%ADOT1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ADOT1 = SrcBeddoesData%ADOT1
   end if
   if (allocated(SrcBeddoesData%AFE)) then
      LB(1:2) = lbound(SrcBeddoesData%AFE, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%AFE, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%AFE)) then
         allocate(DstBeddoesData%AFE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AFE = SrcBeddoesData%AFE
   end if
   if (allocated(SrcBeddoesData%AFE1)) then
      LB(1:2) = lbound(SrcBeddoesData%AFE1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%AFE1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%AFE1)) then
         allocate(DstBeddoesData%AFE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AFE1 = SrcBeddoesData%AFE1
   end if
   DstBeddoesData%AN = SrcBeddoesData%AN
   if (allocated(SrcBeddoesData%ANE)) then
      LB(1:2) = lbound(SrcBeddoesData%ANE, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%ANE, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%ANE)) then
         allocate(DstBeddoesData%ANE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ANE = SrcBeddoesData%ANE
   end if
   if (allocated(SrcBeddoesData%ANE1)) then
      LB(1:2) = lbound(SrcBeddoesData%ANE1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%ANE1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%ANE1)) then
         allocate(DstBeddoesData%ANE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ANE1 = SrcBeddoesData%ANE1
   end if
   if (allocated(SrcBeddoesData%AOD)) then
      LB(1:2) = lbound(SrcBeddoesData%AOD, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%AOD, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%AOD)) then
         allocate(DstBeddoesData%AOD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AOD = SrcBeddoesData%AOD
   end if
   if (allocated(SrcBeddoesData%AOL)) then
      LB(1:2) = lbound(SrcBeddoesData%AOL, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%AOL, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%AOL)) then
         allocate(DstBeddoesData%AOL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AOL = SrcBeddoesData%AOL
   end if
   if (allocated(SrcBeddoesData%BEDSEP)) then
      LB(1:2) = lbound(SrcBeddoesData%BEDSEP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%BEDSEP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%BEDSEP)) then
         allocate(DstBeddoesData%BEDSEP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%BEDSEP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%BEDSEP = SrcBeddoesData%BEDSEP
   end if
   if (allocated(SrcBeddoesData%OLDSEP)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDSEP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDSEP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDSEP)) then
         allocate(DstBeddoesData%OLDSEP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDSEP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDSEP = SrcBeddoesData%OLDSEP
   end if
   DstBeddoesData%CC = SrcBeddoesData%CC
   if (allocated(SrcBeddoesData%CDO)) then
      LB(1:2) = lbound(SrcBeddoesData%CDO, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CDO, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CDO)) then
         allocate(DstBeddoesData%CDO(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CDO.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CDO = SrcBeddoesData%CDO
   end if
   DstBeddoesData%CMI = SrcBeddoesData%CMI
   DstBeddoesData%CMQ = SrcBeddoesData%CMQ
   DstBeddoesData%CN = SrcBeddoesData%CN
   if (allocated(SrcBeddoesData%CNA)) then
      LB(1:2) = lbound(SrcBeddoesData%CNA, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNA, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNA)) then
         allocate(DstBeddoesData%CNA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNA = SrcBeddoesData%CNA
   end if
   DstBeddoesData%CNCP = SrcBeddoesData%CNCP
   DstBeddoesData%CNIQ = SrcBeddoesData%CNIQ
   if (allocated(SrcBeddoesData%CNP)) then
      LB(1:2) = lbound(SrcBeddoesData%CNP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNP)) then
         allocate(DstBeddoesData%CNP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNP = SrcBeddoesData%CNP
   end if
   if (allocated(SrcBeddoesData%CNP1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNP1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNP1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNP1)) then
         allocate(DstBeddoesData%CNP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNP1 = SrcBeddoesData%CNP1
   end if
   if (allocated(SrcBeddoesData%CNPD)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPD, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNPD, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNPD)) then
         allocate(DstBeddoesData%CNPD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPD = SrcBeddoesData%CNPD
   end if
   if (allocated(SrcBeddoesData%CNPD1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPD1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNPD1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNPD1)) then
         allocate(DstBeddoesData%CNPD1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPD1 = SrcBeddoesData%CNPD1
   end if
   if (allocated(SrcBeddoesData%CNPOT)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPOT, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNPOT, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNPOT)) then
         allocate(DstBeddoesData%CNPOT(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPOT = SrcBeddoesData%CNPOT
   end if
   if (allocated(SrcBeddoesData%CNPOT1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPOT1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNPOT1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNPOT1)) then
         allocate(DstBeddoesData%CNPOT1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPOT1 = SrcBeddoesData%CNPOT1
   end if
   if (allocated(SrcBeddoesData%CNS)) then
      LB(1:2) = lbound(SrcBeddoesData%CNS, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNS, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNS)) then
         allocate(DstBeddoesData%CNS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNS = SrcBeddoesData%CNS
   end if
   if (allocated(SrcBeddoesData%CNSL)) then
      LB(1:2) = lbound(SrcBeddoesData%CNSL, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNSL, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNSL)) then
         allocate(DstBeddoesData%CNSL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNSL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNSL = SrcBeddoesData%CNSL
   end if
   if (allocated(SrcBeddoesData%CNV)) then
      LB(1:2) = lbound(SrcBeddoesData%CNV, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CNV, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CNV)) then
         allocate(DstBeddoesData%CNV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNV = SrcBeddoesData%CNV
   end if
   if (allocated(SrcBeddoesData%CVN)) then
      LB(1:2) = lbound(SrcBeddoesData%CVN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CVN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CVN)) then
         allocate(DstBeddoesData%CVN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CVN = SrcBeddoesData%CVN
   end if
   if (allocated(SrcBeddoesData%CVN1)) then
      LB(1:2) = lbound(SrcBeddoesData%CVN1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%CVN1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%CVN1)) then
         allocate(DstBeddoesData%CVN1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CVN1 = SrcBeddoesData%CVN1
   end if
   if (allocated(SrcBeddoesData%DF)) then
      LB(1:2) = lbound(SrcBeddoesData%DF, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DF, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DF)) then
         allocate(DstBeddoesData%DF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DF = SrcBeddoesData%DF
   end if
   if (allocated(SrcBeddoesData%DFAFE)) then
      LB(1:2) = lbound(SrcBeddoesData%DFAFE, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DFAFE, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DFAFE)) then
         allocate(DstBeddoesData%DFAFE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFAFE = SrcBeddoesData%DFAFE
   end if
   if (allocated(SrcBeddoesData%DFAFE1)) then
      LB(1:2) = lbound(SrcBeddoesData%DFAFE1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DFAFE1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DFAFE1)) then
         allocate(DstBeddoesData%DFAFE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFAFE1 = SrcBeddoesData%DFAFE1
   end if
   if (allocated(SrcBeddoesData%DFC)) then
      LB(1:2) = lbound(SrcBeddoesData%DFC, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DFC, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DFC)) then
         allocate(DstBeddoesData%DFC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFC = SrcBeddoesData%DFC
   end if
   if (allocated(SrcBeddoesData%DN)) then
      LB(1:2) = lbound(SrcBeddoesData%DN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DN)) then
         allocate(DstBeddoesData%DN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DN = SrcBeddoesData%DN
   end if
   if (allocated(SrcBeddoesData%DPP)) then
      LB(1:2) = lbound(SrcBeddoesData%DPP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DPP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DPP)) then
         allocate(DstBeddoesData%DPP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DPP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DPP = SrcBeddoesData%DPP
   end if
   if (allocated(SrcBeddoesData%DQ)) then
      LB(1:2) = lbound(SrcBeddoesData%DQ, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DQ, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DQ)) then
         allocate(DstBeddoesData%DQ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQ = SrcBeddoesData%DQ
   end if
   if (allocated(SrcBeddoesData%DQP)) then
      LB(1:2) = lbound(SrcBeddoesData%DQP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DQP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DQP)) then
         allocate(DstBeddoesData%DQP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQP = SrcBeddoesData%DQP
   end if
   if (allocated(SrcBeddoesData%DQP1)) then
      LB(1:2) = lbound(SrcBeddoesData%DQP1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%DQP1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%DQP1)) then
         allocate(DstBeddoesData%DQP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQP1 = SrcBeddoesData%DQP1
   end if
   DstBeddoesData%DS = SrcBeddoesData%DS
   DstBeddoesData%FK = SrcBeddoesData%FK
   DstBeddoesData%FP = SrcBeddoesData%FP
   DstBeddoesData%FPC = SrcBeddoesData%FPC
   if (allocated(SrcBeddoesData%FSP)) then
      LB(1:2) = lbound(SrcBeddoesData%FSP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%FSP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FSP)) then
         allocate(DstBeddoesData%FSP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSP = SrcBeddoesData%FSP
   end if
   if (allocated(SrcBeddoesData%FSP1)) then
      LB(1:2) = lbound(SrcBeddoesData%FSP1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%FSP1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FSP1)) then
         allocate(DstBeddoesData%FSP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSP1 = SrcBeddoesData%FSP1
   end if
   if (allocated(SrcBeddoesData%FSPC)) then
      LB(1:2) = lbound(SrcBeddoesData%FSPC, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%FSPC, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FSPC)) then
         allocate(DstBeddoesData%FSPC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSPC = SrcBeddoesData%FSPC
   end if
   if (allocated(SrcBeddoesData%FSPC1)) then
      LB(1:2) = lbound(SrcBeddoesData%FSPC1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%FSPC1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FSPC1)) then
         allocate(DstBeddoesData%FSPC1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSPC1 = SrcBeddoesData%FSPC1
   end if
   if (allocated(SrcBeddoesData%FTB)) then
      LB(1:3) = lbound(SrcBeddoesData%FTB, kind=B8Ki)
      UB(1:3) = ubound(SrcBeddoesData%FTB, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FTB)) then
         allocate(DstBeddoesData%FTB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FTB = SrcBeddoesData%FTB
   end if
   if (allocated(SrcBeddoesData%FTBC)) then
      LB(1:3) = lbound(SrcBeddoesData%FTBC, kind=B8Ki)
      UB(1:3) = ubound(SrcBeddoesData%FTBC, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%FTBC)) then
         allocate(DstBeddoesData%FTBC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTBC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FTBC = SrcBeddoesData%FTBC
   end if
   if (allocated(SrcBeddoesData%OLDCNV)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDCNV, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDCNV, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDCNV)) then
         allocate(DstBeddoesData%OLDCNV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDCNV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDCNV = SrcBeddoesData%OLDCNV
   end if
   if (allocated(SrcBeddoesData%OLDDF)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDF, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDDF, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDDF)) then
         allocate(DstBeddoesData%OLDDF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDF = SrcBeddoesData%OLDDF
   end if
   if (allocated(SrcBeddoesData%OLDDFC)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDFC, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDDFC, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDDFC)) then
         allocate(DstBeddoesData%OLDDFC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDFC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDFC = SrcBeddoesData%OLDDFC
   end if
   if (allocated(SrcBeddoesData%OLDDN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDDN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDDN)) then
         allocate(DstBeddoesData%OLDDN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDN = SrcBeddoesData%OLDDN
   end if
   if (allocated(SrcBeddoesData%OLDDPP)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDPP, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDDPP, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDDPP)) then
         allocate(DstBeddoesData%OLDDPP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDPP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDPP = SrcBeddoesData%OLDDPP
   end if
   if (allocated(SrcBeddoesData%OLDDQ)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDQ, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDDQ, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDDQ)) then
         allocate(DstBeddoesData%OLDDQ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDQ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDQ = SrcBeddoesData%OLDDQ
   end if
   if (allocated(SrcBeddoesData%OLDTAU)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDTAU, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDTAU, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDTAU)) then
         allocate(DstBeddoesData%OLDTAU(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDTAU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDTAU = SrcBeddoesData%OLDTAU
   end if
   if (allocated(SrcBeddoesData%OLDXN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDXN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDXN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDXN)) then
         allocate(DstBeddoesData%OLDXN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDXN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDXN = SrcBeddoesData%OLDXN
   end if
   if (allocated(SrcBeddoesData%OLDYN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDYN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%OLDYN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%OLDYN)) then
         allocate(DstBeddoesData%OLDYN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDYN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDYN = SrcBeddoesData%OLDYN
   end if
   if (allocated(SrcBeddoesData%QX)) then
      LB(1:2) = lbound(SrcBeddoesData%QX, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%QX, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%QX)) then
         allocate(DstBeddoesData%QX(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%QX = SrcBeddoesData%QX
   end if
   if (allocated(SrcBeddoesData%QX1)) then
      LB(1:2) = lbound(SrcBeddoesData%QX1, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%QX1, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%QX1)) then
         allocate(DstBeddoesData%QX1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%QX1 = SrcBeddoesData%QX1
   end if
   if (allocated(SrcBeddoesData%TAU)) then
      LB(1:2) = lbound(SrcBeddoesData%TAU, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%TAU, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%TAU)) then
         allocate(DstBeddoesData%TAU(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%TAU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%TAU = SrcBeddoesData%TAU
   end if
   if (allocated(SrcBeddoesData%XN)) then
      LB(1:2) = lbound(SrcBeddoesData%XN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%XN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%XN)) then
         allocate(DstBeddoesData%XN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%XN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%XN = SrcBeddoesData%XN
   end if
   if (allocated(SrcBeddoesData%YN)) then
      LB(1:2) = lbound(SrcBeddoesData%YN, kind=B8Ki)
      UB(1:2) = ubound(SrcBeddoesData%YN, kind=B8Ki)
      if (.not. allocated(DstBeddoesData%YN)) then
         allocate(DstBeddoesData%YN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%YN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%YN = SrcBeddoesData%YN
   end if
   DstBeddoesData%SHIFT = SrcBeddoesData%SHIFT
   DstBeddoesData%VOR = SrcBeddoesData%VOR
end subroutine

subroutine AD14_DestroyBeddoes(BeddoesData, ErrStat, ErrMsg)
   type(Beddoes), intent(inout) :: BeddoesData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBeddoes'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BeddoesData%ADOT)) then
      deallocate(BeddoesData%ADOT)
   end if
   if (allocated(BeddoesData%ADOT1)) then
      deallocate(BeddoesData%ADOT1)
   end if
   if (allocated(BeddoesData%AFE)) then
      deallocate(BeddoesData%AFE)
   end if
   if (allocated(BeddoesData%AFE1)) then
      deallocate(BeddoesData%AFE1)
   end if
   if (allocated(BeddoesData%ANE)) then
      deallocate(BeddoesData%ANE)
   end if
   if (allocated(BeddoesData%ANE1)) then
      deallocate(BeddoesData%ANE1)
   end if
   if (allocated(BeddoesData%AOD)) then
      deallocate(BeddoesData%AOD)
   end if
   if (allocated(BeddoesData%AOL)) then
      deallocate(BeddoesData%AOL)
   end if
   if (allocated(BeddoesData%BEDSEP)) then
      deallocate(BeddoesData%BEDSEP)
   end if
   if (allocated(BeddoesData%OLDSEP)) then
      deallocate(BeddoesData%OLDSEP)
   end if
   if (allocated(BeddoesData%CDO)) then
      deallocate(BeddoesData%CDO)
   end if
   if (allocated(BeddoesData%CNA)) then
      deallocate(BeddoesData%CNA)
   end if
   if (allocated(BeddoesData%CNP)) then
      deallocate(BeddoesData%CNP)
   end if
   if (allocated(BeddoesData%CNP1)) then
      deallocate(BeddoesData%CNP1)
   end if
   if (allocated(BeddoesData%CNPD)) then
      deallocate(BeddoesData%CNPD)
   end if
   if (allocated(BeddoesData%CNPD1)) then
      deallocate(BeddoesData%CNPD1)
   end if
   if (allocated(BeddoesData%CNPOT)) then
      deallocate(BeddoesData%CNPOT)
   end if
   if (allocated(BeddoesData%CNPOT1)) then
      deallocate(BeddoesData%CNPOT1)
   end if
   if (allocated(BeddoesData%CNS)) then
      deallocate(BeddoesData%CNS)
   end if
   if (allocated(BeddoesData%CNSL)) then
      deallocate(BeddoesData%CNSL)
   end if
   if (allocated(BeddoesData%CNV)) then
      deallocate(BeddoesData%CNV)
   end if
   if (allocated(BeddoesData%CVN)) then
      deallocate(BeddoesData%CVN)
   end if
   if (allocated(BeddoesData%CVN1)) then
      deallocate(BeddoesData%CVN1)
   end if
   if (allocated(BeddoesData%DF)) then
      deallocate(BeddoesData%DF)
   end if
   if (allocated(BeddoesData%DFAFE)) then
      deallocate(BeddoesData%DFAFE)
   end if
   if (allocated(BeddoesData%DFAFE1)) then
      deallocate(BeddoesData%DFAFE1)
   end if
   if (allocated(BeddoesData%DFC)) then
      deallocate(BeddoesData%DFC)
   end if
   if (allocated(BeddoesData%DN)) then
      deallocate(BeddoesData%DN)
   end if
   if (allocated(BeddoesData%DPP)) then
      deallocate(BeddoesData%DPP)
   end if
   if (allocated(BeddoesData%DQ)) then
      deallocate(BeddoesData%DQ)
   end if
   if (allocated(BeddoesData%DQP)) then
      deallocate(BeddoesData%DQP)
   end if
   if (allocated(BeddoesData%DQP1)) then
      deallocate(BeddoesData%DQP1)
   end if
   if (allocated(BeddoesData%FSP)) then
      deallocate(BeddoesData%FSP)
   end if
   if (allocated(BeddoesData%FSP1)) then
      deallocate(BeddoesData%FSP1)
   end if
   if (allocated(BeddoesData%FSPC)) then
      deallocate(BeddoesData%FSPC)
   end if
   if (allocated(BeddoesData%FSPC1)) then
      deallocate(BeddoesData%FSPC1)
   end if
   if (allocated(BeddoesData%FTB)) then
      deallocate(BeddoesData%FTB)
   end if
   if (allocated(BeddoesData%FTBC)) then
      deallocate(BeddoesData%FTBC)
   end if
   if (allocated(BeddoesData%OLDCNV)) then
      deallocate(BeddoesData%OLDCNV)
   end if
   if (allocated(BeddoesData%OLDDF)) then
      deallocate(BeddoesData%OLDDF)
   end if
   if (allocated(BeddoesData%OLDDFC)) then
      deallocate(BeddoesData%OLDDFC)
   end if
   if (allocated(BeddoesData%OLDDN)) then
      deallocate(BeddoesData%OLDDN)
   end if
   if (allocated(BeddoesData%OLDDPP)) then
      deallocate(BeddoesData%OLDDPP)
   end if
   if (allocated(BeddoesData%OLDDQ)) then
      deallocate(BeddoesData%OLDDQ)
   end if
   if (allocated(BeddoesData%OLDTAU)) then
      deallocate(BeddoesData%OLDTAU)
   end if
   if (allocated(BeddoesData%OLDXN)) then
      deallocate(BeddoesData%OLDXN)
   end if
   if (allocated(BeddoesData%OLDYN)) then
      deallocate(BeddoesData%OLDYN)
   end if
   if (allocated(BeddoesData%QX)) then
      deallocate(BeddoesData%QX)
   end if
   if (allocated(BeddoesData%QX1)) then
      deallocate(BeddoesData%QX1)
   end if
   if (allocated(BeddoesData%TAU)) then
      deallocate(BeddoesData%TAU)
   end if
   if (allocated(BeddoesData%XN)) then
      deallocate(BeddoesData%XN)
   end if
   if (allocated(BeddoesData%YN)) then
      deallocate(BeddoesData%YN)
   end if
end subroutine

subroutine AD14_PackBeddoes(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Beddoes), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoes'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%ADOT)
   call RegPackAlloc(RF, InData%ADOT1)
   call RegPackAlloc(RF, InData%AFE)
   call RegPackAlloc(RF, InData%AFE1)
   call RegPack(RF, InData%AN)
   call RegPackAlloc(RF, InData%ANE)
   call RegPackAlloc(RF, InData%ANE1)
   call RegPackAlloc(RF, InData%AOD)
   call RegPackAlloc(RF, InData%AOL)
   call RegPackAlloc(RF, InData%BEDSEP)
   call RegPackAlloc(RF, InData%OLDSEP)
   call RegPack(RF, InData%CC)
   call RegPackAlloc(RF, InData%CDO)
   call RegPack(RF, InData%CMI)
   call RegPack(RF, InData%CMQ)
   call RegPack(RF, InData%CN)
   call RegPackAlloc(RF, InData%CNA)
   call RegPack(RF, InData%CNCP)
   call RegPack(RF, InData%CNIQ)
   call RegPackAlloc(RF, InData%CNP)
   call RegPackAlloc(RF, InData%CNP1)
   call RegPackAlloc(RF, InData%CNPD)
   call RegPackAlloc(RF, InData%CNPD1)
   call RegPackAlloc(RF, InData%CNPOT)
   call RegPackAlloc(RF, InData%CNPOT1)
   call RegPackAlloc(RF, InData%CNS)
   call RegPackAlloc(RF, InData%CNSL)
   call RegPackAlloc(RF, InData%CNV)
   call RegPackAlloc(RF, InData%CVN)
   call RegPackAlloc(RF, InData%CVN1)
   call RegPackAlloc(RF, InData%DF)
   call RegPackAlloc(RF, InData%DFAFE)
   call RegPackAlloc(RF, InData%DFAFE1)
   call RegPackAlloc(RF, InData%DFC)
   call RegPackAlloc(RF, InData%DN)
   call RegPackAlloc(RF, InData%DPP)
   call RegPackAlloc(RF, InData%DQ)
   call RegPackAlloc(RF, InData%DQP)
   call RegPackAlloc(RF, InData%DQP1)
   call RegPack(RF, InData%DS)
   call RegPack(RF, InData%FK)
   call RegPack(RF, InData%FP)
   call RegPack(RF, InData%FPC)
   call RegPackAlloc(RF, InData%FSP)
   call RegPackAlloc(RF, InData%FSP1)
   call RegPackAlloc(RF, InData%FSPC)
   call RegPackAlloc(RF, InData%FSPC1)
   call RegPackAlloc(RF, InData%FTB)
   call RegPackAlloc(RF, InData%FTBC)
   call RegPackAlloc(RF, InData%OLDCNV)
   call RegPackAlloc(RF, InData%OLDDF)
   call RegPackAlloc(RF, InData%OLDDFC)
   call RegPackAlloc(RF, InData%OLDDN)
   call RegPackAlloc(RF, InData%OLDDPP)
   call RegPackAlloc(RF, InData%OLDDQ)
   call RegPackAlloc(RF, InData%OLDTAU)
   call RegPackAlloc(RF, InData%OLDXN)
   call RegPackAlloc(RF, InData%OLDYN)
   call RegPackAlloc(RF, InData%QX)
   call RegPackAlloc(RF, InData%QX1)
   call RegPackAlloc(RF, InData%TAU)
   call RegPackAlloc(RF, InData%XN)
   call RegPackAlloc(RF, InData%YN)
   call RegPack(RF, InData%SHIFT)
   call RegPack(RF, InData%VOR)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoes(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Beddoes), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoes'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%ADOT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ADOT1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFE); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AFE1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ANE); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ANE1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AOD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AOL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BEDSEP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDSEP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CDO); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CMI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CMQ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CNCP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CNIQ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNP1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNPD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNPD1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNPOT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNPOT1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNSL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CVN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CVN1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DFAFE); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DFAFE1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DFC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DPP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DQ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DQP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DQP1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FPC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FSP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FSP1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FSPC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FSPC1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FTB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FTBC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDCNV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDDF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDDFC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDDN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDDPP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDDQ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDTAU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDXN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLDYN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%QX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%QX1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TAU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%XN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%YN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SHIFT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VOR); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyBeddoesParms(SrcBeddoesParmsData, DstBeddoesParmsData, CtrlCode, ErrStat, ErrMsg)
   type(BeddoesParms), intent(in) :: SrcBeddoesParmsData
   type(BeddoesParms), intent(inout) :: DstBeddoesParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyBeddoesParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstBeddoesParmsData%AS = SrcBeddoesParmsData%AS
   DstBeddoesParmsData%TF = SrcBeddoesParmsData%TF
   DstBeddoesParmsData%TP = SrcBeddoesParmsData%TP
   DstBeddoesParmsData%TV = SrcBeddoesParmsData%TV
   DstBeddoesParmsData%TVL = SrcBeddoesParmsData%TVL
end subroutine

subroutine AD14_DestroyBeddoesParms(BeddoesParmsData, ErrStat, ErrMsg)
   type(BeddoesParms), intent(inout) :: BeddoesParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBeddoesParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackBeddoesParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(BeddoesParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoesParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%AS)
   call RegPack(RF, InData%TF)
   call RegPack(RF, InData%TP)
   call RegPack(RF, InData%TV)
   call RegPack(RF, InData%TVL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoesParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(BeddoesParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoesParms'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%AS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TVL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyBladeParms(SrcBladeParmsData, DstBladeParmsData, CtrlCode, ErrStat, ErrMsg)
   type(BladeParms), intent(in) :: SrcBladeParmsData
   type(BladeParms), intent(inout) :: DstBladeParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyBladeParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBladeParmsData%C)) then
      LB(1:1) = lbound(SrcBladeParmsData%C, kind=B8Ki)
      UB(1:1) = ubound(SrcBladeParmsData%C, kind=B8Ki)
      if (.not. allocated(DstBladeParmsData%C)) then
         allocate(DstBladeParmsData%C(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%C.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeParmsData%C = SrcBladeParmsData%C
   end if
   if (allocated(SrcBladeParmsData%DR)) then
      LB(1:1) = lbound(SrcBladeParmsData%DR, kind=B8Ki)
      UB(1:1) = ubound(SrcBladeParmsData%DR, kind=B8Ki)
      if (.not. allocated(DstBladeParmsData%DR)) then
         allocate(DstBladeParmsData%DR(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%DR.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeParmsData%DR = SrcBladeParmsData%DR
   end if
   DstBladeParmsData%R = SrcBladeParmsData%R
   DstBladeParmsData%BladeLength = SrcBladeParmsData%BladeLength
end subroutine

subroutine AD14_DestroyBladeParms(BladeParmsData, ErrStat, ErrMsg)
   type(BladeParms), intent(inout) :: BladeParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBladeParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladeParmsData%C)) then
      deallocate(BladeParmsData%C)
   end if
   if (allocated(BladeParmsData%DR)) then
      deallocate(BladeParmsData%DR)
   end if
end subroutine

subroutine AD14_PackBladeParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(BladeParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBladeParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%C)
   call RegPackAlloc(RF, InData%DR)
   call RegPack(RF, InData%R)
   call RegPack(RF, InData%BladeLength)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackBladeParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(BladeParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBladeParms'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%C); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%R); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BladeLength); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyDynInflow(SrcDynInflowData, DstDynInflowData, CtrlCode, ErrStat, ErrMsg)
   type(DynInflow), intent(in) :: SrcDynInflowData
   type(DynInflow), intent(inout) :: DstDynInflowData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyDynInflow'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDynInflowData%dAlph_dt = SrcDynInflowData%dAlph_dt
   DstDynInflowData%dBeta_dt = SrcDynInflowData%dBeta_dt
   DstDynInflowData%DTO = SrcDynInflowData%DTO
   DstDynInflowData%old_Alph = SrcDynInflowData%old_Alph
   DstDynInflowData%old_Beta = SrcDynInflowData%old_Beta
   DstDynInflowData%old_LmdM = SrcDynInflowData%old_LmdM
   DstDynInflowData%oldKai = SrcDynInflowData%oldKai
   DstDynInflowData%PhiLqC = SrcDynInflowData%PhiLqC
   DstDynInflowData%PhiLqS = SrcDynInflowData%PhiLqS
   DstDynInflowData%Pzero = SrcDynInflowData%Pzero
   if (allocated(SrcDynInflowData%RMC_SAVE)) then
      LB(1:3) = lbound(SrcDynInflowData%RMC_SAVE, kind=B8Ki)
      UB(1:3) = ubound(SrcDynInflowData%RMC_SAVE, kind=B8Ki)
      if (.not. allocated(DstDynInflowData%RMC_SAVE)) then
         allocate(DstDynInflowData%RMC_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMC_SAVE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstDynInflowData%RMC_SAVE = SrcDynInflowData%RMC_SAVE
   end if
   if (allocated(SrcDynInflowData%RMS_SAVE)) then
      LB(1:3) = lbound(SrcDynInflowData%RMS_SAVE, kind=B8Ki)
      UB(1:3) = ubound(SrcDynInflowData%RMS_SAVE, kind=B8Ki)
      if (.not. allocated(DstDynInflowData%RMS_SAVE)) then
         allocate(DstDynInflowData%RMS_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMS_SAVE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstDynInflowData%RMS_SAVE = SrcDynInflowData%RMS_SAVE
   end if
   DstDynInflowData%TipSpeed = SrcDynInflowData%TipSpeed
   DstDynInflowData%totalInf = SrcDynInflowData%totalInf
   DstDynInflowData%Vparam = SrcDynInflowData%Vparam
   DstDynInflowData%Vtotal = SrcDynInflowData%Vtotal
   DstDynInflowData%xAlpha = SrcDynInflowData%xAlpha
   DstDynInflowData%xBeta = SrcDynInflowData%xBeta
   DstDynInflowData%xKai = SrcDynInflowData%xKai
   DstDynInflowData%XLAMBDA_M = SrcDynInflowData%XLAMBDA_M
   DstDynInflowData%xLcos = SrcDynInflowData%xLcos
   DstDynInflowData%xLsin = SrcDynInflowData%xLsin
   DstDynInflowData%MminR = SrcDynInflowData%MminR
   DstDynInflowData%MminusR = SrcDynInflowData%MminusR
   DstDynInflowData%MplusR = SrcDynInflowData%MplusR
   DstDynInflowData%GAMMA = SrcDynInflowData%GAMMA
end subroutine

subroutine AD14_DestroyDynInflow(DynInflowData, ErrStat, ErrMsg)
   type(DynInflow), intent(inout) :: DynInflowData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyDynInflow'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(DynInflowData%RMC_SAVE)) then
      deallocate(DynInflowData%RMC_SAVE)
   end if
   if (allocated(DynInflowData%RMS_SAVE)) then
      deallocate(DynInflowData%RMS_SAVE)
   end if
end subroutine

subroutine AD14_PackDynInflow(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DynInflow), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflow'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dAlph_dt)
   call RegPack(RF, InData%dBeta_dt)
   call RegPack(RF, InData%DTO)
   call RegPack(RF, InData%old_Alph)
   call RegPack(RF, InData%old_Beta)
   call RegPack(RF, InData%old_LmdM)
   call RegPack(RF, InData%oldKai)
   call RegPack(RF, InData%PhiLqC)
   call RegPack(RF, InData%PhiLqS)
   call RegPack(RF, InData%Pzero)
   call RegPackAlloc(RF, InData%RMC_SAVE)
   call RegPackAlloc(RF, InData%RMS_SAVE)
   call RegPack(RF, InData%TipSpeed)
   call RegPack(RF, InData%totalInf)
   call RegPack(RF, InData%Vparam)
   call RegPack(RF, InData%Vtotal)
   call RegPack(RF, InData%xAlpha)
   call RegPack(RF, InData%xBeta)
   call RegPack(RF, InData%xKai)
   call RegPack(RF, InData%XLAMBDA_M)
   call RegPack(RF, InData%xLcos)
   call RegPack(RF, InData%xLsin)
   call RegPack(RF, InData%MminR)
   call RegPack(RF, InData%MminusR)
   call RegPack(RF, InData%MplusR)
   call RegPack(RF, InData%GAMMA)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflow(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DynInflow), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflow'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dAlph_dt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dBeta_dt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DTO); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%old_Alph); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%old_Beta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%old_LmdM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%oldKai); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PhiLqC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PhiLqS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pzero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RMC_SAVE); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RMS_SAVE); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TipSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%totalInf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vparam); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vtotal); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xAlpha); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xBeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xKai); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XLAMBDA_M); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xLcos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xLsin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MminR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MminusR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MplusR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%GAMMA); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyDynInflowParms(SrcDynInflowParmsData, DstDynInflowParmsData, CtrlCode, ErrStat, ErrMsg)
   type(DynInflowParms), intent(in) :: SrcDynInflowParmsData
   type(DynInflowParms), intent(inout) :: DstDynInflowParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyDynInflowParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDynInflowParmsData%MAXINFLO = SrcDynInflowParmsData%MAXINFLO
   DstDynInflowParmsData%xMinv = SrcDynInflowParmsData%xMinv
end subroutine

subroutine AD14_DestroyDynInflowParms(DynInflowParmsData, ErrStat, ErrMsg)
   type(DynInflowParms), intent(inout) :: DynInflowParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyDynInflowParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackDynInflowParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DynInflowParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflowParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MAXINFLO)
   call RegPack(RF, InData%xMinv)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflowParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DynInflowParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflowParms'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MAXINFLO); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%xMinv); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyElement(SrcElementData, DstElementData, CtrlCode, ErrStat, ErrMsg)
   type(Element), intent(in) :: SrcElementData
   type(Element), intent(inout) :: DstElementData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElement'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcElementData%A)) then
      LB(1:2) = lbound(SrcElementData%A, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%A, kind=B8Ki)
      if (.not. allocated(DstElementData%A)) then
         allocate(DstElementData%A(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%A.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%A = SrcElementData%A
   end if
   if (allocated(SrcElementData%AP)) then
      LB(1:2) = lbound(SrcElementData%AP, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%AP, kind=B8Ki)
      if (.not. allocated(DstElementData%AP)) then
         allocate(DstElementData%AP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%AP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%AP = SrcElementData%AP
   end if
   if (allocated(SrcElementData%ALPHA)) then
      LB(1:2) = lbound(SrcElementData%ALPHA, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%ALPHA, kind=B8Ki)
      if (.not. allocated(DstElementData%ALPHA)) then
         allocate(DstElementData%ALPHA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%ALPHA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%ALPHA = SrcElementData%ALPHA
   end if
   if (allocated(SrcElementData%W2)) then
      LB(1:2) = lbound(SrcElementData%W2, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%W2, kind=B8Ki)
      if (.not. allocated(DstElementData%W2)) then
         allocate(DstElementData%W2(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%W2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%W2 = SrcElementData%W2
   end if
   if (allocated(SrcElementData%OLD_A_NS)) then
      LB(1:2) = lbound(SrcElementData%OLD_A_NS, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%OLD_A_NS, kind=B8Ki)
      if (.not. allocated(DstElementData%OLD_A_NS)) then
         allocate(DstElementData%OLD_A_NS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_A_NS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%OLD_A_NS = SrcElementData%OLD_A_NS
   end if
   if (allocated(SrcElementData%OLD_AP_NS)) then
      LB(1:2) = lbound(SrcElementData%OLD_AP_NS, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%OLD_AP_NS, kind=B8Ki)
      if (.not. allocated(DstElementData%OLD_AP_NS)) then
         allocate(DstElementData%OLD_AP_NS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_AP_NS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%OLD_AP_NS = SrcElementData%OLD_AP_NS
   end if
   if (allocated(SrcElementData%PITNOW)) then
      LB(1:2) = lbound(SrcElementData%PITNOW, kind=B8Ki)
      UB(1:2) = ubound(SrcElementData%PITNOW, kind=B8Ki)
      if (.not. allocated(DstElementData%PITNOW)) then
         allocate(DstElementData%PITNOW(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%PITNOW.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%PITNOW = SrcElementData%PITNOW
   end if
end subroutine

subroutine AD14_DestroyElement(ElementData, ErrStat, ErrMsg)
   type(Element), intent(inout) :: ElementData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElement'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElementData%A)) then
      deallocate(ElementData%A)
   end if
   if (allocated(ElementData%AP)) then
      deallocate(ElementData%AP)
   end if
   if (allocated(ElementData%ALPHA)) then
      deallocate(ElementData%ALPHA)
   end if
   if (allocated(ElementData%W2)) then
      deallocate(ElementData%W2)
   end if
   if (allocated(ElementData%OLD_A_NS)) then
      deallocate(ElementData%OLD_A_NS)
   end if
   if (allocated(ElementData%OLD_AP_NS)) then
      deallocate(ElementData%OLD_AP_NS)
   end if
   if (allocated(ElementData%PITNOW)) then
      deallocate(ElementData%PITNOW)
   end if
end subroutine

subroutine AD14_PackElement(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Element), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElement'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%A)
   call RegPackAlloc(RF, InData%AP)
   call RegPackAlloc(RF, InData%ALPHA)
   call RegPackAlloc(RF, InData%W2)
   call RegPackAlloc(RF, InData%OLD_A_NS)
   call RegPackAlloc(RF, InData%OLD_AP_NS)
   call RegPackAlloc(RF, InData%PITNOW)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackElement(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Element), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElement'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%A); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ALPHA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%W2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLD_A_NS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OLD_AP_NS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PITNOW); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyElementParms(SrcElementParmsData, DstElementParmsData, CtrlCode, ErrStat, ErrMsg)
   type(ElementParms), intent(in) :: SrcElementParmsData
   type(ElementParms), intent(inout) :: DstElementParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElementParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstElementParmsData%NELM = SrcElementParmsData%NELM
   if (allocated(SrcElementParmsData%TWIST)) then
      LB(1:1) = lbound(SrcElementParmsData%TWIST, kind=B8Ki)
      UB(1:1) = ubound(SrcElementParmsData%TWIST, kind=B8Ki)
      if (.not. allocated(DstElementParmsData%TWIST)) then
         allocate(DstElementParmsData%TWIST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TWIST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%TWIST = SrcElementParmsData%TWIST
   end if
   if (allocated(SrcElementParmsData%RELM)) then
      LB(1:1) = lbound(SrcElementParmsData%RELM, kind=B8Ki)
      UB(1:1) = ubound(SrcElementParmsData%RELM, kind=B8Ki)
      if (.not. allocated(DstElementParmsData%RELM)) then
         allocate(DstElementParmsData%RELM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%RELM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%RELM = SrcElementParmsData%RELM
   end if
   if (allocated(SrcElementParmsData%HLCNST)) then
      LB(1:1) = lbound(SrcElementParmsData%HLCNST, kind=B8Ki)
      UB(1:1) = ubound(SrcElementParmsData%HLCNST, kind=B8Ki)
      if (.not. allocated(DstElementParmsData%HLCNST)) then
         allocate(DstElementParmsData%HLCNST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%HLCNST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%HLCNST = SrcElementParmsData%HLCNST
   end if
   if (allocated(SrcElementParmsData%TLCNST)) then
      LB(1:1) = lbound(SrcElementParmsData%TLCNST, kind=B8Ki)
      UB(1:1) = ubound(SrcElementParmsData%TLCNST, kind=B8Ki)
      if (.not. allocated(DstElementParmsData%TLCNST)) then
         allocate(DstElementParmsData%TLCNST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TLCNST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%TLCNST = SrcElementParmsData%TLCNST
   end if
end subroutine

subroutine AD14_DestroyElementParms(ElementParmsData, ErrStat, ErrMsg)
   type(ElementParms), intent(inout) :: ElementParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElementParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElementParmsData%TWIST)) then
      deallocate(ElementParmsData%TWIST)
   end if
   if (allocated(ElementParmsData%RELM)) then
      deallocate(ElementParmsData%RELM)
   end if
   if (allocated(ElementParmsData%HLCNST)) then
      deallocate(ElementParmsData%HLCNST)
   end if
   if (allocated(ElementParmsData%TLCNST)) then
      deallocate(ElementParmsData%TLCNST)
   end if
end subroutine

subroutine AD14_PackElementParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ElementParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElementParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NELM)
   call RegPackAlloc(RF, InData%TWIST)
   call RegPackAlloc(RF, InData%RELM)
   call RegPackAlloc(RF, InData%HLCNST)
   call RegPackAlloc(RF, InData%TLCNST)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackElementParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ElementParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElementParms'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NELM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TWIST); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RELM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%HLCNST); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TLCNST); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyElOutParms(SrcElOutParmsData, DstElOutParmsData, CtrlCode, ErrStat, ErrMsg)
   type(ElOutParms), intent(in) :: SrcElOutParmsData
   type(ElOutParms), intent(inout) :: DstElOutParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElOutParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcElOutParmsData%AAA)) then
      LB(1:1) = lbound(SrcElOutParmsData%AAA, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%AAA, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%AAA)) then
         allocate(DstElOutParmsData%AAA(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%AAA = SrcElOutParmsData%AAA
   end if
   if (allocated(SrcElOutParmsData%AAP)) then
      LB(1:1) = lbound(SrcElOutParmsData%AAP, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%AAP, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%AAP)) then
         allocate(DstElOutParmsData%AAP(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%AAP = SrcElOutParmsData%AAP
   end if
   if (allocated(SrcElOutParmsData%ALF)) then
      LB(1:1) = lbound(SrcElOutParmsData%ALF, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%ALF, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%ALF)) then
         allocate(DstElOutParmsData%ALF(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ALF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ALF = SrcElOutParmsData%ALF
   end if
   if (allocated(SrcElOutParmsData%CDD)) then
      LB(1:1) = lbound(SrcElOutParmsData%CDD, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%CDD, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%CDD)) then
         allocate(DstElOutParmsData%CDD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CDD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CDD = SrcElOutParmsData%CDD
   end if
   if (allocated(SrcElOutParmsData%CLL)) then
      LB(1:1) = lbound(SrcElOutParmsData%CLL, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%CLL, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%CLL)) then
         allocate(DstElOutParmsData%CLL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CLL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CLL = SrcElOutParmsData%CLL
   end if
   if (allocated(SrcElOutParmsData%CMM)) then
      LB(1:1) = lbound(SrcElOutParmsData%CMM, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%CMM, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%CMM)) then
         allocate(DstElOutParmsData%CMM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CMM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CMM = SrcElOutParmsData%CMM
   end if
   if (allocated(SrcElOutParmsData%CNN)) then
      LB(1:1) = lbound(SrcElOutParmsData%CNN, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%CNN, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%CNN)) then
         allocate(DstElOutParmsData%CNN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CNN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CNN = SrcElOutParmsData%CNN
   end if
   if (allocated(SrcElOutParmsData%CTT)) then
      LB(1:1) = lbound(SrcElOutParmsData%CTT, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%CTT, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%CTT)) then
         allocate(DstElOutParmsData%CTT(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CTT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CTT = SrcElOutParmsData%CTT
   end if
   if (allocated(SrcElOutParmsData%DFNSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%DFNSAV, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%DFNSAV, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%DFNSAV)) then
         allocate(DstElOutParmsData%DFNSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFNSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DFNSAV = SrcElOutParmsData%DFNSAV
   end if
   if (allocated(SrcElOutParmsData%DFTSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%DFTSAV, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%DFTSAV, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%DFTSAV)) then
         allocate(DstElOutParmsData%DFTSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFTSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DFTSAV = SrcElOutParmsData%DFTSAV
   end if
   if (allocated(SrcElOutParmsData%DynPres)) then
      LB(1:1) = lbound(SrcElOutParmsData%DynPres, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%DynPres, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%DynPres)) then
         allocate(DstElOutParmsData%DynPres(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DynPres.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DynPres = SrcElOutParmsData%DynPres
   end if
   if (allocated(SrcElOutParmsData%PMM)) then
      LB(1:1) = lbound(SrcElOutParmsData%PMM, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%PMM, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%PMM)) then
         allocate(DstElOutParmsData%PMM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PMM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%PMM = SrcElOutParmsData%PMM
   end if
   if (allocated(SrcElOutParmsData%PITSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%PITSAV, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%PITSAV, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%PITSAV)) then
         allocate(DstElOutParmsData%PITSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PITSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%PITSAV = SrcElOutParmsData%PITSAV
   end if
   if (allocated(SrcElOutParmsData%ReyNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%ReyNum, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%ReyNum, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%ReyNum)) then
         allocate(DstElOutParmsData%ReyNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ReyNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ReyNum = SrcElOutParmsData%ReyNum
   end if
   if (allocated(SrcElOutParmsData%Gamma)) then
      LB(1:1) = lbound(SrcElOutParmsData%Gamma, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%Gamma, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%Gamma)) then
         allocate(DstElOutParmsData%Gamma(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%Gamma.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%Gamma = SrcElOutParmsData%Gamma
   end if
   if (allocated(SrcElOutParmsData%SaveVX)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVX, kind=B8Ki)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVX, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%SaveVX)) then
         allocate(DstElOutParmsData%SaveVX(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVX = SrcElOutParmsData%SaveVX
   end if
   if (allocated(SrcElOutParmsData%SaveVY)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVY, kind=B8Ki)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVY, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%SaveVY)) then
         allocate(DstElOutParmsData%SaveVY(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVY.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVY = SrcElOutParmsData%SaveVY
   end if
   if (allocated(SrcElOutParmsData%SaveVZ)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVZ, kind=B8Ki)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVZ, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%SaveVZ)) then
         allocate(DstElOutParmsData%SaveVZ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVZ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVZ = SrcElOutParmsData%SaveVZ
   end if
   DstElOutParmsData%VXSAV = SrcElOutParmsData%VXSAV
   DstElOutParmsData%VYSAV = SrcElOutParmsData%VYSAV
   DstElOutParmsData%VZSAV = SrcElOutParmsData%VZSAV
   DstElOutParmsData%NumWndElOut = SrcElOutParmsData%NumWndElOut
   if (allocated(SrcElOutParmsData%WndElPrList)) then
      LB(1:1) = lbound(SrcElOutParmsData%WndElPrList, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%WndElPrList, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%WndElPrList)) then
         allocate(DstElOutParmsData%WndElPrList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%WndElPrList = SrcElOutParmsData%WndElPrList
   end if
   if (allocated(SrcElOutParmsData%WndElPrNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%WndElPrNum, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%WndElPrNum, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%WndElPrNum)) then
         allocate(DstElOutParmsData%WndElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%WndElPrNum = SrcElOutParmsData%WndElPrNum
   end if
   if (allocated(SrcElOutParmsData%ElPrList)) then
      LB(1:1) = lbound(SrcElOutParmsData%ElPrList, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%ElPrList, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%ElPrList)) then
         allocate(DstElOutParmsData%ElPrList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ElPrList = SrcElOutParmsData%ElPrList
   end if
   if (allocated(SrcElOutParmsData%ElPrNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%ElPrNum, kind=B8Ki)
      UB(1:1) = ubound(SrcElOutParmsData%ElPrNum, kind=B8Ki)
      if (.not. allocated(DstElOutParmsData%ElPrNum)) then
         allocate(DstElOutParmsData%ElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ElPrNum = SrcElOutParmsData%ElPrNum
   end if
   DstElOutParmsData%NumElOut = SrcElOutParmsData%NumElOut
end subroutine

subroutine AD14_DestroyElOutParms(ElOutParmsData, ErrStat, ErrMsg)
   type(ElOutParms), intent(inout) :: ElOutParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElOutParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElOutParmsData%AAA)) then
      deallocate(ElOutParmsData%AAA)
   end if
   if (allocated(ElOutParmsData%AAP)) then
      deallocate(ElOutParmsData%AAP)
   end if
   if (allocated(ElOutParmsData%ALF)) then
      deallocate(ElOutParmsData%ALF)
   end if
   if (allocated(ElOutParmsData%CDD)) then
      deallocate(ElOutParmsData%CDD)
   end if
   if (allocated(ElOutParmsData%CLL)) then
      deallocate(ElOutParmsData%CLL)
   end if
   if (allocated(ElOutParmsData%CMM)) then
      deallocate(ElOutParmsData%CMM)
   end if
   if (allocated(ElOutParmsData%CNN)) then
      deallocate(ElOutParmsData%CNN)
   end if
   if (allocated(ElOutParmsData%CTT)) then
      deallocate(ElOutParmsData%CTT)
   end if
   if (allocated(ElOutParmsData%DFNSAV)) then
      deallocate(ElOutParmsData%DFNSAV)
   end if
   if (allocated(ElOutParmsData%DFTSAV)) then
      deallocate(ElOutParmsData%DFTSAV)
   end if
   if (allocated(ElOutParmsData%DynPres)) then
      deallocate(ElOutParmsData%DynPres)
   end if
   if (allocated(ElOutParmsData%PMM)) then
      deallocate(ElOutParmsData%PMM)
   end if
   if (allocated(ElOutParmsData%PITSAV)) then
      deallocate(ElOutParmsData%PITSAV)
   end if
   if (allocated(ElOutParmsData%ReyNum)) then
      deallocate(ElOutParmsData%ReyNum)
   end if
   if (allocated(ElOutParmsData%Gamma)) then
      deallocate(ElOutParmsData%Gamma)
   end if
   if (allocated(ElOutParmsData%SaveVX)) then
      deallocate(ElOutParmsData%SaveVX)
   end if
   if (allocated(ElOutParmsData%SaveVY)) then
      deallocate(ElOutParmsData%SaveVY)
   end if
   if (allocated(ElOutParmsData%SaveVZ)) then
      deallocate(ElOutParmsData%SaveVZ)
   end if
   if (allocated(ElOutParmsData%WndElPrList)) then
      deallocate(ElOutParmsData%WndElPrList)
   end if
   if (allocated(ElOutParmsData%WndElPrNum)) then
      deallocate(ElOutParmsData%WndElPrNum)
   end if
   if (allocated(ElOutParmsData%ElPrList)) then
      deallocate(ElOutParmsData%ElPrList)
   end if
   if (allocated(ElOutParmsData%ElPrNum)) then
      deallocate(ElOutParmsData%ElPrNum)
   end if
end subroutine

subroutine AD14_PackElOutParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ElOutParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElOutParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%AAA)
   call RegPackAlloc(RF, InData%AAP)
   call RegPackAlloc(RF, InData%ALF)
   call RegPackAlloc(RF, InData%CDD)
   call RegPackAlloc(RF, InData%CLL)
   call RegPackAlloc(RF, InData%CMM)
   call RegPackAlloc(RF, InData%CNN)
   call RegPackAlloc(RF, InData%CTT)
   call RegPackAlloc(RF, InData%DFNSAV)
   call RegPackAlloc(RF, InData%DFTSAV)
   call RegPackAlloc(RF, InData%DynPres)
   call RegPackAlloc(RF, InData%PMM)
   call RegPackAlloc(RF, InData%PITSAV)
   call RegPackAlloc(RF, InData%ReyNum)
   call RegPackAlloc(RF, InData%Gamma)
   call RegPackAlloc(RF, InData%SaveVX)
   call RegPackAlloc(RF, InData%SaveVY)
   call RegPackAlloc(RF, InData%SaveVZ)
   call RegPack(RF, InData%VXSAV)
   call RegPack(RF, InData%VYSAV)
   call RegPack(RF, InData%VZSAV)
   call RegPack(RF, InData%NumWndElOut)
   call RegPackAlloc(RF, InData%WndElPrList)
   call RegPackAlloc(RF, InData%WndElPrNum)
   call RegPackAlloc(RF, InData%ElPrList)
   call RegPackAlloc(RF, InData%ElPrNum)
   call RegPack(RF, InData%NumElOut)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackElOutParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ElOutParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElOutParms'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%AAA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AAP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ALF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CDD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CLL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CMM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CNN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CTT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DFNSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DFTSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DynPres); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PMM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PITSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ReyNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Gamma); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%SaveVX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%SaveVY); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%SaveVZ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VXSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VYSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VZSAV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumWndElOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WndElPrList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WndElPrNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ElPrList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ElPrNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumElOut); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyInducedVel(SrcInducedVelData, DstInducedVelData, CtrlCode, ErrStat, ErrMsg)
   type(InducedVel), intent(in) :: SrcInducedVelData
   type(InducedVel), intent(inout) :: DstInducedVelData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyInducedVel'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInducedVelData%SumInFl = SrcInducedVelData%SumInFl
end subroutine

subroutine AD14_DestroyInducedVel(InducedVelData, ErrStat, ErrMsg)
   type(InducedVel), intent(inout) :: InducedVelData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyInducedVel'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackInducedVel(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(InducedVel), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVel'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%SumInFl)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVel(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(InducedVel), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVel'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%SumInFl); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyInducedVelParms(SrcInducedVelParmsData, DstInducedVelParmsData, CtrlCode, ErrStat, ErrMsg)
   type(InducedVelParms), intent(in) :: SrcInducedVelParmsData
   type(InducedVelParms), intent(inout) :: DstInducedVelParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyInducedVelParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInducedVelParmsData%AToler = SrcInducedVelParmsData%AToler
   DstInducedVelParmsData%EqAIDmult = SrcInducedVelParmsData%EqAIDmult
   DstInducedVelParmsData%EquilDA = SrcInducedVelParmsData%EquilDA
   DstInducedVelParmsData%EquilDT = SrcInducedVelParmsData%EquilDT
   DstInducedVelParmsData%TLoss = SrcInducedVelParmsData%TLoss
   DstInducedVelParmsData%GTech = SrcInducedVelParmsData%GTech
   DstInducedVelParmsData%HLoss = SrcInducedVelParmsData%HLoss
end subroutine

subroutine AD14_DestroyInducedVelParms(InducedVelParmsData, ErrStat, ErrMsg)
   type(InducedVelParms), intent(inout) :: InducedVelParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyInducedVelParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackInducedVelParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(InducedVelParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVelParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%AToler)
   call RegPack(RF, InData%EqAIDmult)
   call RegPack(RF, InData%EquilDA)
   call RegPack(RF, InData%EquilDT)
   call RegPack(RF, InData%TLoss)
   call RegPack(RF, InData%GTech)
   call RegPack(RF, InData%HLoss)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVelParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(InducedVelParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVelParms'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%AToler); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EqAIDmult); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EquilDA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EquilDT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TLoss); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%GTech); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HLoss); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyRotor(SrcRotorData, DstRotorData, CtrlCode, ErrStat, ErrMsg)
   type(Rotor), intent(in) :: SrcRotorData
   type(Rotor), intent(inout) :: DstRotorData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyRotor'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotorData%AVGINFL = SrcRotorData%AVGINFL
   DstRotorData%CTILT = SrcRotorData%CTILT
   DstRotorData%CYaw = SrcRotorData%CYaw
   DstRotorData%REVS = SrcRotorData%REVS
   DstRotorData%STILT = SrcRotorData%STILT
   DstRotorData%SYaw = SrcRotorData%SYaw
   DstRotorData%TILT = SrcRotorData%TILT
   DstRotorData%YawAng = SrcRotorData%YawAng
   DstRotorData%YawVEL = SrcRotorData%YawVEL
end subroutine

subroutine AD14_DestroyRotor(RotorData, ErrStat, ErrMsg)
   type(Rotor), intent(inout) :: RotorData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyRotor'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackRotor(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Rotor), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotor'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%AVGINFL)
   call RegPack(RF, InData%CTILT)
   call RegPack(RF, InData%CYaw)
   call RegPack(RF, InData%REVS)
   call RegPack(RF, InData%STILT)
   call RegPack(RF, InData%SYaw)
   call RegPack(RF, InData%TILT)
   call RegPack(RF, InData%YawAng)
   call RegPack(RF, InData%YawVEL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotor(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Rotor), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotor'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%AVGINFL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CTILT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CYaw); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%REVS); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%STILT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SYaw); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TILT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%YawAng); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%YawVEL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyRotorParms(SrcRotorParmsData, DstRotorParmsData, CtrlCode, ErrStat, ErrMsg)
   type(RotorParms), intent(in) :: SrcRotorParmsData
   type(RotorParms), intent(inout) :: DstRotorParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyRotorParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotorParmsData%HH = SrcRotorParmsData%HH
end subroutine

subroutine AD14_DestroyRotorParms(RotorParmsData, ErrStat, ErrMsg)
   type(RotorParms), intent(inout) :: RotorParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyRotorParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackRotorParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(RotorParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotorParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%HH)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotorParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(RotorParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotorParms'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%HH); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyTwrPropsParms(SrcTwrPropsParmsData, DstTwrPropsParmsData, CtrlCode, ErrStat, ErrMsg)
   type(TwrPropsParms), intent(in) :: SrcTwrPropsParmsData
   type(TwrPropsParms), intent(inout) :: DstTwrPropsParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyTwrPropsParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcTwrPropsParmsData%TwrHtFr)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrHtFr, kind=B8Ki)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrHtFr, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%TwrHtFr)) then
         allocate(DstTwrPropsParmsData%TwrHtFr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrHtFr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrHtFr = SrcTwrPropsParmsData%TwrHtFr
   end if
   if (allocated(SrcTwrPropsParmsData%TwrWid)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrWid, kind=B8Ki)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrWid, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%TwrWid)) then
         allocate(DstTwrPropsParmsData%TwrWid(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrWid.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrWid = SrcTwrPropsParmsData%TwrWid
   end if
   if (allocated(SrcTwrPropsParmsData%TwrCD)) then
      LB(1:2) = lbound(SrcTwrPropsParmsData%TwrCD, kind=B8Ki)
      UB(1:2) = ubound(SrcTwrPropsParmsData%TwrCD, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%TwrCD)) then
         allocate(DstTwrPropsParmsData%TwrCD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrCD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrCD = SrcTwrPropsParmsData%TwrCD
   end if
   if (allocated(SrcTwrPropsParmsData%TwrRe)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrRe, kind=B8Ki)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrRe, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%TwrRe)) then
         allocate(DstTwrPropsParmsData%TwrRe(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrRe.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrRe = SrcTwrPropsParmsData%TwrRe
   end if
   DstTwrPropsParmsData%VTwr = SrcTwrPropsParmsData%VTwr
   DstTwrPropsParmsData%Tower_Wake_Constant = SrcTwrPropsParmsData%Tower_Wake_Constant
   if (allocated(SrcTwrPropsParmsData%NTwrCDCol)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%NTwrCDCol, kind=B8Ki)
      UB(1:1) = ubound(SrcTwrPropsParmsData%NTwrCDCol, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%NTwrCDCol)) then
         allocate(DstTwrPropsParmsData%NTwrCDCol(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%NTwrCDCol.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%NTwrCDCol = SrcTwrPropsParmsData%NTwrCDCol
   end if
   DstTwrPropsParmsData%NTwrHT = SrcTwrPropsParmsData%NTwrHT
   DstTwrPropsParmsData%NTwrRe = SrcTwrPropsParmsData%NTwrRe
   DstTwrPropsParmsData%NTwrCD = SrcTwrPropsParmsData%NTwrCD
   DstTwrPropsParmsData%TwrPotent = SrcTwrPropsParmsData%TwrPotent
   DstTwrPropsParmsData%TwrShadow = SrcTwrPropsParmsData%TwrShadow
   DstTwrPropsParmsData%ShadHWid = SrcTwrPropsParmsData%ShadHWid
   DstTwrPropsParmsData%TShadC1 = SrcTwrPropsParmsData%TShadC1
   DstTwrPropsParmsData%TShadC2 = SrcTwrPropsParmsData%TShadC2
   DstTwrPropsParmsData%TwrShad = SrcTwrPropsParmsData%TwrShad
   DstTwrPropsParmsData%PJM_Version = SrcTwrPropsParmsData%PJM_Version
   DstTwrPropsParmsData%TwrFile = SrcTwrPropsParmsData%TwrFile
   DstTwrPropsParmsData%T_Shad_Refpt = SrcTwrPropsParmsData%T_Shad_Refpt
   DstTwrPropsParmsData%CalcTwrAero = SrcTwrPropsParmsData%CalcTwrAero
   DstTwrPropsParmsData%NumTwrNodes = SrcTwrPropsParmsData%NumTwrNodes
   if (allocated(SrcTwrPropsParmsData%TwrNodeWidth)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrNodeWidth, kind=B8Ki)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrNodeWidth, kind=B8Ki)
      if (.not. allocated(DstTwrPropsParmsData%TwrNodeWidth)) then
         allocate(DstTwrPropsParmsData%TwrNodeWidth(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrNodeWidth.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrNodeWidth = SrcTwrPropsParmsData%TwrNodeWidth
   end if
end subroutine

subroutine AD14_DestroyTwrPropsParms(TwrPropsParmsData, ErrStat, ErrMsg)
   type(TwrPropsParms), intent(inout) :: TwrPropsParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyTwrPropsParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(TwrPropsParmsData%TwrHtFr)) then
      deallocate(TwrPropsParmsData%TwrHtFr)
   end if
   if (allocated(TwrPropsParmsData%TwrWid)) then
      deallocate(TwrPropsParmsData%TwrWid)
   end if
   if (allocated(TwrPropsParmsData%TwrCD)) then
      deallocate(TwrPropsParmsData%TwrCD)
   end if
   if (allocated(TwrPropsParmsData%TwrRe)) then
      deallocate(TwrPropsParmsData%TwrRe)
   end if
   if (allocated(TwrPropsParmsData%NTwrCDCol)) then
      deallocate(TwrPropsParmsData%NTwrCDCol)
   end if
   if (allocated(TwrPropsParmsData%TwrNodeWidth)) then
      deallocate(TwrPropsParmsData%TwrNodeWidth)
   end if
end subroutine

subroutine AD14_PackTwrPropsParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TwrPropsParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackTwrPropsParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%TwrHtFr)
   call RegPackAlloc(RF, InData%TwrWid)
   call RegPackAlloc(RF, InData%TwrCD)
   call RegPackAlloc(RF, InData%TwrRe)
   call RegPack(RF, InData%VTwr)
   call RegPack(RF, InData%Tower_Wake_Constant)
   call RegPackAlloc(RF, InData%NTwrCDCol)
   call RegPack(RF, InData%NTwrHT)
   call RegPack(RF, InData%NTwrRe)
   call RegPack(RF, InData%NTwrCD)
   call RegPack(RF, InData%TwrPotent)
   call RegPack(RF, InData%TwrShadow)
   call RegPack(RF, InData%ShadHWid)
   call RegPack(RF, InData%TShadC1)
   call RegPack(RF, InData%TShadC2)
   call RegPack(RF, InData%TwrShad)
   call RegPack(RF, InData%PJM_Version)
   call RegPack(RF, InData%TwrFile)
   call RegPack(RF, InData%T_Shad_Refpt)
   call RegPack(RF, InData%CalcTwrAero)
   call RegPack(RF, InData%NumTwrNodes)
   call RegPackAlloc(RF, InData%TwrNodeWidth)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackTwrPropsParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TwrPropsParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackTwrPropsParms'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%TwrHtFr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TwrWid); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TwrCD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TwrRe); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTwr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Tower_Wake_Constant); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NTwrCDCol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NTwrHT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NTwrRe); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NTwrCD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwrPotent); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwrShadow); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ShadHWid); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TShadC1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TShadC2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwrShad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PJM_Version); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwrFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%T_Shad_Refpt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CalcTwrAero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumTwrNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TwrNodeWidth); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyWind(SrcWindData, DstWindData, CtrlCode, ErrStat, ErrMsg)
   type(Wind), intent(in) :: SrcWindData
   type(Wind), intent(inout) :: DstWindData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyWind'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWindData%ANGFLW = SrcWindData%ANGFLW
   DstWindData%CDEL = SrcWindData%CDEL
   DstWindData%VROTORX = SrcWindData%VROTORX
   DstWindData%VROTORY = SrcWindData%VROTORY
   DstWindData%VROTORZ = SrcWindData%VROTORZ
   DstWindData%SDEL = SrcWindData%SDEL
end subroutine

subroutine AD14_DestroyWind(WindData, ErrStat, ErrMsg)
   type(Wind), intent(inout) :: WindData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyWind'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackWind(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Wind), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWind'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%ANGFLW)
   call RegPack(RF, InData%CDEL)
   call RegPack(RF, InData%VROTORX)
   call RegPack(RF, InData%VROTORY)
   call RegPack(RF, InData%VROTORZ)
   call RegPack(RF, InData%SDEL)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackWind(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Wind), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWind'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%ANGFLW); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CDEL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VROTORX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VROTORY); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VROTORZ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SDEL); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyWindParms(SrcWindParmsData, DstWindParmsData, CtrlCode, ErrStat, ErrMsg)
   type(WindParms), intent(in) :: SrcWindParmsData
   type(WindParms), intent(inout) :: DstWindParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyWindParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWindParmsData%Rho = SrcWindParmsData%Rho
   DstWindParmsData%KinVisc = SrcWindParmsData%KinVisc
end subroutine

subroutine AD14_DestroyWindParms(WindParmsData, ErrStat, ErrMsg)
   type(WindParms), intent(inout) :: WindParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyWindParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackWindParms(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(WindParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWindParms'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Rho)
   call RegPack(RF, InData%KinVisc)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackWindParms(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(WindParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWindParms'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Rho); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%KinVisc); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyPositionType(SrcPositionTypeData, DstPositionTypeData, CtrlCode, ErrStat, ErrMsg)
   type(PositionType), intent(in) :: SrcPositionTypeData
   type(PositionType), intent(inout) :: DstPositionTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyPositionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstPositionTypeData%Pos = SrcPositionTypeData%Pos
end subroutine

subroutine AD14_DestroyPositionType(PositionTypeData, ErrStat, ErrMsg)
   type(PositionType), intent(inout) :: PositionTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyPositionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackPositionType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(PositionType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackPositionType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Pos)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackPositionType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(PositionType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackPositionType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Pos); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyOrientationType(SrcOrientationTypeData, DstOrientationTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OrientationType), intent(in) :: SrcOrientationTypeData
   type(OrientationType), intent(inout) :: DstOrientationTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyOrientationType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOrientationTypeData%Orient = SrcOrientationTypeData%Orient
end subroutine

subroutine AD14_DestroyOrientationType(OrientationTypeData, ErrStat, ErrMsg)
   type(OrientationType), intent(inout) :: OrientationTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyOrientationType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackOrientationType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OrientationType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOrientationType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Orient)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackOrientationType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OrientationType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOrientationType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Orient); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InitInputType), intent(in) :: SrcInitInputData
   type(AD14_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%Title = SrcInitInputData%Title
   DstInitInputData%OutRootName = SrcInitInputData%OutRootName
   DstInitInputData%ADFileName = SrcInitInputData%ADFileName
   DstInitInputData%WrSumFile = SrcInitInputData%WrSumFile
   DstInitInputData%NumBl = SrcInitInputData%NumBl
   DstInitInputData%BladeLength = SrcInitInputData%BladeLength
   DstInitInputData%LinearizeFlag = SrcInitInputData%LinearizeFlag
   DstInitInputData%UseDWM = SrcInitInputData%UseDWM
   call AD14_CopyAeroConfig(SrcInitInputData%TurbineComponents, DstInitInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitInputData%NumTwrNodes = SrcInitInputData%NumTwrNodes
   if (allocated(SrcInitInputData%TwrNodeLocs)) then
      LB(1:2) = lbound(SrcInitInputData%TwrNodeLocs, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%TwrNodeLocs, kind=B8Ki)
      if (.not. allocated(DstInitInputData%TwrNodeLocs)) then
         allocate(DstInitInputData%TwrNodeLocs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TwrNodeLocs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%TwrNodeLocs = SrcInitInputData%TwrNodeLocs
   end if
   DstInitInputData%HubHt = SrcInitInputData%HubHt
   call DWM_CopyInitInput(SrcInitInputData%DWM, DstInitInputData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(AD14_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call AD14_DestroyAeroConfig(InitInputData%TurbineComponents, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitInputData%TwrNodeLocs)) then
      deallocate(InitInputData%TwrNodeLocs)
   end if
   call DWM_DestroyInitInput(InitInputData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Title)
   call RegPack(RF, InData%OutRootName)
   call RegPack(RF, InData%ADFileName)
   call RegPack(RF, InData%WrSumFile)
   call RegPack(RF, InData%NumBl)
   call RegPack(RF, InData%BladeLength)
   call RegPack(RF, InData%LinearizeFlag)
   call RegPack(RF, InData%UseDWM)
   call AD14_PackAeroConfig(RF, InData%TurbineComponents) 
   call RegPack(RF, InData%NumTwrNodes)
   call RegPackAlloc(RF, InData%TwrNodeLocs)
   call RegPack(RF, InData%HubHt)
   call DWM_PackInitInput(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitInput'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Title); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutRootName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ADFileName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrSumFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumBl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BladeLength); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinearizeFlag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UseDWM); if (RegCheckErr(RF, RoutineName)) return
   call AD14_UnpackAeroConfig(RF, OutData%TurbineComponents) ! TurbineComponents 
   call RegUnpack(RF, OutData%NumTwrNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TwrNodeLocs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubHt); if (RegCheckErr(RF, RoutineName)) return
   call DWM_UnpackInitInput(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InitOutputType), intent(in) :: SrcInitOutputData
   type(AD14_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyInitOutput(SrcInitOutputData%DWM, DstInitOutputData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitOutputData%AirDens = SrcInitOutputData%AirDens
end subroutine

subroutine AD14_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(AD14_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyProgDesc(InitOutputData%Ver, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyInitOutput(InitOutputData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(RF, InData%Ver) 
   call DWM_PackInitOutput(RF, InData%DWM) 
   call RegPack(RF, InData%AirDens)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitOutput'
   if (RF%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(RF, OutData%Ver) ! Ver 
   call DWM_UnpackInitOutput(RF, OutData%DWM) ! DWM 
   call RegUnpack(RF, OutData%AirDens); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ContinuousStateType), intent(in) :: SrcContStateData
   type(AD14_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyContState(SrcContStateData%DWM, DstContStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(AD14_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_DestroyContState(ContStateData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackContState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackContState'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_PackContState(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackContState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackContState'
   if (RF%ErrStat /= ErrID_None) return
   call DWM_UnpackContState(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(AD14_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyDiscState(SrcDiscStateData%DWM, DstDiscStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(AD14_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_DestroyDiscState(DiscStateData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackDiscState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDiscState'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_PackDiscState(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackDiscState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDiscState'
   if (RF%ErrStat /= ErrID_None) return
   call DWM_UnpackDiscState(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(AD14_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyConstrState(SrcConstrStateData%DWM, DstConstrStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(AD14_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_DestroyConstrState(ConstrStateData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackConstrState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackConstrState'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_PackConstrState(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackConstrState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackConstrState'
   if (RF%ErrStat /= ErrID_None) return
   call DWM_UnpackConstrState(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_OtherStateType), intent(in) :: SrcOtherStateData
   type(AD14_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyOtherState(SrcOtherStateData%DWM, DstOtherStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(AD14_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_DestroyOtherState(OtherStateData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_PackOtherState(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOtherState'
   if (RF%ErrStat /= ErrID_None) return
   call DWM_UnpackOtherState(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_MiscVarType), intent(in) :: SrcMiscData
   type(AD14_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyMisc(SrcMiscData%DWM, DstMiscData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyInput(SrcMiscData%DWM_Inputs, DstMiscData%DWM_Inputs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyOutput(SrcMiscData%DWM_Outputs, DstMiscData%DWM_Outputs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%DT = SrcMiscData%DT
   if (allocated(SrcMiscData%ElPrNum)) then
      LB(1:1) = lbound(SrcMiscData%ElPrNum, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%ElPrNum, kind=B8Ki)
      if (.not. allocated(DstMiscData%ElPrNum)) then
         allocate(DstMiscData%ElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%ElPrNum = SrcMiscData%ElPrNum
   end if
   DstMiscData%OldTime = SrcMiscData%OldTime
   DstMiscData%HubLoss = SrcMiscData%HubLoss
   DstMiscData%Loss = SrcMiscData%Loss
   DstMiscData%TipLoss = SrcMiscData%TipLoss
   DstMiscData%TLpt7 = SrcMiscData%TLpt7
   DstMiscData%FirstPassGTL = SrcMiscData%FirstPassGTL
   DstMiscData%SuperSonic = SrcMiscData%SuperSonic
   DstMiscData%AFLAGVinderr = SrcMiscData%AFLAGVinderr
   DstMiscData%AFLAGTwrInflu = SrcMiscData%AFLAGTwrInflu
   DstMiscData%OnePassDynDbg = SrcMiscData%OnePassDynDbg
   DstMiscData%NoLoadsCalculated = SrcMiscData%NoLoadsCalculated
   DstMiscData%NERRORS = SrcMiscData%NERRORS
   call AD14_CopyAirFoil(SrcMiscData%AirFoil, DstMiscData%AirFoil, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBeddoes(SrcMiscData%Beddoes, DstMiscData%Beddoes, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyDynInflow(SrcMiscData%DynInflow, DstMiscData%DynInflow, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElement(SrcMiscData%Element, DstMiscData%Element, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyRotor(SrcMiscData%Rotor, DstMiscData%Rotor, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyWind(SrcMiscData%Wind, DstMiscData%Wind, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyInducedVel(SrcMiscData%InducedVel, DstMiscData%InducedVel, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElOutParms(SrcMiscData%ElOut, DstMiscData%ElOut, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%Skew = SrcMiscData%Skew
   DstMiscData%DynInit = SrcMiscData%DynInit
   DstMiscData%FirstWarn = SrcMiscData%FirstWarn
   if (allocated(SrcMiscData%StoredForces)) then
      LB(1:3) = lbound(SrcMiscData%StoredForces, kind=B8Ki)
      UB(1:3) = ubound(SrcMiscData%StoredForces, kind=B8Ki)
      if (.not. allocated(DstMiscData%StoredForces)) then
         allocate(DstMiscData%StoredForces(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredForces.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%StoredForces = SrcMiscData%StoredForces
   end if
   if (allocated(SrcMiscData%StoredMoments)) then
      LB(1:3) = lbound(SrcMiscData%StoredMoments, kind=B8Ki)
      UB(1:3) = ubound(SrcMiscData%StoredMoments, kind=B8Ki)
      if (.not. allocated(DstMiscData%StoredMoments)) then
         allocate(DstMiscData%StoredMoments(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredMoments.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%StoredMoments = SrcMiscData%StoredMoments
   end if
end subroutine

subroutine AD14_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(AD14_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_DestroyMisc(MiscData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyInput(MiscData%DWM_Inputs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyOutput(MiscData%DWM_Outputs, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%ElPrNum)) then
      deallocate(MiscData%ElPrNum)
   end if
   call AD14_DestroyAirFoil(MiscData%AirFoil, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyBeddoes(MiscData%Beddoes, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyDynInflow(MiscData%DynInflow, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyElement(MiscData%Element, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyRotor(MiscData%Rotor, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyWind(MiscData%Wind, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyInducedVel(MiscData%InducedVel, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyElOutParms(MiscData%ElOut, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%StoredForces)) then
      deallocate(MiscData%StoredForces)
   end if
   if (allocated(MiscData%StoredMoments)) then
      deallocate(MiscData%StoredMoments)
   end if
end subroutine

subroutine AD14_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call DWM_PackMisc(RF, InData%DWM) 
   call DWM_PackInput(RF, InData%DWM_Inputs) 
   call DWM_PackOutput(RF, InData%DWM_Outputs) 
   call RegPack(RF, InData%DT)
   call RegPackAlloc(RF, InData%ElPrNum)
   call RegPack(RF, InData%OldTime)
   call RegPack(RF, InData%HubLoss)
   call RegPack(RF, InData%Loss)
   call RegPack(RF, InData%TipLoss)
   call RegPack(RF, InData%TLpt7)
   call RegPack(RF, InData%FirstPassGTL)
   call RegPack(RF, InData%SuperSonic)
   call RegPack(RF, InData%AFLAGVinderr)
   call RegPack(RF, InData%AFLAGTwrInflu)
   call RegPack(RF, InData%OnePassDynDbg)
   call RegPack(RF, InData%NoLoadsCalculated)
   call RegPack(RF, InData%NERRORS)
   call AD14_PackAirFoil(RF, InData%AirFoil) 
   call AD14_PackBeddoes(RF, InData%Beddoes) 
   call AD14_PackDynInflow(RF, InData%DynInflow) 
   call AD14_PackElement(RF, InData%Element) 
   call AD14_PackRotor(RF, InData%Rotor) 
   call AD14_PackWind(RF, InData%Wind) 
   call AD14_PackInducedVel(RF, InData%InducedVel) 
   call AD14_PackElOutParms(RF, InData%ElOut) 
   call RegPack(RF, InData%Skew)
   call RegPack(RF, InData%DynInit)
   call RegPack(RF, InData%FirstWarn)
   call RegPackAlloc(RF, InData%StoredForces)
   call RegPackAlloc(RF, InData%StoredMoments)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMisc'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call DWM_UnpackMisc(RF, OutData%DWM) ! DWM 
   call DWM_UnpackInput(RF, OutData%DWM_Inputs) ! DWM_Inputs 
   call DWM_UnpackOutput(RF, OutData%DWM_Outputs) ! DWM_Outputs 
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ElPrNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OldTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubLoss); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Loss); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TipLoss); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TLpt7); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FirstPassGTL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SuperSonic); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AFLAGVinderr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AFLAGTwrInflu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OnePassDynDbg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NoLoadsCalculated); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NERRORS); if (RegCheckErr(RF, RoutineName)) return
   call AD14_UnpackAirFoil(RF, OutData%AirFoil) ! AirFoil 
   call AD14_UnpackBeddoes(RF, OutData%Beddoes) ! Beddoes 
   call AD14_UnpackDynInflow(RF, OutData%DynInflow) ! DynInflow 
   call AD14_UnpackElement(RF, OutData%Element) ! Element 
   call AD14_UnpackRotor(RF, OutData%Rotor) ! Rotor 
   call AD14_UnpackWind(RF, OutData%Wind) ! Wind 
   call AD14_UnpackInducedVel(RF, OutData%InducedVel) ! InducedVel 
   call AD14_UnpackElOutParms(RF, OutData%ElOut) ! ElOut 
   call RegUnpack(RF, OutData%Skew); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DynInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FirstWarn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StoredForces); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StoredMoments); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ParameterType), intent(in) :: SrcParamData
   type(AD14_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%Title = SrcParamData%Title
   DstParamData%SIUnit = SrcParamData%SIUnit
   DstParamData%Echo = SrcParamData%Echo
   DstParamData%MultiTab = SrcParamData%MultiTab
   DstParamData%LinearizeFlag = SrcParamData%LinearizeFlag
   DstParamData%OutputPlottingInfo = SrcParamData%OutputPlottingInfo
   DstParamData%UseDWM = SrcParamData%UseDWM
   DstParamData%TwoPiNB = SrcParamData%TwoPiNB
   DstParamData%NumBl = SrcParamData%NumBl
   DstParamData%NBlInpSt = SrcParamData%NBlInpSt
   DstParamData%ElemPrn = SrcParamData%ElemPrn
   DstParamData%DStall = SrcParamData%DStall
   DstParamData%PMoment = SrcParamData%PMoment
   DstParamData%Reynolds = SrcParamData%Reynolds
   DstParamData%DynInfl = SrcParamData%DynInfl
   DstParamData%Wake = SrcParamData%Wake
   DstParamData%Swirl = SrcParamData%Swirl
   DstParamData%DtAero = SrcParamData%DtAero
   DstParamData%HubRad = SrcParamData%HubRad
   DstParamData%UnEc = SrcParamData%UnEc
   DstParamData%UnElem = SrcParamData%UnElem
   DstParamData%UnWndOut = SrcParamData%UnWndOut
   DstParamData%MAXICOUNT = SrcParamData%MAXICOUNT
   DstParamData%WrOptFile = SrcParamData%WrOptFile
   DstParamData%DEFAULT_Wind = SrcParamData%DEFAULT_Wind
   call AD14_CopyAirFoilParms(SrcParamData%AirFoil, DstParamData%AirFoil, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBladeParms(SrcParamData%Blade, DstParamData%Blade, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBeddoesParms(SrcParamData%Beddoes, DstParamData%Beddoes, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyDynInflowParms(SrcParamData%DynInflow, DstParamData%DynInflow, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElementParms(SrcParamData%Element, DstParamData%Element, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyTwrPropsParms(SrcParamData%TwrProps, DstParamData%TwrProps, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyInducedVelParms(SrcParamData%InducedVel, DstParamData%InducedVel, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyWindParms(SrcParamData%Wind, DstParamData%Wind, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyRotorParms(SrcParamData%Rotor, DstParamData%Rotor, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyParam(SrcParamData%DWM, DstParamData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(AD14_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call AD14_DestroyAirFoilParms(ParamData%AirFoil, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyBladeParms(ParamData%Blade, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyBeddoesParms(ParamData%Beddoes, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyDynInflowParms(ParamData%DynInflow, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyElementParms(ParamData%Element, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyTwrPropsParms(ParamData%TwrProps, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyInducedVelParms(ParamData%InducedVel, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyWindParms(ParamData%Wind, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyRotorParms(ParamData%Rotor, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DWM_DestroyParam(ParamData%DWM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Title)
   call RegPack(RF, InData%SIUnit)
   call RegPack(RF, InData%Echo)
   call RegPack(RF, InData%MultiTab)
   call RegPack(RF, InData%LinearizeFlag)
   call RegPack(RF, InData%OutputPlottingInfo)
   call RegPack(RF, InData%UseDWM)
   call RegPack(RF, InData%TwoPiNB)
   call RegPack(RF, InData%NumBl)
   call RegPack(RF, InData%NBlInpSt)
   call RegPack(RF, InData%ElemPrn)
   call RegPack(RF, InData%DStall)
   call RegPack(RF, InData%PMoment)
   call RegPack(RF, InData%Reynolds)
   call RegPack(RF, InData%DynInfl)
   call RegPack(RF, InData%Wake)
   call RegPack(RF, InData%Swirl)
   call RegPack(RF, InData%DtAero)
   call RegPack(RF, InData%HubRad)
   call RegPack(RF, InData%UnEc)
   call RegPack(RF, InData%UnElem)
   call RegPack(RF, InData%UnWndOut)
   call RegPack(RF, InData%MAXICOUNT)
   call RegPack(RF, InData%WrOptFile)
   call RegPack(RF, InData%DEFAULT_Wind)
   call AD14_PackAirFoilParms(RF, InData%AirFoil) 
   call AD14_PackBladeParms(RF, InData%Blade) 
   call AD14_PackBeddoesParms(RF, InData%Beddoes) 
   call AD14_PackDynInflowParms(RF, InData%DynInflow) 
   call AD14_PackElementParms(RF, InData%Element) 
   call AD14_PackTwrPropsParms(RF, InData%TwrProps) 
   call AD14_PackInducedVelParms(RF, InData%InducedVel) 
   call AD14_PackWindParms(RF, InData%Wind) 
   call AD14_PackRotorParms(RF, InData%Rotor) 
   call DWM_PackParam(RF, InData%DWM) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackParam'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Title); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SIUnit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Echo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MultiTab); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinearizeFlag); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutputPlottingInfo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UseDWM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwoPiNB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumBl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NBlInpSt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ElemPrn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DStall); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PMoment); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Reynolds); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DynInfl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Wake); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Swirl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DtAero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnEc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnElem); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnWndOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MAXICOUNT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrOptFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DEFAULT_Wind); if (RegCheckErr(RF, RoutineName)) return
   call AD14_UnpackAirFoilParms(RF, OutData%AirFoil) ! AirFoil 
   call AD14_UnpackBladeParms(RF, OutData%Blade) ! Blade 
   call AD14_UnpackBeddoesParms(RF, OutData%Beddoes) ! Beddoes 
   call AD14_UnpackDynInflowParms(RF, OutData%DynInflow) ! DynInflow 
   call AD14_UnpackElementParms(RF, OutData%Element) ! Element 
   call AD14_UnpackTwrPropsParms(RF, OutData%TwrProps) ! TwrProps 
   call AD14_UnpackInducedVelParms(RF, OutData%InducedVel) ! InducedVel 
   call AD14_UnpackWindParms(RF, OutData%Wind) ! Wind 
   call AD14_UnpackRotorParms(RF, OutData%Rotor) ! Rotor 
   call DWM_UnpackParam(RF, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InputType), intent(inout) :: SrcInputData
   type(AD14_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInputData%InputMarkers)) then
      LB(1:1) = lbound(SrcInputData%InputMarkers, kind=B8Ki)
      UB(1:1) = ubound(SrcInputData%InputMarkers, kind=B8Ki)
      if (.not. allocated(DstInputData%InputMarkers)) then
         allocate(DstInputData%InputMarkers(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InputMarkers.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcInputData%InputMarkers(i1), DstInputData%InputMarkers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcInputData%Twr_InputMarkers, DstInputData%Twr_InputMarkers, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyAeroConfig(SrcInputData%TurbineComponents, DstInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInputData%MulTabLoc)) then
      LB(1:2) = lbound(SrcInputData%MulTabLoc, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%MulTabLoc, kind=B8Ki)
      if (.not. allocated(DstInputData%MulTabLoc)) then
         allocate(DstInputData%MulTabLoc(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MulTabLoc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%MulTabLoc = SrcInputData%MulTabLoc
   end if
   if (allocated(SrcInputData%InflowVelocity)) then
      LB(1:2) = lbound(SrcInputData%InflowVelocity, kind=B8Ki)
      UB(1:2) = ubound(SrcInputData%InflowVelocity, kind=B8Ki)
      if (.not. allocated(DstInputData%InflowVelocity)) then
         allocate(DstInputData%InflowVelocity(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowVelocity.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%InflowVelocity = SrcInputData%InflowVelocity
   end if
   DstInputData%AvgInfVel = SrcInputData%AvgInfVel
end subroutine

subroutine AD14_DestroyInput(InputData, ErrStat, ErrMsg)
   type(AD14_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%InputMarkers)) then
      LB(1:1) = lbound(InputData%InputMarkers, kind=B8Ki)
      UB(1:1) = ubound(InputData%InputMarkers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( InputData%InputMarkers(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InputData%InputMarkers)
   end if
   call MeshDestroy( InputData%Twr_InputMarkers, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD14_DestroyAeroConfig(InputData%TurbineComponents, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InputData%MulTabLoc)) then
      deallocate(InputData%MulTabLoc)
   end if
   if (allocated(InputData%InflowVelocity)) then
      deallocate(InputData%InflowVelocity)
   end if
end subroutine

subroutine AD14_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInput'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%InputMarkers))
   if (allocated(InData%InputMarkers)) then
      call RegPackBounds(RF, 1, lbound(InData%InputMarkers, kind=B8Ki), ubound(InData%InputMarkers, kind=B8Ki))
      LB(1:1) = lbound(InData%InputMarkers, kind=B8Ki)
      UB(1:1) = ubound(InData%InputMarkers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%InputMarkers(i1)) 
      end do
   end if
   call MeshPack(RF, InData%Twr_InputMarkers) 
   call AD14_PackAeroConfig(RF, InData%TurbineComponents) 
   call RegPackAlloc(RF, InData%MulTabLoc)
   call RegPackAlloc(RF, InData%InflowVelocity)
   call RegPack(RF, InData%AvgInfVel)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInput'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%InputMarkers)) deallocate(OutData%InputMarkers)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%InputMarkers(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputMarkers.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%InputMarkers(i1)) ! InputMarkers 
      end do
   end if
   call MeshUnpack(RF, OutData%Twr_InputMarkers) ! Twr_InputMarkers 
   call AD14_UnpackAeroConfig(RF, OutData%TurbineComponents) ! TurbineComponents 
   call RegUnpackAlloc(RF, OutData%MulTabLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%InflowVelocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AvgInfVel); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_OutputType), intent(inout) :: SrcOutputData
   type(AD14_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%OutputLoads)) then
      LB(1:1) = lbound(SrcOutputData%OutputLoads, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%OutputLoads, kind=B8Ki)
      if (.not. allocated(DstOutputData%OutputLoads)) then
         allocate(DstOutputData%OutputLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%OutputLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%OutputLoads(i1), DstOutputData%OutputLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcOutputData%Twr_OutputLoads, DstOutputData%Twr_OutputLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(AD14_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%OutputLoads)) then
      LB(1:1) = lbound(OutputData%OutputLoads, kind=B8Ki)
      UB(1:1) = ubound(OutputData%OutputLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%OutputLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%OutputLoads)
   end if
   call MeshDestroy( OutputData%Twr_OutputLoads, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD14_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AD14_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOutput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%OutputLoads))
   if (allocated(InData%OutputLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%OutputLoads, kind=B8Ki), ubound(InData%OutputLoads, kind=B8Ki))
      LB(1:1) = lbound(InData%OutputLoads, kind=B8Ki)
      UB(1:1) = ubound(InData%OutputLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%OutputLoads(i1)) 
      end do
   end if
   call MeshPack(RF, InData%Twr_OutputLoads) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine AD14_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AD14_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOutput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%OutputLoads)) deallocate(OutData%OutputLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OutputLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutputLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%OutputLoads(i1)) ! OutputLoads 
      end do
   end if
   call MeshUnpack(RF, OutData%Twr_OutputLoads) ! Twr_OutputLoads 
end subroutine

subroutine AD14_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
   ! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(AD14_InputType), intent(inout)  :: u(:) ! Input at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Inputs
   type(AD14_InputType), intent(inout)  :: u_out ! Input at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'AD14_Input_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(u)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(u)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(u) - 1
   select case (order)
   case (0)
      call AD14_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call AD14_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call AD14_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(u) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE AD14_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

   TYPE(AD14_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
   TYPE(AD14_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
   TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Input_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i11      ! dim1 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i02      ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i12      ! dim2 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   INTEGER                                    :: i2       ! dim2 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
      DO i1 = LBOUND(u_out%InputMarkers,1, kind=B8Ki),UBOUND(u_out%InputMarkers,1, kind=B8Ki)
         CALL MeshExtrapInterp1(u1%InputMarkers(i1), u2%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   CALL MeshExtrapInterp1(u1%Twr_InputMarkers, u2%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%Position = a1*u1%TurbineComponents%Blade(i11)%Position + a2*u2%TurbineComponents%Blade(i11)%Position
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%Orientation = a1*u1%TurbineComponents%Blade(i11)%Orientation + a2*u2%TurbineComponents%Blade(i11)%Orientation
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%TranslationVel = a1*u1%TurbineComponents%Blade(i11)%TranslationVel + a2*u2%TurbineComponents%Blade(i11)%TranslationVel
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%RotationVel = a1*u1%TurbineComponents%Blade(i11)%RotationVel + a2*u2%TurbineComponents%Blade(i11)%RotationVel
      END DO
   END IF ! check if allocated
   u_out%TurbineComponents%Hub%Position = a1*u1%TurbineComponents%Hub%Position + a2*u2%TurbineComponents%Hub%Position
   u_out%TurbineComponents%Hub%Orientation = a1*u1%TurbineComponents%Hub%Orientation + a2*u2%TurbineComponents%Hub%Orientation
   u_out%TurbineComponents%Hub%TranslationVel = a1*u1%TurbineComponents%Hub%TranslationVel + a2*u2%TurbineComponents%Hub%TranslationVel
   u_out%TurbineComponents%Hub%RotationVel = a1*u1%TurbineComponents%Hub%RotationVel + a2*u2%TurbineComponents%Hub%RotationVel
   u_out%TurbineComponents%RotorFurl%Position = a1*u1%TurbineComponents%RotorFurl%Position + a2*u2%TurbineComponents%RotorFurl%Position
   u_out%TurbineComponents%RotorFurl%Orientation = a1*u1%TurbineComponents%RotorFurl%Orientation + a2*u2%TurbineComponents%RotorFurl%Orientation
   u_out%TurbineComponents%RotorFurl%TranslationVel = a1*u1%TurbineComponents%RotorFurl%TranslationVel + a2*u2%TurbineComponents%RotorFurl%TranslationVel
   u_out%TurbineComponents%RotorFurl%RotationVel = a1*u1%TurbineComponents%RotorFurl%RotationVel + a2*u2%TurbineComponents%RotorFurl%RotationVel
   u_out%TurbineComponents%Nacelle%Position = a1*u1%TurbineComponents%Nacelle%Position + a2*u2%TurbineComponents%Nacelle%Position
   u_out%TurbineComponents%Nacelle%Orientation = a1*u1%TurbineComponents%Nacelle%Orientation + a2*u2%TurbineComponents%Nacelle%Orientation
   u_out%TurbineComponents%Nacelle%TranslationVel = a1*u1%TurbineComponents%Nacelle%TranslationVel + a2*u2%TurbineComponents%Nacelle%TranslationVel
   u_out%TurbineComponents%Nacelle%RotationVel = a1*u1%TurbineComponents%Nacelle%RotationVel + a2*u2%TurbineComponents%Nacelle%RotationVel
   u_out%TurbineComponents%TailFin%Position = a1*u1%TurbineComponents%TailFin%Position + a2*u2%TurbineComponents%TailFin%Position
   u_out%TurbineComponents%TailFin%Orientation = a1*u1%TurbineComponents%TailFin%Orientation + a2*u2%TurbineComponents%TailFin%Orientation
   u_out%TurbineComponents%TailFin%TranslationVel = a1*u1%TurbineComponents%TailFin%TranslationVel + a2*u2%TurbineComponents%TailFin%TranslationVel
   u_out%TurbineComponents%TailFin%RotationVel = a1*u1%TurbineComponents%TailFin%RotationVel + a2*u2%TurbineComponents%TailFin%RotationVel
   u_out%TurbineComponents%Tower%Position = a1*u1%TurbineComponents%Tower%Position + a2*u2%TurbineComponents%Tower%Position
   u_out%TurbineComponents%Tower%Orientation = a1*u1%TurbineComponents%Tower%Orientation + a2*u2%TurbineComponents%Tower%Orientation
   u_out%TurbineComponents%Tower%TranslationVel = a1*u1%TurbineComponents%Tower%TranslationVel + a2*u2%TurbineComponents%Tower%TranslationVel
   u_out%TurbineComponents%Tower%RotationVel = a1*u1%TurbineComponents%Tower%RotationVel + a2*u2%TurbineComponents%Tower%RotationVel
   u_out%TurbineComponents%SubStructure%Position = a1*u1%TurbineComponents%SubStructure%Position + a2*u2%TurbineComponents%SubStructure%Position
   u_out%TurbineComponents%SubStructure%Orientation = a1*u1%TurbineComponents%SubStructure%Orientation + a2*u2%TurbineComponents%SubStructure%Orientation
   u_out%TurbineComponents%SubStructure%TranslationVel = a1*u1%TurbineComponents%SubStructure%TranslationVel + a2*u2%TurbineComponents%SubStructure%TranslationVel
   u_out%TurbineComponents%SubStructure%RotationVel = a1*u1%TurbineComponents%SubStructure%RotationVel + a2*u2%TurbineComponents%SubStructure%RotationVel
   u_out%TurbineComponents%Foundation%Position = a1*u1%TurbineComponents%Foundation%Position + a2*u2%TurbineComponents%Foundation%Position
   u_out%TurbineComponents%Foundation%Orientation = a1*u1%TurbineComponents%Foundation%Orientation + a2*u2%TurbineComponents%Foundation%Orientation
   u_out%TurbineComponents%Foundation%TranslationVel = a1*u1%TurbineComponents%Foundation%TranslationVel + a2*u2%TurbineComponents%Foundation%TranslationVel
   u_out%TurbineComponents%Foundation%RotationVel = a1*u1%TurbineComponents%Foundation%RotationVel + a2*u2%TurbineComponents%Foundation%RotationVel
   u_out%TurbineComponents%BladeLength = a1*u1%TurbineComponents%BladeLength + a2*u2%TurbineComponents%BladeLength
   IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
      u_out%MulTabLoc = a1*u1%MulTabLoc + a2*u2%MulTabLoc
   END IF ! check if allocated
   IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
      u_out%InflowVelocity = a1*u1%InflowVelocity + a2*u2%InflowVelocity
   END IF ! check if allocated
   u_out%AvgInfVel = a1*u1%AvgInfVel + a2*u2%AvgInfVel
END SUBROUTINE

SUBROUTINE AD14_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

   TYPE(AD14_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
   TYPE(AD14_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
   TYPE(AD14_InputType), INTENT(INOUT)  :: u3      ! Input at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
   TYPE(AD14_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Input_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   INTEGER                                    :: i2    ! dim2 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
      DO i1 = LBOUND(u_out%InputMarkers,1, kind=B8Ki),UBOUND(u_out%InputMarkers,1, kind=B8Ki)
         CALL MeshExtrapInterp2(u1%InputMarkers(i1), u2%InputMarkers(i1), u3%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   CALL MeshExtrapInterp2(u1%Twr_InputMarkers, u2%Twr_InputMarkers, u3%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%Position = a1*u1%TurbineComponents%Blade(i11)%Position + a2*u2%TurbineComponents%Blade(i11)%Position + a3*u3%TurbineComponents%Blade(i11)%Position
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%Orientation = a1*u1%TurbineComponents%Blade(i11)%Orientation + a2*u2%TurbineComponents%Blade(i11)%Orientation + a3*u3%TurbineComponents%Blade(i11)%Orientation
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%TranslationVel = a1*u1%TurbineComponents%Blade(i11)%TranslationVel + a2*u2%TurbineComponents%Blade(i11)%TranslationVel + a3*u3%TurbineComponents%Blade(i11)%TranslationVel
      END DO
      DO i11 = LBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki),UBOUND(u_out%TurbineComponents%Blade,1, kind=B8Ki)
         u_out%TurbineComponents%Blade(i11)%RotationVel = a1*u1%TurbineComponents%Blade(i11)%RotationVel + a2*u2%TurbineComponents%Blade(i11)%RotationVel + a3*u3%TurbineComponents%Blade(i11)%RotationVel
      END DO
   END IF ! check if allocated
   u_out%TurbineComponents%Hub%Position = a1*u1%TurbineComponents%Hub%Position + a2*u2%TurbineComponents%Hub%Position + a3*u3%TurbineComponents%Hub%Position
   u_out%TurbineComponents%Hub%Orientation = a1*u1%TurbineComponents%Hub%Orientation + a2*u2%TurbineComponents%Hub%Orientation + a3*u3%TurbineComponents%Hub%Orientation
   u_out%TurbineComponents%Hub%TranslationVel = a1*u1%TurbineComponents%Hub%TranslationVel + a2*u2%TurbineComponents%Hub%TranslationVel + a3*u3%TurbineComponents%Hub%TranslationVel
   u_out%TurbineComponents%Hub%RotationVel = a1*u1%TurbineComponents%Hub%RotationVel + a2*u2%TurbineComponents%Hub%RotationVel + a3*u3%TurbineComponents%Hub%RotationVel
   u_out%TurbineComponents%RotorFurl%Position = a1*u1%TurbineComponents%RotorFurl%Position + a2*u2%TurbineComponents%RotorFurl%Position + a3*u3%TurbineComponents%RotorFurl%Position
   u_out%TurbineComponents%RotorFurl%Orientation = a1*u1%TurbineComponents%RotorFurl%Orientation + a2*u2%TurbineComponents%RotorFurl%Orientation + a3*u3%TurbineComponents%RotorFurl%Orientation
   u_out%TurbineComponents%RotorFurl%TranslationVel = a1*u1%TurbineComponents%RotorFurl%TranslationVel + a2*u2%TurbineComponents%RotorFurl%TranslationVel + a3*u3%TurbineComponents%RotorFurl%TranslationVel
   u_out%TurbineComponents%RotorFurl%RotationVel = a1*u1%TurbineComponents%RotorFurl%RotationVel + a2*u2%TurbineComponents%RotorFurl%RotationVel + a3*u3%TurbineComponents%RotorFurl%RotationVel
   u_out%TurbineComponents%Nacelle%Position = a1*u1%TurbineComponents%Nacelle%Position + a2*u2%TurbineComponents%Nacelle%Position + a3*u3%TurbineComponents%Nacelle%Position
   u_out%TurbineComponents%Nacelle%Orientation = a1*u1%TurbineComponents%Nacelle%Orientation + a2*u2%TurbineComponents%Nacelle%Orientation + a3*u3%TurbineComponents%Nacelle%Orientation
   u_out%TurbineComponents%Nacelle%TranslationVel = a1*u1%TurbineComponents%Nacelle%TranslationVel + a2*u2%TurbineComponents%Nacelle%TranslationVel + a3*u3%TurbineComponents%Nacelle%TranslationVel
   u_out%TurbineComponents%Nacelle%RotationVel = a1*u1%TurbineComponents%Nacelle%RotationVel + a2*u2%TurbineComponents%Nacelle%RotationVel + a3*u3%TurbineComponents%Nacelle%RotationVel
   u_out%TurbineComponents%TailFin%Position = a1*u1%TurbineComponents%TailFin%Position + a2*u2%TurbineComponents%TailFin%Position + a3*u3%TurbineComponents%TailFin%Position
   u_out%TurbineComponents%TailFin%Orientation = a1*u1%TurbineComponents%TailFin%Orientation + a2*u2%TurbineComponents%TailFin%Orientation + a3*u3%TurbineComponents%TailFin%Orientation
   u_out%TurbineComponents%TailFin%TranslationVel = a1*u1%TurbineComponents%TailFin%TranslationVel + a2*u2%TurbineComponents%TailFin%TranslationVel + a3*u3%TurbineComponents%TailFin%TranslationVel
   u_out%TurbineComponents%TailFin%RotationVel = a1*u1%TurbineComponents%TailFin%RotationVel + a2*u2%TurbineComponents%TailFin%RotationVel + a3*u3%TurbineComponents%TailFin%RotationVel
   u_out%TurbineComponents%Tower%Position = a1*u1%TurbineComponents%Tower%Position + a2*u2%TurbineComponents%Tower%Position + a3*u3%TurbineComponents%Tower%Position
   u_out%TurbineComponents%Tower%Orientation = a1*u1%TurbineComponents%Tower%Orientation + a2*u2%TurbineComponents%Tower%Orientation + a3*u3%TurbineComponents%Tower%Orientation
   u_out%TurbineComponents%Tower%TranslationVel = a1*u1%TurbineComponents%Tower%TranslationVel + a2*u2%TurbineComponents%Tower%TranslationVel + a3*u3%TurbineComponents%Tower%TranslationVel
   u_out%TurbineComponents%Tower%RotationVel = a1*u1%TurbineComponents%Tower%RotationVel + a2*u2%TurbineComponents%Tower%RotationVel + a3*u3%TurbineComponents%Tower%RotationVel
   u_out%TurbineComponents%SubStructure%Position = a1*u1%TurbineComponents%SubStructure%Position + a2*u2%TurbineComponents%SubStructure%Position + a3*u3%TurbineComponents%SubStructure%Position
   u_out%TurbineComponents%SubStructure%Orientation = a1*u1%TurbineComponents%SubStructure%Orientation + a2*u2%TurbineComponents%SubStructure%Orientation + a3*u3%TurbineComponents%SubStructure%Orientation
   u_out%TurbineComponents%SubStructure%TranslationVel = a1*u1%TurbineComponents%SubStructure%TranslationVel + a2*u2%TurbineComponents%SubStructure%TranslationVel + a3*u3%TurbineComponents%SubStructure%TranslationVel
   u_out%TurbineComponents%SubStructure%RotationVel = a1*u1%TurbineComponents%SubStructure%RotationVel + a2*u2%TurbineComponents%SubStructure%RotationVel + a3*u3%TurbineComponents%SubStructure%RotationVel
   u_out%TurbineComponents%Foundation%Position = a1*u1%TurbineComponents%Foundation%Position + a2*u2%TurbineComponents%Foundation%Position + a3*u3%TurbineComponents%Foundation%Position
   u_out%TurbineComponents%Foundation%Orientation = a1*u1%TurbineComponents%Foundation%Orientation + a2*u2%TurbineComponents%Foundation%Orientation + a3*u3%TurbineComponents%Foundation%Orientation
   u_out%TurbineComponents%Foundation%TranslationVel = a1*u1%TurbineComponents%Foundation%TranslationVel + a2*u2%TurbineComponents%Foundation%TranslationVel + a3*u3%TurbineComponents%Foundation%TranslationVel
   u_out%TurbineComponents%Foundation%RotationVel = a1*u1%TurbineComponents%Foundation%RotationVel + a2*u2%TurbineComponents%Foundation%RotationVel + a3*u3%TurbineComponents%Foundation%RotationVel
   u_out%TurbineComponents%BladeLength = a1*u1%TurbineComponents%BladeLength + a2*u2%TurbineComponents%BladeLength + a3*u3%TurbineComponents%BladeLength
   IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
      u_out%MulTabLoc = a1*u1%MulTabLoc + a2*u2%MulTabLoc + a3*u3%MulTabLoc
   END IF ! check if allocated
   IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
      u_out%InflowVelocity = a1*u1%InflowVelocity + a2*u2%InflowVelocity + a3*u3%InflowVelocity
   END IF ! check if allocated
   u_out%AvgInfVel = a1*u1%AvgInfVel + a2*u2%AvgInfVel + a3*u3%AvgInfVel
END SUBROUTINE

subroutine AD14_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
   ! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(AD14_OutputType), intent(inout)  :: y(:) ! Output at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Outputs
   type(AD14_OutputType), intent(inout)  :: y_out ! Output at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'AD14_Output_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(y)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(y)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(y) - 1
   select case (order)
   case (0)
      call AD14_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call AD14_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call AD14_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(y) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE AD14_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

   TYPE(AD14_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
   TYPE(AD14_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
   TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Output_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
      DO i1 = LBOUND(y_out%OutputLoads,1, kind=B8Ki),UBOUND(y_out%OutputLoads,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%OutputLoads(i1), y2%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   CALL MeshExtrapInterp1(y1%Twr_OutputLoads, y2%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE

SUBROUTINE AD14_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

   TYPE(AD14_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
   TYPE(AD14_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
   TYPE(AD14_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
   TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Output_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
      DO i1 = LBOUND(y_out%OutputLoads,1, kind=B8Ki),UBOUND(y_out%OutputLoads,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%OutputLoads(i1), y2%OutputLoads(i1), y3%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   CALL MeshExtrapInterp2(y1%Twr_OutputLoads, y2%Twr_OutputLoads, y3%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
END SUBROUTINE

function AD14_InputMeshPointer(u, ML) result(Mesh)
   type(AD14_InputType), target, intent(in) :: u
   type(MeshLocType), intent(in)      :: ML
   type(MeshType), pointer            :: Mesh
   nullify(Mesh)
   select case (ML%Num)
   case (AD14_u_InputMarkers)
       Mesh => u%InputMarkers(ML%i1)
   case (AD14_u_Twr_InputMarkers)
       Mesh => u%Twr_InputMarkers
   end select
end function

function AD14_InputMeshName(ML) result(Name)
   type(MeshLocType), intent(in)      :: ML
   character(32)                      :: Name
   Name = ""
   select case (ML%Num)
   case (AD14_u_InputMarkers)
       Name = "u%InputMarkers("//trim(Num2LStr(ML%i1))//")"
   case (AD14_u_Twr_InputMarkers)
       Name = "u%Twr_InputMarkers"
   end select
end function

function AD14_OutputMeshPointer(y, ML) result(Mesh)
   type(AD14_OutputType), target, intent(in) :: y
   type(MeshLocType), intent(in)      :: ML
   type(MeshType), pointer            :: Mesh
   nullify(Mesh)
   select case (ML%Num)
   case (AD14_y_OutputLoads)
       Mesh => y%OutputLoads(ML%i1)
   case (AD14_y_Twr_OutputLoads)
       Mesh => y%Twr_OutputLoads
   end select
end function

function AD14_OutputMeshName(ML) result(Name)
   type(MeshLocType), intent(in)      :: ML
   character(32)                      :: Name
   Name = ""
   select case (ML%Num)
   case (AD14_y_OutputLoads)
       Name = "y%OutputLoads("//trim(Num2LStr(ML%i1))//")"
   case (AD14_y_Twr_OutputLoads)
       Name = "y%Twr_OutputLoads"
   end select
end function
END MODULE AeroDyn14_Types
!ENDOFREGISTRYGENERATEDFILE
