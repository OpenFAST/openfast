!STARTOFREGISTRYGENERATEDFILE 'AeroDyn14_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn14_Types
!.................................................................................................................................
! This file is part of AeroDyn14.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn14. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn14_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE IfW_UniformWind_Types
USE IfW_TSFFWind_Types
USE IfW_BladedFFWind_Types
USE IfW_HAWCWind_Types
USE IfW_UserWind_Types
USE IfW_4Dext_Types
USE Lidar_Types
USE InflowWind_Types
USE DWM_Types
USE NWTC_Library
IMPLICIT NONE
! =========  Marker  =======
  TYPE, PUBLIC :: Marker
    REAL(ReKi) , DIMENSION(1:3)  :: Position 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orientation 
    REAL(ReKi) , DIMENSION(1:3)  :: TranslationVel 
    REAL(ReKi) , DIMENSION(1:3)  :: RotationVel 
  END TYPE Marker
! =======================
! =========  AeroConfig  =======
  TYPE, PUBLIC :: AeroConfig
    TYPE(Marker) , DIMENSION(:), ALLOCATABLE  :: Blade 
    TYPE(Marker)  :: Hub 
    TYPE(Marker)  :: RotorFurl 
    TYPE(Marker)  :: Nacelle 
    TYPE(Marker)  :: TailFin 
    TYPE(Marker)  :: Tower 
    TYPE(Marker)  :: SubStructure 
    TYPE(Marker)  :: Foundation 
    REAL(ReKi)  :: BladeLength 
  END TYPE AeroConfig
! =======================
! =========  AirFoil  =======
  TYPE, PUBLIC :: AirFoil
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CD 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CM 
    REAL(ReKi)  :: PMC 
    REAL(ReKi)  :: MulTabLoc 
  END TYPE AirFoil
! =======================
! =========  AirFoilParms  =======
  TYPE, PUBLIC :: AirFoilParms
    INTEGER(IntKi)  :: MaxTable = 20 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTables 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NLift 
    INTEGER(IntKi)  :: NumCL 
    INTEGER(IntKi)  :: NumFoil 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NFoil 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabMet 
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: FoilNm 
  END TYPE AirFoilParms
! =======================
! =========  Beddoes  =======
  TYPE, PUBLIC :: Beddoes
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE1 
    REAL(ReKi)  :: AN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOL 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: BEDSEP 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: OLDSEP 
    REAL(ReKi)  :: CC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CDO 
    REAL(ReKi)  :: CMI 
    REAL(ReKi)  :: CMQ 
    REAL(ReKi)  :: CN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNA 
    REAL(ReKi)  :: CNCP 
    REAL(ReKi)  :: CNIQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP1 
    REAL(ReKi)  :: DS 
    REAL(ReKi)  :: FK 
    REAL(ReKi)  :: FP 
    REAL(ReKi)  :: FPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC1 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTB 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTBC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDCNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDTAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDXN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDYN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: YN 
    LOGICAL  :: SHIFT 
    LOGICAL  :: VOR 
  END TYPE Beddoes
! =======================
! =========  BeddoesParms  =======
  TYPE, PUBLIC :: BeddoesParms
    REAL(ReKi)  :: AS      !< Speed of sound for mach num calc [-]
    REAL(ReKi)  :: TF      !< Time constant applied to loc of separation pt [-]
    REAL(ReKi)  :: TP      !< Time constant for pressure lag [-]
    REAL(ReKi)  :: TV      !< Time constant for strength and shed of vortex [-]
    REAL(ReKi)  :: TVL      !< Nondim time of transit of vort moving across airfoil surf [-]
  END TYPE BeddoesParms
! =======================
! =========  BladeParms  =======
  TYPE, PUBLIC :: BladeParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: C      !< Chord of each blade element from input file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DR      !< Span-wise width of elem (len of elem ctred at RELM(i) [-]
    REAL(ReKi)  :: R      !< Rotor radius [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
  END TYPE BladeParms
! =======================
! =========  DynInflow  =======
  TYPE, PUBLIC :: DynInflow
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: dAlph_dt 
    REAL(ReKi) , DIMENSION(3:6,1:4)  :: dBeta_dt 
    REAL(ReKi)  :: DTO 
    REAL(ReKi) , DIMENSION(1:6)  :: old_Alph 
    REAL(ReKi) , DIMENSION(3:6)  :: old_Beta 
    REAL(ReKi)  :: old_LmdM 
    REAL(ReKi)  :: oldKai 
    REAL(ReKi) , DIMENSION(1:6)  :: PhiLqC 
    REAL(ReKi) , DIMENSION(3:6)  :: PhiLqS 
    REAL(ReKi)  :: Pzero 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMC_SAVE 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMS_SAVE 
    REAL(ReKi)  :: TipSpeed 
    REAL(ReKi)  :: totalInf 
    REAL(ReKi)  :: Vparam 
    REAL(ReKi)  :: Vtotal 
    REAL(ReKi) , DIMENSION(1:6)  :: xAlpha 
    REAL(ReKi) , DIMENSION(3:6)  :: xBeta 
    REAL(ReKi)  :: xKai 
    REAL(ReKi)  :: XLAMBDA_M 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: xLcos 
    REAL(ReKi) , DIMENSION(3:6,3:6)  :: xLsin 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminusR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MplusR 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: GAMMA 
  END TYPE DynInflow
! =======================
! =========  DynInflowParms  =======
  TYPE, PUBLIC :: DynInflowParms
    INTEGER(IntKi)  :: MAXINFLO = 2 
    REAL(ReKi) , DIMENSION(1:6)  :: xMinv 
  END TYPE DynInflowParms
! =======================
! =========  Element  =======
  TYPE, PUBLIC :: Element
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ALPHA 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W2 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_A_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_AP_NS 
    REAL(ReKi)  :: PITNOW 
  END TYPE Element
! =======================
! =========  ElementParms  =======
  TYPE, PUBLIC :: ElementParms
    INTEGER(IntKi)  :: NELM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TWIST 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RELM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HLCNST 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TLCNST 
  END TYPE ElementParms
! =======================
! =========  ElOutParms  =======
  TYPE, PUBLIC :: ElOutParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ALF 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CDD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CLL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CNN 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CTT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFNSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFTSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DynPres 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PITSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ReyNum 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVZ 
    REAL(ReKi)  :: VXSAV 
    REAL(ReKi)  :: VYSAV 
    REAL(ReKi)  :: VZSAV 
    INTEGER(IntKi)  :: NumWndElOut      !< Number of Blade Elements [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrNum 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    INTEGER(IntKi)  :: NumElOut      !< Number of Blade Elements [-]
  END TYPE ElOutParms
! =======================
! =========  InducedVel  =======
  TYPE, PUBLIC :: InducedVel
    REAL(ReKi)  :: SumInFl = 0 
  END TYPE InducedVel
! =======================
! =========  InducedVelParms  =======
  TYPE, PUBLIC :: InducedVelParms
    REAL(ReKi)  :: AToler      !< Convergence tolerance for induction factor [-]
    REAL(ReKi)  :: EqAIDmult      !< Multiplier for drag term in axial-induction equation. [-]
    LOGICAL  :: EquilDA      !< False unless DB or DA appended to EQUIL [-]
    LOGICAL  :: EquilDT      !< False unless DB or DT appended to EQUIL [-]
    LOGICAL  :: TLoss      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: GTech      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: HLoss      !< Hub-loss model (EQUIL only) [PRANDtl or NONE] [-]
  END TYPE InducedVelParms
! =======================
! =========  Rotor  =======
  TYPE, PUBLIC :: Rotor
    REAL(ReKi)  :: AVGINFL      !< average induced velocity at the previous time [-]
    REAL(ReKi)  :: CTILT 
    REAL(ReKi)  :: CYaw 
    REAL(ReKi)  :: REVS 
    REAL(ReKi)  :: STILT 
    REAL(ReKi)  :: SYaw 
    REAL(ReKi)  :: TILT 
    REAL(ReKi)  :: YawAng 
    REAL(ReKi)  :: YawVEL 
  END TYPE Rotor
! =======================
! =========  RotorParms  =======
  TYPE, PUBLIC :: RotorParms
    REAL(ReKi)  :: HH 
  END TYPE RotorParms
! =======================
! =========  TwrPropsParms  =======
  TYPE, PUBLIC :: TwrPropsParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrHtFr 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrWid 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRe 
    REAL(ReKi) , DIMENSION(1:3)  :: VTwr 
    REAL(ReKi)  :: Tower_Wake_Constant 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTwrCDCol      !< The tower CD column that represents a particular twr ht [-]
    INTEGER(IntKi)  :: NTwrHT      !< The number of tower height rows in the table [-]
    INTEGER(IntKi)  :: NTwrRe      !< The number of tower Re entry rows in the table [-]
    INTEGER(IntKi)  :: NTwrCD      !< The number of tower CD columns in the table [-]
    LOGICAL  :: TwrPotent      !< Tower influence model [-]
    LOGICAL  :: TwrShadow      !< Tower shadow model [-]
    REAL(ReKi)  :: ShadHWid      !< Tower-shadow half width [m]
    REAL(ReKi)  :: TShadC1      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TShadC2      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TwrShad      !< Tower-shadow velocity deficit [-]
    LOGICAL  :: PJM_Version      !< Only true if new tower influence model, by PJM [-]
    CHARACTER(1024)  :: TwrFile      !< Tower data file name [-]
    REAL(ReKi)  :: T_Shad_Refpt      !< Tower-shadow reference point [m]
    LOGICAL  :: CalcTwrAero      !< Flag to tell AeroDyn to calculate drag on the tower [m]
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrNodeWidth      !< The width (diameter) of the tower at the ElastoDyn node locations. [-]
  END TYPE TwrPropsParms
! =======================
! =========  Wind  =======
  TYPE, PUBLIC :: Wind
    REAL(ReKi)  :: ANGFLW 
    REAL(ReKi)  :: CDEL 
    REAL(ReKi)  :: VROTORX 
    REAL(ReKi)  :: VROTORY 
    REAL(ReKi)  :: VROTORZ 
    REAL(ReKi)  :: SDEL 
  END TYPE Wind
! =======================
! =========  WindParms  =======
  TYPE, PUBLIC :: WindParms
    REAL(ReKi)  :: Rho      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [(m^2/sec)]
  END TYPE WindParms
! =======================
! =========  PositionType  =======
  TYPE, PUBLIC :: PositionType
    REAL(ReKi) , DIMENSION(1:3)  :: Pos      !< X,Y,Z coordinate of a point [-]
  END TYPE PositionType
! =======================
! =========  OrientationType  =======
  TYPE, PUBLIC :: OrientationType
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orient      !< Direction Cosine Matrix [-]
  END TYPE OrientationType
! =======================
! =========  AD14_InitInputType  =======
  TYPE, PUBLIC :: AD14_InitInputType
    CHARACTER(1024)  :: Title      !< Title [-]
    CHARACTER(1024)  :: OutRootName 
    CHARACTER(1024)  :: ADFileName      !< AeroDyn file name [-]
    LOGICAL  :: WrSumFile      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    TYPE(AeroConfig)  :: TurbineComponents 
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrNodeLocs      !< Location of ElastoDyn tower nodes with respect to the inertial origin. [-]
    REAL(ReKi)  :: HubHt      !< hub height wrt inertial origin [m]
    TYPE(DWM_InitInputType)  :: DWM 
  END TYPE AD14_InitInputType
! =======================
! =========  AD14_InitOutputType  =======
  TYPE, PUBLIC :: AD14_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< version information [-]
    TYPE(DWM_InitOutputType)  :: DWM 
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
  END TYPE AD14_InitOutputType
! =======================
! =========  AD14_ContinuousStateType  =======
  TYPE, PUBLIC :: AD14_ContinuousStateType
    TYPE(DWM_ContinuousStateType)  :: DWM 
  END TYPE AD14_ContinuousStateType
! =======================
! =========  AD14_DiscreteStateType  =======
  TYPE, PUBLIC :: AD14_DiscreteStateType
    TYPE(DWM_DiscreteStateType)  :: DWM 
  END TYPE AD14_DiscreteStateType
! =======================
! =========  AD14_ConstraintStateType  =======
  TYPE, PUBLIC :: AD14_ConstraintStateType
    TYPE(DWM_ConstraintStateType)  :: DWM 
  END TYPE AD14_ConstraintStateType
! =======================
! =========  AD14_OtherStateType  =======
  TYPE, PUBLIC :: AD14_OtherStateType
    TYPE(DWM_OtherStateType)  :: DWM      !< variables for DWM module [-]
  END TYPE AD14_OtherStateType
! =======================
! =========  AD14_MiscVarType  =======
  TYPE, PUBLIC :: AD14_MiscVarType
    TYPE(DWM_MiscVarType)  :: DWM      !< variables for DWM module [-]
    TYPE(DWM_InputType)  :: DWM_Inputs 
    TYPE(DWM_OutputType)  :: DWM_Outputs 
    REAL(DbKi)  :: DT      !< actual Time step [seconds]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    REAL(DbKi)  :: OldTime 
    REAL(ReKi)  :: HubLoss = 1 
    REAL(ReKi)  :: Loss = 1 
    REAL(ReKi)  :: TipLoss = 1 
    REAL(ReKi)  :: TLpt7 
    LOGICAL  :: FirstPassGTL = .TRUE. 
    LOGICAL  :: SuperSonic = .FALSE. 
    LOGICAL  :: AFLAGVinderr = .FALSE. 
    LOGICAL  :: AFLAGTwrInflu = .FALSE. 
    LOGICAL  :: OnePassDynDbg = .TRUE. 
    LOGICAL  :: NoLoadsCalculated = .TRUE. 
    INTEGER(IntKi)  :: NERRORS = 0 
    TYPE(AirFoil)  :: AirFoil 
    TYPE(Beddoes)  :: Beddoes 
    TYPE(DynInflow)  :: DynInflow 
    TYPE(Element)  :: Element 
    TYPE(Rotor)  :: Rotor 
    TYPE(Wind)  :: Wind 
    TYPE(InducedVel)  :: InducedVel 
    TYPE(ElOutParms)  :: ElOut 
    LOGICAL  :: Skew 
    LOGICAL  :: DynInit      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: FirstWarn      !< If it's the first warning about AeroDyn not recalculating loads [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredForces 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredMoments 
  END TYPE AD14_MiscVarType
! =======================
! =========  AD14_ParameterType  =======
  TYPE, PUBLIC :: AD14_ParameterType
    CHARACTER(1024)  :: Title      !< Title [-]
    LOGICAL  :: SIUnit 
    LOGICAL  :: Echo = .FALSE. 
    LOGICAL  :: MultiTab 
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: OutputPlottingInfo = .FALSE. 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    REAL(ReKi)  :: TwoPiNB      !< 2*pi/num of blades [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    INTEGER(IntKi)  :: NBlInpSt      !< Number of Blade Input Stations [-]
    LOGICAL  :: ElemPrn 
    LOGICAL  :: DStall      !< FALSE=Steady, TRUE=BEDDOES [-]
    LOGICAL  :: PMoment      !< FALSE=NO_CM, TRUE=USE_CM [-]
    LOGICAL  :: Reynolds 
    LOGICAL  :: DynInfl      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: Wake      !< False unless WAKE or SWIRL [-]
    LOGICAL  :: Swirl      !< False unless WAKE or SWIRL [-]
    REAL(DbKi)  :: DtAero      !< Time interval for aerodynamic calculations [-]
    REAL(ReKi)  :: HubRad      !< Hub radius [m]
    INTEGER(IntKi)  :: UnEc = -1 
    INTEGER(IntKi)  :: UnElem = -1 
    INTEGER(IntKi)  :: UnWndOut = -1 
    INTEGER(IntKi)  :: MAXICOUNT = 1000 
    LOGICAL  :: WrOptFile = .TRUE.      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: DEFAULT_Wind = -1 
    TYPE(AirFoilParms)  :: AirFoil 
    TYPE(BladeParms)  :: Blade 
    TYPE(BeddoesParms)  :: Beddoes 
    TYPE(DynInflowParms)  :: DynInflow 
    TYPE(ElementParms)  :: Element 
    TYPE(TwrPropsParms)  :: TwrProps 
    TYPE(InducedVelParms)  :: InducedVel 
    TYPE(WindParms)  :: Wind 
    TYPE(RotorParms)  :: Rotor 
    TYPE(DWM_ParameterType)  :: DWM 
  END TYPE AD14_ParameterType
! =======================
! =========  AD14_InputType  =======
  TYPE, PUBLIC :: AD14_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: InputMarkers      !< Input Forces and positions for the blades (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_InputMarkers      !< Input Forces and positions for the tower (mesh) [-]
    TYPE(AeroConfig)  :: TurbineComponents      !< Current locations of components [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabLoc 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowVelocity      !< U,V,W wind inflow speeds at all locations on the Inputmarker and Twr_InputMarker meshes [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgInfVel      !< an average disk velocity (depends on wind type and should be removed) [m/s]
  END TYPE AD14_InputType
! =======================
! =========  AD14_OutputType  =======
  TYPE, PUBLIC :: AD14_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: OutputLoads      !< Output Loads (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_OutputLoads      !< Tower Output Loads (mesh) [-]
  END TYPE AD14_OutputType
! =======================
CONTAINS
 SUBROUTINE AD14_CopyMarker( SrcMarkerData, DstMarkerData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Marker), INTENT(IN) :: SrcMarkerData
   TYPE(Marker), INTENT(INOUT) :: DstMarkerData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyMarker'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMarkerData%Position = SrcMarkerData%Position
    DstMarkerData%Orientation = SrcMarkerData%Orientation
    DstMarkerData%TranslationVel = SrcMarkerData%TranslationVel
    DstMarkerData%RotationVel = SrcMarkerData%RotationVel
 END SUBROUTINE AD14_CopyMarker

 SUBROUTINE AD14_DestroyMarker( MarkerData, ErrStat, ErrMsg )
  TYPE(Marker), INTENT(INOUT) :: MarkerData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyMarker'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyMarker

 SUBROUTINE AD14_PackMarker( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Marker),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackMarker'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + SIZE(InData%Position)  ! Position
      Re_BufSz   = Re_BufSz   + SIZE(InData%Orientation)  ! Orientation
      Re_BufSz   = Re_BufSz   + SIZE(InData%TranslationVel)  ! TranslationVel
      Re_BufSz   = Re_BufSz   + SIZE(InData%RotationVel)  ! RotationVel
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Position))-1 ) = PACK(InData%Position,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Position)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Orientation))-1 ) = PACK(InData%Orientation,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Orientation)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TranslationVel))-1 ) = PACK(InData%TranslationVel,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TranslationVel)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RotationVel))-1 ) = PACK(InData%RotationVel,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%RotationVel)
 END SUBROUTINE AD14_PackMarker

 SUBROUTINE AD14_UnPackMarker( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Marker), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackMarker'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    i1_l = LBOUND(OutData%Position,1)
    i1_u = UBOUND(OutData%Position,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%Position = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Position))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Position)
    DEALLOCATE(mask1)
    i1_l = LBOUND(OutData%Orientation,1)
    i1_u = UBOUND(OutData%Orientation,1)
    i2_l = LBOUND(OutData%Orientation,2)
    i2_u = UBOUND(OutData%Orientation,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%Orientation = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Orientation))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Orientation)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%TranslationVel,1)
    i1_u = UBOUND(OutData%TranslationVel,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%TranslationVel = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TranslationVel))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TranslationVel)
    DEALLOCATE(mask1)
    i1_l = LBOUND(OutData%RotationVel,1)
    i1_u = UBOUND(OutData%RotationVel,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%RotationVel = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RotationVel))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%RotationVel)
    DEALLOCATE(mask1)
 END SUBROUTINE AD14_UnPackMarker

 SUBROUTINE AD14_CopyAeroConfig( SrcAeroConfigData, DstAeroConfigData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AeroConfig), INTENT(IN) :: SrcAeroConfigData
   TYPE(AeroConfig), INTENT(INOUT) :: DstAeroConfigData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAeroConfig'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcAeroConfigData%Blade)) THEN
  i1_l = LBOUND(SrcAeroConfigData%Blade,1)
  i1_u = UBOUND(SrcAeroConfigData%Blade,1)
  IF (.NOT. ALLOCATED(DstAeroConfigData%Blade)) THEN 
    ALLOCATE(DstAeroConfigData%Blade(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroConfigData%Blade.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcAeroConfigData%Blade,1), UBOUND(SrcAeroConfigData%Blade,1)
      CALL AD14_Copymarker( SrcAeroConfigData%Blade(i1), DstAeroConfigData%Blade(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL AD14_Copymarker( SrcAeroConfigData%Hub, DstAeroConfigData%Hub, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%RotorFurl, DstAeroConfigData%RotorFurl, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Nacelle, DstAeroConfigData%Nacelle, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%TailFin, DstAeroConfigData%TailFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Tower, DstAeroConfigData%Tower, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%SubStructure, DstAeroConfigData%SubStructure, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Foundation, DstAeroConfigData%Foundation, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstAeroConfigData%BladeLength = SrcAeroConfigData%BladeLength
 END SUBROUTINE AD14_CopyAeroConfig

 SUBROUTINE AD14_DestroyAeroConfig( AeroConfigData, ErrStat, ErrMsg )
  TYPE(AeroConfig), INTENT(INOUT) :: AeroConfigData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAeroConfig'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(AeroConfigData%Blade)) THEN
DO i1 = LBOUND(AeroConfigData%Blade,1), UBOUND(AeroConfigData%Blade,1)
  CALL AD14_Destroymarker( AeroConfigData%Blade(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(AeroConfigData%Blade)
ENDIF
  CALL AD14_Destroymarker( AeroConfigData%Hub, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%RotorFurl, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%Nacelle, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%TailFin, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%Tower, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%SubStructure, ErrStat, ErrMsg )
  CALL AD14_Destroymarker( AeroConfigData%Foundation, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyAeroConfig

 SUBROUTINE AD14_PackAeroConfig( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AeroConfig),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackAeroConfig'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Blade allocated yes/no
  IF ( ALLOCATED(InData%Blade) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Blade upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%Blade,1), UBOUND(InData%Blade,1)
      Int_BufSz   = Int_BufSz + 3  ! Blade: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Blade(i1), ErrStat2, ErrMsg2, .TRUE. ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Blade
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Blade
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Blade
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! Hub: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Hub, ErrStat2, ErrMsg2, .TRUE. ) ! Hub 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Hub
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Hub
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Hub
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! RotorFurl: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%RotorFurl, ErrStat2, ErrMsg2, .TRUE. ) ! RotorFurl 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! RotorFurl
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! RotorFurl
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! RotorFurl
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Nacelle: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Nacelle, ErrStat2, ErrMsg2, .TRUE. ) ! Nacelle 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Nacelle
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Nacelle
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Nacelle
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! TailFin: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%TailFin, ErrStat2, ErrMsg2, .TRUE. ) ! TailFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TailFin
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TailFin
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TailFin
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Tower: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Tower, ErrStat2, ErrMsg2, .TRUE. ) ! Tower 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Tower
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Tower
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Tower
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! SubStructure: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%SubStructure, ErrStat2, ErrMsg2, .TRUE. ) ! SubStructure 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! SubStructure
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! SubStructure
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! SubStructure
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Foundation: size of buffers for each call to pack subtype
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Foundation, ErrStat2, ErrMsg2, .TRUE. ) ! Foundation 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Foundation
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Foundation
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Foundation
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Re_BufSz   = Re_BufSz   + 1  ! BladeLength
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Blade) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Blade,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Blade,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%Blade,1), UBOUND(InData%Blade,1)
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Blade(i1), ErrStat2, ErrMsg2, OnlySize ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Hub, ErrStat2, ErrMsg2, OnlySize ) ! Hub 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%RotorFurl, ErrStat2, ErrMsg2, OnlySize ) ! RotorFurl 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Nacelle, ErrStat2, ErrMsg2, OnlySize ) ! Nacelle 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%TailFin, ErrStat2, ErrMsg2, OnlySize ) ! TailFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Tower, ErrStat2, ErrMsg2, OnlySize ) ! Tower 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%SubStructure, ErrStat2, ErrMsg2, OnlySize ) ! SubStructure 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packmarker( Re_Buf, Db_Buf, Int_Buf, InData%Foundation, ErrStat2, ErrMsg2, OnlySize ) ! Foundation 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%BladeLength
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackAeroConfig

 SUBROUTINE AD14_UnPackAeroConfig( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AeroConfig), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackAeroConfig'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Blade not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Blade)) DEALLOCATE(OutData%Blade)
    ALLOCATE(OutData%Blade(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Blade.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%Blade,1), UBOUND(OutData%Blade,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%Blade(i1), ErrStat2, ErrMsg2 ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%Hub, ErrStat2, ErrMsg2 ) ! Hub 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%RotorFurl, ErrStat2, ErrMsg2 ) ! RotorFurl 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%Nacelle, ErrStat2, ErrMsg2 ) ! Nacelle 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%TailFin, ErrStat2, ErrMsg2 ) ! TailFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%Tower, ErrStat2, ErrMsg2 ) ! Tower 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%SubStructure, ErrStat2, ErrMsg2 ) ! SubStructure 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackmarker( Re_Buf, Db_Buf, Int_Buf, OutData%Foundation, ErrStat2, ErrMsg2 ) ! Foundation 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      OutData%BladeLength = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackAeroConfig

 SUBROUTINE AD14_CopyAirFoil( SrcAirFoilData, DstAirFoilData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AirFoil), INTENT(IN) :: SrcAirFoilData
   TYPE(AirFoil), INTENT(INOUT) :: DstAirFoilData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAirFoil'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcAirFoilData%AL)) THEN
  i1_l = LBOUND(SrcAirFoilData%AL,1)
  i1_u = UBOUND(SrcAirFoilData%AL,1)
  i2_l = LBOUND(SrcAirFoilData%AL,2)
  i2_u = UBOUND(SrcAirFoilData%AL,2)
  IF (.NOT. ALLOCATED(DstAirFoilData%AL)) THEN 
    ALLOCATE(DstAirFoilData%AL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%AL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%AL = SrcAirFoilData%AL
ENDIF
IF (ALLOCATED(SrcAirFoilData%CD)) THEN
  i1_l = LBOUND(SrcAirFoilData%CD,1)
  i1_u = UBOUND(SrcAirFoilData%CD,1)
  i2_l = LBOUND(SrcAirFoilData%CD,2)
  i2_u = UBOUND(SrcAirFoilData%CD,2)
  i3_l = LBOUND(SrcAirFoilData%CD,3)
  i3_u = UBOUND(SrcAirFoilData%CD,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CD)) THEN 
    ALLOCATE(DstAirFoilData%CD(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CD = SrcAirFoilData%CD
ENDIF
IF (ALLOCATED(SrcAirFoilData%CL)) THEN
  i1_l = LBOUND(SrcAirFoilData%CL,1)
  i1_u = UBOUND(SrcAirFoilData%CL,1)
  i2_l = LBOUND(SrcAirFoilData%CL,2)
  i2_u = UBOUND(SrcAirFoilData%CL,2)
  i3_l = LBOUND(SrcAirFoilData%CL,3)
  i3_u = UBOUND(SrcAirFoilData%CL,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CL)) THEN 
    ALLOCATE(DstAirFoilData%CL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CL = SrcAirFoilData%CL
ENDIF
IF (ALLOCATED(SrcAirFoilData%CM)) THEN
  i1_l = LBOUND(SrcAirFoilData%CM,1)
  i1_u = UBOUND(SrcAirFoilData%CM,1)
  i2_l = LBOUND(SrcAirFoilData%CM,2)
  i2_u = UBOUND(SrcAirFoilData%CM,2)
  i3_l = LBOUND(SrcAirFoilData%CM,3)
  i3_u = UBOUND(SrcAirFoilData%CM,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CM)) THEN 
    ALLOCATE(DstAirFoilData%CM(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CM = SrcAirFoilData%CM
ENDIF
    DstAirFoilData%PMC = SrcAirFoilData%PMC
    DstAirFoilData%MulTabLoc = SrcAirFoilData%MulTabLoc
 END SUBROUTINE AD14_CopyAirFoil

 SUBROUTINE AD14_DestroyAirFoil( AirFoilData, ErrStat, ErrMsg )
  TYPE(AirFoil), INTENT(INOUT) :: AirFoilData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAirFoil'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(AirFoilData%AL)) THEN
  DEALLOCATE(AirFoilData%AL)
ENDIF
IF (ALLOCATED(AirFoilData%CD)) THEN
  DEALLOCATE(AirFoilData%CD)
ENDIF
IF (ALLOCATED(AirFoilData%CL)) THEN
  DEALLOCATE(AirFoilData%CL)
ENDIF
IF (ALLOCATED(AirFoilData%CM)) THEN
  DEALLOCATE(AirFoilData%CM)
ENDIF
 END SUBROUTINE AD14_DestroyAirFoil

 SUBROUTINE AD14_PackAirFoil( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AirFoil),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackAirFoil'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! AL allocated yes/no
  IF ( ALLOCATED(InData%AL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AL)  ! AL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CD allocated yes/no
  IF ( ALLOCATED(InData%CD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! CD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CD)  ! CD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CL allocated yes/no
  IF ( ALLOCATED(InData%CL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! CL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CL)  ! CL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CM allocated yes/no
  IF ( ALLOCATED(InData%CM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! CM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CM)  ! CM
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! PMC
      Re_BufSz   = Re_BufSz   + 1  ! MulTabLoc
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%AL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AL))-1 ) = PACK(InData%AL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AL)
  END IF
  IF ( .NOT. ALLOCATED(InData%CD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CD,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CD,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CD,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CD,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CD,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CD))-1 ) = PACK(InData%CD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CD)
  END IF
  IF ( .NOT. ALLOCATED(InData%CL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CL))-1 ) = PACK(InData%CL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CL)
  END IF
  IF ( .NOT. ALLOCATED(InData%CM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CM,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CM,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CM,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CM,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CM,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CM)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CM))-1 ) = PACK(InData%CM,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CM)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%PMC
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%MulTabLoc
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackAirFoil

 SUBROUTINE AD14_UnPackAirFoil( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AirFoil), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackAirFoil'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AL)) DEALLOCATE(OutData%AL)
    ALLOCATE(OutData%AL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AL)>0) OutData%AL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CD)) DEALLOCATE(OutData%CD)
    ALLOCATE(OutData%CD(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%CD)>0) OutData%CD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CD))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CD)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CL)) DEALLOCATE(OutData%CL)
    ALLOCATE(OutData%CL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%CL)>0) OutData%CL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CM)) DEALLOCATE(OutData%CM)
    ALLOCATE(OutData%CM(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%CM)>0) OutData%CM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CM))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CM)
    DEALLOCATE(mask3)
  END IF
      OutData%PMC = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%MulTabLoc = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackAirFoil

 SUBROUTINE AD14_CopyAirFoilParms( SrcAirFoilParmsData, DstAirFoilParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AirFoilParms), INTENT(IN) :: SrcAirFoilParmsData
   TYPE(AirFoilParms), INTENT(INOUT) :: DstAirFoilParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAirFoilParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstAirFoilParmsData%MaxTable = SrcAirFoilParmsData%MaxTable
IF (ALLOCATED(SrcAirFoilParmsData%NTables)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NTables,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NTables,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NTables)) THEN 
    ALLOCATE(DstAirFoilParmsData%NTables(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NTables.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NTables = SrcAirFoilParmsData%NTables
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%NLift)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NLift,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NLift,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NLift)) THEN 
    ALLOCATE(DstAirFoilParmsData%NLift(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NLift.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NLift = SrcAirFoilParmsData%NLift
ENDIF
    DstAirFoilParmsData%NumCL = SrcAirFoilParmsData%NumCL
    DstAirFoilParmsData%NumFoil = SrcAirFoilParmsData%NumFoil
IF (ALLOCATED(SrcAirFoilParmsData%NFoil)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NFoil,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NFoil,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NFoil)) THEN 
    ALLOCATE(DstAirFoilParmsData%NFoil(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NFoil.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NFoil = SrcAirFoilParmsData%NFoil
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%MulTabMet)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%MulTabMet,1)
  i1_u = UBOUND(SrcAirFoilParmsData%MulTabMet,1)
  i2_l = LBOUND(SrcAirFoilParmsData%MulTabMet,2)
  i2_u = UBOUND(SrcAirFoilParmsData%MulTabMet,2)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%MulTabMet)) THEN 
    ALLOCATE(DstAirFoilParmsData%MulTabMet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%MulTabMet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%MulTabMet = SrcAirFoilParmsData%MulTabMet
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%FoilNm)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%FoilNm,1)
  i1_u = UBOUND(SrcAirFoilParmsData%FoilNm,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%FoilNm)) THEN 
    ALLOCATE(DstAirFoilParmsData%FoilNm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%FoilNm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%FoilNm = SrcAirFoilParmsData%FoilNm
ENDIF
 END SUBROUTINE AD14_CopyAirFoilParms

 SUBROUTINE AD14_DestroyAirFoilParms( AirFoilParmsData, ErrStat, ErrMsg )
  TYPE(AirFoilParms), INTENT(INOUT) :: AirFoilParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAirFoilParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(AirFoilParmsData%NTables)) THEN
  DEALLOCATE(AirFoilParmsData%NTables)
ENDIF
IF (ALLOCATED(AirFoilParmsData%NLift)) THEN
  DEALLOCATE(AirFoilParmsData%NLift)
ENDIF
IF (ALLOCATED(AirFoilParmsData%NFoil)) THEN
  DEALLOCATE(AirFoilParmsData%NFoil)
ENDIF
IF (ALLOCATED(AirFoilParmsData%MulTabMet)) THEN
  DEALLOCATE(AirFoilParmsData%MulTabMet)
ENDIF
IF (ALLOCATED(AirFoilParmsData%FoilNm)) THEN
  DEALLOCATE(AirFoilParmsData%FoilNm)
ENDIF
 END SUBROUTINE AD14_DestroyAirFoilParms

 SUBROUTINE AD14_PackAirFoilParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AirFoilParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackAirFoilParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MaxTable
  Int_BufSz   = Int_BufSz   + 1     ! NTables allocated yes/no
  IF ( ALLOCATED(InData%NTables) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NTables upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%NTables)  ! NTables
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! NLift allocated yes/no
  IF ( ALLOCATED(InData%NLift) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NLift upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%NLift)  ! NLift
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumCL
      Int_BufSz  = Int_BufSz  + 1  ! NumFoil
  Int_BufSz   = Int_BufSz   + 1     ! NFoil allocated yes/no
  IF ( ALLOCATED(InData%NFoil) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NFoil upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%NFoil)  ! NFoil
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! MulTabMet allocated yes/no
  IF ( ALLOCATED(InData%MulTabMet) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! MulTabMet upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%MulTabMet)  ! MulTabMet
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FoilNm allocated yes/no
  IF ( ALLOCATED(InData%FoilNm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FoilNm upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%FoilNm)*LEN(InData%FoilNm)  ! FoilNm
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%MaxTable
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%NTables) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NTables,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NTables,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%NTables)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NTables))-1 ) = PACK(InData%NTables,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%NTables)
  END IF
  IF ( .NOT. ALLOCATED(InData%NLift) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NLift,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NLift,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%NLift)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NLift))-1 ) = PACK(InData%NLift,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%NLift)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumCL
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumFoil
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%NFoil) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NFoil,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NFoil,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%NFoil)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NFoil))-1 ) = PACK(InData%NFoil,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%NFoil)
  END IF
  IF ( .NOT. ALLOCATED(InData%MulTabMet) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MulTabMet,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MulTabMet,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MulTabMet,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MulTabMet,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%MulTabMet)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MulTabMet))-1 ) = PACK(InData%MulTabMet,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%MulTabMet)
  END IF
  IF ( .NOT. ALLOCATED(InData%FoilNm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FoilNm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FoilNm,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%FoilNm,1), UBOUND(InData%FoilNm,1)
        DO I = 1, LEN(InData%FoilNm)
          IntKiBuf(Int_Xferred) = ICHAR(InData%FoilNm(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
    END DO !i1
  END IF
 END SUBROUTINE AD14_PackAirFoilParms

 SUBROUTINE AD14_UnPackAirFoilParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AirFoilParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackAirFoilParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%MaxTable = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NTables not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NTables)) DEALLOCATE(OutData%NTables)
    ALLOCATE(OutData%NTables(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTables.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%NTables)>0) OutData%NTables = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%NTables))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%NTables)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NLift not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NLift)) DEALLOCATE(OutData%NLift)
    ALLOCATE(OutData%NLift(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NLift.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%NLift)>0) OutData%NLift = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%NLift))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%NLift)
    DEALLOCATE(mask1)
  END IF
      OutData%NumCL = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%NumFoil = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NFoil not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NFoil)) DEALLOCATE(OutData%NFoil)
    ALLOCATE(OutData%NFoil(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NFoil.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%NFoil)>0) OutData%NFoil = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%NFoil))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%NFoil)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MulTabMet not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MulTabMet)) DEALLOCATE(OutData%MulTabMet)
    ALLOCATE(OutData%MulTabMet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabMet.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%MulTabMet)>0) OutData%MulTabMet = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MulTabMet))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%MulTabMet)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FoilNm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FoilNm)) DEALLOCATE(OutData%FoilNm)
    ALLOCATE(OutData%FoilNm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FoilNm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
    DO i1 = LBOUND(OutData%FoilNm,1), UBOUND(OutData%FoilNm,1)
        DO I = 1, LEN(OutData%FoilNm)
          OutData%FoilNm(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
    END DO !i1
    DEALLOCATE(mask1)
  END IF
 END SUBROUTINE AD14_UnPackAirFoilParms

 SUBROUTINE AD14_CopyBeddoes( SrcBeddoesData, DstBeddoesData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Beddoes), INTENT(IN) :: SrcBeddoesData
   TYPE(Beddoes), INTENT(INOUT) :: DstBeddoesData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBeddoes'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBeddoesData%ADOT)) THEN
  i1_l = LBOUND(SrcBeddoesData%ADOT,1)
  i1_u = UBOUND(SrcBeddoesData%ADOT,1)
  i2_l = LBOUND(SrcBeddoesData%ADOT,2)
  i2_u = UBOUND(SrcBeddoesData%ADOT,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ADOT)) THEN 
    ALLOCATE(DstBeddoesData%ADOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ADOT = SrcBeddoesData%ADOT
ENDIF
IF (ALLOCATED(SrcBeddoesData%ADOT1)) THEN
  i1_l = LBOUND(SrcBeddoesData%ADOT1,1)
  i1_u = UBOUND(SrcBeddoesData%ADOT1,1)
  i2_l = LBOUND(SrcBeddoesData%ADOT1,2)
  i2_u = UBOUND(SrcBeddoesData%ADOT1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ADOT1)) THEN 
    ALLOCATE(DstBeddoesData%ADOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ADOT1 = SrcBeddoesData%ADOT1
ENDIF
IF (ALLOCATED(SrcBeddoesData%AFE)) THEN
  i1_l = LBOUND(SrcBeddoesData%AFE,1)
  i1_u = UBOUND(SrcBeddoesData%AFE,1)
  i2_l = LBOUND(SrcBeddoesData%AFE,2)
  i2_u = UBOUND(SrcBeddoesData%AFE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AFE)) THEN 
    ALLOCATE(DstBeddoesData%AFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AFE = SrcBeddoesData%AFE
ENDIF
IF (ALLOCATED(SrcBeddoesData%AFE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%AFE1,1)
  i1_u = UBOUND(SrcBeddoesData%AFE1,1)
  i2_l = LBOUND(SrcBeddoesData%AFE1,2)
  i2_u = UBOUND(SrcBeddoesData%AFE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AFE1)) THEN 
    ALLOCATE(DstBeddoesData%AFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AFE1 = SrcBeddoesData%AFE1
ENDIF
    DstBeddoesData%AN = SrcBeddoesData%AN
IF (ALLOCATED(SrcBeddoesData%ANE)) THEN
  i1_l = LBOUND(SrcBeddoesData%ANE,1)
  i1_u = UBOUND(SrcBeddoesData%ANE,1)
  i2_l = LBOUND(SrcBeddoesData%ANE,2)
  i2_u = UBOUND(SrcBeddoesData%ANE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ANE)) THEN 
    ALLOCATE(DstBeddoesData%ANE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ANE = SrcBeddoesData%ANE
ENDIF
IF (ALLOCATED(SrcBeddoesData%ANE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%ANE1,1)
  i1_u = UBOUND(SrcBeddoesData%ANE1,1)
  i2_l = LBOUND(SrcBeddoesData%ANE1,2)
  i2_u = UBOUND(SrcBeddoesData%ANE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ANE1)) THEN 
    ALLOCATE(DstBeddoesData%ANE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ANE1 = SrcBeddoesData%ANE1
ENDIF
IF (ALLOCATED(SrcBeddoesData%AOD)) THEN
  i1_l = LBOUND(SrcBeddoesData%AOD,1)
  i1_u = UBOUND(SrcBeddoesData%AOD,1)
  i2_l = LBOUND(SrcBeddoesData%AOD,2)
  i2_u = UBOUND(SrcBeddoesData%AOD,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AOD)) THEN 
    ALLOCATE(DstBeddoesData%AOD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AOD = SrcBeddoesData%AOD
ENDIF
IF (ALLOCATED(SrcBeddoesData%AOL)) THEN
  i1_l = LBOUND(SrcBeddoesData%AOL,1)
  i1_u = UBOUND(SrcBeddoesData%AOL,1)
  i2_l = LBOUND(SrcBeddoesData%AOL,2)
  i2_u = UBOUND(SrcBeddoesData%AOL,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AOL)) THEN 
    ALLOCATE(DstBeddoesData%AOL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AOL = SrcBeddoesData%AOL
ENDIF
IF (ALLOCATED(SrcBeddoesData%BEDSEP)) THEN
  i1_l = LBOUND(SrcBeddoesData%BEDSEP,1)
  i1_u = UBOUND(SrcBeddoesData%BEDSEP,1)
  i2_l = LBOUND(SrcBeddoesData%BEDSEP,2)
  i2_u = UBOUND(SrcBeddoesData%BEDSEP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%BEDSEP)) THEN 
    ALLOCATE(DstBeddoesData%BEDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%BEDSEP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%BEDSEP = SrcBeddoesData%BEDSEP
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDSEP)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDSEP,1)
  i1_u = UBOUND(SrcBeddoesData%OLDSEP,1)
  i2_l = LBOUND(SrcBeddoesData%OLDSEP,2)
  i2_u = UBOUND(SrcBeddoesData%OLDSEP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDSEP)) THEN 
    ALLOCATE(DstBeddoesData%OLDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDSEP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDSEP = SrcBeddoesData%OLDSEP
ENDIF
    DstBeddoesData%CC = SrcBeddoesData%CC
IF (ALLOCATED(SrcBeddoesData%CDO)) THEN
  i1_l = LBOUND(SrcBeddoesData%CDO,1)
  i1_u = UBOUND(SrcBeddoesData%CDO,1)
  i2_l = LBOUND(SrcBeddoesData%CDO,2)
  i2_u = UBOUND(SrcBeddoesData%CDO,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CDO)) THEN 
    ALLOCATE(DstBeddoesData%CDO(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CDO.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CDO = SrcBeddoesData%CDO
ENDIF
    DstBeddoesData%CMI = SrcBeddoesData%CMI
    DstBeddoesData%CMQ = SrcBeddoesData%CMQ
    DstBeddoesData%CN = SrcBeddoesData%CN
IF (ALLOCATED(SrcBeddoesData%CNA)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNA,1)
  i1_u = UBOUND(SrcBeddoesData%CNA,1)
  i2_l = LBOUND(SrcBeddoesData%CNA,2)
  i2_u = UBOUND(SrcBeddoesData%CNA,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNA)) THEN 
    ALLOCATE(DstBeddoesData%CNA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNA = SrcBeddoesData%CNA
ENDIF
    DstBeddoesData%CNCP = SrcBeddoesData%CNCP
    DstBeddoesData%CNIQ = SrcBeddoesData%CNIQ
IF (ALLOCATED(SrcBeddoesData%CNP)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNP,1)
  i1_u = UBOUND(SrcBeddoesData%CNP,1)
  i2_l = LBOUND(SrcBeddoesData%CNP,2)
  i2_u = UBOUND(SrcBeddoesData%CNP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNP)) THEN 
    ALLOCATE(DstBeddoesData%CNP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNP = SrcBeddoesData%CNP
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNP1,1)
  i1_u = UBOUND(SrcBeddoesData%CNP1,1)
  i2_l = LBOUND(SrcBeddoesData%CNP1,2)
  i2_u = UBOUND(SrcBeddoesData%CNP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNP1)) THEN 
    ALLOCATE(DstBeddoesData%CNP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNP1 = SrcBeddoesData%CNP1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPD)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPD,1)
  i1_u = UBOUND(SrcBeddoesData%CNPD,1)
  i2_l = LBOUND(SrcBeddoesData%CNPD,2)
  i2_u = UBOUND(SrcBeddoesData%CNPD,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPD)) THEN 
    ALLOCATE(DstBeddoesData%CNPD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPD = SrcBeddoesData%CNPD
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPD1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPD1,1)
  i1_u = UBOUND(SrcBeddoesData%CNPD1,1)
  i2_l = LBOUND(SrcBeddoesData%CNPD1,2)
  i2_u = UBOUND(SrcBeddoesData%CNPD1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPD1)) THEN 
    ALLOCATE(DstBeddoesData%CNPD1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPD1 = SrcBeddoesData%CNPD1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPOT)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPOT,1)
  i1_u = UBOUND(SrcBeddoesData%CNPOT,1)
  i2_l = LBOUND(SrcBeddoesData%CNPOT,2)
  i2_u = UBOUND(SrcBeddoesData%CNPOT,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPOT)) THEN 
    ALLOCATE(DstBeddoesData%CNPOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPOT = SrcBeddoesData%CNPOT
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPOT1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPOT1,1)
  i1_u = UBOUND(SrcBeddoesData%CNPOT1,1)
  i2_l = LBOUND(SrcBeddoesData%CNPOT1,2)
  i2_u = UBOUND(SrcBeddoesData%CNPOT1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPOT1)) THEN 
    ALLOCATE(DstBeddoesData%CNPOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPOT1 = SrcBeddoesData%CNPOT1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNS)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNS,1)
  i1_u = UBOUND(SrcBeddoesData%CNS,1)
  i2_l = LBOUND(SrcBeddoesData%CNS,2)
  i2_u = UBOUND(SrcBeddoesData%CNS,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNS)) THEN 
    ALLOCATE(DstBeddoesData%CNS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNS = SrcBeddoesData%CNS
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNSL)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNSL,1)
  i1_u = UBOUND(SrcBeddoesData%CNSL,1)
  i2_l = LBOUND(SrcBeddoesData%CNSL,2)
  i2_u = UBOUND(SrcBeddoesData%CNSL,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNSL)) THEN 
    ALLOCATE(DstBeddoesData%CNSL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNSL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNSL = SrcBeddoesData%CNSL
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNV)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNV,1)
  i1_u = UBOUND(SrcBeddoesData%CNV,1)
  i2_l = LBOUND(SrcBeddoesData%CNV,2)
  i2_u = UBOUND(SrcBeddoesData%CNV,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNV)) THEN 
    ALLOCATE(DstBeddoesData%CNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNV = SrcBeddoesData%CNV
ENDIF
IF (ALLOCATED(SrcBeddoesData%CVN)) THEN
  i1_l = LBOUND(SrcBeddoesData%CVN,1)
  i1_u = UBOUND(SrcBeddoesData%CVN,1)
  i2_l = LBOUND(SrcBeddoesData%CVN,2)
  i2_u = UBOUND(SrcBeddoesData%CVN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CVN)) THEN 
    ALLOCATE(DstBeddoesData%CVN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CVN = SrcBeddoesData%CVN
ENDIF
IF (ALLOCATED(SrcBeddoesData%CVN1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CVN1,1)
  i1_u = UBOUND(SrcBeddoesData%CVN1,1)
  i2_l = LBOUND(SrcBeddoesData%CVN1,2)
  i2_u = UBOUND(SrcBeddoesData%CVN1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CVN1)) THEN 
    ALLOCATE(DstBeddoesData%CVN1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CVN1 = SrcBeddoesData%CVN1
ENDIF
IF (ALLOCATED(SrcBeddoesData%DF)) THEN
  i1_l = LBOUND(SrcBeddoesData%DF,1)
  i1_u = UBOUND(SrcBeddoesData%DF,1)
  i2_l = LBOUND(SrcBeddoesData%DF,2)
  i2_u = UBOUND(SrcBeddoesData%DF,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DF)) THEN 
    ALLOCATE(DstBeddoesData%DF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DF = SrcBeddoesData%DF
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFAFE)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFAFE,1)
  i1_u = UBOUND(SrcBeddoesData%DFAFE,1)
  i2_l = LBOUND(SrcBeddoesData%DFAFE,2)
  i2_u = UBOUND(SrcBeddoesData%DFAFE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFAFE)) THEN 
    ALLOCATE(DstBeddoesData%DFAFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFAFE = SrcBeddoesData%DFAFE
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFAFE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFAFE1,1)
  i1_u = UBOUND(SrcBeddoesData%DFAFE1,1)
  i2_l = LBOUND(SrcBeddoesData%DFAFE1,2)
  i2_u = UBOUND(SrcBeddoesData%DFAFE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFAFE1)) THEN 
    ALLOCATE(DstBeddoesData%DFAFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFAFE1 = SrcBeddoesData%DFAFE1
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFC)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFC,1)
  i1_u = UBOUND(SrcBeddoesData%DFC,1)
  i2_l = LBOUND(SrcBeddoesData%DFC,2)
  i2_u = UBOUND(SrcBeddoesData%DFC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFC)) THEN 
    ALLOCATE(DstBeddoesData%DFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFC = SrcBeddoesData%DFC
ENDIF
IF (ALLOCATED(SrcBeddoesData%DN)) THEN
  i1_l = LBOUND(SrcBeddoesData%DN,1)
  i1_u = UBOUND(SrcBeddoesData%DN,1)
  i2_l = LBOUND(SrcBeddoesData%DN,2)
  i2_u = UBOUND(SrcBeddoesData%DN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DN)) THEN 
    ALLOCATE(DstBeddoesData%DN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DN = SrcBeddoesData%DN
ENDIF
IF (ALLOCATED(SrcBeddoesData%DPP)) THEN
  i1_l = LBOUND(SrcBeddoesData%DPP,1)
  i1_u = UBOUND(SrcBeddoesData%DPP,1)
  i2_l = LBOUND(SrcBeddoesData%DPP,2)
  i2_u = UBOUND(SrcBeddoesData%DPP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DPP)) THEN 
    ALLOCATE(DstBeddoesData%DPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DPP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DPP = SrcBeddoesData%DPP
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQ)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQ,1)
  i1_u = UBOUND(SrcBeddoesData%DQ,1)
  i2_l = LBOUND(SrcBeddoesData%DQ,2)
  i2_u = UBOUND(SrcBeddoesData%DQ,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQ)) THEN 
    ALLOCATE(DstBeddoesData%DQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQ = SrcBeddoesData%DQ
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQP)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQP,1)
  i1_u = UBOUND(SrcBeddoesData%DQP,1)
  i2_l = LBOUND(SrcBeddoesData%DQP,2)
  i2_u = UBOUND(SrcBeddoesData%DQP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQP)) THEN 
    ALLOCATE(DstBeddoesData%DQP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQP = SrcBeddoesData%DQP
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQP1,1)
  i1_u = UBOUND(SrcBeddoesData%DQP1,1)
  i2_l = LBOUND(SrcBeddoesData%DQP1,2)
  i2_u = UBOUND(SrcBeddoesData%DQP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQP1)) THEN 
    ALLOCATE(DstBeddoesData%DQP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQP1 = SrcBeddoesData%DQP1
ENDIF
    DstBeddoesData%DS = SrcBeddoesData%DS
    DstBeddoesData%FK = SrcBeddoesData%FK
    DstBeddoesData%FP = SrcBeddoesData%FP
    DstBeddoesData%FPC = SrcBeddoesData%FPC
IF (ALLOCATED(SrcBeddoesData%FSP)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSP,1)
  i1_u = UBOUND(SrcBeddoesData%FSP,1)
  i2_l = LBOUND(SrcBeddoesData%FSP,2)
  i2_u = UBOUND(SrcBeddoesData%FSP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSP)) THEN 
    ALLOCATE(DstBeddoesData%FSP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSP = SrcBeddoesData%FSP
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSP1,1)
  i1_u = UBOUND(SrcBeddoesData%FSP1,1)
  i2_l = LBOUND(SrcBeddoesData%FSP1,2)
  i2_u = UBOUND(SrcBeddoesData%FSP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSP1)) THEN 
    ALLOCATE(DstBeddoesData%FSP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSP1 = SrcBeddoesData%FSP1
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSPC)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSPC,1)
  i1_u = UBOUND(SrcBeddoesData%FSPC,1)
  i2_l = LBOUND(SrcBeddoesData%FSPC,2)
  i2_u = UBOUND(SrcBeddoesData%FSPC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSPC)) THEN 
    ALLOCATE(DstBeddoesData%FSPC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSPC = SrcBeddoesData%FSPC
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSPC1)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSPC1,1)
  i1_u = UBOUND(SrcBeddoesData%FSPC1,1)
  i2_l = LBOUND(SrcBeddoesData%FSPC1,2)
  i2_u = UBOUND(SrcBeddoesData%FSPC1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSPC1)) THEN 
    ALLOCATE(DstBeddoesData%FSPC1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSPC1 = SrcBeddoesData%FSPC1
ENDIF
IF (ALLOCATED(SrcBeddoesData%FTB)) THEN
  i1_l = LBOUND(SrcBeddoesData%FTB,1)
  i1_u = UBOUND(SrcBeddoesData%FTB,1)
  i2_l = LBOUND(SrcBeddoesData%FTB,2)
  i2_u = UBOUND(SrcBeddoesData%FTB,2)
  i3_l = LBOUND(SrcBeddoesData%FTB,3)
  i3_u = UBOUND(SrcBeddoesData%FTB,3)
  IF (.NOT. ALLOCATED(DstBeddoesData%FTB)) THEN 
    ALLOCATE(DstBeddoesData%FTB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FTB = SrcBeddoesData%FTB
ENDIF
IF (ALLOCATED(SrcBeddoesData%FTBC)) THEN
  i1_l = LBOUND(SrcBeddoesData%FTBC,1)
  i1_u = UBOUND(SrcBeddoesData%FTBC,1)
  i2_l = LBOUND(SrcBeddoesData%FTBC,2)
  i2_u = UBOUND(SrcBeddoesData%FTBC,2)
  i3_l = LBOUND(SrcBeddoesData%FTBC,3)
  i3_u = UBOUND(SrcBeddoesData%FTBC,3)
  IF (.NOT. ALLOCATED(DstBeddoesData%FTBC)) THEN 
    ALLOCATE(DstBeddoesData%FTBC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTBC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FTBC = SrcBeddoesData%FTBC
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDCNV)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDCNV,1)
  i1_u = UBOUND(SrcBeddoesData%OLDCNV,1)
  i2_l = LBOUND(SrcBeddoesData%OLDCNV,2)
  i2_u = UBOUND(SrcBeddoesData%OLDCNV,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDCNV)) THEN 
    ALLOCATE(DstBeddoesData%OLDCNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDCNV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDCNV = SrcBeddoesData%OLDCNV
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDF)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDF,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDF,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDF,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDF,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDF)) THEN 
    ALLOCATE(DstBeddoesData%OLDDF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDF = SrcBeddoesData%OLDDF
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDFC)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDFC,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDFC,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDFC,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDFC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDFC)) THEN 
    ALLOCATE(DstBeddoesData%OLDDFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDFC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDFC = SrcBeddoesData%OLDDFC
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDN)) THEN 
    ALLOCATE(DstBeddoesData%OLDDN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDN = SrcBeddoesData%OLDDN
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDPP)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDPP,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDPP,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDPP,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDPP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDPP)) THEN 
    ALLOCATE(DstBeddoesData%OLDDPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDPP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDPP = SrcBeddoesData%OLDDPP
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDQ)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDQ,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDQ,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDQ,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDQ,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDQ)) THEN 
    ALLOCATE(DstBeddoesData%OLDDQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDQ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDQ = SrcBeddoesData%OLDDQ
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDTAU)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDTAU,1)
  i1_u = UBOUND(SrcBeddoesData%OLDTAU,1)
  i2_l = LBOUND(SrcBeddoesData%OLDTAU,2)
  i2_u = UBOUND(SrcBeddoesData%OLDTAU,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDTAU)) THEN 
    ALLOCATE(DstBeddoesData%OLDTAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDTAU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDTAU = SrcBeddoesData%OLDTAU
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDXN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDXN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDXN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDXN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDXN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDXN)) THEN 
    ALLOCATE(DstBeddoesData%OLDXN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDXN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDXN = SrcBeddoesData%OLDXN
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDYN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDYN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDYN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDYN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDYN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDYN)) THEN 
    ALLOCATE(DstBeddoesData%OLDYN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDYN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDYN = SrcBeddoesData%OLDYN
ENDIF
IF (ALLOCATED(SrcBeddoesData%QX)) THEN
  i1_l = LBOUND(SrcBeddoesData%QX,1)
  i1_u = UBOUND(SrcBeddoesData%QX,1)
  i2_l = LBOUND(SrcBeddoesData%QX,2)
  i2_u = UBOUND(SrcBeddoesData%QX,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%QX)) THEN 
    ALLOCATE(DstBeddoesData%QX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%QX = SrcBeddoesData%QX
ENDIF
IF (ALLOCATED(SrcBeddoesData%QX1)) THEN
  i1_l = LBOUND(SrcBeddoesData%QX1,1)
  i1_u = UBOUND(SrcBeddoesData%QX1,1)
  i2_l = LBOUND(SrcBeddoesData%QX1,2)
  i2_u = UBOUND(SrcBeddoesData%QX1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%QX1)) THEN 
    ALLOCATE(DstBeddoesData%QX1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%QX1 = SrcBeddoesData%QX1
ENDIF
IF (ALLOCATED(SrcBeddoesData%TAU)) THEN
  i1_l = LBOUND(SrcBeddoesData%TAU,1)
  i1_u = UBOUND(SrcBeddoesData%TAU,1)
  i2_l = LBOUND(SrcBeddoesData%TAU,2)
  i2_u = UBOUND(SrcBeddoesData%TAU,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%TAU)) THEN 
    ALLOCATE(DstBeddoesData%TAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%TAU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%TAU = SrcBeddoesData%TAU
ENDIF
IF (ALLOCATED(SrcBeddoesData%XN)) THEN
  i1_l = LBOUND(SrcBeddoesData%XN,1)
  i1_u = UBOUND(SrcBeddoesData%XN,1)
  i2_l = LBOUND(SrcBeddoesData%XN,2)
  i2_u = UBOUND(SrcBeddoesData%XN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%XN)) THEN 
    ALLOCATE(DstBeddoesData%XN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%XN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%XN = SrcBeddoesData%XN
ENDIF
IF (ALLOCATED(SrcBeddoesData%YN)) THEN
  i1_l = LBOUND(SrcBeddoesData%YN,1)
  i1_u = UBOUND(SrcBeddoesData%YN,1)
  i2_l = LBOUND(SrcBeddoesData%YN,2)
  i2_u = UBOUND(SrcBeddoesData%YN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%YN)) THEN 
    ALLOCATE(DstBeddoesData%YN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%YN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%YN = SrcBeddoesData%YN
ENDIF
    DstBeddoesData%SHIFT = SrcBeddoesData%SHIFT
    DstBeddoesData%VOR = SrcBeddoesData%VOR
 END SUBROUTINE AD14_CopyBeddoes

 SUBROUTINE AD14_DestroyBeddoes( BeddoesData, ErrStat, ErrMsg )
  TYPE(Beddoes), INTENT(INOUT) :: BeddoesData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBeddoes'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(BeddoesData%ADOT)) THEN
  DEALLOCATE(BeddoesData%ADOT)
ENDIF
IF (ALLOCATED(BeddoesData%ADOT1)) THEN
  DEALLOCATE(BeddoesData%ADOT1)
ENDIF
IF (ALLOCATED(BeddoesData%AFE)) THEN
  DEALLOCATE(BeddoesData%AFE)
ENDIF
IF (ALLOCATED(BeddoesData%AFE1)) THEN
  DEALLOCATE(BeddoesData%AFE1)
ENDIF
IF (ALLOCATED(BeddoesData%ANE)) THEN
  DEALLOCATE(BeddoesData%ANE)
ENDIF
IF (ALLOCATED(BeddoesData%ANE1)) THEN
  DEALLOCATE(BeddoesData%ANE1)
ENDIF
IF (ALLOCATED(BeddoesData%AOD)) THEN
  DEALLOCATE(BeddoesData%AOD)
ENDIF
IF (ALLOCATED(BeddoesData%AOL)) THEN
  DEALLOCATE(BeddoesData%AOL)
ENDIF
IF (ALLOCATED(BeddoesData%BEDSEP)) THEN
  DEALLOCATE(BeddoesData%BEDSEP)
ENDIF
IF (ALLOCATED(BeddoesData%OLDSEP)) THEN
  DEALLOCATE(BeddoesData%OLDSEP)
ENDIF
IF (ALLOCATED(BeddoesData%CDO)) THEN
  DEALLOCATE(BeddoesData%CDO)
ENDIF
IF (ALLOCATED(BeddoesData%CNA)) THEN
  DEALLOCATE(BeddoesData%CNA)
ENDIF
IF (ALLOCATED(BeddoesData%CNP)) THEN
  DEALLOCATE(BeddoesData%CNP)
ENDIF
IF (ALLOCATED(BeddoesData%CNP1)) THEN
  DEALLOCATE(BeddoesData%CNP1)
ENDIF
IF (ALLOCATED(BeddoesData%CNPD)) THEN
  DEALLOCATE(BeddoesData%CNPD)
ENDIF
IF (ALLOCATED(BeddoesData%CNPD1)) THEN
  DEALLOCATE(BeddoesData%CNPD1)
ENDIF
IF (ALLOCATED(BeddoesData%CNPOT)) THEN
  DEALLOCATE(BeddoesData%CNPOT)
ENDIF
IF (ALLOCATED(BeddoesData%CNPOT1)) THEN
  DEALLOCATE(BeddoesData%CNPOT1)
ENDIF
IF (ALLOCATED(BeddoesData%CNS)) THEN
  DEALLOCATE(BeddoesData%CNS)
ENDIF
IF (ALLOCATED(BeddoesData%CNSL)) THEN
  DEALLOCATE(BeddoesData%CNSL)
ENDIF
IF (ALLOCATED(BeddoesData%CNV)) THEN
  DEALLOCATE(BeddoesData%CNV)
ENDIF
IF (ALLOCATED(BeddoesData%CVN)) THEN
  DEALLOCATE(BeddoesData%CVN)
ENDIF
IF (ALLOCATED(BeddoesData%CVN1)) THEN
  DEALLOCATE(BeddoesData%CVN1)
ENDIF
IF (ALLOCATED(BeddoesData%DF)) THEN
  DEALLOCATE(BeddoesData%DF)
ENDIF
IF (ALLOCATED(BeddoesData%DFAFE)) THEN
  DEALLOCATE(BeddoesData%DFAFE)
ENDIF
IF (ALLOCATED(BeddoesData%DFAFE1)) THEN
  DEALLOCATE(BeddoesData%DFAFE1)
ENDIF
IF (ALLOCATED(BeddoesData%DFC)) THEN
  DEALLOCATE(BeddoesData%DFC)
ENDIF
IF (ALLOCATED(BeddoesData%DN)) THEN
  DEALLOCATE(BeddoesData%DN)
ENDIF
IF (ALLOCATED(BeddoesData%DPP)) THEN
  DEALLOCATE(BeddoesData%DPP)
ENDIF
IF (ALLOCATED(BeddoesData%DQ)) THEN
  DEALLOCATE(BeddoesData%DQ)
ENDIF
IF (ALLOCATED(BeddoesData%DQP)) THEN
  DEALLOCATE(BeddoesData%DQP)
ENDIF
IF (ALLOCATED(BeddoesData%DQP1)) THEN
  DEALLOCATE(BeddoesData%DQP1)
ENDIF
IF (ALLOCATED(BeddoesData%FSP)) THEN
  DEALLOCATE(BeddoesData%FSP)
ENDIF
IF (ALLOCATED(BeddoesData%FSP1)) THEN
  DEALLOCATE(BeddoesData%FSP1)
ENDIF
IF (ALLOCATED(BeddoesData%FSPC)) THEN
  DEALLOCATE(BeddoesData%FSPC)
ENDIF
IF (ALLOCATED(BeddoesData%FSPC1)) THEN
  DEALLOCATE(BeddoesData%FSPC1)
ENDIF
IF (ALLOCATED(BeddoesData%FTB)) THEN
  DEALLOCATE(BeddoesData%FTB)
ENDIF
IF (ALLOCATED(BeddoesData%FTBC)) THEN
  DEALLOCATE(BeddoesData%FTBC)
ENDIF
IF (ALLOCATED(BeddoesData%OLDCNV)) THEN
  DEALLOCATE(BeddoesData%OLDCNV)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDF)) THEN
  DEALLOCATE(BeddoesData%OLDDF)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDFC)) THEN
  DEALLOCATE(BeddoesData%OLDDFC)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDN)) THEN
  DEALLOCATE(BeddoesData%OLDDN)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDPP)) THEN
  DEALLOCATE(BeddoesData%OLDDPP)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDQ)) THEN
  DEALLOCATE(BeddoesData%OLDDQ)
ENDIF
IF (ALLOCATED(BeddoesData%OLDTAU)) THEN
  DEALLOCATE(BeddoesData%OLDTAU)
ENDIF
IF (ALLOCATED(BeddoesData%OLDXN)) THEN
  DEALLOCATE(BeddoesData%OLDXN)
ENDIF
IF (ALLOCATED(BeddoesData%OLDYN)) THEN
  DEALLOCATE(BeddoesData%OLDYN)
ENDIF
IF (ALLOCATED(BeddoesData%QX)) THEN
  DEALLOCATE(BeddoesData%QX)
ENDIF
IF (ALLOCATED(BeddoesData%QX1)) THEN
  DEALLOCATE(BeddoesData%QX1)
ENDIF
IF (ALLOCATED(BeddoesData%TAU)) THEN
  DEALLOCATE(BeddoesData%TAU)
ENDIF
IF (ALLOCATED(BeddoesData%XN)) THEN
  DEALLOCATE(BeddoesData%XN)
ENDIF
IF (ALLOCATED(BeddoesData%YN)) THEN
  DEALLOCATE(BeddoesData%YN)
ENDIF
 END SUBROUTINE AD14_DestroyBeddoes

 SUBROUTINE AD14_PackBeddoes( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Beddoes),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackBeddoes'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! ADOT allocated yes/no
  IF ( ALLOCATED(InData%ADOT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! ADOT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ADOT)  ! ADOT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ADOT1 allocated yes/no
  IF ( ALLOCATED(InData%ADOT1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! ADOT1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ADOT1)  ! ADOT1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AFE allocated yes/no
  IF ( ALLOCATED(InData%AFE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AFE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AFE)  ! AFE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AFE1 allocated yes/no
  IF ( ALLOCATED(InData%AFE1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AFE1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AFE1)  ! AFE1
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! AN
  Int_BufSz   = Int_BufSz   + 1     ! ANE allocated yes/no
  IF ( ALLOCATED(InData%ANE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! ANE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ANE)  ! ANE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ANE1 allocated yes/no
  IF ( ALLOCATED(InData%ANE1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! ANE1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ANE1)  ! ANE1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AOD allocated yes/no
  IF ( ALLOCATED(InData%AOD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AOD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AOD)  ! AOD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AOL allocated yes/no
  IF ( ALLOCATED(InData%AOL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AOL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AOL)  ! AOL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BEDSEP allocated yes/no
  IF ( ALLOCATED(InData%BEDSEP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BEDSEP upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BEDSEP)  ! BEDSEP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDSEP allocated yes/no
  IF ( ALLOCATED(InData%OLDSEP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDSEP upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%OLDSEP)  ! OLDSEP
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! CC
  Int_BufSz   = Int_BufSz   + 1     ! CDO allocated yes/no
  IF ( ALLOCATED(InData%CDO) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CDO upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CDO)  ! CDO
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! CMI
      Re_BufSz   = Re_BufSz   + 1  ! CMQ
      Re_BufSz   = Re_BufSz   + 1  ! CN
  Int_BufSz   = Int_BufSz   + 1     ! CNA allocated yes/no
  IF ( ALLOCATED(InData%CNA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNA)  ! CNA
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! CNCP
      Re_BufSz   = Re_BufSz   + 1  ! CNIQ
  Int_BufSz   = Int_BufSz   + 1     ! CNP allocated yes/no
  IF ( ALLOCATED(InData%CNP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNP)  ! CNP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNP1 allocated yes/no
  IF ( ALLOCATED(InData%CNP1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNP1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNP1)  ! CNP1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNPD allocated yes/no
  IF ( ALLOCATED(InData%CNPD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNPD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNPD)  ! CNPD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNPD1 allocated yes/no
  IF ( ALLOCATED(InData%CNPD1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNPD1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNPD1)  ! CNPD1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNPOT allocated yes/no
  IF ( ALLOCATED(InData%CNPOT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNPOT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNPOT)  ! CNPOT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNPOT1 allocated yes/no
  IF ( ALLOCATED(InData%CNPOT1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNPOT1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNPOT1)  ! CNPOT1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNS allocated yes/no
  IF ( ALLOCATED(InData%CNS) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNS upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNS)  ! CNS
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNSL allocated yes/no
  IF ( ALLOCATED(InData%CNSL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNSL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNSL)  ! CNSL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNV allocated yes/no
  IF ( ALLOCATED(InData%CNV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CNV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNV)  ! CNV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CVN allocated yes/no
  IF ( ALLOCATED(InData%CVN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CVN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CVN)  ! CVN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CVN1 allocated yes/no
  IF ( ALLOCATED(InData%CVN1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CVN1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CVN1)  ! CVN1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DF allocated yes/no
  IF ( ALLOCATED(InData%DF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DF upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DF)  ! DF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DFAFE allocated yes/no
  IF ( ALLOCATED(InData%DFAFE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DFAFE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DFAFE)  ! DFAFE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DFAFE1 allocated yes/no
  IF ( ALLOCATED(InData%DFAFE1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DFAFE1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DFAFE1)  ! DFAFE1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DFC allocated yes/no
  IF ( ALLOCATED(InData%DFC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DFC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DFC)  ! DFC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DN allocated yes/no
  IF ( ALLOCATED(InData%DN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DN)  ! DN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DPP allocated yes/no
  IF ( ALLOCATED(InData%DPP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DPP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DPP)  ! DPP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DQ allocated yes/no
  IF ( ALLOCATED(InData%DQ) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DQ upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DQ)  ! DQ
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DQP allocated yes/no
  IF ( ALLOCATED(InData%DQP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DQP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DQP)  ! DQP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DQP1 allocated yes/no
  IF ( ALLOCATED(InData%DQP1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! DQP1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DQP1)  ! DQP1
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! DS
      Re_BufSz   = Re_BufSz   + 1  ! FK
      Re_BufSz   = Re_BufSz   + 1  ! FP
      Re_BufSz   = Re_BufSz   + 1  ! FPC
  Int_BufSz   = Int_BufSz   + 1     ! FSP allocated yes/no
  IF ( ALLOCATED(InData%FSP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! FSP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FSP)  ! FSP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FSP1 allocated yes/no
  IF ( ALLOCATED(InData%FSP1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! FSP1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FSP1)  ! FSP1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FSPC allocated yes/no
  IF ( ALLOCATED(InData%FSPC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! FSPC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FSPC)  ! FSPC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FSPC1 allocated yes/no
  IF ( ALLOCATED(InData%FSPC1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! FSPC1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FSPC1)  ! FSPC1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FTB allocated yes/no
  IF ( ALLOCATED(InData%FTB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! FTB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FTB)  ! FTB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FTBC allocated yes/no
  IF ( ALLOCATED(InData%FTBC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! FTBC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FTBC)  ! FTBC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDCNV allocated yes/no
  IF ( ALLOCATED(InData%OLDCNV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDCNV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDCNV)  ! OLDCNV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDDF allocated yes/no
  IF ( ALLOCATED(InData%OLDDF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDDF upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDDF)  ! OLDDF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDDFC allocated yes/no
  IF ( ALLOCATED(InData%OLDDFC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDDFC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDDFC)  ! OLDDFC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDDN allocated yes/no
  IF ( ALLOCATED(InData%OLDDN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDDN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDDN)  ! OLDDN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDDPP allocated yes/no
  IF ( ALLOCATED(InData%OLDDPP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDDPP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDDPP)  ! OLDDPP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDDQ allocated yes/no
  IF ( ALLOCATED(InData%OLDDQ) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDDQ upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDDQ)  ! OLDDQ
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDTAU allocated yes/no
  IF ( ALLOCATED(InData%OLDTAU) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDTAU upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDTAU)  ! OLDTAU
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDXN allocated yes/no
  IF ( ALLOCATED(InData%OLDXN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDXN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDXN)  ! OLDXN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLDYN allocated yes/no
  IF ( ALLOCATED(InData%OLDYN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLDYN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLDYN)  ! OLDYN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! QX allocated yes/no
  IF ( ALLOCATED(InData%QX) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! QX upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%QX)  ! QX
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! QX1 allocated yes/no
  IF ( ALLOCATED(InData%QX1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! QX1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%QX1)  ! QX1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TAU allocated yes/no
  IF ( ALLOCATED(InData%TAU) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TAU upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TAU)  ! TAU
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! XN allocated yes/no
  IF ( ALLOCATED(InData%XN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! XN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%XN)  ! XN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! YN allocated yes/no
  IF ( ALLOCATED(InData%YN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! YN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%YN)  ! YN
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! SHIFT
      Int_BufSz  = Int_BufSz  + 1  ! VOR
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%ADOT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ADOT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ADOT,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ADOT,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ADOT,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ADOT)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ADOT))-1 ) = PACK(InData%ADOT,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ADOT)
  END IF
  IF ( .NOT. ALLOCATED(InData%ADOT1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ADOT1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ADOT1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ADOT1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ADOT1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ADOT1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ADOT1))-1 ) = PACK(InData%ADOT1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ADOT1)
  END IF
  IF ( .NOT. ALLOCATED(InData%AFE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFE,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AFE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AFE))-1 ) = PACK(InData%AFE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AFE)
  END IF
  IF ( .NOT. ALLOCATED(InData%AFE1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFE1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFE1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFE1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFE1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AFE1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AFE1))-1 ) = PACK(InData%AFE1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AFE1)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%AN
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%ANE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ANE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ANE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ANE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ANE,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ANE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANE))-1 ) = PACK(InData%ANE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ANE)
  END IF
  IF ( .NOT. ALLOCATED(InData%ANE1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ANE1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ANE1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ANE1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ANE1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ANE1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANE1))-1 ) = PACK(InData%ANE1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ANE1)
  END IF
  IF ( .NOT. ALLOCATED(InData%AOD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AOD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AOD,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AOD,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AOD,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AOD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AOD))-1 ) = PACK(InData%AOD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AOD)
  END IF
  IF ( .NOT. ALLOCATED(InData%AOL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AOL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AOL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AOL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AOL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AOL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AOL))-1 ) = PACK(InData%AOL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AOL)
  END IF
  IF ( .NOT. ALLOCATED(InData%BEDSEP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BEDSEP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BEDSEP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BEDSEP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BEDSEP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%BEDSEP)>0) IntKiBuf ( Int_Xferred:Int_Xferred+SIZE(InData%BEDSEP)-1 ) = TRANSFER(PACK( InData%BEDSEP ,.TRUE.), IntKiBuf(1), SIZE(InData%BEDSEP))
      Int_Xferred   = Int_Xferred   + SIZE(InData%BEDSEP)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDSEP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDSEP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDSEP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDSEP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDSEP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDSEP)>0) IntKiBuf ( Int_Xferred:Int_Xferred+SIZE(InData%OLDSEP)-1 ) = TRANSFER(PACK( InData%OLDSEP ,.TRUE.), IntKiBuf(1), SIZE(InData%OLDSEP))
      Int_Xferred   = Int_Xferred   + SIZE(InData%OLDSEP)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CC
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%CDO) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CDO,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CDO,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CDO,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CDO,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CDO)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CDO))-1 ) = PACK(InData%CDO,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CDO)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CMI
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CMQ
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CN
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%CNA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNA,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNA)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNA))-1 ) = PACK(InData%CNA,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNA)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CNCP
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CNIQ
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%CNP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNP))-1 ) = PACK(InData%CNP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNP)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNP1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNP1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNP1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNP1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNP1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNP1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNP1))-1 ) = PACK(InData%CNP1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNP1)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNPD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPD,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPD,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPD,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNPD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNPD))-1 ) = PACK(InData%CNPD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNPD)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNPD1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPD1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPD1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPD1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPD1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNPD1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNPD1))-1 ) = PACK(InData%CNPD1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNPD1)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNPOT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPOT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPOT,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPOT,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPOT,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNPOT)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNPOT))-1 ) = PACK(InData%CNPOT,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNPOT)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNPOT1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPOT1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPOT1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNPOT1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNPOT1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNPOT1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNPOT1))-1 ) = PACK(InData%CNPOT1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNPOT1)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNS) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNS,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNS,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNS,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNS,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNS)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNS))-1 ) = PACK(InData%CNS,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNS)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNSL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNSL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNSL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNSL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNSL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNSL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNSL))-1 ) = PACK(InData%CNSL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNSL)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNV,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNV,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNV,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNV)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNV))-1 ) = PACK(InData%CNV,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNV)
  END IF
  IF ( .NOT. ALLOCATED(InData%CVN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CVN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CVN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CVN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CVN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CVN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CVN))-1 ) = PACK(InData%CVN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CVN)
  END IF
  IF ( .NOT. ALLOCATED(InData%CVN1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CVN1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CVN1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CVN1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CVN1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CVN1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CVN1))-1 ) = PACK(InData%CVN1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CVN1)
  END IF
  IF ( .NOT. ALLOCATED(InData%DF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DF,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DF,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DF,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DF)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DF))-1 ) = PACK(InData%DF,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DF)
  END IF
  IF ( .NOT. ALLOCATED(InData%DFAFE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFAFE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFAFE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFAFE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFAFE,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DFAFE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DFAFE))-1 ) = PACK(InData%DFAFE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DFAFE)
  END IF
  IF ( .NOT. ALLOCATED(InData%DFAFE1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFAFE1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFAFE1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFAFE1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFAFE1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DFAFE1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DFAFE1))-1 ) = PACK(InData%DFAFE1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DFAFE1)
  END IF
  IF ( .NOT. ALLOCATED(InData%DFC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFC,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFC,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFC,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DFC)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DFC))-1 ) = PACK(InData%DFC,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DFC)
  END IF
  IF ( .NOT. ALLOCATED(InData%DN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DN))-1 ) = PACK(InData%DN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DN)
  END IF
  IF ( .NOT. ALLOCATED(InData%DPP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DPP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DPP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DPP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DPP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DPP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DPP))-1 ) = PACK(InData%DPP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DPP)
  END IF
  IF ( .NOT. ALLOCATED(InData%DQ) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQ,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQ,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQ,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQ,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DQ)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DQ))-1 ) = PACK(InData%DQ,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DQ)
  END IF
  IF ( .NOT. ALLOCATED(InData%DQP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DQP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DQP))-1 ) = PACK(InData%DQP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DQP)
  END IF
  IF ( .NOT. ALLOCATED(InData%DQP1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQP1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQP1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DQP1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DQP1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DQP1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DQP1))-1 ) = PACK(InData%DQP1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DQP1)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%DS
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FK
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FP
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FPC
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%FSP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FSP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FSP))-1 ) = PACK(InData%FSP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FSP)
  END IF
  IF ( .NOT. ALLOCATED(InData%FSP1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSP1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSP1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSP1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSP1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FSP1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FSP1))-1 ) = PACK(InData%FSP1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FSP1)
  END IF
  IF ( .NOT. ALLOCATED(InData%FSPC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSPC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSPC,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSPC,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSPC,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FSPC)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FSPC))-1 ) = PACK(InData%FSPC,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FSPC)
  END IF
  IF ( .NOT. ALLOCATED(InData%FSPC1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSPC1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSPC1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FSPC1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FSPC1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FSPC1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FSPC1))-1 ) = PACK(InData%FSPC1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FSPC1)
  END IF
  IF ( .NOT. ALLOCATED(InData%FTB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTB,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTB,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTB,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTB,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTB,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FTB)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FTB))-1 ) = PACK(InData%FTB,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FTB)
  END IF
  IF ( .NOT. ALLOCATED(InData%FTBC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTBC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTBC,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTBC,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTBC,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FTBC,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FTBC,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%FTBC)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FTBC))-1 ) = PACK(InData%FTBC,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%FTBC)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDCNV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDCNV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDCNV,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDCNV,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDCNV,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDCNV)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDCNV))-1 ) = PACK(InData%OLDCNV,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDCNV)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDDF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDF,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDF,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDF,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDDF)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDDF))-1 ) = PACK(InData%OLDDF,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDDF)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDDFC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDFC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDFC,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDFC,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDFC,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDDFC)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDDFC))-1 ) = PACK(InData%OLDDFC,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDDFC)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDDN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDDN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDDN))-1 ) = PACK(InData%OLDDN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDDN)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDDPP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDPP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDPP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDPP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDPP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDDPP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDDPP))-1 ) = PACK(InData%OLDDPP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDDPP)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDDQ) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDQ,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDQ,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDDQ,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDDQ,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDDQ)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDDQ))-1 ) = PACK(InData%OLDDQ,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDDQ)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDTAU) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDTAU,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDTAU,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDTAU,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDTAU,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDTAU)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDTAU))-1 ) = PACK(InData%OLDTAU,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDTAU)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDXN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDXN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDXN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDXN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDXN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDXN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDXN))-1 ) = PACK(InData%OLDXN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDXN)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLDYN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDYN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDYN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLDYN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLDYN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLDYN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLDYN))-1 ) = PACK(InData%OLDYN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLDYN)
  END IF
  IF ( .NOT. ALLOCATED(InData%QX) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%QX,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%QX,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%QX,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%QX,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%QX)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%QX))-1 ) = PACK(InData%QX,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%QX)
  END IF
  IF ( .NOT. ALLOCATED(InData%QX1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%QX1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%QX1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%QX1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%QX1,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%QX1)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%QX1))-1 ) = PACK(InData%QX1,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%QX1)
  END IF
  IF ( .NOT. ALLOCATED(InData%TAU) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TAU,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TAU,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TAU,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TAU,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TAU)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TAU))-1 ) = PACK(InData%TAU,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TAU)
  END IF
  IF ( .NOT. ALLOCATED(InData%XN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%XN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%XN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%XN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%XN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%XN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%XN))-1 ) = PACK(InData%XN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%XN)
  END IF
  IF ( .NOT. ALLOCATED(InData%YN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%YN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%YN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%YN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%YN,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%YN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%YN))-1 ) = PACK(InData%YN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%YN)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%SHIFT , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%VOR , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AD14_PackBeddoes

 SUBROUTINE AD14_UnPackBeddoes( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Beddoes), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackBeddoes'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ADOT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ADOT)) DEALLOCATE(OutData%ADOT)
    ALLOCATE(OutData%ADOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%ADOT)>0) OutData%ADOT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ADOT))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ADOT)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ADOT1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ADOT1)) DEALLOCATE(OutData%ADOT1)
    ALLOCATE(OutData%ADOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%ADOT1)>0) OutData%ADOT1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ADOT1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ADOT1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AFE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AFE)) DEALLOCATE(OutData%AFE)
    ALLOCATE(OutData%AFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AFE)>0) OutData%AFE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AFE))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AFE)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AFE1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AFE1)) DEALLOCATE(OutData%AFE1)
    ALLOCATE(OutData%AFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AFE1)>0) OutData%AFE1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AFE1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AFE1)
    DEALLOCATE(mask2)
  END IF
      OutData%AN = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ANE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ANE)) DEALLOCATE(OutData%ANE)
    ALLOCATE(OutData%ANE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%ANE)>0) OutData%ANE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANE))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ANE)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ANE1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ANE1)) DEALLOCATE(OutData%ANE1)
    ALLOCATE(OutData%ANE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%ANE1)>0) OutData%ANE1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANE1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ANE1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AOD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AOD)) DEALLOCATE(OutData%AOD)
    ALLOCATE(OutData%AOD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AOD)>0) OutData%AOD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AOD))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AOD)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AOL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AOL)) DEALLOCATE(OutData%AOL)
    ALLOCATE(OutData%AOL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AOL)>0) OutData%AOL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AOL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AOL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BEDSEP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BEDSEP)) DEALLOCATE(OutData%BEDSEP)
    ALLOCATE(OutData%BEDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BEDSEP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%BEDSEP)>0) OutData%BEDSEP = UNPACK( TRANSFER( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%BEDSEP))-1 ), OutData%BEDSEP), mask2,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(OutData%BEDSEP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDSEP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDSEP)) DEALLOCATE(OutData%OLDSEP)
    ALLOCATE(OutData%OLDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDSEP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDSEP)>0) OutData%OLDSEP = UNPACK( TRANSFER( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%OLDSEP))-1 ), OutData%OLDSEP), mask2,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(OutData%OLDSEP)
    DEALLOCATE(mask2)
  END IF
      OutData%CC = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CDO not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CDO)) DEALLOCATE(OutData%CDO)
    ALLOCATE(OutData%CDO(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDO.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CDO)>0) OutData%CDO = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CDO))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CDO)
    DEALLOCATE(mask2)
  END IF
      OutData%CMI = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CMQ = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CN = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNA)) DEALLOCATE(OutData%CNA)
    ALLOCATE(OutData%CNA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNA)>0) OutData%CNA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNA))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNA)
    DEALLOCATE(mask2)
  END IF
      OutData%CNCP = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CNIQ = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNP)) DEALLOCATE(OutData%CNP)
    ALLOCATE(OutData%CNP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNP)>0) OutData%CNP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNP1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNP1)) DEALLOCATE(OutData%CNP1)
    ALLOCATE(OutData%CNP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNP1)>0) OutData%CNP1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNP1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNP1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNPD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNPD)) DEALLOCATE(OutData%CNPD)
    ALLOCATE(OutData%CNPD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNPD)>0) OutData%CNPD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNPD))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNPD)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNPD1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNPD1)) DEALLOCATE(OutData%CNPD1)
    ALLOCATE(OutData%CNPD1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNPD1)>0) OutData%CNPD1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNPD1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNPD1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNPOT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNPOT)) DEALLOCATE(OutData%CNPOT)
    ALLOCATE(OutData%CNPOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNPOT)>0) OutData%CNPOT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNPOT))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNPOT)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNPOT1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNPOT1)) DEALLOCATE(OutData%CNPOT1)
    ALLOCATE(OutData%CNPOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNPOT1)>0) OutData%CNPOT1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNPOT1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNPOT1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNS not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNS)) DEALLOCATE(OutData%CNS)
    ALLOCATE(OutData%CNS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNS.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNS)>0) OutData%CNS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNS))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNS)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNSL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNSL)) DEALLOCATE(OutData%CNSL)
    ALLOCATE(OutData%CNSL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNSL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNSL)>0) OutData%CNSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNSL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNSL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNV)) DEALLOCATE(OutData%CNV)
    ALLOCATE(OutData%CNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CNV)>0) OutData%CNV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNV))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNV)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CVN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CVN)) DEALLOCATE(OutData%CVN)
    ALLOCATE(OutData%CVN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CVN)>0) OutData%CVN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CVN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CVN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CVN1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CVN1)) DEALLOCATE(OutData%CVN1)
    ALLOCATE(OutData%CVN1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%CVN1)>0) OutData%CVN1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CVN1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CVN1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DF)) DEALLOCATE(OutData%DF)
    ALLOCATE(OutData%DF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DF)>0) OutData%DF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DF))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DF)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DFAFE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DFAFE)) DEALLOCATE(OutData%DFAFE)
    ALLOCATE(OutData%DFAFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DFAFE)>0) OutData%DFAFE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DFAFE))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DFAFE)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DFAFE1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DFAFE1)) DEALLOCATE(OutData%DFAFE1)
    ALLOCATE(OutData%DFAFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DFAFE1)>0) OutData%DFAFE1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DFAFE1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DFAFE1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DFC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DFC)) DEALLOCATE(OutData%DFC)
    ALLOCATE(OutData%DFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DFC)>0) OutData%DFC = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DFC))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DFC)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DN)) DEALLOCATE(OutData%DN)
    ALLOCATE(OutData%DN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DN)>0) OutData%DN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DPP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DPP)) DEALLOCATE(OutData%DPP)
    ALLOCATE(OutData%DPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DPP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DPP)>0) OutData%DPP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DPP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DPP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DQ not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DQ)) DEALLOCATE(OutData%DQ)
    ALLOCATE(OutData%DQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQ.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DQ)>0) OutData%DQ = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DQ))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DQ)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DQP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DQP)) DEALLOCATE(OutData%DQP)
    ALLOCATE(OutData%DQP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DQP)>0) OutData%DQP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DQP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DQP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DQP1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DQP1)) DEALLOCATE(OutData%DQP1)
    ALLOCATE(OutData%DQP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%DQP1)>0) OutData%DQP1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DQP1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DQP1)
    DEALLOCATE(mask2)
  END IF
      OutData%DS = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FK = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FP = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FPC = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FSP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FSP)) DEALLOCATE(OutData%FSP)
    ALLOCATE(OutData%FSP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%FSP)>0) OutData%FSP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FSP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FSP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FSP1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FSP1)) DEALLOCATE(OutData%FSP1)
    ALLOCATE(OutData%FSP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%FSP1)>0) OutData%FSP1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FSP1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FSP1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FSPC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FSPC)) DEALLOCATE(OutData%FSPC)
    ALLOCATE(OutData%FSPC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%FSPC)>0) OutData%FSPC = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FSPC))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FSPC)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FSPC1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FSPC1)) DEALLOCATE(OutData%FSPC1)
    ALLOCATE(OutData%FSPC1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%FSPC1)>0) OutData%FSPC1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FSPC1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FSPC1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FTB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FTB)) DEALLOCATE(OutData%FTB)
    ALLOCATE(OutData%FTB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%FTB)>0) OutData%FTB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FTB))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FTB)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FTBC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FTBC)) DEALLOCATE(OutData%FTBC)
    ALLOCATE(OutData%FTBC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTBC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%FTBC)>0) OutData%FTBC = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FTBC))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%FTBC)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDCNV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDCNV)) DEALLOCATE(OutData%OLDCNV)
    ALLOCATE(OutData%OLDCNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDCNV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDCNV)>0) OutData%OLDCNV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDCNV))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDCNV)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDDF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDDF)) DEALLOCATE(OutData%OLDDF)
    ALLOCATE(OutData%OLDDF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDDF)>0) OutData%OLDDF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDDF))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDDF)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDDFC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDDFC)) DEALLOCATE(OutData%OLDDFC)
    ALLOCATE(OutData%OLDDFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDFC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDDFC)>0) OutData%OLDDFC = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDDFC))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDDFC)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDDN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDDN)) DEALLOCATE(OutData%OLDDN)
    ALLOCATE(OutData%OLDDN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDDN)>0) OutData%OLDDN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDDN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDDN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDDPP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDDPP)) DEALLOCATE(OutData%OLDDPP)
    ALLOCATE(OutData%OLDDPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDPP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDDPP)>0) OutData%OLDDPP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDDPP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDDPP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDDQ not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDDQ)) DEALLOCATE(OutData%OLDDQ)
    ALLOCATE(OutData%OLDDQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDQ.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDDQ)>0) OutData%OLDDQ = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDDQ))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDDQ)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDTAU not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDTAU)) DEALLOCATE(OutData%OLDTAU)
    ALLOCATE(OutData%OLDTAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDTAU.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDTAU)>0) OutData%OLDTAU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDTAU))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDTAU)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDXN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDXN)) DEALLOCATE(OutData%OLDXN)
    ALLOCATE(OutData%OLDXN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDXN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDXN)>0) OutData%OLDXN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDXN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDXN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLDYN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLDYN)) DEALLOCATE(OutData%OLDYN)
    ALLOCATE(OutData%OLDYN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDYN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLDYN)>0) OutData%OLDYN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLDYN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLDYN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! QX not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%QX)) DEALLOCATE(OutData%QX)
    ALLOCATE(OutData%QX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%QX)>0) OutData%QX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%QX))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%QX)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! QX1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%QX1)) DEALLOCATE(OutData%QX1)
    ALLOCATE(OutData%QX1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%QX1)>0) OutData%QX1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%QX1))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%QX1)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TAU not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TAU)) DEALLOCATE(OutData%TAU)
    ALLOCATE(OutData%TAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TAU.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%TAU)>0) OutData%TAU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TAU))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TAU)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! XN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%XN)) DEALLOCATE(OutData%XN)
    ALLOCATE(OutData%XN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%XN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%XN)>0) OutData%XN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%XN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%XN)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! YN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%YN)) DEALLOCATE(OutData%YN)
    ALLOCATE(OutData%YN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%YN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%YN)>0) OutData%YN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%YN))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%YN)
    DEALLOCATE(mask2)
  END IF
      OutData%SHIFT = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%VOR = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE AD14_UnPackBeddoes

 SUBROUTINE AD14_CopyBeddoesParms( SrcBeddoesParmsData, DstBeddoesParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BeddoesParms), INTENT(IN) :: SrcBeddoesParmsData
   TYPE(BeddoesParms), INTENT(INOUT) :: DstBeddoesParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBeddoesParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBeddoesParmsData%AS = SrcBeddoesParmsData%AS
    DstBeddoesParmsData%TF = SrcBeddoesParmsData%TF
    DstBeddoesParmsData%TP = SrcBeddoesParmsData%TP
    DstBeddoesParmsData%TV = SrcBeddoesParmsData%TV
    DstBeddoesParmsData%TVL = SrcBeddoesParmsData%TVL
 END SUBROUTINE AD14_CopyBeddoesParms

 SUBROUTINE AD14_DestroyBeddoesParms( BeddoesParmsData, ErrStat, ErrMsg )
  TYPE(BeddoesParms), INTENT(INOUT) :: BeddoesParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBeddoesParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyBeddoesParms

 SUBROUTINE AD14_PackBeddoesParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BeddoesParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackBeddoesParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! AS
      Re_BufSz   = Re_BufSz   + 1  ! TF
      Re_BufSz   = Re_BufSz   + 1  ! TP
      Re_BufSz   = Re_BufSz   + 1  ! TV
      Re_BufSz   = Re_BufSz   + 1  ! TVL
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%AS
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TF
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TP
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TV
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TVL
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackBeddoesParms

 SUBROUTINE AD14_UnPackBeddoesParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BeddoesParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackBeddoesParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%AS = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TF = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TP = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TV = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TVL = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackBeddoesParms

 SUBROUTINE AD14_CopyBladeParms( SrcBladeParmsData, DstBladeParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BladeParms), INTENT(IN) :: SrcBladeParmsData
   TYPE(BladeParms), INTENT(INOUT) :: DstBladeParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBladeParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBladeParmsData%C)) THEN
  i1_l = LBOUND(SrcBladeParmsData%C,1)
  i1_u = UBOUND(SrcBladeParmsData%C,1)
  IF (.NOT. ALLOCATED(DstBladeParmsData%C)) THEN 
    ALLOCATE(DstBladeParmsData%C(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%C.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladeParmsData%C = SrcBladeParmsData%C
ENDIF
IF (ALLOCATED(SrcBladeParmsData%DR)) THEN
  i1_l = LBOUND(SrcBladeParmsData%DR,1)
  i1_u = UBOUND(SrcBladeParmsData%DR,1)
  IF (.NOT. ALLOCATED(DstBladeParmsData%DR)) THEN 
    ALLOCATE(DstBladeParmsData%DR(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%DR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladeParmsData%DR = SrcBladeParmsData%DR
ENDIF
    DstBladeParmsData%R = SrcBladeParmsData%R
    DstBladeParmsData%BladeLength = SrcBladeParmsData%BladeLength
 END SUBROUTINE AD14_CopyBladeParms

 SUBROUTINE AD14_DestroyBladeParms( BladeParmsData, ErrStat, ErrMsg )
  TYPE(BladeParms), INTENT(INOUT) :: BladeParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBladeParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(BladeParmsData%C)) THEN
  DEALLOCATE(BladeParmsData%C)
ENDIF
IF (ALLOCATED(BladeParmsData%DR)) THEN
  DEALLOCATE(BladeParmsData%DR)
ENDIF
 END SUBROUTINE AD14_DestroyBladeParms

 SUBROUTINE AD14_PackBladeParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BladeParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackBladeParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! C allocated yes/no
  IF ( ALLOCATED(InData%C) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! C upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%C)  ! C
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DR allocated yes/no
  IF ( ALLOCATED(InData%DR) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! DR upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DR)  ! DR
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! R
      Re_BufSz   = Re_BufSz   + 1  ! BladeLength
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%C) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%C,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%C,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%C)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C))-1 ) = PACK(InData%C,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%C)
  END IF
  IF ( .NOT. ALLOCATED(InData%DR) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DR,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DR,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DR)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DR))-1 ) = PACK(InData%DR,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DR)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%R
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%BladeLength
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackBladeParms

 SUBROUTINE AD14_UnPackBladeParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BladeParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackBladeParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! C not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%C)) DEALLOCATE(OutData%C)
    ALLOCATE(OutData%C(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%C.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%C)>0) OutData%C = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%C)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DR not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DR)) DEALLOCATE(OutData%DR)
    ALLOCATE(OutData%DR(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DR.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%DR)>0) OutData%DR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DR))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DR)
    DEALLOCATE(mask1)
  END IF
      OutData%R = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%BladeLength = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackBladeParms

 SUBROUTINE AD14_CopyDynInflow( SrcDynInflowData, DstDynInflowData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DynInflow), INTENT(IN) :: SrcDynInflowData
   TYPE(DynInflow), INTENT(INOUT) :: DstDynInflowData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDynInflow'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDynInflowData%dAlph_dt = SrcDynInflowData%dAlph_dt
    DstDynInflowData%dBeta_dt = SrcDynInflowData%dBeta_dt
    DstDynInflowData%DTO = SrcDynInflowData%DTO
    DstDynInflowData%old_Alph = SrcDynInflowData%old_Alph
    DstDynInflowData%old_Beta = SrcDynInflowData%old_Beta
    DstDynInflowData%old_LmdM = SrcDynInflowData%old_LmdM
    DstDynInflowData%oldKai = SrcDynInflowData%oldKai
    DstDynInflowData%PhiLqC = SrcDynInflowData%PhiLqC
    DstDynInflowData%PhiLqS = SrcDynInflowData%PhiLqS
    DstDynInflowData%Pzero = SrcDynInflowData%Pzero
IF (ALLOCATED(SrcDynInflowData%RMC_SAVE)) THEN
  i1_l = LBOUND(SrcDynInflowData%RMC_SAVE,1)
  i1_u = UBOUND(SrcDynInflowData%RMC_SAVE,1)
  i2_l = LBOUND(SrcDynInflowData%RMC_SAVE,2)
  i2_u = UBOUND(SrcDynInflowData%RMC_SAVE,2)
  i3_l = LBOUND(SrcDynInflowData%RMC_SAVE,3)
  i3_u = UBOUND(SrcDynInflowData%RMC_SAVE,3)
  IF (.NOT. ALLOCATED(DstDynInflowData%RMC_SAVE)) THEN 
    ALLOCATE(DstDynInflowData%RMC_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMC_SAVE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDynInflowData%RMC_SAVE = SrcDynInflowData%RMC_SAVE
ENDIF
IF (ALLOCATED(SrcDynInflowData%RMS_SAVE)) THEN
  i1_l = LBOUND(SrcDynInflowData%RMS_SAVE,1)
  i1_u = UBOUND(SrcDynInflowData%RMS_SAVE,1)
  i2_l = LBOUND(SrcDynInflowData%RMS_SAVE,2)
  i2_u = UBOUND(SrcDynInflowData%RMS_SAVE,2)
  i3_l = LBOUND(SrcDynInflowData%RMS_SAVE,3)
  i3_u = UBOUND(SrcDynInflowData%RMS_SAVE,3)
  IF (.NOT. ALLOCATED(DstDynInflowData%RMS_SAVE)) THEN 
    ALLOCATE(DstDynInflowData%RMS_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMS_SAVE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDynInflowData%RMS_SAVE = SrcDynInflowData%RMS_SAVE
ENDIF
    DstDynInflowData%TipSpeed = SrcDynInflowData%TipSpeed
    DstDynInflowData%totalInf = SrcDynInflowData%totalInf
    DstDynInflowData%Vparam = SrcDynInflowData%Vparam
    DstDynInflowData%Vtotal = SrcDynInflowData%Vtotal
    DstDynInflowData%xAlpha = SrcDynInflowData%xAlpha
    DstDynInflowData%xBeta = SrcDynInflowData%xBeta
    DstDynInflowData%xKai = SrcDynInflowData%xKai
    DstDynInflowData%XLAMBDA_M = SrcDynInflowData%XLAMBDA_M
    DstDynInflowData%xLcos = SrcDynInflowData%xLcos
    DstDynInflowData%xLsin = SrcDynInflowData%xLsin
    DstDynInflowData%MminR = SrcDynInflowData%MminR
    DstDynInflowData%MminusR = SrcDynInflowData%MminusR
    DstDynInflowData%MplusR = SrcDynInflowData%MplusR
    DstDynInflowData%GAMMA = SrcDynInflowData%GAMMA
 END SUBROUTINE AD14_CopyDynInflow

 SUBROUTINE AD14_DestroyDynInflow( DynInflowData, ErrStat, ErrMsg )
  TYPE(DynInflow), INTENT(INOUT) :: DynInflowData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDynInflow'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(DynInflowData%RMC_SAVE)) THEN
  DEALLOCATE(DynInflowData%RMC_SAVE)
ENDIF
IF (ALLOCATED(DynInflowData%RMS_SAVE)) THEN
  DEALLOCATE(DynInflowData%RMS_SAVE)
ENDIF
 END SUBROUTINE AD14_DestroyDynInflow

 SUBROUTINE AD14_PackDynInflow( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DynInflow),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackDynInflow'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + SIZE(InData%dAlph_dt)  ! dAlph_dt
      Re_BufSz   = Re_BufSz   + SIZE(InData%dBeta_dt)  ! dBeta_dt
      Re_BufSz   = Re_BufSz   + 1  ! DTO
      Re_BufSz   = Re_BufSz   + SIZE(InData%old_Alph)  ! old_Alph
      Re_BufSz   = Re_BufSz   + SIZE(InData%old_Beta)  ! old_Beta
      Re_BufSz   = Re_BufSz   + 1  ! old_LmdM
      Re_BufSz   = Re_BufSz   + 1  ! oldKai
      Re_BufSz   = Re_BufSz   + SIZE(InData%PhiLqC)  ! PhiLqC
      Re_BufSz   = Re_BufSz   + SIZE(InData%PhiLqS)  ! PhiLqS
      Re_BufSz   = Re_BufSz   + 1  ! Pzero
  Int_BufSz   = Int_BufSz   + 1     ! RMC_SAVE allocated yes/no
  IF ( ALLOCATED(InData%RMC_SAVE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! RMC_SAVE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RMC_SAVE)  ! RMC_SAVE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RMS_SAVE allocated yes/no
  IF ( ALLOCATED(InData%RMS_SAVE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! RMS_SAVE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RMS_SAVE)  ! RMS_SAVE
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! TipSpeed
      Re_BufSz   = Re_BufSz   + 1  ! totalInf
      Re_BufSz   = Re_BufSz   + 1  ! Vparam
      Re_BufSz   = Re_BufSz   + 1  ! Vtotal
      Re_BufSz   = Re_BufSz   + SIZE(InData%xAlpha)  ! xAlpha
      Re_BufSz   = Re_BufSz   + SIZE(InData%xBeta)  ! xBeta
      Re_BufSz   = Re_BufSz   + 1  ! xKai
      Re_BufSz   = Re_BufSz   + 1  ! XLAMBDA_M
      Re_BufSz   = Re_BufSz   + SIZE(InData%xLcos)  ! xLcos
      Re_BufSz   = Re_BufSz   + SIZE(InData%xLsin)  ! xLsin
      Int_BufSz  = Int_BufSz  + SIZE(InData%MminR)  ! MminR
      Int_BufSz  = Int_BufSz  + SIZE(InData%MminusR)  ! MminusR
      Int_BufSz  = Int_BufSz  + SIZE(InData%MplusR)  ! MplusR
      Re_BufSz   = Re_BufSz   + SIZE(InData%GAMMA)  ! GAMMA
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%dAlph_dt))-1 ) = PACK(InData%dAlph_dt,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%dAlph_dt)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%dBeta_dt))-1 ) = PACK(InData%dBeta_dt,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%dBeta_dt)
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%DTO
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%old_Alph))-1 ) = PACK(InData%old_Alph,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%old_Alph)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%old_Beta))-1 ) = PACK(InData%old_Beta,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%old_Beta)
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%old_LmdM
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%oldKai
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiLqC))-1 ) = PACK(InData%PhiLqC,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%PhiLqC)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiLqS))-1 ) = PACK(InData%PhiLqS,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%PhiLqS)
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Pzero
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%RMC_SAVE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMC_SAVE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMC_SAVE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMC_SAVE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMC_SAVE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMC_SAVE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMC_SAVE,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%RMC_SAVE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RMC_SAVE))-1 ) = PACK(InData%RMC_SAVE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%RMC_SAVE)
  END IF
  IF ( .NOT. ALLOCATED(InData%RMS_SAVE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMS_SAVE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMS_SAVE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMS_SAVE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMS_SAVE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RMS_SAVE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RMS_SAVE,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%RMS_SAVE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RMS_SAVE))-1 ) = PACK(InData%RMS_SAVE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%RMS_SAVE)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TipSpeed
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%totalInf
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Vparam
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Vtotal
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%xAlpha))-1 ) = PACK(InData%xAlpha,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%xAlpha)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%xBeta))-1 ) = PACK(InData%xBeta,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%xBeta)
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%xKai
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%XLAMBDA_M
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%xLcos))-1 ) = PACK(InData%xLcos,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%xLcos)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%xLsin))-1 ) = PACK(InData%xLsin,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%xLsin)
      IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MminR))-1 ) = PACK(InData%MminR,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%MminR)
      IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MminusR))-1 ) = PACK(InData%MminusR,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%MminusR)
      IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MplusR))-1 ) = PACK(InData%MplusR,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%MplusR)
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GAMMA))-1 ) = PACK(InData%GAMMA,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%GAMMA)
 END SUBROUTINE AD14_PackDynInflow

 SUBROUTINE AD14_UnPackDynInflow( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DynInflow), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackDynInflow'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    i1_l = LBOUND(OutData%dAlph_dt,1)
    i1_u = UBOUND(OutData%dAlph_dt,1)
    i2_l = LBOUND(OutData%dAlph_dt,2)
    i2_u = UBOUND(OutData%dAlph_dt,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%dAlph_dt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%dAlph_dt))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%dAlph_dt)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%dBeta_dt,1)
    i1_u = UBOUND(OutData%dBeta_dt,1)
    i2_l = LBOUND(OutData%dBeta_dt,2)
    i2_u = UBOUND(OutData%dBeta_dt,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%dBeta_dt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%dBeta_dt))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%dBeta_dt)
    DEALLOCATE(mask2)
      OutData%DTO = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
    i1_l = LBOUND(OutData%old_Alph,1)
    i1_u = UBOUND(OutData%old_Alph,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%old_Alph = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%old_Alph))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%old_Alph)
    DEALLOCATE(mask1)
    i1_l = LBOUND(OutData%old_Beta,1)
    i1_u = UBOUND(OutData%old_Beta,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%old_Beta = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%old_Beta))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%old_Beta)
    DEALLOCATE(mask1)
      OutData%old_LmdM = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%oldKai = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
    i1_l = LBOUND(OutData%PhiLqC,1)
    i1_u = UBOUND(OutData%PhiLqC,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%PhiLqC = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiLqC))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiLqC)
    DEALLOCATE(mask1)
    i1_l = LBOUND(OutData%PhiLqS,1)
    i1_u = UBOUND(OutData%PhiLqS,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%PhiLqS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiLqS))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiLqS)
    DEALLOCATE(mask1)
      OutData%Pzero = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RMC_SAVE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RMC_SAVE)) DEALLOCATE(OutData%RMC_SAVE)
    ALLOCATE(OutData%RMC_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMC_SAVE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%RMC_SAVE)>0) OutData%RMC_SAVE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RMC_SAVE))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%RMC_SAVE)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RMS_SAVE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RMS_SAVE)) DEALLOCATE(OutData%RMS_SAVE)
    ALLOCATE(OutData%RMS_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMS_SAVE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%RMS_SAVE)>0) OutData%RMS_SAVE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RMS_SAVE))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%RMS_SAVE)
    DEALLOCATE(mask3)
  END IF
      OutData%TipSpeed = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%totalInf = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%Vparam = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%Vtotal = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
    i1_l = LBOUND(OutData%xAlpha,1)
    i1_u = UBOUND(OutData%xAlpha,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%xAlpha = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%xAlpha))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%xAlpha)
    DEALLOCATE(mask1)
    i1_l = LBOUND(OutData%xBeta,1)
    i1_u = UBOUND(OutData%xBeta,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%xBeta = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%xBeta))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%xBeta)
    DEALLOCATE(mask1)
      OutData%xKai = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%XLAMBDA_M = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
    i1_l = LBOUND(OutData%xLcos,1)
    i1_u = UBOUND(OutData%xLcos,1)
    i2_l = LBOUND(OutData%xLcos,2)
    i2_u = UBOUND(OutData%xLcos,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%xLcos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%xLcos))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%xLcos)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%xLsin,1)
    i1_u = UBOUND(OutData%xLsin,1)
    i2_l = LBOUND(OutData%xLsin,2)
    i2_u = UBOUND(OutData%xLsin,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%xLsin = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%xLsin))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%xLsin)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%MminR,1)
    i1_u = UBOUND(OutData%MminR,1)
    i2_l = LBOUND(OutData%MminR,2)
    i2_u = UBOUND(OutData%MminR,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%MminR = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%MminR))-1 ), mask2, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%MminR)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%MminusR,1)
    i1_u = UBOUND(OutData%MminusR,1)
    i2_l = LBOUND(OutData%MminusR,2)
    i2_u = UBOUND(OutData%MminusR,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%MminusR = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%MminusR))-1 ), mask2, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%MminusR)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%MplusR,1)
    i1_u = UBOUND(OutData%MplusR,1)
    i2_l = LBOUND(OutData%MplusR,2)
    i2_u = UBOUND(OutData%MplusR,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%MplusR = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%MplusR))-1 ), mask2, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%MplusR)
    DEALLOCATE(mask2)
    i1_l = LBOUND(OutData%GAMMA,1)
    i1_u = UBOUND(OutData%GAMMA,1)
    i2_l = LBOUND(OutData%GAMMA,2)
    i2_u = UBOUND(OutData%GAMMA,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%GAMMA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GAMMA))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%GAMMA)
    DEALLOCATE(mask2)
 END SUBROUTINE AD14_UnPackDynInflow

 SUBROUTINE AD14_CopyDynInflowParms( SrcDynInflowParmsData, DstDynInflowParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DynInflowParms), INTENT(IN) :: SrcDynInflowParmsData
   TYPE(DynInflowParms), INTENT(INOUT) :: DstDynInflowParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDynInflowParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDynInflowParmsData%MAXINFLO = SrcDynInflowParmsData%MAXINFLO
    DstDynInflowParmsData%xMinv = SrcDynInflowParmsData%xMinv
 END SUBROUTINE AD14_CopyDynInflowParms

 SUBROUTINE AD14_DestroyDynInflowParms( DynInflowParmsData, ErrStat, ErrMsg )
  TYPE(DynInflowParms), INTENT(INOUT) :: DynInflowParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDynInflowParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyDynInflowParms

 SUBROUTINE AD14_PackDynInflowParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DynInflowParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackDynInflowParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MAXINFLO
      Re_BufSz   = Re_BufSz   + SIZE(InData%xMinv)  ! xMinv
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%MAXINFLO
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%xMinv))-1 ) = PACK(InData%xMinv,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%xMinv)
 END SUBROUTINE AD14_PackDynInflowParms

 SUBROUTINE AD14_UnPackDynInflowParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DynInflowParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackDynInflowParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%MAXINFLO = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
    i1_l = LBOUND(OutData%xMinv,1)
    i1_u = UBOUND(OutData%xMinv,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%xMinv = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%xMinv))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%xMinv)
    DEALLOCATE(mask1)
 END SUBROUTINE AD14_UnPackDynInflowParms

 SUBROUTINE AD14_CopyElement( SrcElementData, DstElementData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Element), INTENT(IN) :: SrcElementData
   TYPE(Element), INTENT(INOUT) :: DstElementData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElement'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcElementData%A)) THEN
  i1_l = LBOUND(SrcElementData%A,1)
  i1_u = UBOUND(SrcElementData%A,1)
  i2_l = LBOUND(SrcElementData%A,2)
  i2_u = UBOUND(SrcElementData%A,2)
  IF (.NOT. ALLOCATED(DstElementData%A)) THEN 
    ALLOCATE(DstElementData%A(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%A.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%A = SrcElementData%A
ENDIF
IF (ALLOCATED(SrcElementData%AP)) THEN
  i1_l = LBOUND(SrcElementData%AP,1)
  i1_u = UBOUND(SrcElementData%AP,1)
  i2_l = LBOUND(SrcElementData%AP,2)
  i2_u = UBOUND(SrcElementData%AP,2)
  IF (.NOT. ALLOCATED(DstElementData%AP)) THEN 
    ALLOCATE(DstElementData%AP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%AP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%AP = SrcElementData%AP
ENDIF
IF (ALLOCATED(SrcElementData%ALPHA)) THEN
  i1_l = LBOUND(SrcElementData%ALPHA,1)
  i1_u = UBOUND(SrcElementData%ALPHA,1)
  i2_l = LBOUND(SrcElementData%ALPHA,2)
  i2_u = UBOUND(SrcElementData%ALPHA,2)
  IF (.NOT. ALLOCATED(DstElementData%ALPHA)) THEN 
    ALLOCATE(DstElementData%ALPHA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%ALPHA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%ALPHA = SrcElementData%ALPHA
ENDIF
IF (ALLOCATED(SrcElementData%W2)) THEN
  i1_l = LBOUND(SrcElementData%W2,1)
  i1_u = UBOUND(SrcElementData%W2,1)
  i2_l = LBOUND(SrcElementData%W2,2)
  i2_u = UBOUND(SrcElementData%W2,2)
  IF (.NOT. ALLOCATED(DstElementData%W2)) THEN 
    ALLOCATE(DstElementData%W2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%W2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%W2 = SrcElementData%W2
ENDIF
IF (ALLOCATED(SrcElementData%OLD_A_NS)) THEN
  i1_l = LBOUND(SrcElementData%OLD_A_NS,1)
  i1_u = UBOUND(SrcElementData%OLD_A_NS,1)
  i2_l = LBOUND(SrcElementData%OLD_A_NS,2)
  i2_u = UBOUND(SrcElementData%OLD_A_NS,2)
  IF (.NOT. ALLOCATED(DstElementData%OLD_A_NS)) THEN 
    ALLOCATE(DstElementData%OLD_A_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_A_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%OLD_A_NS = SrcElementData%OLD_A_NS
ENDIF
IF (ALLOCATED(SrcElementData%OLD_AP_NS)) THEN
  i1_l = LBOUND(SrcElementData%OLD_AP_NS,1)
  i1_u = UBOUND(SrcElementData%OLD_AP_NS,1)
  i2_l = LBOUND(SrcElementData%OLD_AP_NS,2)
  i2_u = UBOUND(SrcElementData%OLD_AP_NS,2)
  IF (.NOT. ALLOCATED(DstElementData%OLD_AP_NS)) THEN 
    ALLOCATE(DstElementData%OLD_AP_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_AP_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%OLD_AP_NS = SrcElementData%OLD_AP_NS
ENDIF
    DstElementData%PITNOW = SrcElementData%PITNOW
 END SUBROUTINE AD14_CopyElement

 SUBROUTINE AD14_DestroyElement( ElementData, ErrStat, ErrMsg )
  TYPE(Element), INTENT(INOUT) :: ElementData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElement'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ElementData%A)) THEN
  DEALLOCATE(ElementData%A)
ENDIF
IF (ALLOCATED(ElementData%AP)) THEN
  DEALLOCATE(ElementData%AP)
ENDIF
IF (ALLOCATED(ElementData%ALPHA)) THEN
  DEALLOCATE(ElementData%ALPHA)
ENDIF
IF (ALLOCATED(ElementData%W2)) THEN
  DEALLOCATE(ElementData%W2)
ENDIF
IF (ALLOCATED(ElementData%OLD_A_NS)) THEN
  DEALLOCATE(ElementData%OLD_A_NS)
ENDIF
IF (ALLOCATED(ElementData%OLD_AP_NS)) THEN
  DEALLOCATE(ElementData%OLD_AP_NS)
ENDIF
 END SUBROUTINE AD14_DestroyElement

 SUBROUTINE AD14_PackElement( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Element),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackElement'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! A allocated yes/no
  IF ( ALLOCATED(InData%A) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! A upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%A)  ! A
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AP allocated yes/no
  IF ( ALLOCATED(InData%AP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AP)  ! AP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ALPHA allocated yes/no
  IF ( ALLOCATED(InData%ALPHA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! ALPHA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ALPHA)  ! ALPHA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! W2 allocated yes/no
  IF ( ALLOCATED(InData%W2) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! W2 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%W2)  ! W2
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLD_A_NS allocated yes/no
  IF ( ALLOCATED(InData%OLD_A_NS) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLD_A_NS upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLD_A_NS)  ! OLD_A_NS
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OLD_AP_NS allocated yes/no
  IF ( ALLOCATED(InData%OLD_AP_NS) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! OLD_AP_NS upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%OLD_AP_NS)  ! OLD_AP_NS
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! PITNOW
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%A) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%A,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%A,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%A,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%A,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%A)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%A))-1 ) = PACK(InData%A,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%A)
  END IF
  IF ( .NOT. ALLOCATED(InData%AP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AP,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AP))-1 ) = PACK(InData%AP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AP)
  END IF
  IF ( .NOT. ALLOCATED(InData%ALPHA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ALPHA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ALPHA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ALPHA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ALPHA,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ALPHA)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ALPHA))-1 ) = PACK(InData%ALPHA,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ALPHA)
  END IF
  IF ( .NOT. ALLOCATED(InData%W2) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W2,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W2,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W2,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W2,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%W2)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%W2))-1 ) = PACK(InData%W2,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%W2)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLD_A_NS) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLD_A_NS,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLD_A_NS,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLD_A_NS,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLD_A_NS,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLD_A_NS)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLD_A_NS))-1 ) = PACK(InData%OLD_A_NS,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLD_A_NS)
  END IF
  IF ( .NOT. ALLOCATED(InData%OLD_AP_NS) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLD_AP_NS,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLD_AP_NS,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OLD_AP_NS,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OLD_AP_NS,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%OLD_AP_NS)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OLD_AP_NS))-1 ) = PACK(InData%OLD_AP_NS,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%OLD_AP_NS)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%PITNOW
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackElement

 SUBROUTINE AD14_UnPackElement( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Element), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackElement'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! A not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%A)) DEALLOCATE(OutData%A)
    ALLOCATE(OutData%A(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%A.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%A)>0) OutData%A = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%A))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%A)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AP)) DEALLOCATE(OutData%AP)
    ALLOCATE(OutData%AP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%AP)>0) OutData%AP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AP))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AP)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ALPHA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ALPHA)) DEALLOCATE(OutData%ALPHA)
    ALLOCATE(OutData%ALPHA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALPHA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%ALPHA)>0) OutData%ALPHA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ALPHA))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ALPHA)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! W2 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%W2)) DEALLOCATE(OutData%W2)
    ALLOCATE(OutData%W2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%W2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%W2)>0) OutData%W2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%W2))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%W2)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLD_A_NS not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLD_A_NS)) DEALLOCATE(OutData%OLD_A_NS)
    ALLOCATE(OutData%OLD_A_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_A_NS.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLD_A_NS)>0) OutData%OLD_A_NS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLD_A_NS))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLD_A_NS)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OLD_AP_NS not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OLD_AP_NS)) DEALLOCATE(OutData%OLD_AP_NS)
    ALLOCATE(OutData%OLD_AP_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_AP_NS.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%OLD_AP_NS)>0) OutData%OLD_AP_NS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OLD_AP_NS))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%OLD_AP_NS)
    DEALLOCATE(mask2)
  END IF
      OutData%PITNOW = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackElement

 SUBROUTINE AD14_CopyElementParms( SrcElementParmsData, DstElementParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElementParms), INTENT(IN) :: SrcElementParmsData
   TYPE(ElementParms), INTENT(INOUT) :: DstElementParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElementParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstElementParmsData%NELM = SrcElementParmsData%NELM
IF (ALLOCATED(SrcElementParmsData%TWIST)) THEN
  i1_l = LBOUND(SrcElementParmsData%TWIST,1)
  i1_u = UBOUND(SrcElementParmsData%TWIST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%TWIST)) THEN 
    ALLOCATE(DstElementParmsData%TWIST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TWIST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%TWIST = SrcElementParmsData%TWIST
ENDIF
IF (ALLOCATED(SrcElementParmsData%RELM)) THEN
  i1_l = LBOUND(SrcElementParmsData%RELM,1)
  i1_u = UBOUND(SrcElementParmsData%RELM,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%RELM)) THEN 
    ALLOCATE(DstElementParmsData%RELM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%RELM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%RELM = SrcElementParmsData%RELM
ENDIF
IF (ALLOCATED(SrcElementParmsData%HLCNST)) THEN
  i1_l = LBOUND(SrcElementParmsData%HLCNST,1)
  i1_u = UBOUND(SrcElementParmsData%HLCNST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%HLCNST)) THEN 
    ALLOCATE(DstElementParmsData%HLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%HLCNST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%HLCNST = SrcElementParmsData%HLCNST
ENDIF
IF (ALLOCATED(SrcElementParmsData%TLCNST)) THEN
  i1_l = LBOUND(SrcElementParmsData%TLCNST,1)
  i1_u = UBOUND(SrcElementParmsData%TLCNST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%TLCNST)) THEN 
    ALLOCATE(DstElementParmsData%TLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TLCNST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%TLCNST = SrcElementParmsData%TLCNST
ENDIF
 END SUBROUTINE AD14_CopyElementParms

 SUBROUTINE AD14_DestroyElementParms( ElementParmsData, ErrStat, ErrMsg )
  TYPE(ElementParms), INTENT(INOUT) :: ElementParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElementParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ElementParmsData%TWIST)) THEN
  DEALLOCATE(ElementParmsData%TWIST)
ENDIF
IF (ALLOCATED(ElementParmsData%RELM)) THEN
  DEALLOCATE(ElementParmsData%RELM)
ENDIF
IF (ALLOCATED(ElementParmsData%HLCNST)) THEN
  DEALLOCATE(ElementParmsData%HLCNST)
ENDIF
IF (ALLOCATED(ElementParmsData%TLCNST)) THEN
  DEALLOCATE(ElementParmsData%TLCNST)
ENDIF
 END SUBROUTINE AD14_DestroyElementParms

 SUBROUTINE AD14_PackElementParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ElementParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackElementParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NELM
  Int_BufSz   = Int_BufSz   + 1     ! TWIST allocated yes/no
  IF ( ALLOCATED(InData%TWIST) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TWIST upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TWIST)  ! TWIST
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RELM allocated yes/no
  IF ( ALLOCATED(InData%RELM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RELM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RELM)  ! RELM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! HLCNST allocated yes/no
  IF ( ALLOCATED(InData%HLCNST) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! HLCNST upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%HLCNST)  ! HLCNST
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TLCNST allocated yes/no
  IF ( ALLOCATED(InData%TLCNST) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TLCNST upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TLCNST)  ! TLCNST
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NELM
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%TWIST) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TWIST,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TWIST,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TWIST)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TWIST))-1 ) = PACK(InData%TWIST,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TWIST)
  END IF
  IF ( .NOT. ALLOCATED(InData%RELM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RELM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RELM,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%RELM)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RELM))-1 ) = PACK(InData%RELM,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%RELM)
  END IF
  IF ( .NOT. ALLOCATED(InData%HLCNST) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%HLCNST,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%HLCNST,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%HLCNST)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%HLCNST))-1 ) = PACK(InData%HLCNST,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%HLCNST)
  END IF
  IF ( .NOT. ALLOCATED(InData%TLCNST) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TLCNST,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TLCNST,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TLCNST)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TLCNST))-1 ) = PACK(InData%TLCNST,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TLCNST)
  END IF
 END SUBROUTINE AD14_PackElementParms

 SUBROUTINE AD14_UnPackElementParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ElementParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackElementParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%NELM = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TWIST not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TWIST)) DEALLOCATE(OutData%TWIST)
    ALLOCATE(OutData%TWIST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TWIST.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TWIST)>0) OutData%TWIST = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TWIST))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TWIST)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RELM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RELM)) DEALLOCATE(OutData%RELM)
    ALLOCATE(OutData%RELM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RELM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%RELM)>0) OutData%RELM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RELM))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%RELM)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! HLCNST not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%HLCNST)) DEALLOCATE(OutData%HLCNST)
    ALLOCATE(OutData%HLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%HLCNST.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%HLCNST)>0) OutData%HLCNST = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%HLCNST))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%HLCNST)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TLCNST not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TLCNST)) DEALLOCATE(OutData%TLCNST)
    ALLOCATE(OutData%TLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TLCNST.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TLCNST)>0) OutData%TLCNST = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TLCNST))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TLCNST)
    DEALLOCATE(mask1)
  END IF
 END SUBROUTINE AD14_UnPackElementParms

 SUBROUTINE AD14_CopyElOutParms( SrcElOutParmsData, DstElOutParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElOutParms), INTENT(IN) :: SrcElOutParmsData
   TYPE(ElOutParms), INTENT(INOUT) :: DstElOutParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElOutParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcElOutParmsData%AAA)) THEN
  i1_l = LBOUND(SrcElOutParmsData%AAA,1)
  i1_u = UBOUND(SrcElOutParmsData%AAA,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%AAA)) THEN 
    ALLOCATE(DstElOutParmsData%AAA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%AAA = SrcElOutParmsData%AAA
ENDIF
IF (ALLOCATED(SrcElOutParmsData%AAP)) THEN
  i1_l = LBOUND(SrcElOutParmsData%AAP,1)
  i1_u = UBOUND(SrcElOutParmsData%AAP,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%AAP)) THEN 
    ALLOCATE(DstElOutParmsData%AAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%AAP = SrcElOutParmsData%AAP
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ALF)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ALF,1)
  i1_u = UBOUND(SrcElOutParmsData%ALF,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ALF)) THEN 
    ALLOCATE(DstElOutParmsData%ALF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ALF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ALF = SrcElOutParmsData%ALF
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CDD)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CDD,1)
  i1_u = UBOUND(SrcElOutParmsData%CDD,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CDD)) THEN 
    ALLOCATE(DstElOutParmsData%CDD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CDD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CDD = SrcElOutParmsData%CDD
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CLL)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CLL,1)
  i1_u = UBOUND(SrcElOutParmsData%CLL,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CLL)) THEN 
    ALLOCATE(DstElOutParmsData%CLL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CLL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CLL = SrcElOutParmsData%CLL
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CMM)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CMM,1)
  i1_u = UBOUND(SrcElOutParmsData%CMM,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CMM)) THEN 
    ALLOCATE(DstElOutParmsData%CMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CMM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CMM = SrcElOutParmsData%CMM
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CNN)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CNN,1)
  i1_u = UBOUND(SrcElOutParmsData%CNN,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CNN)) THEN 
    ALLOCATE(DstElOutParmsData%CNN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CNN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CNN = SrcElOutParmsData%CNN
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CTT)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CTT,1)
  i1_u = UBOUND(SrcElOutParmsData%CTT,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CTT)) THEN 
    ALLOCATE(DstElOutParmsData%CTT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CTT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CTT = SrcElOutParmsData%CTT
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DFNSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DFNSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%DFNSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DFNSAV)) THEN 
    ALLOCATE(DstElOutParmsData%DFNSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFNSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DFNSAV = SrcElOutParmsData%DFNSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DFTSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DFTSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%DFTSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DFTSAV)) THEN 
    ALLOCATE(DstElOutParmsData%DFTSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFTSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DFTSAV = SrcElOutParmsData%DFTSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DynPres)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DynPres,1)
  i1_u = UBOUND(SrcElOutParmsData%DynPres,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DynPres)) THEN 
    ALLOCATE(DstElOutParmsData%DynPres(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DynPres.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DynPres = SrcElOutParmsData%DynPres
ENDIF
IF (ALLOCATED(SrcElOutParmsData%PMM)) THEN
  i1_l = LBOUND(SrcElOutParmsData%PMM,1)
  i1_u = UBOUND(SrcElOutParmsData%PMM,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%PMM)) THEN 
    ALLOCATE(DstElOutParmsData%PMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PMM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%PMM = SrcElOutParmsData%PMM
ENDIF
IF (ALLOCATED(SrcElOutParmsData%PITSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%PITSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%PITSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%PITSAV)) THEN 
    ALLOCATE(DstElOutParmsData%PITSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PITSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%PITSAV = SrcElOutParmsData%PITSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ReyNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ReyNum,1)
  i1_u = UBOUND(SrcElOutParmsData%ReyNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ReyNum)) THEN 
    ALLOCATE(DstElOutParmsData%ReyNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ReyNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ReyNum = SrcElOutParmsData%ReyNum
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVX)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVX,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVX,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVX,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVX,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVX)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVX = SrcElOutParmsData%SaveVX
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVY)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVY,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVY,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVY,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVY,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVY)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVY(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVY = SrcElOutParmsData%SaveVY
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVZ)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVZ,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVZ,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVZ,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVZ,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVZ)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVZ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVZ = SrcElOutParmsData%SaveVZ
ENDIF
    DstElOutParmsData%VXSAV = SrcElOutParmsData%VXSAV
    DstElOutParmsData%VYSAV = SrcElOutParmsData%VYSAV
    DstElOutParmsData%VZSAV = SrcElOutParmsData%VZSAV
    DstElOutParmsData%NumWndElOut = SrcElOutParmsData%NumWndElOut
IF (ALLOCATED(SrcElOutParmsData%WndElPrList)) THEN
  i1_l = LBOUND(SrcElOutParmsData%WndElPrList,1)
  i1_u = UBOUND(SrcElOutParmsData%WndElPrList,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%WndElPrList)) THEN 
    ALLOCATE(DstElOutParmsData%WndElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%WndElPrList = SrcElOutParmsData%WndElPrList
ENDIF
IF (ALLOCATED(SrcElOutParmsData%WndElPrNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%WndElPrNum,1)
  i1_u = UBOUND(SrcElOutParmsData%WndElPrNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%WndElPrNum)) THEN 
    ALLOCATE(DstElOutParmsData%WndElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%WndElPrNum = SrcElOutParmsData%WndElPrNum
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ElPrList)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ElPrList,1)
  i1_u = UBOUND(SrcElOutParmsData%ElPrList,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ElPrList)) THEN 
    ALLOCATE(DstElOutParmsData%ElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ElPrList = SrcElOutParmsData%ElPrList
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ElPrNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ElPrNum,1)
  i1_u = UBOUND(SrcElOutParmsData%ElPrNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ElPrNum)) THEN 
    ALLOCATE(DstElOutParmsData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ElPrNum = SrcElOutParmsData%ElPrNum
ENDIF
    DstElOutParmsData%NumElOut = SrcElOutParmsData%NumElOut
 END SUBROUTINE AD14_CopyElOutParms

 SUBROUTINE AD14_DestroyElOutParms( ElOutParmsData, ErrStat, ErrMsg )
  TYPE(ElOutParms), INTENT(INOUT) :: ElOutParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElOutParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ElOutParmsData%AAA)) THEN
  DEALLOCATE(ElOutParmsData%AAA)
ENDIF
IF (ALLOCATED(ElOutParmsData%AAP)) THEN
  DEALLOCATE(ElOutParmsData%AAP)
ENDIF
IF (ALLOCATED(ElOutParmsData%ALF)) THEN
  DEALLOCATE(ElOutParmsData%ALF)
ENDIF
IF (ALLOCATED(ElOutParmsData%CDD)) THEN
  DEALLOCATE(ElOutParmsData%CDD)
ENDIF
IF (ALLOCATED(ElOutParmsData%CLL)) THEN
  DEALLOCATE(ElOutParmsData%CLL)
ENDIF
IF (ALLOCATED(ElOutParmsData%CMM)) THEN
  DEALLOCATE(ElOutParmsData%CMM)
ENDIF
IF (ALLOCATED(ElOutParmsData%CNN)) THEN
  DEALLOCATE(ElOutParmsData%CNN)
ENDIF
IF (ALLOCATED(ElOutParmsData%CTT)) THEN
  DEALLOCATE(ElOutParmsData%CTT)
ENDIF
IF (ALLOCATED(ElOutParmsData%DFNSAV)) THEN
  DEALLOCATE(ElOutParmsData%DFNSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%DFTSAV)) THEN
  DEALLOCATE(ElOutParmsData%DFTSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%DynPres)) THEN
  DEALLOCATE(ElOutParmsData%DynPres)
ENDIF
IF (ALLOCATED(ElOutParmsData%PMM)) THEN
  DEALLOCATE(ElOutParmsData%PMM)
ENDIF
IF (ALLOCATED(ElOutParmsData%PITSAV)) THEN
  DEALLOCATE(ElOutParmsData%PITSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%ReyNum)) THEN
  DEALLOCATE(ElOutParmsData%ReyNum)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVX)) THEN
  DEALLOCATE(ElOutParmsData%SaveVX)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVY)) THEN
  DEALLOCATE(ElOutParmsData%SaveVY)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVZ)) THEN
  DEALLOCATE(ElOutParmsData%SaveVZ)
ENDIF
IF (ALLOCATED(ElOutParmsData%WndElPrList)) THEN
  DEALLOCATE(ElOutParmsData%WndElPrList)
ENDIF
IF (ALLOCATED(ElOutParmsData%WndElPrNum)) THEN
  DEALLOCATE(ElOutParmsData%WndElPrNum)
ENDIF
IF (ALLOCATED(ElOutParmsData%ElPrList)) THEN
  DEALLOCATE(ElOutParmsData%ElPrList)
ENDIF
IF (ALLOCATED(ElOutParmsData%ElPrNum)) THEN
  DEALLOCATE(ElOutParmsData%ElPrNum)
ENDIF
 END SUBROUTINE AD14_DestroyElOutParms

 SUBROUTINE AD14_PackElOutParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ElOutParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackElOutParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! AAA allocated yes/no
  IF ( ALLOCATED(InData%AAA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AAA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AAA)  ! AAA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AAP allocated yes/no
  IF ( ALLOCATED(InData%AAP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AAP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AAP)  ! AAP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ALF allocated yes/no
  IF ( ALLOCATED(InData%ALF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ALF upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ALF)  ! ALF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CDD allocated yes/no
  IF ( ALLOCATED(InData%CDD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CDD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CDD)  ! CDD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CLL allocated yes/no
  IF ( ALLOCATED(InData%CLL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CLL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CLL)  ! CLL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CMM allocated yes/no
  IF ( ALLOCATED(InData%CMM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CMM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CMM)  ! CMM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CNN allocated yes/no
  IF ( ALLOCATED(InData%CNN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CNN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CNN)  ! CNN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CTT allocated yes/no
  IF ( ALLOCATED(InData%CTT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CTT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CTT)  ! CTT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DFNSAV allocated yes/no
  IF ( ALLOCATED(InData%DFNSAV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! DFNSAV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DFNSAV)  ! DFNSAV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DFTSAV allocated yes/no
  IF ( ALLOCATED(InData%DFTSAV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! DFTSAV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DFTSAV)  ! DFTSAV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DynPres allocated yes/no
  IF ( ALLOCATED(InData%DynPres) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! DynPres upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DynPres)  ! DynPres
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PMM allocated yes/no
  IF ( ALLOCATED(InData%PMM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PMM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%PMM)  ! PMM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PITSAV allocated yes/no
  IF ( ALLOCATED(InData%PITSAV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PITSAV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%PITSAV)  ! PITSAV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ReyNum allocated yes/no
  IF ( ALLOCATED(InData%ReyNum) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ReyNum upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ReyNum)  ! ReyNum
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SaveVX allocated yes/no
  IF ( ALLOCATED(InData%SaveVX) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SaveVX upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SaveVX)  ! SaveVX
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SaveVY allocated yes/no
  IF ( ALLOCATED(InData%SaveVY) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SaveVY upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SaveVY)  ! SaveVY
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SaveVZ allocated yes/no
  IF ( ALLOCATED(InData%SaveVZ) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SaveVZ upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SaveVZ)  ! SaveVZ
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! VXSAV
      Re_BufSz   = Re_BufSz   + 1  ! VYSAV
      Re_BufSz   = Re_BufSz   + 1  ! VZSAV
      Int_BufSz  = Int_BufSz  + 1  ! NumWndElOut
  Int_BufSz   = Int_BufSz   + 1     ! WndElPrList allocated yes/no
  IF ( ALLOCATED(InData%WndElPrList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WndElPrList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WndElPrList)  ! WndElPrList
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WndElPrNum allocated yes/no
  IF ( ALLOCATED(InData%WndElPrNum) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WndElPrNum upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WndElPrNum)  ! WndElPrNum
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ElPrList allocated yes/no
  IF ( ALLOCATED(InData%ElPrList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ElPrList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ElPrList)  ! ElPrList
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ElPrNum allocated yes/no
  IF ( ALLOCATED(InData%ElPrNum) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ElPrNum upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ElPrNum)  ! ElPrNum
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumElOut
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%AAA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AAA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AAA,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AAA)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AAA))-1 ) = PACK(InData%AAA,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AAA)
  END IF
  IF ( .NOT. ALLOCATED(InData%AAP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AAP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AAP,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AAP)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AAP))-1 ) = PACK(InData%AAP,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AAP)
  END IF
  IF ( .NOT. ALLOCATED(InData%ALF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ALF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ALF,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ALF)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ALF))-1 ) = PACK(InData%ALF,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ALF)
  END IF
  IF ( .NOT. ALLOCATED(InData%CDD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CDD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CDD,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CDD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CDD))-1 ) = PACK(InData%CDD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CDD)
  END IF
  IF ( .NOT. ALLOCATED(InData%CLL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CLL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CLL,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CLL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CLL))-1 ) = PACK(InData%CLL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CLL)
  END IF
  IF ( .NOT. ALLOCATED(InData%CMM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CMM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CMM,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CMM)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CMM))-1 ) = PACK(InData%CMM,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CMM)
  END IF
  IF ( .NOT. ALLOCATED(InData%CNN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CNN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CNN,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CNN)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CNN))-1 ) = PACK(InData%CNN,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CNN)
  END IF
  IF ( .NOT. ALLOCATED(InData%CTT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CTT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CTT,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CTT)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CTT))-1 ) = PACK(InData%CTT,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CTT)
  END IF
  IF ( .NOT. ALLOCATED(InData%DFNSAV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFNSAV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFNSAV,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DFNSAV)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DFNSAV))-1 ) = PACK(InData%DFNSAV,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DFNSAV)
  END IF
  IF ( .NOT. ALLOCATED(InData%DFTSAV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DFTSAV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DFTSAV,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DFTSAV)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DFTSAV))-1 ) = PACK(InData%DFTSAV,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DFTSAV)
  END IF
  IF ( .NOT. ALLOCATED(InData%DynPres) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DynPres,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DynPres,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%DynPres)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DynPres))-1 ) = PACK(InData%DynPres,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%DynPres)
  END IF
  IF ( .NOT. ALLOCATED(InData%PMM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PMM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PMM,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%PMM)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PMM))-1 ) = PACK(InData%PMM,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%PMM)
  END IF
  IF ( .NOT. ALLOCATED(InData%PITSAV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PITSAV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PITSAV,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%PITSAV)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PITSAV))-1 ) = PACK(InData%PITSAV,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%PITSAV)
  END IF
  IF ( .NOT. ALLOCATED(InData%ReyNum) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ReyNum,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ReyNum,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ReyNum)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ReyNum))-1 ) = PACK(InData%ReyNum,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ReyNum)
  END IF
  IF ( .NOT. ALLOCATED(InData%SaveVX) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVX,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVX,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVX,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVX,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%SaveVX)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SaveVX))-1 ) = PACK(InData%SaveVX,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%SaveVX)
  END IF
  IF ( .NOT. ALLOCATED(InData%SaveVY) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVY,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVY,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVY,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVY,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%SaveVY)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SaveVY))-1 ) = PACK(InData%SaveVY,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%SaveVY)
  END IF
  IF ( .NOT. ALLOCATED(InData%SaveVZ) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVZ,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVZ,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SaveVZ,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SaveVZ,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%SaveVZ)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SaveVZ))-1 ) = PACK(InData%SaveVZ,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%SaveVZ)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VXSAV
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VYSAV
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VZSAV
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumWndElOut
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%WndElPrList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WndElPrList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WndElPrList,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%WndElPrList)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%WndElPrList))-1 ) = PACK(InData%WndElPrList,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%WndElPrList)
  END IF
  IF ( .NOT. ALLOCATED(InData%WndElPrNum) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WndElPrNum,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WndElPrNum,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%WndElPrNum)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%WndElPrNum))-1 ) = PACK(InData%WndElPrNum,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%WndElPrNum)
  END IF
  IF ( .NOT. ALLOCATED(InData%ElPrList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ElPrList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ElPrList,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ElPrList)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElPrList))-1 ) = PACK(InData%ElPrList,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%ElPrList)
  END IF
  IF ( .NOT. ALLOCATED(InData%ElPrNum) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ElPrNum,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ElPrNum,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ElPrNum)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElPrNum))-1 ) = PACK(InData%ElPrNum,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%ElPrNum)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumElOut
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AD14_PackElOutParms

 SUBROUTINE AD14_UnPackElOutParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ElOutParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackElOutParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AAA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AAA)) DEALLOCATE(OutData%AAA)
    ALLOCATE(OutData%AAA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%AAA)>0) OutData%AAA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AAA))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AAA)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AAP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AAP)) DEALLOCATE(OutData%AAP)
    ALLOCATE(OutData%AAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%AAP)>0) OutData%AAP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AAP))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AAP)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ALF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ALF)) DEALLOCATE(OutData%ALF)
    ALLOCATE(OutData%ALF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ALF)>0) OutData%ALF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ALF))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ALF)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CDD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CDD)) DEALLOCATE(OutData%CDD)
    ALLOCATE(OutData%CDD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%CDD)>0) OutData%CDD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CDD))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CDD)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CLL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CLL)) DEALLOCATE(OutData%CLL)
    ALLOCATE(OutData%CLL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CLL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%CLL)>0) OutData%CLL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CLL))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CLL)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CMM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CMM)) DEALLOCATE(OutData%CMM)
    ALLOCATE(OutData%CMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%CMM)>0) OutData%CMM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CMM))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CMM)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CNN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CNN)) DEALLOCATE(OutData%CNN)
    ALLOCATE(OutData%CNN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%CNN)>0) OutData%CNN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CNN))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CNN)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CTT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CTT)) DEALLOCATE(OutData%CTT)
    ALLOCATE(OutData%CTT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CTT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%CTT)>0) OutData%CTT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CTT))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CTT)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DFNSAV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DFNSAV)) DEALLOCATE(OutData%DFNSAV)
    ALLOCATE(OutData%DFNSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFNSAV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%DFNSAV)>0) OutData%DFNSAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DFNSAV))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DFNSAV)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DFTSAV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DFTSAV)) DEALLOCATE(OutData%DFTSAV)
    ALLOCATE(OutData%DFTSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFTSAV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%DFTSAV)>0) OutData%DFTSAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DFTSAV))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DFTSAV)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DynPres not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DynPres)) DEALLOCATE(OutData%DynPres)
    ALLOCATE(OutData%DynPres(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DynPres.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%DynPres)>0) OutData%DynPres = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DynPres))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%DynPres)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PMM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PMM)) DEALLOCATE(OutData%PMM)
    ALLOCATE(OutData%PMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PMM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%PMM)>0) OutData%PMM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PMM))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%PMM)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PITSAV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PITSAV)) DEALLOCATE(OutData%PITSAV)
    ALLOCATE(OutData%PITSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PITSAV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%PITSAV)>0) OutData%PITSAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PITSAV))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%PITSAV)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ReyNum not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ReyNum)) DEALLOCATE(OutData%ReyNum)
    ALLOCATE(OutData%ReyNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ReyNum.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ReyNum)>0) OutData%ReyNum = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ReyNum))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ReyNum)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SaveVX not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SaveVX)) DEALLOCATE(OutData%SaveVX)
    ALLOCATE(OutData%SaveVX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVX.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%SaveVX)>0) OutData%SaveVX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SaveVX))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%SaveVX)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SaveVY not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SaveVY)) DEALLOCATE(OutData%SaveVY)
    ALLOCATE(OutData%SaveVY(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVY.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%SaveVY)>0) OutData%SaveVY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SaveVY))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%SaveVY)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SaveVZ not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SaveVZ)) DEALLOCATE(OutData%SaveVZ)
    ALLOCATE(OutData%SaveVZ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVZ.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%SaveVZ)>0) OutData%SaveVZ = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SaveVZ))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%SaveVZ)
    DEALLOCATE(mask2)
  END IF
      OutData%VXSAV = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%VYSAV = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%VZSAV = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%NumWndElOut = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WndElPrList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WndElPrList)) DEALLOCATE(OutData%WndElPrList)
    ALLOCATE(OutData%WndElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%WndElPrList)>0) OutData%WndElPrList = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%WndElPrList))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%WndElPrList)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WndElPrNum not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WndElPrNum)) DEALLOCATE(OutData%WndElPrNum)
    ALLOCATE(OutData%WndElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrNum.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%WndElPrNum)>0) OutData%WndElPrNum = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%WndElPrNum))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%WndElPrNum)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ElPrList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ElPrList)) DEALLOCATE(OutData%ElPrList)
    ALLOCATE(OutData%ElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ElPrList)>0) OutData%ElPrList = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%ElPrList))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%ElPrList)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ElPrNum not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ElPrNum)) DEALLOCATE(OutData%ElPrNum)
    ALLOCATE(OutData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ElPrNum)>0) OutData%ElPrNum = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%ElPrNum))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%ElPrNum)
    DEALLOCATE(mask1)
  END IF
      OutData%NumElOut = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE AD14_UnPackElOutParms

 SUBROUTINE AD14_CopyInducedVel( SrcInducedVelData, DstInducedVelData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InducedVel), INTENT(IN) :: SrcInducedVelData
   TYPE(InducedVel), INTENT(INOUT) :: DstInducedVelData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInducedVel'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInducedVelData%SumInFl = SrcInducedVelData%SumInFl
 END SUBROUTINE AD14_CopyInducedVel

 SUBROUTINE AD14_DestroyInducedVel( InducedVelData, ErrStat, ErrMsg )
  TYPE(InducedVel), INTENT(INOUT) :: InducedVelData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInducedVel'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyInducedVel

 SUBROUTINE AD14_PackInducedVel( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InducedVel),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackInducedVel'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! SumInFl
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%SumInFl
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackInducedVel

 SUBROUTINE AD14_UnPackInducedVel( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InducedVel), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackInducedVel'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%SumInFl = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackInducedVel

 SUBROUTINE AD14_CopyInducedVelParms( SrcInducedVelParmsData, DstInducedVelParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InducedVelParms), INTENT(IN) :: SrcInducedVelParmsData
   TYPE(InducedVelParms), INTENT(INOUT) :: DstInducedVelParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInducedVelParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInducedVelParmsData%AToler = SrcInducedVelParmsData%AToler
    DstInducedVelParmsData%EqAIDmult = SrcInducedVelParmsData%EqAIDmult
    DstInducedVelParmsData%EquilDA = SrcInducedVelParmsData%EquilDA
    DstInducedVelParmsData%EquilDT = SrcInducedVelParmsData%EquilDT
    DstInducedVelParmsData%TLoss = SrcInducedVelParmsData%TLoss
    DstInducedVelParmsData%GTech = SrcInducedVelParmsData%GTech
    DstInducedVelParmsData%HLoss = SrcInducedVelParmsData%HLoss
 END SUBROUTINE AD14_CopyInducedVelParms

 SUBROUTINE AD14_DestroyInducedVelParms( InducedVelParmsData, ErrStat, ErrMsg )
  TYPE(InducedVelParms), INTENT(INOUT) :: InducedVelParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInducedVelParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyInducedVelParms

 SUBROUTINE AD14_PackInducedVelParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InducedVelParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackInducedVelParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! AToler
      Re_BufSz   = Re_BufSz   + 1  ! EqAIDmult
      Int_BufSz  = Int_BufSz  + 1  ! EquilDA
      Int_BufSz  = Int_BufSz  + 1  ! EquilDT
      Int_BufSz  = Int_BufSz  + 1  ! TLoss
      Int_BufSz  = Int_BufSz  + 1  ! GTech
      Int_BufSz  = Int_BufSz  + 1  ! HLoss
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%AToler
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%EqAIDmult
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%EquilDA , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%EquilDT , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%TLoss , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%GTech , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%HLoss , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AD14_PackInducedVelParms

 SUBROUTINE AD14_UnPackInducedVelParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InducedVelParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackInducedVelParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%AToler = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%EqAIDmult = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%EquilDA = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%EquilDT = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%TLoss = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%GTech = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%HLoss = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE AD14_UnPackInducedVelParms

 SUBROUTINE AD14_CopyRotor( SrcRotorData, DstRotorData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Rotor), INTENT(IN) :: SrcRotorData
   TYPE(Rotor), INTENT(INOUT) :: DstRotorData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyRotor'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotorData%AVGINFL = SrcRotorData%AVGINFL
    DstRotorData%CTILT = SrcRotorData%CTILT
    DstRotorData%CYaw = SrcRotorData%CYaw
    DstRotorData%REVS = SrcRotorData%REVS
    DstRotorData%STILT = SrcRotorData%STILT
    DstRotorData%SYaw = SrcRotorData%SYaw
    DstRotorData%TILT = SrcRotorData%TILT
    DstRotorData%YawAng = SrcRotorData%YawAng
    DstRotorData%YawVEL = SrcRotorData%YawVEL
 END SUBROUTINE AD14_CopyRotor

 SUBROUTINE AD14_DestroyRotor( RotorData, ErrStat, ErrMsg )
  TYPE(Rotor), INTENT(INOUT) :: RotorData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyRotor'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyRotor

 SUBROUTINE AD14_PackRotor( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Rotor),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackRotor'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! AVGINFL
      Re_BufSz   = Re_BufSz   + 1  ! CTILT
      Re_BufSz   = Re_BufSz   + 1  ! CYaw
      Re_BufSz   = Re_BufSz   + 1  ! REVS
      Re_BufSz   = Re_BufSz   + 1  ! STILT
      Re_BufSz   = Re_BufSz   + 1  ! SYaw
      Re_BufSz   = Re_BufSz   + 1  ! TILT
      Re_BufSz   = Re_BufSz   + 1  ! YawAng
      Re_BufSz   = Re_BufSz   + 1  ! YawVEL
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%AVGINFL
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CTILT
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CYaw
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%REVS
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%STILT
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%SYaw
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TILT
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%YawAng
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%YawVEL
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackRotor

 SUBROUTINE AD14_UnPackRotor( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Rotor), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackRotor'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%AVGINFL = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CTILT = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CYaw = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%REVS = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%STILT = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%SYaw = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TILT = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%YawAng = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%YawVEL = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackRotor

 SUBROUTINE AD14_CopyRotorParms( SrcRotorParmsData, DstRotorParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotorParms), INTENT(IN) :: SrcRotorParmsData
   TYPE(RotorParms), INTENT(INOUT) :: DstRotorParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyRotorParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotorParmsData%HH = SrcRotorParmsData%HH
 END SUBROUTINE AD14_CopyRotorParms

 SUBROUTINE AD14_DestroyRotorParms( RotorParmsData, ErrStat, ErrMsg )
  TYPE(RotorParms), INTENT(INOUT) :: RotorParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyRotorParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyRotorParms

 SUBROUTINE AD14_PackRotorParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RotorParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackRotorParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! HH
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%HH
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackRotorParms

 SUBROUTINE AD14_UnPackRotorParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RotorParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackRotorParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%HH = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackRotorParms

 SUBROUTINE AD14_CopyTwrPropsParms( SrcTwrPropsParmsData, DstTwrPropsParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(TwrPropsParms), INTENT(IN) :: SrcTwrPropsParmsData
   TYPE(TwrPropsParms), INTENT(INOUT) :: DstTwrPropsParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyTwrPropsParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcTwrPropsParmsData%TwrHtFr)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrHtFr,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrHtFr,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrHtFr)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrHtFr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrHtFr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrHtFr = SrcTwrPropsParmsData%TwrHtFr
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrWid)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrWid,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrWid,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrWid)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrWid(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrWid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrWid = SrcTwrPropsParmsData%TwrWid
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrCD)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrCD,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrCD,1)
  i2_l = LBOUND(SrcTwrPropsParmsData%TwrCD,2)
  i2_u = UBOUND(SrcTwrPropsParmsData%TwrCD,2)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrCD)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrCD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrCD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrCD = SrcTwrPropsParmsData%TwrCD
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrRe)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrRe,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrRe,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrRe)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrRe(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrRe.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrRe = SrcTwrPropsParmsData%TwrRe
ENDIF
    DstTwrPropsParmsData%VTwr = SrcTwrPropsParmsData%VTwr
    DstTwrPropsParmsData%Tower_Wake_Constant = SrcTwrPropsParmsData%Tower_Wake_Constant
IF (ALLOCATED(SrcTwrPropsParmsData%NTwrCDCol)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%NTwrCDCol,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%NTwrCDCol,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%NTwrCDCol)) THEN 
    ALLOCATE(DstTwrPropsParmsData%NTwrCDCol(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%NTwrCDCol.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%NTwrCDCol = SrcTwrPropsParmsData%NTwrCDCol
ENDIF
    DstTwrPropsParmsData%NTwrHT = SrcTwrPropsParmsData%NTwrHT
    DstTwrPropsParmsData%NTwrRe = SrcTwrPropsParmsData%NTwrRe
    DstTwrPropsParmsData%NTwrCD = SrcTwrPropsParmsData%NTwrCD
    DstTwrPropsParmsData%TwrPotent = SrcTwrPropsParmsData%TwrPotent
    DstTwrPropsParmsData%TwrShadow = SrcTwrPropsParmsData%TwrShadow
    DstTwrPropsParmsData%ShadHWid = SrcTwrPropsParmsData%ShadHWid
    DstTwrPropsParmsData%TShadC1 = SrcTwrPropsParmsData%TShadC1
    DstTwrPropsParmsData%TShadC2 = SrcTwrPropsParmsData%TShadC2
    DstTwrPropsParmsData%TwrShad = SrcTwrPropsParmsData%TwrShad
    DstTwrPropsParmsData%PJM_Version = SrcTwrPropsParmsData%PJM_Version
    DstTwrPropsParmsData%TwrFile = SrcTwrPropsParmsData%TwrFile
    DstTwrPropsParmsData%T_Shad_Refpt = SrcTwrPropsParmsData%T_Shad_Refpt
    DstTwrPropsParmsData%CalcTwrAero = SrcTwrPropsParmsData%CalcTwrAero
    DstTwrPropsParmsData%NumTwrNodes = SrcTwrPropsParmsData%NumTwrNodes
IF (ALLOCATED(SrcTwrPropsParmsData%TwrNodeWidth)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrNodeWidth,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrNodeWidth,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrNodeWidth)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrNodeWidth(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrNodeWidth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrNodeWidth = SrcTwrPropsParmsData%TwrNodeWidth
ENDIF
 END SUBROUTINE AD14_CopyTwrPropsParms

 SUBROUTINE AD14_DestroyTwrPropsParms( TwrPropsParmsData, ErrStat, ErrMsg )
  TYPE(TwrPropsParms), INTENT(INOUT) :: TwrPropsParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyTwrPropsParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(TwrPropsParmsData%TwrHtFr)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrHtFr)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrWid)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrWid)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrCD)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrCD)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrRe)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrRe)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%NTwrCDCol)) THEN
  DEALLOCATE(TwrPropsParmsData%NTwrCDCol)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrNodeWidth)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrNodeWidth)
ENDIF
 END SUBROUTINE AD14_DestroyTwrPropsParms

 SUBROUTINE AD14_PackTwrPropsParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(TwrPropsParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackTwrPropsParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! TwrHtFr allocated yes/no
  IF ( ALLOCATED(InData%TwrHtFr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrHtFr upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrHtFr)  ! TwrHtFr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrWid allocated yes/no
  IF ( ALLOCATED(InData%TwrWid) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrWid upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrWid)  ! TwrWid
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCD allocated yes/no
  IF ( ALLOCATED(InData%TwrCD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrCD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCD)  ! TwrCD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrRe allocated yes/no
  IF ( ALLOCATED(InData%TwrRe) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrRe upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrRe)  ! TwrRe
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%VTwr)  ! VTwr
      Re_BufSz   = Re_BufSz   + 1  ! Tower_Wake_Constant
  Int_BufSz   = Int_BufSz   + 1     ! NTwrCDCol allocated yes/no
  IF ( ALLOCATED(InData%NTwrCDCol) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NTwrCDCol upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%NTwrCDCol)  ! NTwrCDCol
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NTwrHT
      Int_BufSz  = Int_BufSz  + 1  ! NTwrRe
      Int_BufSz  = Int_BufSz  + 1  ! NTwrCD
      Int_BufSz  = Int_BufSz  + 1  ! TwrPotent
      Int_BufSz  = Int_BufSz  + 1  ! TwrShadow
      Re_BufSz   = Re_BufSz   + 1  ! ShadHWid
      Re_BufSz   = Re_BufSz   + 1  ! TShadC1
      Re_BufSz   = Re_BufSz   + 1  ! TShadC2
      Re_BufSz   = Re_BufSz   + 1  ! TwrShad
      Int_BufSz  = Int_BufSz  + 1  ! PJM_Version
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%TwrFile)  ! TwrFile
      Re_BufSz   = Re_BufSz   + 1  ! T_Shad_Refpt
      Int_BufSz  = Int_BufSz  + 1  ! CalcTwrAero
      Int_BufSz  = Int_BufSz  + 1  ! NumTwrNodes
  Int_BufSz   = Int_BufSz   + 1     ! TwrNodeWidth allocated yes/no
  IF ( ALLOCATED(InData%TwrNodeWidth) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrNodeWidth upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrNodeWidth)  ! TwrNodeWidth
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%TwrHtFr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrHtFr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrHtFr,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrHtFr)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrHtFr))-1 ) = PACK(InData%TwrHtFr,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrHtFr)
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrWid) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrWid,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrWid,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrWid)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrWid))-1 ) = PACK(InData%TwrWid,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrWid)
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCD,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCD,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCD,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrCD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrCD))-1 ) = PACK(InData%TwrCD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrCD)
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrRe) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrRe,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrRe,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrRe)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrRe))-1 ) = PACK(InData%TwrRe,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrRe)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%VTwr))-1 ) = PACK(InData%VTwr,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%VTwr)
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Tower_Wake_Constant
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%NTwrCDCol) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NTwrCDCol,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NTwrCDCol,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%NTwrCDCol)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NTwrCDCol))-1 ) = PACK(InData%NTwrCDCol,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%NTwrCDCol)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NTwrHT
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NTwrRe
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NTwrCD
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%TwrPotent , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%TwrShadow , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%ShadHWid
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TShadC1
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TShadC2
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TwrShad
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%PJM_Version , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
        DO I = 1, LEN(InData%TwrFile)
          IntKiBuf(Int_Xferred) = ICHAR(InData%TwrFile(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%T_Shad_Refpt
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%CalcTwrAero , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumTwrNodes
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%TwrNodeWidth) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrNodeWidth,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrNodeWidth,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrNodeWidth)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrNodeWidth))-1 ) = PACK(InData%TwrNodeWidth,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrNodeWidth)
  END IF
 END SUBROUTINE AD14_PackTwrPropsParms

 SUBROUTINE AD14_UnPackTwrPropsParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(TwrPropsParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackTwrPropsParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrHtFr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrHtFr)) DEALLOCATE(OutData%TwrHtFr)
    ALLOCATE(OutData%TwrHtFr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrHtFr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TwrHtFr)>0) OutData%TwrHtFr = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrHtFr))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrHtFr)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrWid not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrWid)) DEALLOCATE(OutData%TwrWid)
    ALLOCATE(OutData%TwrWid(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrWid.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TwrWid)>0) OutData%TwrWid = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrWid))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrWid)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCD)) DEALLOCATE(OutData%TwrCD)
    ALLOCATE(OutData%TwrCD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%TwrCD)>0) OutData%TwrCD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrCD))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrCD)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrRe not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrRe)) DEALLOCATE(OutData%TwrRe)
    ALLOCATE(OutData%TwrRe(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRe.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TwrRe)>0) OutData%TwrRe = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrRe))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrRe)
    DEALLOCATE(mask1)
  END IF
    i1_l = LBOUND(OutData%VTwr,1)
    i1_u = UBOUND(OutData%VTwr,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%VTwr = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%VTwr))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%VTwr)
    DEALLOCATE(mask1)
      OutData%Tower_Wake_Constant = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NTwrCDCol not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NTwrCDCol)) DEALLOCATE(OutData%NTwrCDCol)
    ALLOCATE(OutData%NTwrCDCol(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTwrCDCol.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%NTwrCDCol)>0) OutData%NTwrCDCol = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%NTwrCDCol))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%NTwrCDCol)
    DEALLOCATE(mask1)
  END IF
      OutData%NTwrHT = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%NTwrRe = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%NTwrCD = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%TwrPotent = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%TwrShadow = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%ShadHWid = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TShadC1 = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TShadC2 = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TwrShad = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%PJM_Version = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      DO I = 1, LEN(OutData%TwrFile)
        OutData%TwrFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      OutData%T_Shad_Refpt = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CalcTwrAero = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%NumTwrNodes = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrNodeWidth not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrNodeWidth)) DEALLOCATE(OutData%TwrNodeWidth)
    ALLOCATE(OutData%TwrNodeWidth(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeWidth.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%TwrNodeWidth)>0) OutData%TwrNodeWidth = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrNodeWidth))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrNodeWidth)
    DEALLOCATE(mask1)
  END IF
 END SUBROUTINE AD14_UnPackTwrPropsParms

 SUBROUTINE AD14_CopyWind( SrcWindData, DstWindData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wind), INTENT(IN) :: SrcWindData
   TYPE(Wind), INTENT(INOUT) :: DstWindData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyWind'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstWindData%ANGFLW = SrcWindData%ANGFLW
    DstWindData%CDEL = SrcWindData%CDEL
    DstWindData%VROTORX = SrcWindData%VROTORX
    DstWindData%VROTORY = SrcWindData%VROTORY
    DstWindData%VROTORZ = SrcWindData%VROTORZ
    DstWindData%SDEL = SrcWindData%SDEL
 END SUBROUTINE AD14_CopyWind

 SUBROUTINE AD14_DestroyWind( WindData, ErrStat, ErrMsg )
  TYPE(Wind), INTENT(INOUT) :: WindData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyWind'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyWind

 SUBROUTINE AD14_PackWind( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Wind),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackWind'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! ANGFLW
      Re_BufSz   = Re_BufSz   + 1  ! CDEL
      Re_BufSz   = Re_BufSz   + 1  ! VROTORX
      Re_BufSz   = Re_BufSz   + 1  ! VROTORY
      Re_BufSz   = Re_BufSz   + 1  ! VROTORZ
      Re_BufSz   = Re_BufSz   + 1  ! SDEL
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%ANGFLW
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CDEL
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VROTORX
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VROTORY
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%VROTORZ
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%SDEL
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackWind

 SUBROUTINE AD14_UnPackWind( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Wind), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackWind'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%ANGFLW = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CDEL = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%VROTORX = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%VROTORY = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%VROTORZ = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%SDEL = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackWind

 SUBROUTINE AD14_CopyWindParms( SrcWindParmsData, DstWindParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WindParms), INTENT(IN) :: SrcWindParmsData
   TYPE(WindParms), INTENT(INOUT) :: DstWindParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyWindParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstWindParmsData%Rho = SrcWindParmsData%Rho
    DstWindParmsData%KinVisc = SrcWindParmsData%KinVisc
 END SUBROUTINE AD14_CopyWindParms

 SUBROUTINE AD14_DestroyWindParms( WindParmsData, ErrStat, ErrMsg )
  TYPE(WindParms), INTENT(INOUT) :: WindParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyWindParms'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyWindParms

 SUBROUTINE AD14_PackWindParms( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WindParms),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackWindParms'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Rho
      Re_BufSz   = Re_BufSz   + 1  ! KinVisc
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Rho
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%KinVisc
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackWindParms

 SUBROUTINE AD14_UnPackWindParms( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WindParms), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackWindParms'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%Rho = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%KinVisc = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackWindParms

 SUBROUTINE AD14_CopyPositionType( SrcPositionTypeData, DstPositionTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(PositionType), INTENT(IN) :: SrcPositionTypeData
   TYPE(PositionType), INTENT(INOUT) :: DstPositionTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyPositionType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstPositionTypeData%Pos = SrcPositionTypeData%Pos
 END SUBROUTINE AD14_CopyPositionType

 SUBROUTINE AD14_DestroyPositionType( PositionTypeData, ErrStat, ErrMsg )
  TYPE(PositionType), INTENT(INOUT) :: PositionTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyPositionType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyPositionType

 SUBROUTINE AD14_PackPositionType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(PositionType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackPositionType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + SIZE(InData%Pos)  ! Pos
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Pos))-1 ) = PACK(InData%Pos,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Pos)
 END SUBROUTINE AD14_PackPositionType

 SUBROUTINE AD14_UnPackPositionType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(PositionType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackPositionType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    i1_l = LBOUND(OutData%Pos,1)
    i1_u = UBOUND(OutData%Pos,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%Pos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Pos))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Pos)
    DEALLOCATE(mask1)
 END SUBROUTINE AD14_UnPackPositionType

 SUBROUTINE AD14_CopyOrientationType( SrcOrientationTypeData, DstOrientationTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(OrientationType), INTENT(IN) :: SrcOrientationTypeData
   TYPE(OrientationType), INTENT(INOUT) :: DstOrientationTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOrientationType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOrientationTypeData%Orient = SrcOrientationTypeData%Orient
 END SUBROUTINE AD14_CopyOrientationType

 SUBROUTINE AD14_DestroyOrientationType( OrientationTypeData, ErrStat, ErrMsg )
  TYPE(OrientationType), INTENT(INOUT) :: OrientationTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOrientationType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AD14_DestroyOrientationType

 SUBROUTINE AD14_PackOrientationType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(OrientationType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackOrientationType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + SIZE(InData%Orient)  ! Orient
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Orient))-1 ) = PACK(InData%Orient,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Orient)
 END SUBROUTINE AD14_PackOrientationType

 SUBROUTINE AD14_UnPackOrientationType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(OrientationType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackOrientationType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    i1_l = LBOUND(OutData%Orient,1)
    i1_u = UBOUND(OutData%Orient,1)
    i2_l = LBOUND(OutData%Orient,2)
    i2_u = UBOUND(OutData%Orient,2)
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      OutData%Orient = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Orient))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Orient)
    DEALLOCATE(mask2)
 END SUBROUTINE AD14_UnPackOrientationType

 SUBROUTINE AD14_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AD14_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%Title = SrcInitInputData%Title
    DstInitInputData%OutRootName = SrcInitInputData%OutRootName
    DstInitInputData%ADFileName = SrcInitInputData%ADFileName
    DstInitInputData%WrSumFile = SrcInitInputData%WrSumFile
    DstInitInputData%NumBl = SrcInitInputData%NumBl
    DstInitInputData%BladeLength = SrcInitInputData%BladeLength
    DstInitInputData%LinearizeFlag = SrcInitInputData%LinearizeFlag
    DstInitInputData%UseDWM = SrcInitInputData%UseDWM
      CALL AD14_Copyaeroconfig( SrcInitInputData%TurbineComponents, DstInitInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%NumTwrNodes = SrcInitInputData%NumTwrNodes
IF (ALLOCATED(SrcInitInputData%TwrNodeLocs)) THEN
  i1_l = LBOUND(SrcInitInputData%TwrNodeLocs,1)
  i1_u = UBOUND(SrcInitInputData%TwrNodeLocs,1)
  i2_l = LBOUND(SrcInitInputData%TwrNodeLocs,2)
  i2_u = UBOUND(SrcInitInputData%TwrNodeLocs,2)
  IF (.NOT. ALLOCATED(DstInitInputData%TwrNodeLocs)) THEN 
    ALLOCATE(DstInitInputData%TwrNodeLocs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TwrNodeLocs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%TwrNodeLocs = SrcInitInputData%TwrNodeLocs
ENDIF
    DstInitInputData%HubHt = SrcInitInputData%HubHt
      CALL DWM_CopyInitInput( SrcInitInputData%DWM, DstInitInputData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyInitInput

 SUBROUTINE AD14_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AD14_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL AD14_Destroyaeroconfig( InitInputData%TurbineComponents, ErrStat, ErrMsg )
IF (ALLOCATED(InitInputData%TwrNodeLocs)) THEN
  DEALLOCATE(InitInputData%TwrNodeLocs)
ENDIF
  CALL DWM_DestroyInitInput( InitInputData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyInitInput

 SUBROUTINE AD14_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%Title)  ! Title
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%OutRootName)  ! OutRootName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%ADFileName)  ! ADFileName
      Int_BufSz  = Int_BufSz  + 1  ! WrSumFile
      Int_BufSz  = Int_BufSz  + 1  ! NumBl
      Re_BufSz   = Re_BufSz   + 1  ! BladeLength
      Int_BufSz  = Int_BufSz  + 1  ! LinearizeFlag
      Int_BufSz  = Int_BufSz  + 1  ! UseDWM
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! TurbineComponents: size of buffers for each call to pack subtype
      CALL AD14_Packaeroconfig( Re_Buf, Db_Buf, Int_Buf, InData%TurbineComponents, ErrStat2, ErrMsg2, .TRUE. ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TurbineComponents
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TurbineComponents
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TurbineComponents
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumTwrNodes
  Int_BufSz   = Int_BufSz   + 1     ! TwrNodeLocs allocated yes/no
  IF ( ALLOCATED(InData%TwrNodeLocs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrNodeLocs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrNodeLocs)  ! TwrNodeLocs
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! HubHt
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackInitInput( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

        DO I = 1, LEN(InData%Title)
          IntKiBuf(Int_Xferred) = ICHAR(InData%Title(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
        DO I = 1, LEN(InData%OutRootName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%OutRootName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
        DO I = 1, LEN(InData%ADFileName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%ADFileName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%WrSumFile , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumBl
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%BladeLength
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%LinearizeFlag , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%UseDWM , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      CALL AD14_Packaeroconfig( Re_Buf, Db_Buf, Int_Buf, InData%TurbineComponents, ErrStat2, ErrMsg2, OnlySize ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumTwrNodes
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%TwrNodeLocs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrNodeLocs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrNodeLocs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrNodeLocs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrNodeLocs,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TwrNodeLocs)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TwrNodeLocs))-1 ) = PACK(InData%TwrNodeLocs,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TwrNodeLocs)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%HubHt
      Re_Xferred   = Re_Xferred   + 1
      CALL DWM_PackInitInput( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackInitInput

 SUBROUTINE AD14_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      DO I = 1, LEN(OutData%Title)
        OutData%Title(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      DO I = 1, LEN(OutData%OutRootName)
        OutData%OutRootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      DO I = 1, LEN(OutData%ADFileName)
        OutData%ADFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      OutData%WrSumFile = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%NumBl = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%BladeLength = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%LinearizeFlag = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%UseDWM = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackaeroconfig( Re_Buf, Db_Buf, Int_Buf, OutData%TurbineComponents, ErrStat2, ErrMsg2 ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      OutData%NumTwrNodes = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrNodeLocs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrNodeLocs)) DEALLOCATE(OutData%TwrNodeLocs)
    ALLOCATE(OutData%TwrNodeLocs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeLocs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%TwrNodeLocs)>0) OutData%TwrNodeLocs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TwrNodeLocs))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TwrNodeLocs)
    DEALLOCATE(mask2)
  END IF
      OutData%HubHt = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackInitInput( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackInitInput

 SUBROUTINE AD14_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AD14_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyInitOutput( SrcInitOutputData%DWM, DstInitOutputData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitOutputData%AirDens = SrcInitOutputData%AirDens
 END SUBROUTINE AD14_CopyInitOutput

 SUBROUTINE AD14_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AD14_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
  CALL DWM_DestroyInitOutput( InitOutputData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyInitOutput

 SUBROUTINE AD14_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! Ver: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Ver, ErrStat2, ErrMsg2, .TRUE. ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Ver
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Ver
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Ver
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackInitOutput( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Re_BufSz   = Re_BufSz   + 1  ! AirDens
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Ver, ErrStat2, ErrMsg2, OnlySize ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL DWM_PackInitOutput( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%AirDens
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AD14_PackInitOutput

 SUBROUTINE AD14_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackprogdesc( Re_Buf, Db_Buf, Int_Buf, OutData%Ver, ErrStat2, ErrMsg2 ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackInitOutput( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      OutData%AirDens = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE AD14_UnPackInitOutput

 SUBROUTINE AD14_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AD14_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyContState( SrcContStateData%DWM, DstContStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyContState

 SUBROUTINE AD14_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AD14_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_DestroyContState( ContStateData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyContState

 SUBROUTINE AD14_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL DWM_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackContState

 SUBROUTINE AD14_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackContState( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackContState

 SUBROUTINE AD14_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AD14_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyDiscState( SrcDiscStateData%DWM, DstDiscStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyDiscState

 SUBROUTINE AD14_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AD14_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_DestroyDiscState( DiscStateData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyDiscState

 SUBROUTINE AD14_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackDiscState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL DWM_PackDiscState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackDiscState

 SUBROUTINE AD14_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackDiscState( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackDiscState

 SUBROUTINE AD14_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AD14_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyConstrState( SrcConstrStateData%DWM, DstConstrStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyConstrState

 SUBROUTINE AD14_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AD14_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_DestroyConstrState( ConstrStateData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyConstrState

 SUBROUTINE AD14_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackConstrState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL DWM_PackConstrState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackConstrState

 SUBROUTINE AD14_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackConstrState( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackConstrState

 SUBROUTINE AD14_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AD14_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyOtherState( SrcOtherStateData%DWM, DstOtherStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyOtherState

 SUBROUTINE AD14_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AD14_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_DestroyOtherState( OtherStateData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyOtherState

 SUBROUTINE AD14_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackOtherState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL DWM_PackOtherState( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackOtherState

 SUBROUTINE AD14_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackOtherState( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackOtherState

 SUBROUTINE AD14_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(AD14_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyMisc( SrcMiscData%DWM, DstMiscData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyInput( SrcMiscData%DWM_Inputs, DstMiscData%DWM_Inputs, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyOutput( SrcMiscData%DWM_Outputs, DstMiscData%DWM_Outputs, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%DT = SrcMiscData%DT
IF (ALLOCATED(SrcMiscData%ElPrNum)) THEN
  i1_l = LBOUND(SrcMiscData%ElPrNum,1)
  i1_u = UBOUND(SrcMiscData%ElPrNum,1)
  IF (.NOT. ALLOCATED(DstMiscData%ElPrNum)) THEN 
    ALLOCATE(DstMiscData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ElPrNum = SrcMiscData%ElPrNum
ENDIF
    DstMiscData%OldTime = SrcMiscData%OldTime
    DstMiscData%HubLoss = SrcMiscData%HubLoss
    DstMiscData%Loss = SrcMiscData%Loss
    DstMiscData%TipLoss = SrcMiscData%TipLoss
    DstMiscData%TLpt7 = SrcMiscData%TLpt7
    DstMiscData%FirstPassGTL = SrcMiscData%FirstPassGTL
    DstMiscData%SuperSonic = SrcMiscData%SuperSonic
    DstMiscData%AFLAGVinderr = SrcMiscData%AFLAGVinderr
    DstMiscData%AFLAGTwrInflu = SrcMiscData%AFLAGTwrInflu
    DstMiscData%OnePassDynDbg = SrcMiscData%OnePassDynDbg
    DstMiscData%NoLoadsCalculated = SrcMiscData%NoLoadsCalculated
    DstMiscData%NERRORS = SrcMiscData%NERRORS
      CALL AD14_Copyairfoil( SrcMiscData%AirFoil, DstMiscData%AirFoil, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybeddoes( SrcMiscData%Beddoes, DstMiscData%Beddoes, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copydyninflow( SrcMiscData%DynInflow, DstMiscData%DynInflow, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyelement( SrcMiscData%Element, DstMiscData%Element, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyrotor( SrcMiscData%Rotor, DstMiscData%Rotor, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copywind( SrcMiscData%Wind, DstMiscData%Wind, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyinducedvel( SrcMiscData%InducedVel, DstMiscData%InducedVel, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyeloutparms( SrcMiscData%ElOut, DstMiscData%ElOut, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%Skew = SrcMiscData%Skew
    DstMiscData%DynInit = SrcMiscData%DynInit
    DstMiscData%FirstWarn = SrcMiscData%FirstWarn
IF (ALLOCATED(SrcMiscData%StoredForces)) THEN
  i1_l = LBOUND(SrcMiscData%StoredForces,1)
  i1_u = UBOUND(SrcMiscData%StoredForces,1)
  i2_l = LBOUND(SrcMiscData%StoredForces,2)
  i2_u = UBOUND(SrcMiscData%StoredForces,2)
  i3_l = LBOUND(SrcMiscData%StoredForces,3)
  i3_u = UBOUND(SrcMiscData%StoredForces,3)
  IF (.NOT. ALLOCATED(DstMiscData%StoredForces)) THEN 
    ALLOCATE(DstMiscData%StoredForces(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredForces.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%StoredForces = SrcMiscData%StoredForces
ENDIF
IF (ALLOCATED(SrcMiscData%StoredMoments)) THEN
  i1_l = LBOUND(SrcMiscData%StoredMoments,1)
  i1_u = UBOUND(SrcMiscData%StoredMoments,1)
  i2_l = LBOUND(SrcMiscData%StoredMoments,2)
  i2_u = UBOUND(SrcMiscData%StoredMoments,2)
  i3_l = LBOUND(SrcMiscData%StoredMoments,3)
  i3_u = UBOUND(SrcMiscData%StoredMoments,3)
  IF (.NOT. ALLOCATED(DstMiscData%StoredMoments)) THEN 
    ALLOCATE(DstMiscData%StoredMoments(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredMoments.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%StoredMoments = SrcMiscData%StoredMoments
ENDIF
 END SUBROUTINE AD14_CopyMisc

 SUBROUTINE AD14_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(AD14_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_DestroyMisc( MiscData%DWM, ErrStat, ErrMsg )
  CALL DWM_DestroyInput( MiscData%DWM_Inputs, ErrStat, ErrMsg )
  CALL DWM_DestroyOutput( MiscData%DWM_Outputs, ErrStat, ErrMsg )
IF (ALLOCATED(MiscData%ElPrNum)) THEN
  DEALLOCATE(MiscData%ElPrNum)
ENDIF
  CALL AD14_Destroyairfoil( MiscData%AirFoil, ErrStat, ErrMsg )
  CALL AD14_Destroybeddoes( MiscData%Beddoes, ErrStat, ErrMsg )
  CALL AD14_Destroydyninflow( MiscData%DynInflow, ErrStat, ErrMsg )
  CALL AD14_Destroyelement( MiscData%Element, ErrStat, ErrMsg )
  CALL AD14_Destroyrotor( MiscData%Rotor, ErrStat, ErrMsg )
  CALL AD14_Destroywind( MiscData%Wind, ErrStat, ErrMsg )
  CALL AD14_Destroyinducedvel( MiscData%InducedVel, ErrStat, ErrMsg )
  CALL AD14_Destroyeloutparms( MiscData%ElOut, ErrStat, ErrMsg )
IF (ALLOCATED(MiscData%StoredForces)) THEN
  DEALLOCATE(MiscData%StoredForces)
ENDIF
IF (ALLOCATED(MiscData%StoredMoments)) THEN
  DEALLOCATE(MiscData%StoredMoments)
ENDIF
 END SUBROUTINE AD14_DestroyMisc

 SUBROUTINE AD14_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DWM_Inputs: size of buffers for each call to pack subtype
      CALL DWM_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%DWM_Inputs, ErrStat2, ErrMsg2, .TRUE. ) ! DWM_Inputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM_Inputs
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM_Inputs
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM_Inputs
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DWM_Outputs: size of buffers for each call to pack subtype
      CALL DWM_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%DWM_Outputs, ErrStat2, ErrMsg2, .TRUE. ) ! DWM_Outputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM_Outputs
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM_Outputs
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM_Outputs
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz   = Int_BufSz   + 1     ! ElPrNum allocated yes/no
  IF ( ALLOCATED(InData%ElPrNum) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ElPrNum upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ElPrNum)  ! ElPrNum
  END IF
      Db_BufSz   = Db_BufSz   + 1  ! OldTime
      Re_BufSz   = Re_BufSz   + 1  ! HubLoss
      Re_BufSz   = Re_BufSz   + 1  ! Loss
      Re_BufSz   = Re_BufSz   + 1  ! TipLoss
      Re_BufSz   = Re_BufSz   + 1  ! TLpt7
      Int_BufSz  = Int_BufSz  + 1  ! FirstPassGTL
      Int_BufSz  = Int_BufSz  + 1  ! SuperSonic
      Int_BufSz  = Int_BufSz  + 1  ! AFLAGVinderr
      Int_BufSz  = Int_BufSz  + 1  ! AFLAGTwrInflu
      Int_BufSz  = Int_BufSz  + 1  ! OnePassDynDbg
      Int_BufSz  = Int_BufSz  + 1  ! NoLoadsCalculated
      Int_BufSz  = Int_BufSz  + 1  ! NERRORS
      Int_BufSz   = Int_BufSz + 3  ! AirFoil: size of buffers for each call to pack subtype
      CALL AD14_Packairfoil( Re_Buf, Db_Buf, Int_Buf, InData%AirFoil, ErrStat2, ErrMsg2, .TRUE. ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AirFoil
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AirFoil
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AirFoil
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Beddoes: size of buffers for each call to pack subtype
      CALL AD14_Packbeddoes( Re_Buf, Db_Buf, Int_Buf, InData%Beddoes, ErrStat2, ErrMsg2, .TRUE. ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Beddoes
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Beddoes
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Beddoes
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DynInflow: size of buffers for each call to pack subtype
      CALL AD14_Packdyninflow( Re_Buf, Db_Buf, Int_Buf, InData%DynInflow, ErrStat2, ErrMsg2, .TRUE. ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DynInflow
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DynInflow
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DynInflow
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Element: size of buffers for each call to pack subtype
      CALL AD14_Packelement( Re_Buf, Db_Buf, Int_Buf, InData%Element, ErrStat2, ErrMsg2, .TRUE. ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Element
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Element
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Element
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Rotor: size of buffers for each call to pack subtype
      CALL AD14_Packrotor( Re_Buf, Db_Buf, Int_Buf, InData%Rotor, ErrStat2, ErrMsg2, .TRUE. ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Rotor
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Rotor
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Rotor
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Wind: size of buffers for each call to pack subtype
      CALL AD14_Packwind( Re_Buf, Db_Buf, Int_Buf, InData%Wind, ErrStat2, ErrMsg2, .TRUE. ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Wind
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Wind
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Wind
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! InducedVel: size of buffers for each call to pack subtype
      CALL AD14_Packinducedvel( Re_Buf, Db_Buf, Int_Buf, InData%InducedVel, ErrStat2, ErrMsg2, .TRUE. ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InducedVel
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InducedVel
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InducedVel
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! ElOut: size of buffers for each call to pack subtype
      CALL AD14_Packeloutparms( Re_Buf, Db_Buf, Int_Buf, InData%ElOut, ErrStat2, ErrMsg2, .TRUE. ) ! ElOut 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! ElOut
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! ElOut
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! ElOut
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! Skew
      Int_BufSz  = Int_BufSz  + 1  ! DynInit
      Int_BufSz  = Int_BufSz  + 1  ! FirstWarn
  Int_BufSz   = Int_BufSz   + 1     ! StoredForces allocated yes/no
  IF ( ALLOCATED(InData%StoredForces) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! StoredForces upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%StoredForces)  ! StoredForces
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! StoredMoments allocated yes/no
  IF ( ALLOCATED(InData%StoredMoments) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! StoredMoments upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%StoredMoments)  ! StoredMoments
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL DWM_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL DWM_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%DWM_Inputs, ErrStat2, ErrMsg2, OnlySize ) ! DWM_Inputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL DWM_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%DWM_Outputs, ErrStat2, ErrMsg2, OnlySize ) ! DWM_Outputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) = InData%DT
      Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%ElPrNum) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ElPrNum,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ElPrNum,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ElPrNum)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElPrNum))-1 ) = PACK(InData%ElPrNum,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%ElPrNum)
  END IF
      DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) = InData%OldTime
      Db_Xferred   = Db_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%HubLoss
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Loss
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TipLoss
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TLpt7
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%FirstPassGTL , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%SuperSonic , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%AFLAGVinderr , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%AFLAGTwrInflu , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%OnePassDynDbg , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%NoLoadsCalculated , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NERRORS
      Int_Xferred   = Int_Xferred   + 1
      CALL AD14_Packairfoil( Re_Buf, Db_Buf, Int_Buf, InData%AirFoil, ErrStat2, ErrMsg2, OnlySize ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packbeddoes( Re_Buf, Db_Buf, Int_Buf, InData%Beddoes, ErrStat2, ErrMsg2, OnlySize ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packdyninflow( Re_Buf, Db_Buf, Int_Buf, InData%DynInflow, ErrStat2, ErrMsg2, OnlySize ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packelement( Re_Buf, Db_Buf, Int_Buf, InData%Element, ErrStat2, ErrMsg2, OnlySize ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packrotor( Re_Buf, Db_Buf, Int_Buf, InData%Rotor, ErrStat2, ErrMsg2, OnlySize ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packwind( Re_Buf, Db_Buf, Int_Buf, InData%Wind, ErrStat2, ErrMsg2, OnlySize ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packinducedvel( Re_Buf, Db_Buf, Int_Buf, InData%InducedVel, ErrStat2, ErrMsg2, OnlySize ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packeloutparms( Re_Buf, Db_Buf, Int_Buf, InData%ElOut, ErrStat2, ErrMsg2, OnlySize ) ! ElOut 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%Skew , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%DynInit , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%FirstWarn , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%StoredForces) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredForces,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredForces,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredForces,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredForces,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredForces,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredForces,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%StoredForces)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%StoredForces))-1 ) = PACK(InData%StoredForces,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%StoredForces)
  END IF
  IF ( .NOT. ALLOCATED(InData%StoredMoments) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredMoments,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredMoments,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredMoments,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredMoments,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%StoredMoments,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%StoredMoments,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%StoredMoments)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%StoredMoments))-1 ) = PACK(InData%StoredMoments,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%StoredMoments)
  END IF
 END SUBROUTINE AD14_PackMisc

 SUBROUTINE AD14_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackMisc( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackInput( Re_Buf, Db_Buf, Int_Buf, OutData%DWM_Inputs, ErrStat2, ErrMsg2 ) ! DWM_Inputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackOutput( Re_Buf, Db_Buf, Int_Buf, OutData%DWM_Outputs, ErrStat2, ErrMsg2 ) ! DWM_Outputs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      OutData%DT = DbKiBuf( Db_Xferred ) 
      Db_Xferred   = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ElPrNum not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ElPrNum)) DEALLOCATE(OutData%ElPrNum)
    ALLOCATE(OutData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ElPrNum)>0) OutData%ElPrNum = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%ElPrNum))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%ElPrNum)
    DEALLOCATE(mask1)
  END IF
      OutData%OldTime = DbKiBuf( Db_Xferred ) 
      Db_Xferred   = Db_Xferred + 1
      OutData%HubLoss = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%Loss = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TipLoss = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%TLpt7 = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FirstPassGTL = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%SuperSonic = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%AFLAGVinderr = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%AFLAGTwrInflu = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%OnePassDynDbg = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%NoLoadsCalculated = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%NERRORS = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackairfoil( Re_Buf, Db_Buf, Int_Buf, OutData%AirFoil, ErrStat2, ErrMsg2 ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackbeddoes( Re_Buf, Db_Buf, Int_Buf, OutData%Beddoes, ErrStat2, ErrMsg2 ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackdyninflow( Re_Buf, Db_Buf, Int_Buf, OutData%DynInflow, ErrStat2, ErrMsg2 ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackelement( Re_Buf, Db_Buf, Int_Buf, OutData%Element, ErrStat2, ErrMsg2 ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackrotor( Re_Buf, Db_Buf, Int_Buf, OutData%Rotor, ErrStat2, ErrMsg2 ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackwind( Re_Buf, Db_Buf, Int_Buf, OutData%Wind, ErrStat2, ErrMsg2 ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackinducedvel( Re_Buf, Db_Buf, Int_Buf, OutData%InducedVel, ErrStat2, ErrMsg2 ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackeloutparms( Re_Buf, Db_Buf, Int_Buf, OutData%ElOut, ErrStat2, ErrMsg2 ) ! ElOut 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      OutData%Skew = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%DynInit = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%FirstWarn = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! StoredForces not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%StoredForces)) DEALLOCATE(OutData%StoredForces)
    ALLOCATE(OutData%StoredForces(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredForces.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%StoredForces)>0) OutData%StoredForces = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%StoredForces))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%StoredForces)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! StoredMoments not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%StoredMoments)) DEALLOCATE(OutData%StoredMoments)
    ALLOCATE(OutData%StoredMoments(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredMoments.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%StoredMoments)>0) OutData%StoredMoments = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%StoredMoments))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%StoredMoments)
    DEALLOCATE(mask3)
  END IF
 END SUBROUTINE AD14_UnPackMisc

 SUBROUTINE AD14_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AD14_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%Title = SrcParamData%Title
    DstParamData%SIUnit = SrcParamData%SIUnit
    DstParamData%Echo = SrcParamData%Echo
    DstParamData%MultiTab = SrcParamData%MultiTab
    DstParamData%LinearizeFlag = SrcParamData%LinearizeFlag
    DstParamData%OutputPlottingInfo = SrcParamData%OutputPlottingInfo
    DstParamData%UseDWM = SrcParamData%UseDWM
    DstParamData%TwoPiNB = SrcParamData%TwoPiNB
    DstParamData%NumBl = SrcParamData%NumBl
    DstParamData%NBlInpSt = SrcParamData%NBlInpSt
    DstParamData%ElemPrn = SrcParamData%ElemPrn
    DstParamData%DStall = SrcParamData%DStall
    DstParamData%PMoment = SrcParamData%PMoment
    DstParamData%Reynolds = SrcParamData%Reynolds
    DstParamData%DynInfl = SrcParamData%DynInfl
    DstParamData%Wake = SrcParamData%Wake
    DstParamData%Swirl = SrcParamData%Swirl
    DstParamData%DtAero = SrcParamData%DtAero
    DstParamData%HubRad = SrcParamData%HubRad
    DstParamData%UnEc = SrcParamData%UnEc
    DstParamData%UnElem = SrcParamData%UnElem
    DstParamData%UnWndOut = SrcParamData%UnWndOut
    DstParamData%MAXICOUNT = SrcParamData%MAXICOUNT
    DstParamData%WrOptFile = SrcParamData%WrOptFile
    DstParamData%DEFAULT_Wind = SrcParamData%DEFAULT_Wind
      CALL AD14_Copyairfoilparms( SrcParamData%AirFoil, DstParamData%AirFoil, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybladeparms( SrcParamData%Blade, DstParamData%Blade, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybeddoesparms( SrcParamData%Beddoes, DstParamData%Beddoes, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copydyninflowparms( SrcParamData%DynInflow, DstParamData%DynInflow, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyelementparms( SrcParamData%Element, DstParamData%Element, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copytwrpropsparms( SrcParamData%TwrProps, DstParamData%TwrProps, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyinducedvelparms( SrcParamData%InducedVel, DstParamData%InducedVel, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copywindparms( SrcParamData%Wind, DstParamData%Wind, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyrotorparms( SrcParamData%Rotor, DstParamData%Rotor, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyParam( SrcParamData%DWM, DstParamData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyParam

 SUBROUTINE AD14_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AD14_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL AD14_Destroyairfoilparms( ParamData%AirFoil, ErrStat, ErrMsg )
  CALL AD14_Destroybladeparms( ParamData%Blade, ErrStat, ErrMsg )
  CALL AD14_Destroybeddoesparms( ParamData%Beddoes, ErrStat, ErrMsg )
  CALL AD14_Destroydyninflowparms( ParamData%DynInflow, ErrStat, ErrMsg )
  CALL AD14_Destroyelementparms( ParamData%Element, ErrStat, ErrMsg )
  CALL AD14_Destroytwrpropsparms( ParamData%TwrProps, ErrStat, ErrMsg )
  CALL AD14_Destroyinducedvelparms( ParamData%InducedVel, ErrStat, ErrMsg )
  CALL AD14_Destroywindparms( ParamData%Wind, ErrStat, ErrMsg )
  CALL AD14_Destroyrotorparms( ParamData%Rotor, ErrStat, ErrMsg )
  CALL DWM_DestroyParam( ParamData%DWM, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyParam

 SUBROUTINE AD14_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%Title)  ! Title
      Int_BufSz  = Int_BufSz  + 1  ! SIUnit
      Int_BufSz  = Int_BufSz  + 1  ! Echo
      Int_BufSz  = Int_BufSz  + 1  ! MultiTab
      Int_BufSz  = Int_BufSz  + 1  ! LinearizeFlag
      Int_BufSz  = Int_BufSz  + 1  ! OutputPlottingInfo
      Int_BufSz  = Int_BufSz  + 1  ! UseDWM
      Re_BufSz   = Re_BufSz   + 1  ! TwoPiNB
      Int_BufSz  = Int_BufSz  + 1  ! NumBl
      Int_BufSz  = Int_BufSz  + 1  ! NBlInpSt
      Int_BufSz  = Int_BufSz  + 1  ! ElemPrn
      Int_BufSz  = Int_BufSz  + 1  ! DStall
      Int_BufSz  = Int_BufSz  + 1  ! PMoment
      Int_BufSz  = Int_BufSz  + 1  ! Reynolds
      Int_BufSz  = Int_BufSz  + 1  ! DynInfl
      Int_BufSz  = Int_BufSz  + 1  ! Wake
      Int_BufSz  = Int_BufSz  + 1  ! Swirl
      Db_BufSz   = Db_BufSz   + 1  ! DtAero
      Re_BufSz   = Re_BufSz   + 1  ! HubRad
      Int_BufSz  = Int_BufSz  + 1  ! UnEc
      Int_BufSz  = Int_BufSz  + 1  ! UnElem
      Int_BufSz  = Int_BufSz  + 1  ! UnWndOut
      Int_BufSz  = Int_BufSz  + 1  ! MAXICOUNT
      Int_BufSz  = Int_BufSz  + 1  ! WrOptFile
      Int_BufSz  = Int_BufSz  + 1  ! DEFAULT_Wind
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! AirFoil: size of buffers for each call to pack subtype
      CALL AD14_Packairfoilparms( Re_Buf, Db_Buf, Int_Buf, InData%AirFoil, ErrStat2, ErrMsg2, .TRUE. ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AirFoil
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AirFoil
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AirFoil
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Blade: size of buffers for each call to pack subtype
      CALL AD14_Packbladeparms( Re_Buf, Db_Buf, Int_Buf, InData%Blade, ErrStat2, ErrMsg2, .TRUE. ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Blade
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Blade
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Blade
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Beddoes: size of buffers for each call to pack subtype
      CALL AD14_Packbeddoesparms( Re_Buf, Db_Buf, Int_Buf, InData%Beddoes, ErrStat2, ErrMsg2, .TRUE. ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Beddoes
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Beddoes
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Beddoes
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DynInflow: size of buffers for each call to pack subtype
      CALL AD14_Packdyninflowparms( Re_Buf, Db_Buf, Int_Buf, InData%DynInflow, ErrStat2, ErrMsg2, .TRUE. ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DynInflow
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DynInflow
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DynInflow
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Element: size of buffers for each call to pack subtype
      CALL AD14_Packelementparms( Re_Buf, Db_Buf, Int_Buf, InData%Element, ErrStat2, ErrMsg2, .TRUE. ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Element
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Element
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Element
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! TwrProps: size of buffers for each call to pack subtype
      CALL AD14_Packtwrpropsparms( Re_Buf, Db_Buf, Int_Buf, InData%TwrProps, ErrStat2, ErrMsg2, .TRUE. ) ! TwrProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TwrProps
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TwrProps
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TwrProps
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! InducedVel: size of buffers for each call to pack subtype
      CALL AD14_Packinducedvelparms( Re_Buf, Db_Buf, Int_Buf, InData%InducedVel, ErrStat2, ErrMsg2, .TRUE. ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InducedVel
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InducedVel
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InducedVel
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Wind: size of buffers for each call to pack subtype
      CALL AD14_Packwindparms( Re_Buf, Db_Buf, Int_Buf, InData%Wind, ErrStat2, ErrMsg2, .TRUE. ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Wind
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Wind
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Wind
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Rotor: size of buffers for each call to pack subtype
      CALL AD14_Packrotorparms( Re_Buf, Db_Buf, Int_Buf, InData%Rotor, ErrStat2, ErrMsg2, .TRUE. ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Rotor
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Rotor
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Rotor
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! DWM: size of buffers for each call to pack subtype
      CALL DWM_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, .TRUE. ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DWM
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DWM
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DWM
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

        DO I = 1, LEN(InData%Title)
          IntKiBuf(Int_Xferred) = ICHAR(InData%Title(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%SIUnit , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%Echo , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%MultiTab , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%LinearizeFlag , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%OutputPlottingInfo , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%UseDWM , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%TwoPiNB
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumBl
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NBlInpSt
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%ElemPrn , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%DStall , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%PMoment , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%Reynolds , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%DynInfl , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%Wake , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%Swirl , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) = InData%DtAero
      Db_Xferred   = Db_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%HubRad
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%UnEc
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%UnElem
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%UnWndOut
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%MAXICOUNT
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%WrOptFile , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%DEFAULT_Wind
      Int_Xferred   = Int_Xferred   + 1
      CALL AD14_Packairfoilparms( Re_Buf, Db_Buf, Int_Buf, InData%AirFoil, ErrStat2, ErrMsg2, OnlySize ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packbladeparms( Re_Buf, Db_Buf, Int_Buf, InData%Blade, ErrStat2, ErrMsg2, OnlySize ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packbeddoesparms( Re_Buf, Db_Buf, Int_Buf, InData%Beddoes, ErrStat2, ErrMsg2, OnlySize ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packdyninflowparms( Re_Buf, Db_Buf, Int_Buf, InData%DynInflow, ErrStat2, ErrMsg2, OnlySize ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packelementparms( Re_Buf, Db_Buf, Int_Buf, InData%Element, ErrStat2, ErrMsg2, OnlySize ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packtwrpropsparms( Re_Buf, Db_Buf, Int_Buf, InData%TwrProps, ErrStat2, ErrMsg2, OnlySize ) ! TwrProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packinducedvelparms( Re_Buf, Db_Buf, Int_Buf, InData%InducedVel, ErrStat2, ErrMsg2, OnlySize ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packwindparms( Re_Buf, Db_Buf, Int_Buf, InData%Wind, ErrStat2, ErrMsg2, OnlySize ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packrotorparms( Re_Buf, Db_Buf, Int_Buf, InData%Rotor, ErrStat2, ErrMsg2, OnlySize ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL DWM_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%DWM, ErrStat2, ErrMsg2, OnlySize ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackParam

 SUBROUTINE AD14_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      DO I = 1, LEN(OutData%Title)
        OutData%Title(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      OutData%SIUnit = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%Echo = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%MultiTab = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%LinearizeFlag = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%OutputPlottingInfo = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%UseDWM = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%TwoPiNB = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%NumBl = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%NBlInpSt = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%ElemPrn = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%DStall = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%PMoment = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%Reynolds = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%DynInfl = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%Wake = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%Swirl = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%DtAero = DbKiBuf( Db_Xferred ) 
      Db_Xferred   = Db_Xferred + 1
      OutData%HubRad = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%UnEc = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%UnElem = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%UnWndOut = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%MAXICOUNT = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%WrOptFile = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%DEFAULT_Wind = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackairfoilparms( Re_Buf, Db_Buf, Int_Buf, OutData%AirFoil, ErrStat2, ErrMsg2 ) ! AirFoil 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackbladeparms( Re_Buf, Db_Buf, Int_Buf, OutData%Blade, ErrStat2, ErrMsg2 ) ! Blade 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackbeddoesparms( Re_Buf, Db_Buf, Int_Buf, OutData%Beddoes, ErrStat2, ErrMsg2 ) ! Beddoes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackdyninflowparms( Re_Buf, Db_Buf, Int_Buf, OutData%DynInflow, ErrStat2, ErrMsg2 ) ! DynInflow 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackelementparms( Re_Buf, Db_Buf, Int_Buf, OutData%Element, ErrStat2, ErrMsg2 ) ! Element 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpacktwrpropsparms( Re_Buf, Db_Buf, Int_Buf, OutData%TwrProps, ErrStat2, ErrMsg2 ) ! TwrProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackinducedvelparms( Re_Buf, Db_Buf, Int_Buf, OutData%InducedVel, ErrStat2, ErrMsg2 ) ! InducedVel 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackwindparms( Re_Buf, Db_Buf, Int_Buf, OutData%Wind, ErrStat2, ErrMsg2 ) ! Wind 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackrotorparms( Re_Buf, Db_Buf, Int_Buf, OutData%Rotor, ErrStat2, ErrMsg2 ) ! Rotor 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL DWM_UnpackParam( Re_Buf, Db_Buf, Int_Buf, OutData%DWM, ErrStat2, ErrMsg2 ) ! DWM 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackParam

 SUBROUTINE AD14_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(AD14_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%InputMarkers)) THEN
  i1_l = LBOUND(SrcInputData%InputMarkers,1)
  i1_u = UBOUND(SrcInputData%InputMarkers,1)
  IF (.NOT. ALLOCATED(DstInputData%InputMarkers)) THEN 
    ALLOCATE(DstInputData%InputMarkers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InputMarkers.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%InputMarkers,1), UBOUND(SrcInputData%InputMarkers,1)
      CALL MeshCopy( SrcInputData%InputMarkers(i1), DstInputData%InputMarkers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcInputData%Twr_InputMarkers, DstInputData%Twr_InputMarkers, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyaeroconfig( SrcInputData%TurbineComponents, DstInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputData%MulTabLoc)) THEN
  i1_l = LBOUND(SrcInputData%MulTabLoc,1)
  i1_u = UBOUND(SrcInputData%MulTabLoc,1)
  i2_l = LBOUND(SrcInputData%MulTabLoc,2)
  i2_u = UBOUND(SrcInputData%MulTabLoc,2)
  IF (.NOT. ALLOCATED(DstInputData%MulTabLoc)) THEN 
    ALLOCATE(DstInputData%MulTabLoc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MulTabLoc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%MulTabLoc = SrcInputData%MulTabLoc
ENDIF
IF (ALLOCATED(SrcInputData%InflowVelocity)) THEN
  i1_l = LBOUND(SrcInputData%InflowVelocity,1)
  i1_u = UBOUND(SrcInputData%InflowVelocity,1)
  i2_l = LBOUND(SrcInputData%InflowVelocity,2)
  i2_u = UBOUND(SrcInputData%InflowVelocity,2)
  IF (.NOT. ALLOCATED(DstInputData%InflowVelocity)) THEN 
    ALLOCATE(DstInputData%InflowVelocity(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowVelocity.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%InflowVelocity = SrcInputData%InflowVelocity
ENDIF
    DstInputData%AvgInfVel = SrcInputData%AvgInfVel
 END SUBROUTINE AD14_CopyInput

 SUBROUTINE AD14_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AD14_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%InputMarkers)) THEN
DO i1 = LBOUND(InputData%InputMarkers,1), UBOUND(InputData%InputMarkers,1)
  CALL MeshDestroy( InputData%InputMarkers(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InputData%InputMarkers)
ENDIF
  CALL MeshDestroy( InputData%Twr_InputMarkers, ErrStat, ErrMsg )
  CALL AD14_Destroyaeroconfig( InputData%TurbineComponents, ErrStat, ErrMsg )
IF (ALLOCATED(InputData%MulTabLoc)) THEN
  DEALLOCATE(InputData%MulTabLoc)
ENDIF
IF (ALLOCATED(InputData%InflowVelocity)) THEN
  DEALLOCATE(InputData%InflowVelocity)
ENDIF
 END SUBROUTINE AD14_DestroyInput

 SUBROUTINE AD14_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! InputMarkers allocated yes/no
  IF ( ALLOCATED(InData%InputMarkers) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! InputMarkers upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%InputMarkers,1), UBOUND(InData%InputMarkers,1)
      Int_BufSz   = Int_BufSz + 3  ! InputMarkers: size of buffers for each call to pack subtype
      CALL MeshPack( InData%InputMarkers(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InputMarkers
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InputMarkers
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InputMarkers
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! Twr_InputMarkers: size of buffers for each call to pack subtype
      CALL MeshPack( InData%Twr_InputMarkers, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! Twr_InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Twr_InputMarkers
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Twr_InputMarkers
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Twr_InputMarkers
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! TurbineComponents: size of buffers for each call to pack subtype
      CALL AD14_Packaeroconfig( Re_Buf, Db_Buf, Int_Buf, InData%TurbineComponents, ErrStat2, ErrMsg2, .TRUE. ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TurbineComponents
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TurbineComponents
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TurbineComponents
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! MulTabLoc allocated yes/no
  IF ( ALLOCATED(InData%MulTabLoc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! MulTabLoc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%MulTabLoc)  ! MulTabLoc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! InflowVelocity allocated yes/no
  IF ( ALLOCATED(InData%InflowVelocity) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! InflowVelocity upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowVelocity)  ! InflowVelocity
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%AvgInfVel)  ! AvgInfVel
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%InputMarkers) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InputMarkers,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InputMarkers,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%InputMarkers,1), UBOUND(InData%InputMarkers,1)
      CALL MeshPack( InData%InputMarkers(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL MeshPack( InData%Twr_InputMarkers, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! Twr_InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AD14_Packaeroconfig( Re_Buf, Db_Buf, Int_Buf, InData%TurbineComponents, ErrStat2, ErrMsg2, OnlySize ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%MulTabLoc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MulTabLoc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MulTabLoc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MulTabLoc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MulTabLoc,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%MulTabLoc)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MulTabLoc))-1 ) = PACK(InData%MulTabLoc,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%MulTabLoc)
  END IF
  IF ( .NOT. ALLOCATED(InData%InflowVelocity) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowVelocity,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowVelocity,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowVelocity,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowVelocity,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%InflowVelocity)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%InflowVelocity))-1 ) = PACK(InData%InflowVelocity,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%InflowVelocity)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AvgInfVel))-1 ) = PACK(InData%AvgInfVel,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AvgInfVel)
 END SUBROUTINE AD14_PackInput

 SUBROUTINE AD14_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InputMarkers not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InputMarkers)) DEALLOCATE(OutData%InputMarkers)
    ALLOCATE(OutData%InputMarkers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputMarkers.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%InputMarkers,1), UBOUND(OutData%InputMarkers,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%InputMarkers(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%Twr_InputMarkers, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! Twr_InputMarkers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD14_Unpackaeroconfig( Re_Buf, Db_Buf, Int_Buf, OutData%TurbineComponents, ErrStat2, ErrMsg2 ) ! TurbineComponents 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MulTabLoc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MulTabLoc)) DEALLOCATE(OutData%MulTabLoc)
    ALLOCATE(OutData%MulTabLoc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabLoc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%MulTabLoc)>0) OutData%MulTabLoc = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MulTabLoc))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%MulTabLoc)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InflowVelocity not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InflowVelocity)) DEALLOCATE(OutData%InflowVelocity)
    ALLOCATE(OutData%InflowVelocity(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowVelocity.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%InflowVelocity)>0) OutData%InflowVelocity = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%InflowVelocity))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%InflowVelocity)
    DEALLOCATE(mask2)
  END IF
    i1_l = LBOUND(OutData%AvgInfVel,1)
    i1_u = UBOUND(OutData%AvgInfVel,1)
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      OutData%AvgInfVel = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AvgInfVel))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AvgInfVel)
    DEALLOCATE(mask1)
 END SUBROUTINE AD14_UnPackInput

 SUBROUTINE AD14_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(AD14_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%OutputLoads)) THEN
  i1_l = LBOUND(SrcOutputData%OutputLoads,1)
  i1_u = UBOUND(SrcOutputData%OutputLoads,1)
  IF (.NOT. ALLOCATED(DstOutputData%OutputLoads)) THEN 
    ALLOCATE(DstOutputData%OutputLoads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%OutputLoads.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%OutputLoads,1), UBOUND(SrcOutputData%OutputLoads,1)
      CALL MeshCopy( SrcOutputData%OutputLoads(i1), DstOutputData%OutputLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcOutputData%Twr_OutputLoads, DstOutputData%Twr_OutputLoads, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyOutput

 SUBROUTINE AD14_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AD14_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%OutputLoads)) THEN
DO i1 = LBOUND(OutputData%OutputLoads,1), UBOUND(OutputData%OutputLoads,1)
  CALL MeshDestroy( OutputData%OutputLoads(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(OutputData%OutputLoads)
ENDIF
  CALL MeshDestroy( OutputData%Twr_OutputLoads, ErrStat, ErrMsg )
 END SUBROUTINE AD14_DestroyOutput

 SUBROUTINE AD14_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD14_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! OutputLoads allocated yes/no
  IF ( ALLOCATED(InData%OutputLoads) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! OutputLoads upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%OutputLoads,1), UBOUND(InData%OutputLoads,1)
      Int_BufSz   = Int_BufSz + 3  ! OutputLoads: size of buffers for each call to pack subtype
      CALL MeshPack( InData%OutputLoads(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! OutputLoads
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! OutputLoads
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! OutputLoads
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! Twr_OutputLoads: size of buffers for each call to pack subtype
      CALL MeshPack( InData%Twr_OutputLoads, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! Twr_OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Twr_OutputLoads
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Twr_OutputLoads
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Twr_OutputLoads
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%OutputLoads) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OutputLoads,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OutputLoads,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%OutputLoads,1), UBOUND(InData%OutputLoads,1)
      CALL MeshPack( InData%OutputLoads(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL MeshPack( InData%Twr_OutputLoads, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! Twr_OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD14_PackOutput

 SUBROUTINE AD14_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD14_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OutputLoads not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OutputLoads)) DEALLOCATE(OutData%OutputLoads)
    ALLOCATE(OutData%OutputLoads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutputLoads.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%OutputLoads,1), UBOUND(OutData%OutputLoads,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%OutputLoads(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%Twr_OutputLoads, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! Twr_OutputLoads 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD14_UnPackOutput


 SUBROUTINE AD14_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Input_ExtrapInterp


 SUBROUTINE AD14_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i01 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp1(u1%InputMarkers(i01), u2%InputMarkers(i01), tin, u_out%InputMarkers(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(u1%Twr_InputMarkers, u2%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%Position,1)))
  b1 = -(u1%TurbineComponents%Blade(i11)%Position - u2%TurbineComponents%Blade(i11)%Position)/t(2)
  u_out%TurbineComponents%Blade(i11)%Position = u1%TurbineComponents%Blade(i11)%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,1),SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,1),SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,2) ))
  b2 = -(u1%TurbineComponents%Blade(i11)%Orientation - u2%TurbineComponents%Blade(i11)%Orientation)/t(2)
  u_out%TurbineComponents%Blade(i11)%Orientation = u1%TurbineComponents%Blade(i11)%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%Blade(i11)%TranslationVel - u2%TurbineComponents%Blade(i11)%TranslationVel)/t(2)
  u_out%TurbineComponents%Blade(i11)%TranslationVel = u1%TurbineComponents%Blade(i11)%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%RotationVel,1)))
  b1 = -(u1%TurbineComponents%Blade(i11)%RotationVel - u2%TurbineComponents%Blade(i11)%RotationVel)/t(2)
  u_out%TurbineComponents%Blade(i11)%RotationVel = u1%TurbineComponents%Blade(i11)%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
END IF ! check if allocated
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%Position,1)))
  b1 = -(u1%TurbineComponents%Hub%Position - u2%TurbineComponents%Hub%Position)/t(2)
  u_out%TurbineComponents%Hub%Position = u1%TurbineComponents%Hub%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Hub%Orientation,1),SIZE(u_out%TurbineComponents%Hub%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Hub%Orientation,1),SIZE(u_out%TurbineComponents%Hub%Orientation,2) ))
  b2 = -(u1%TurbineComponents%Hub%Orientation - u2%TurbineComponents%Hub%Orientation)/t(2)
  u_out%TurbineComponents%Hub%Orientation = u1%TurbineComponents%Hub%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%Hub%TranslationVel - u2%TurbineComponents%Hub%TranslationVel)/t(2)
  u_out%TurbineComponents%Hub%TranslationVel = u1%TurbineComponents%Hub%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%RotationVel,1)))
  b1 = -(u1%TurbineComponents%Hub%RotationVel - u2%TurbineComponents%Hub%RotationVel)/t(2)
  u_out%TurbineComponents%Hub%RotationVel = u1%TurbineComponents%Hub%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%Position,1)))
  b1 = -(u1%TurbineComponents%RotorFurl%Position - u2%TurbineComponents%RotorFurl%Position)/t(2)
  u_out%TurbineComponents%RotorFurl%Position = u1%TurbineComponents%RotorFurl%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%RotorFurl%Orientation,1),SIZE(u_out%TurbineComponents%RotorFurl%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%RotorFurl%Orientation,1),SIZE(u_out%TurbineComponents%RotorFurl%Orientation,2) ))
  b2 = -(u1%TurbineComponents%RotorFurl%Orientation - u2%TurbineComponents%RotorFurl%Orientation)/t(2)
  u_out%TurbineComponents%RotorFurl%Orientation = u1%TurbineComponents%RotorFurl%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%RotorFurl%TranslationVel - u2%TurbineComponents%RotorFurl%TranslationVel)/t(2)
  u_out%TurbineComponents%RotorFurl%TranslationVel = u1%TurbineComponents%RotorFurl%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%RotationVel,1)))
  b1 = -(u1%TurbineComponents%RotorFurl%RotationVel - u2%TurbineComponents%RotorFurl%RotationVel)/t(2)
  u_out%TurbineComponents%RotorFurl%RotationVel = u1%TurbineComponents%RotorFurl%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%Position,1)))
  b1 = -(u1%TurbineComponents%Nacelle%Position - u2%TurbineComponents%Nacelle%Position)/t(2)
  u_out%TurbineComponents%Nacelle%Position = u1%TurbineComponents%Nacelle%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Nacelle%Orientation,1),SIZE(u_out%TurbineComponents%Nacelle%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Nacelle%Orientation,1),SIZE(u_out%TurbineComponents%Nacelle%Orientation,2) ))
  b2 = -(u1%TurbineComponents%Nacelle%Orientation - u2%TurbineComponents%Nacelle%Orientation)/t(2)
  u_out%TurbineComponents%Nacelle%Orientation = u1%TurbineComponents%Nacelle%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%Nacelle%TranslationVel - u2%TurbineComponents%Nacelle%TranslationVel)/t(2)
  u_out%TurbineComponents%Nacelle%TranslationVel = u1%TurbineComponents%Nacelle%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%RotationVel,1)))
  b1 = -(u1%TurbineComponents%Nacelle%RotationVel - u2%TurbineComponents%Nacelle%RotationVel)/t(2)
  u_out%TurbineComponents%Nacelle%RotationVel = u1%TurbineComponents%Nacelle%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%Position,1)))
  b1 = -(u1%TurbineComponents%TailFin%Position - u2%TurbineComponents%TailFin%Position)/t(2)
  u_out%TurbineComponents%TailFin%Position = u1%TurbineComponents%TailFin%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%TailFin%Orientation,1),SIZE(u_out%TurbineComponents%TailFin%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%TailFin%Orientation,1),SIZE(u_out%TurbineComponents%TailFin%Orientation,2) ))
  b2 = -(u1%TurbineComponents%TailFin%Orientation - u2%TurbineComponents%TailFin%Orientation)/t(2)
  u_out%TurbineComponents%TailFin%Orientation = u1%TurbineComponents%TailFin%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%TailFin%TranslationVel - u2%TurbineComponents%TailFin%TranslationVel)/t(2)
  u_out%TurbineComponents%TailFin%TranslationVel = u1%TurbineComponents%TailFin%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%RotationVel,1)))
  b1 = -(u1%TurbineComponents%TailFin%RotationVel - u2%TurbineComponents%TailFin%RotationVel)/t(2)
  u_out%TurbineComponents%TailFin%RotationVel = u1%TurbineComponents%TailFin%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%Position,1)))
  b1 = -(u1%TurbineComponents%Tower%Position - u2%TurbineComponents%Tower%Position)/t(2)
  u_out%TurbineComponents%Tower%Position = u1%TurbineComponents%Tower%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Tower%Orientation,1),SIZE(u_out%TurbineComponents%Tower%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Tower%Orientation,1),SIZE(u_out%TurbineComponents%Tower%Orientation,2) ))
  b2 = -(u1%TurbineComponents%Tower%Orientation - u2%TurbineComponents%Tower%Orientation)/t(2)
  u_out%TurbineComponents%Tower%Orientation = u1%TurbineComponents%Tower%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%Tower%TranslationVel - u2%TurbineComponents%Tower%TranslationVel)/t(2)
  u_out%TurbineComponents%Tower%TranslationVel = u1%TurbineComponents%Tower%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%RotationVel,1)))
  b1 = -(u1%TurbineComponents%Tower%RotationVel - u2%TurbineComponents%Tower%RotationVel)/t(2)
  u_out%TurbineComponents%Tower%RotationVel = u1%TurbineComponents%Tower%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%Position,1)))
  b1 = -(u1%TurbineComponents%SubStructure%Position - u2%TurbineComponents%SubStructure%Position)/t(2)
  u_out%TurbineComponents%SubStructure%Position = u1%TurbineComponents%SubStructure%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%SubStructure%Orientation,1),SIZE(u_out%TurbineComponents%SubStructure%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%SubStructure%Orientation,1),SIZE(u_out%TurbineComponents%SubStructure%Orientation,2) ))
  b2 = -(u1%TurbineComponents%SubStructure%Orientation - u2%TurbineComponents%SubStructure%Orientation)/t(2)
  u_out%TurbineComponents%SubStructure%Orientation = u1%TurbineComponents%SubStructure%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%SubStructure%TranslationVel - u2%TurbineComponents%SubStructure%TranslationVel)/t(2)
  u_out%TurbineComponents%SubStructure%TranslationVel = u1%TurbineComponents%SubStructure%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%RotationVel,1)))
  b1 = -(u1%TurbineComponents%SubStructure%RotationVel - u2%TurbineComponents%SubStructure%RotationVel)/t(2)
  u_out%TurbineComponents%SubStructure%RotationVel = u1%TurbineComponents%SubStructure%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%Position,1)))
  b1 = -(u1%TurbineComponents%Foundation%Position - u2%TurbineComponents%Foundation%Position)/t(2)
  u_out%TurbineComponents%Foundation%Position = u1%TurbineComponents%Foundation%Position + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Foundation%Orientation,1),SIZE(u_out%TurbineComponents%Foundation%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Foundation%Orientation,1),SIZE(u_out%TurbineComponents%Foundation%Orientation,2) ))
  b2 = -(u1%TurbineComponents%Foundation%Orientation - u2%TurbineComponents%Foundation%Orientation)/t(2)
  u_out%TurbineComponents%Foundation%Orientation = u1%TurbineComponents%Foundation%Orientation + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%TranslationVel,1)))
  b1 = -(u1%TurbineComponents%Foundation%TranslationVel - u2%TurbineComponents%Foundation%TranslationVel)/t(2)
  u_out%TurbineComponents%Foundation%TranslationVel = u1%TurbineComponents%Foundation%TranslationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%RotationVel,1)))
  b1 = -(u1%TurbineComponents%Foundation%RotationVel - u2%TurbineComponents%Foundation%RotationVel)/t(2)
  u_out%TurbineComponents%Foundation%RotationVel = u1%TurbineComponents%Foundation%RotationVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = -(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength)/t(2)
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b0 * t_out
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  ALLOCATE(b2(SIZE(u_out%MulTabLoc,1),SIZE(u_out%MulTabLoc,2) ))
  ALLOCATE(c2(SIZE(u_out%MulTabLoc,1),SIZE(u_out%MulTabLoc,2) ))
  b2 = -(u1%MulTabLoc - u2%MulTabLoc)/t(2)
  u_out%MulTabLoc = u1%MulTabLoc + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  ALLOCATE(b2(SIZE(u_out%InflowVelocity,1),SIZE(u_out%InflowVelocity,2) ))
  ALLOCATE(c2(SIZE(u_out%InflowVelocity,1),SIZE(u_out%InflowVelocity,2) ))
  b2 = -(u1%InflowVelocity - u2%InflowVelocity)/t(2)
  u_out%InflowVelocity = u1%InflowVelocity + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  ALLOCATE(b1(SIZE(u_out%AvgInfVel,1)))
  ALLOCATE(c1(SIZE(u_out%AvgInfVel,1)))
  b1 = -(u1%AvgInfVel - u2%AvgInfVel)/t(2)
  u_out%AvgInfVel = u1%AvgInfVel + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 END SUBROUTINE AD14_Input_ExtrapInterp1


 SUBROUTINE AD14_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i01 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp2(u1%InputMarkers(i01), u2%InputMarkers(i01), u3%InputMarkers(i01), tin, u_out%InputMarkers(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(u1%Twr_InputMarkers, u2%Twr_InputMarkers, u3%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Position - u2%TurbineComponents%Blade(i11)%Position) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Position + u3%TurbineComponents%Blade(i11)%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Position + t(3)*u2%TurbineComponents%Blade(i11)%Position - t(2)*u3%TurbineComponents%Blade(i11)%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Blade(i11)%Position = u1%TurbineComponents%Blade(i11)%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,1),SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,1),SIZE(u_out%TurbineComponents%Blade(i11)%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Orientation - u2%TurbineComponents%Blade(i11)%Orientation) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Orientation + u3%TurbineComponents%Blade(i11)%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Orientation + t(3)*u2%TurbineComponents%Blade(i11)%Orientation - t(2)*u3%TurbineComponents%Blade(i11)%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Blade(i11)%Orientation = u1%TurbineComponents%Blade(i11)%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Blade(i11)%TranslationVel - u2%TurbineComponents%Blade(i11)%TranslationVel) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%TranslationVel + u3%TurbineComponents%Blade(i11)%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%TranslationVel + t(3)*u2%TurbineComponents%Blade(i11)%TranslationVel - t(2)*u3%TurbineComponents%Blade(i11)%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Blade(i11)%TranslationVel = u1%TurbineComponents%Blade(i11)%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Blade(i11)%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Blade(i11)%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Blade(i11)%RotationVel - u2%TurbineComponents%Blade(i11)%RotationVel) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%RotationVel + u3%TurbineComponents%Blade(i11)%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%RotationVel + t(3)*u2%TurbineComponents%Blade(i11)%RotationVel - t(2)*u3%TurbineComponents%Blade(i11)%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Blade(i11)%RotationVel = u1%TurbineComponents%Blade(i11)%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ENDDO
END IF ! check if allocated
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Hub%Position - u2%TurbineComponents%Hub%Position) + t(2)**2*(-u1%TurbineComponents%Hub%Position + u3%TurbineComponents%Hub%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Position + t(3)*u2%TurbineComponents%Hub%Position - t(2)*u3%TurbineComponents%Hub%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Hub%Position = u1%TurbineComponents%Hub%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Hub%Orientation,1),SIZE(u_out%TurbineComponents%Hub%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Hub%Orientation,1),SIZE(u_out%TurbineComponents%Hub%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%Hub%Orientation - u2%TurbineComponents%Hub%Orientation) + t(2)**2*(-u1%TurbineComponents%Hub%Orientation + u3%TurbineComponents%Hub%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Orientation + t(3)*u2%TurbineComponents%Hub%Orientation - t(2)*u3%TurbineComponents%Hub%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Hub%Orientation = u1%TurbineComponents%Hub%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Hub%TranslationVel - u2%TurbineComponents%Hub%TranslationVel) + t(2)**2*(-u1%TurbineComponents%Hub%TranslationVel + u3%TurbineComponents%Hub%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Hub%TranslationVel + t(3)*u2%TurbineComponents%Hub%TranslationVel - t(2)*u3%TurbineComponents%Hub%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Hub%TranslationVel = u1%TurbineComponents%Hub%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Hub%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Hub%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Hub%RotationVel - u2%TurbineComponents%Hub%RotationVel) + t(2)**2*(-u1%TurbineComponents%Hub%RotationVel + u3%TurbineComponents%Hub%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Hub%RotationVel + t(3)*u2%TurbineComponents%Hub%RotationVel - t(2)*u3%TurbineComponents%Hub%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Hub%RotationVel = u1%TurbineComponents%Hub%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%RotorFurl%Position - u2%TurbineComponents%RotorFurl%Position) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Position + u3%TurbineComponents%RotorFurl%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Position + t(3)*u2%TurbineComponents%RotorFurl%Position - t(2)*u3%TurbineComponents%RotorFurl%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%RotorFurl%Position = u1%TurbineComponents%RotorFurl%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%RotorFurl%Orientation,1),SIZE(u_out%TurbineComponents%RotorFurl%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%RotorFurl%Orientation,1),SIZE(u_out%TurbineComponents%RotorFurl%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%RotorFurl%Orientation - u2%TurbineComponents%RotorFurl%Orientation) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Orientation + u3%TurbineComponents%RotorFurl%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Orientation + t(3)*u2%TurbineComponents%RotorFurl%Orientation - t(2)*u3%TurbineComponents%RotorFurl%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%RotorFurl%Orientation = u1%TurbineComponents%RotorFurl%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%RotorFurl%TranslationVel - u2%TurbineComponents%RotorFurl%TranslationVel) + t(2)**2*(-u1%TurbineComponents%RotorFurl%TranslationVel + u3%TurbineComponents%RotorFurl%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%TranslationVel + t(3)*u2%TurbineComponents%RotorFurl%TranslationVel - t(2)*u3%TurbineComponents%RotorFurl%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%RotorFurl%TranslationVel = u1%TurbineComponents%RotorFurl%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%RotorFurl%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%RotorFurl%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%RotorFurl%RotationVel - u2%TurbineComponents%RotorFurl%RotationVel) + t(2)**2*(-u1%TurbineComponents%RotorFurl%RotationVel + u3%TurbineComponents%RotorFurl%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%RotationVel + t(3)*u2%TurbineComponents%RotorFurl%RotationVel - t(2)*u3%TurbineComponents%RotorFurl%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%RotorFurl%RotationVel = u1%TurbineComponents%RotorFurl%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Nacelle%Position - u2%TurbineComponents%Nacelle%Position) + t(2)**2*(-u1%TurbineComponents%Nacelle%Position + u3%TurbineComponents%Nacelle%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Position + t(3)*u2%TurbineComponents%Nacelle%Position - t(2)*u3%TurbineComponents%Nacelle%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Nacelle%Position = u1%TurbineComponents%Nacelle%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Nacelle%Orientation,1),SIZE(u_out%TurbineComponents%Nacelle%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Nacelle%Orientation,1),SIZE(u_out%TurbineComponents%Nacelle%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%Nacelle%Orientation - u2%TurbineComponents%Nacelle%Orientation) + t(2)**2*(-u1%TurbineComponents%Nacelle%Orientation + u3%TurbineComponents%Nacelle%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Orientation + t(3)*u2%TurbineComponents%Nacelle%Orientation - t(2)*u3%TurbineComponents%Nacelle%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Nacelle%Orientation = u1%TurbineComponents%Nacelle%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Nacelle%TranslationVel - u2%TurbineComponents%Nacelle%TranslationVel) + t(2)**2*(-u1%TurbineComponents%Nacelle%TranslationVel + u3%TurbineComponents%Nacelle%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%TranslationVel + t(3)*u2%TurbineComponents%Nacelle%TranslationVel - t(2)*u3%TurbineComponents%Nacelle%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Nacelle%TranslationVel = u1%TurbineComponents%Nacelle%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Nacelle%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Nacelle%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Nacelle%RotationVel - u2%TurbineComponents%Nacelle%RotationVel) + t(2)**2*(-u1%TurbineComponents%Nacelle%RotationVel + u3%TurbineComponents%Nacelle%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%RotationVel + t(3)*u2%TurbineComponents%Nacelle%RotationVel - t(2)*u3%TurbineComponents%Nacelle%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Nacelle%RotationVel = u1%TurbineComponents%Nacelle%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%TailFin%Position - u2%TurbineComponents%TailFin%Position) + t(2)**2*(-u1%TurbineComponents%TailFin%Position + u3%TurbineComponents%TailFin%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Position + t(3)*u2%TurbineComponents%TailFin%Position - t(2)*u3%TurbineComponents%TailFin%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%TailFin%Position = u1%TurbineComponents%TailFin%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%TailFin%Orientation,1),SIZE(u_out%TurbineComponents%TailFin%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%TailFin%Orientation,1),SIZE(u_out%TurbineComponents%TailFin%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%TailFin%Orientation - u2%TurbineComponents%TailFin%Orientation) + t(2)**2*(-u1%TurbineComponents%TailFin%Orientation + u3%TurbineComponents%TailFin%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Orientation + t(3)*u2%TurbineComponents%TailFin%Orientation - t(2)*u3%TurbineComponents%TailFin%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%TailFin%Orientation = u1%TurbineComponents%TailFin%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%TailFin%TranslationVel - u2%TurbineComponents%TailFin%TranslationVel) + t(2)**2*(-u1%TurbineComponents%TailFin%TranslationVel + u3%TurbineComponents%TailFin%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%TranslationVel + t(3)*u2%TurbineComponents%TailFin%TranslationVel - t(2)*u3%TurbineComponents%TailFin%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%TailFin%TranslationVel = u1%TurbineComponents%TailFin%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%TailFin%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%TailFin%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%TailFin%RotationVel - u2%TurbineComponents%TailFin%RotationVel) + t(2)**2*(-u1%TurbineComponents%TailFin%RotationVel + u3%TurbineComponents%TailFin%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%RotationVel + t(3)*u2%TurbineComponents%TailFin%RotationVel - t(2)*u3%TurbineComponents%TailFin%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%TailFin%RotationVel = u1%TurbineComponents%TailFin%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Tower%Position - u2%TurbineComponents%Tower%Position) + t(2)**2*(-u1%TurbineComponents%Tower%Position + u3%TurbineComponents%Tower%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Position + t(3)*u2%TurbineComponents%Tower%Position - t(2)*u3%TurbineComponents%Tower%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Tower%Position = u1%TurbineComponents%Tower%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Tower%Orientation,1),SIZE(u_out%TurbineComponents%Tower%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Tower%Orientation,1),SIZE(u_out%TurbineComponents%Tower%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%Tower%Orientation - u2%TurbineComponents%Tower%Orientation) + t(2)**2*(-u1%TurbineComponents%Tower%Orientation + u3%TurbineComponents%Tower%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Orientation + t(3)*u2%TurbineComponents%Tower%Orientation - t(2)*u3%TurbineComponents%Tower%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Tower%Orientation = u1%TurbineComponents%Tower%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Tower%TranslationVel - u2%TurbineComponents%Tower%TranslationVel) + t(2)**2*(-u1%TurbineComponents%Tower%TranslationVel + u3%TurbineComponents%Tower%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Tower%TranslationVel + t(3)*u2%TurbineComponents%Tower%TranslationVel - t(2)*u3%TurbineComponents%Tower%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Tower%TranslationVel = u1%TurbineComponents%Tower%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Tower%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Tower%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Tower%RotationVel - u2%TurbineComponents%Tower%RotationVel) + t(2)**2*(-u1%TurbineComponents%Tower%RotationVel + u3%TurbineComponents%Tower%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Tower%RotationVel + t(3)*u2%TurbineComponents%Tower%RotationVel - t(2)*u3%TurbineComponents%Tower%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Tower%RotationVel = u1%TurbineComponents%Tower%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%SubStructure%Position - u2%TurbineComponents%SubStructure%Position) + t(2)**2*(-u1%TurbineComponents%SubStructure%Position + u3%TurbineComponents%SubStructure%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Position + t(3)*u2%TurbineComponents%SubStructure%Position - t(2)*u3%TurbineComponents%SubStructure%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%SubStructure%Position = u1%TurbineComponents%SubStructure%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%SubStructure%Orientation,1),SIZE(u_out%TurbineComponents%SubStructure%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%SubStructure%Orientation,1),SIZE(u_out%TurbineComponents%SubStructure%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%SubStructure%Orientation - u2%TurbineComponents%SubStructure%Orientation) + t(2)**2*(-u1%TurbineComponents%SubStructure%Orientation + u3%TurbineComponents%SubStructure%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Orientation + t(3)*u2%TurbineComponents%SubStructure%Orientation - t(2)*u3%TurbineComponents%SubStructure%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%SubStructure%Orientation = u1%TurbineComponents%SubStructure%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%SubStructure%TranslationVel - u2%TurbineComponents%SubStructure%TranslationVel) + t(2)**2*(-u1%TurbineComponents%SubStructure%TranslationVel + u3%TurbineComponents%SubStructure%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%TranslationVel + t(3)*u2%TurbineComponents%SubStructure%TranslationVel - t(2)*u3%TurbineComponents%SubStructure%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%SubStructure%TranslationVel = u1%TurbineComponents%SubStructure%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%SubStructure%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%SubStructure%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%SubStructure%RotationVel - u2%TurbineComponents%SubStructure%RotationVel) + t(2)**2*(-u1%TurbineComponents%SubStructure%RotationVel + u3%TurbineComponents%SubStructure%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%RotationVel + t(3)*u2%TurbineComponents%SubStructure%RotationVel - t(2)*u3%TurbineComponents%SubStructure%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%SubStructure%RotationVel = u1%TurbineComponents%SubStructure%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%Position,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%Position,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Foundation%Position - u2%TurbineComponents%Foundation%Position) + t(2)**2*(-u1%TurbineComponents%Foundation%Position + u3%TurbineComponents%Foundation%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Position + t(3)*u2%TurbineComponents%Foundation%Position - t(2)*u3%TurbineComponents%Foundation%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Foundation%Position = u1%TurbineComponents%Foundation%Position + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b2(SIZE(u_out%TurbineComponents%Foundation%Orientation,1),SIZE(u_out%TurbineComponents%Foundation%Orientation,2) ))
  ALLOCATE(c2(SIZE(u_out%TurbineComponents%Foundation%Orientation,1),SIZE(u_out%TurbineComponents%Foundation%Orientation,2) ))
  b2 = (t(3)**2*(u1%TurbineComponents%Foundation%Orientation - u2%TurbineComponents%Foundation%Orientation) + t(2)**2*(-u1%TurbineComponents%Foundation%Orientation + u3%TurbineComponents%Foundation%Orientation))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Orientation + t(3)*u2%TurbineComponents%Foundation%Orientation - t(2)*u3%TurbineComponents%Foundation%Orientation ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Foundation%Orientation = u1%TurbineComponents%Foundation%Orientation + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%TranslationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%TranslationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Foundation%TranslationVel - u2%TurbineComponents%Foundation%TranslationVel) + t(2)**2*(-u1%TurbineComponents%Foundation%TranslationVel + u3%TurbineComponents%Foundation%TranslationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%TranslationVel + t(3)*u2%TurbineComponents%Foundation%TranslationVel - t(2)*u3%TurbineComponents%Foundation%TranslationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Foundation%TranslationVel = u1%TurbineComponents%Foundation%TranslationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%TurbineComponents%Foundation%RotationVel,1)))
  ALLOCATE(c1(SIZE(u_out%TurbineComponents%Foundation%RotationVel,1)))
  b1 = (t(3)**2*(u1%TurbineComponents%Foundation%RotationVel - u2%TurbineComponents%Foundation%RotationVel) + t(2)**2*(-u1%TurbineComponents%Foundation%RotationVel + u3%TurbineComponents%Foundation%RotationVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%RotationVel + t(3)*u2%TurbineComponents%Foundation%RotationVel - t(2)*u3%TurbineComponents%Foundation%RotationVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%Foundation%RotationVel = u1%TurbineComponents%Foundation%RotationVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = (t(3)**2*(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength) + t(2)**2*(-u1%TurbineComponents%BladeLength + u3%TurbineComponents%BladeLength))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u1%TurbineComponents%BladeLength + t(3)*u2%TurbineComponents%BladeLength - t(2)*u3%TurbineComponents%BladeLength ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  ALLOCATE(b2(SIZE(u_out%MulTabLoc,1),SIZE(u_out%MulTabLoc,2) ))
  ALLOCATE(c2(SIZE(u_out%MulTabLoc,1),SIZE(u_out%MulTabLoc,2) ))
  b2 = (t(3)**2*(u1%MulTabLoc - u2%MulTabLoc) + t(2)**2*(-u1%MulTabLoc + u3%MulTabLoc))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%MulTabLoc + t(3)*u2%MulTabLoc - t(2)*u3%MulTabLoc ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%MulTabLoc = u1%MulTabLoc + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  ALLOCATE(b2(SIZE(u_out%InflowVelocity,1),SIZE(u_out%InflowVelocity,2) ))
  ALLOCATE(c2(SIZE(u_out%InflowVelocity,1),SIZE(u_out%InflowVelocity,2) ))
  b2 = (t(3)**2*(u1%InflowVelocity - u2%InflowVelocity) + t(2)**2*(-u1%InflowVelocity + u3%InflowVelocity))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%InflowVelocity + t(3)*u2%InflowVelocity - t(2)*u3%InflowVelocity ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%InflowVelocity = u1%InflowVelocity + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  ALLOCATE(b1(SIZE(u_out%AvgInfVel,1)))
  ALLOCATE(c1(SIZE(u_out%AvgInfVel,1)))
  b1 = (t(3)**2*(u1%AvgInfVel - u2%AvgInfVel) + t(2)**2*(-u1%AvgInfVel + u3%AvgInfVel))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u1%AvgInfVel + t(3)*u2%AvgInfVel - t(2)*u3%AvgInfVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%AvgInfVel = u1%AvgInfVel + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 END SUBROUTINE AD14_Input_ExtrapInterp2


 SUBROUTINE AD14_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Output_ExtrapInterp


 SUBROUTINE AD14_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i01 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp1(y1%OutputLoads(i01), y2%OutputLoads(i01), tin, y_out%OutputLoads(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(y1%Twr_OutputLoads, y2%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp1


 SUBROUTINE AD14_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i01 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp2(y1%OutputLoads(i01), y2%OutputLoads(i01), y3%OutputLoads(i01), tin, y_out%OutputLoads(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(y1%Twr_OutputLoads, y2%Twr_OutputLoads, y3%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp2

END MODULE AeroDyn14_Types
!ENDOFREGISTRYGENERATEDFILE
