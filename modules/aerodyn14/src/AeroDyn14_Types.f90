!STARTOFREGISTRYGENERATEDFILE 'AeroDyn14_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn14_Types
!.................................................................................................................................
! This file is part of AeroDyn14.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn14. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn14_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE DWM_Types
USE NWTC_Library
IMPLICIT NONE
! =========  Marker  =======
  TYPE, PUBLIC :: Marker
    REAL(ReKi) , DIMENSION(1:3)  :: Position 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orientation 
    REAL(ReKi) , DIMENSION(1:3)  :: TranslationVel 
    REAL(ReKi) , DIMENSION(1:3)  :: RotationVel 
  END TYPE Marker
! =======================
! =========  AeroConfig  =======
  TYPE, PUBLIC :: AeroConfig
    TYPE(Marker) , DIMENSION(:), ALLOCATABLE  :: Blade 
    TYPE(Marker)  :: Hub 
    TYPE(Marker)  :: RotorFurl 
    TYPE(Marker)  :: Nacelle 
    TYPE(Marker)  :: TailFin 
    TYPE(Marker)  :: Tower 
    TYPE(Marker)  :: SubStructure 
    TYPE(Marker)  :: Foundation 
    REAL(ReKi)  :: BladeLength 
  END TYPE AeroConfig
! =======================
! =========  AirFoil  =======
  TYPE, PUBLIC :: AirFoil
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CD 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CM 
    REAL(ReKi)  :: PMC 
    REAL(ReKi)  :: MulTabLoc 
  END TYPE AirFoil
! =======================
! =========  AirFoilParms  =======
  TYPE, PUBLIC :: AirFoilParms
    INTEGER(IntKi)  :: MaxTable = 20 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTables 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NLift 
    INTEGER(IntKi)  :: NumCL 
    INTEGER(IntKi)  :: NumFoil 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NFoil 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabMet 
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: FoilNm 
  END TYPE AirFoilParms
! =======================
! =========  Beddoes  =======
  TYPE, PUBLIC :: Beddoes
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE1 
    REAL(ReKi)  :: AN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOL 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: BEDSEP 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: OLDSEP 
    REAL(ReKi)  :: CC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CDO 
    REAL(ReKi)  :: CMI 
    REAL(ReKi)  :: CMQ 
    REAL(ReKi)  :: CN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNA 
    REAL(ReKi)  :: CNCP 
    REAL(ReKi)  :: CNIQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP1 
    REAL(ReKi)  :: DS 
    REAL(ReKi)  :: FK 
    REAL(ReKi)  :: FP 
    REAL(ReKi)  :: FPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC1 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTB 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTBC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDCNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDTAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDXN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDYN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: YN 
    LOGICAL  :: SHIFT 
    LOGICAL  :: VOR 
  END TYPE Beddoes
! =======================
! =========  BeddoesParms  =======
  TYPE, PUBLIC :: BeddoesParms
    REAL(ReKi)  :: AS      !< Speed of sound for mach num calc [-]
    REAL(ReKi)  :: TF      !< Time constant applied to loc of separation pt [-]
    REAL(ReKi)  :: TP      !< Time constant for pressure lag [-]
    REAL(ReKi)  :: TV      !< Time constant for strength and shed of vortex [-]
    REAL(ReKi)  :: TVL      !< Nondim time of transit of vort moving across airfoil surf [-]
  END TYPE BeddoesParms
! =======================
! =========  BladeParms  =======
  TYPE, PUBLIC :: BladeParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: C      !< Chord of each blade element from input file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DR      !< Span-wise width of elem (len of elem ctred at RELM(i) [-]
    REAL(ReKi)  :: R      !< Rotor radius [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
  END TYPE BladeParms
! =======================
! =========  DynInflow  =======
  TYPE, PUBLIC :: DynInflow
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: dAlph_dt 
    REAL(ReKi) , DIMENSION(3:6,1:4)  :: dBeta_dt 
    REAL(ReKi)  :: DTO 
    REAL(ReKi) , DIMENSION(1:6)  :: old_Alph 
    REAL(ReKi) , DIMENSION(3:6)  :: old_Beta 
    REAL(ReKi)  :: old_LmdM 
    REAL(ReKi)  :: oldKai 
    REAL(ReKi) , DIMENSION(1:6)  :: PhiLqC 
    REAL(ReKi) , DIMENSION(3:6)  :: PhiLqS 
    REAL(ReKi)  :: Pzero 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMC_SAVE 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMS_SAVE 
    REAL(ReKi)  :: TipSpeed 
    REAL(ReKi)  :: totalInf 
    REAL(ReKi)  :: Vparam 
    REAL(ReKi)  :: Vtotal 
    REAL(ReKi) , DIMENSION(1:6)  :: xAlpha 
    REAL(ReKi) , DIMENSION(3:6)  :: xBeta 
    REAL(ReKi)  :: xKai 
    REAL(ReKi)  :: XLAMBDA_M 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: xLcos 
    REAL(ReKi) , DIMENSION(3:6,3:6)  :: xLsin 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminusR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MplusR 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: GAMMA 
  END TYPE DynInflow
! =======================
! =========  DynInflowParms  =======
  TYPE, PUBLIC :: DynInflowParms
    INTEGER(IntKi)  :: MAXINFLO = 2 
    REAL(ReKi) , DIMENSION(1:6)  :: xMinv 
  END TYPE DynInflowParms
! =======================
! =========  Element  =======
  TYPE, PUBLIC :: Element
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A      !< - [Axial induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AP      !< - [Tangential induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ALPHA      !< - [Angle of attack]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W2      !< - [Relative velocity norm ]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_A_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_AP_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PITNOW      !< - [Current pitch angle - Based on blade orientation (to verify)]
  END TYPE Element
! =======================
! =========  ElementParms  =======
  TYPE, PUBLIC :: ElementParms
    INTEGER(IntKi)  :: NELM      !< - [Number of elements (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TWIST      !< - [Airfoil twist angle (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RELM      !< - [Radius of element (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HLCNST      !< - [Hub loss constant B/2*(r-rh)/rh (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TLCNST      !< - [Tip loss constant B/2*(R-r)/R (constant) ]
  END TYPE ElementParms
! =======================
! =========  ElOutParms  =======
  TYPE, PUBLIC :: ElOutParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ALF 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CDD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CLL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CNN 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CTT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFNSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFTSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DynPres 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PITSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ReyNum 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Gamma      !< - [Circulation along the span, 1/2 c Vrel Cl]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVZ 
    REAL(ReKi)  :: VXSAV 
    REAL(ReKi)  :: VYSAV 
    REAL(ReKi)  :: VZSAV 
    INTEGER(IntKi)  :: NumWndElOut      !< Number of Blade Elements [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrNum 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    INTEGER(IntKi)  :: NumElOut      !< Number of Blade Elements [-]
  END TYPE ElOutParms
! =======================
! =========  InducedVel  =======
  TYPE, PUBLIC :: InducedVel
    REAL(ReKi)  :: SumInFl = 0 
  END TYPE InducedVel
! =======================
! =========  InducedVelParms  =======
  TYPE, PUBLIC :: InducedVelParms
    REAL(ReKi)  :: AToler      !< Convergence tolerance for induction factor [-]
    REAL(ReKi)  :: EqAIDmult      !< Multiplier for drag term in axial-induction equation. [-]
    LOGICAL  :: EquilDA      !< False unless DB or DA appended to EQUIL [-]
    LOGICAL  :: EquilDT      !< False unless DB or DT appended to EQUIL [-]
    LOGICAL  :: TLoss      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: GTech      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: HLoss      !< Hub-loss model (EQUIL only) [PRANDtl or NONE] [-]
  END TYPE InducedVelParms
! =======================
! =========  Rotor  =======
  TYPE, PUBLIC :: Rotor
    REAL(ReKi)  :: AVGINFL      !< average induced velocity at the previous time [-]
    REAL(ReKi)  :: CTILT 
    REAL(ReKi)  :: CYaw 
    REAL(ReKi)  :: REVS 
    REAL(ReKi)  :: STILT 
    REAL(ReKi)  :: SYaw 
    REAL(ReKi)  :: TILT 
    REAL(ReKi)  :: YawAng 
    REAL(ReKi)  :: YawVEL 
  END TYPE Rotor
! =======================
! =========  RotorParms  =======
  TYPE, PUBLIC :: RotorParms
    REAL(ReKi)  :: HH 
  END TYPE RotorParms
! =======================
! =========  TwrPropsParms  =======
  TYPE, PUBLIC :: TwrPropsParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrHtFr 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrWid 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRe 
    REAL(ReKi) , DIMENSION(1:3)  :: VTwr 
    REAL(ReKi)  :: Tower_Wake_Constant 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTwrCDCol      !< The tower CD column that represents a particular twr ht [-]
    INTEGER(IntKi)  :: NTwrHT      !< The number of tower height rows in the table [-]
    INTEGER(IntKi)  :: NTwrRe      !< The number of tower Re entry rows in the table [-]
    INTEGER(IntKi)  :: NTwrCD      !< The number of tower CD columns in the table [-]
    LOGICAL  :: TwrPotent      !< Tower influence model [-]
    LOGICAL  :: TwrShadow      !< Tower shadow model [-]
    REAL(ReKi)  :: ShadHWid      !< Tower-shadow half width [m]
    REAL(ReKi)  :: TShadC1      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TShadC2      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TwrShad      !< Tower-shadow velocity deficit [-]
    LOGICAL  :: PJM_Version      !< Only true if new tower influence model, by PJM [-]
    CHARACTER(1024)  :: TwrFile      !< Tower data file name [-]
    REAL(ReKi)  :: T_Shad_Refpt      !< Tower-shadow reference point [m]
    LOGICAL  :: CalcTwrAero      !< Flag to tell AeroDyn to calculate drag on the tower [m]
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrNodeWidth      !< The width (diameter) of the tower at the ElastoDyn node locations. [-]
  END TYPE TwrPropsParms
! =======================
! =========  Wind  =======
  TYPE, PUBLIC :: Wind
    REAL(ReKi)  :: ANGFLW 
    REAL(ReKi)  :: CDEL 
    REAL(ReKi)  :: VROTORX 
    REAL(ReKi)  :: VROTORY 
    REAL(ReKi)  :: VROTORZ 
    REAL(ReKi)  :: SDEL 
  END TYPE Wind
! =======================
! =========  WindParms  =======
  TYPE, PUBLIC :: WindParms
    REAL(ReKi)  :: Rho      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [(m^2/sec)]
  END TYPE WindParms
! =======================
! =========  PositionType  =======
  TYPE, PUBLIC :: PositionType
    REAL(ReKi) , DIMENSION(1:3)  :: Pos      !< X,Y,Z coordinate of a point [-]
  END TYPE PositionType
! =======================
! =========  OrientationType  =======
  TYPE, PUBLIC :: OrientationType
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orient      !< Direction Cosine Matrix [-]
  END TYPE OrientationType
! =======================
! =========  AD14_InitInputType  =======
  TYPE, PUBLIC :: AD14_InitInputType
    CHARACTER(1024)  :: Title      !< Title [-]
    CHARACTER(1024)  :: OutRootName 
    CHARACTER(1024)  :: ADFileName      !< AeroDyn file name [-]
    LOGICAL  :: WrSumFile      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    TYPE(AeroConfig)  :: TurbineComponents 
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrNodeLocs      !< Location of ElastoDyn tower nodes with respect to the inertial origin. [-]
    REAL(ReKi)  :: HubHt      !< hub height wrt inertial origin [m]
    TYPE(DWM_InitInputType)  :: DWM 
  END TYPE AD14_InitInputType
! =======================
! =========  AD14_InitOutputType  =======
  TYPE, PUBLIC :: AD14_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< version information [-]
    TYPE(DWM_InitOutputType)  :: DWM 
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
  END TYPE AD14_InitOutputType
! =======================
! =========  AD14_ContinuousStateType  =======
  TYPE, PUBLIC :: AD14_ContinuousStateType
    TYPE(DWM_ContinuousStateType)  :: DWM 
  END TYPE AD14_ContinuousStateType
! =======================
! =========  AD14_DiscreteStateType  =======
  TYPE, PUBLIC :: AD14_DiscreteStateType
    TYPE(DWM_DiscreteStateType)  :: DWM 
  END TYPE AD14_DiscreteStateType
! =======================
! =========  AD14_ConstraintStateType  =======
  TYPE, PUBLIC :: AD14_ConstraintStateType
    TYPE(DWM_ConstraintStateType)  :: DWM 
  END TYPE AD14_ConstraintStateType
! =======================
! =========  AD14_OtherStateType  =======
  TYPE, PUBLIC :: AD14_OtherStateType
    TYPE(DWM_OtherStateType)  :: DWM      !< variables for DWM module [-]
  END TYPE AD14_OtherStateType
! =======================
! =========  AD14_MiscVarType  =======
  TYPE, PUBLIC :: AD14_MiscVarType
    TYPE(DWM_MiscVarType)  :: DWM      !< variables for DWM module [-]
    TYPE(DWM_InputType)  :: DWM_Inputs 
    TYPE(DWM_OutputType)  :: DWM_Outputs 
    REAL(DbKi)  :: DT      !< actual Time step [seconds]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    REAL(DbKi)  :: OldTime 
    REAL(ReKi)  :: HubLoss = 1 
    REAL(ReKi)  :: Loss = 1 
    REAL(ReKi)  :: TipLoss = 1 
    REAL(ReKi)  :: TLpt7 
    LOGICAL  :: FirstPassGTL = .TRUE. 
    LOGICAL  :: SuperSonic = .FALSE. 
    LOGICAL  :: AFLAGVinderr = .FALSE. 
    LOGICAL  :: AFLAGTwrInflu = .FALSE. 
    LOGICAL  :: OnePassDynDbg = .TRUE. 
    LOGICAL  :: NoLoadsCalculated = .TRUE. 
    INTEGER(IntKi)  :: NERRORS = 0 
    TYPE(AirFoil)  :: AirFoil 
    TYPE(Beddoes)  :: Beddoes 
    TYPE(DynInflow)  :: DynInflow 
    TYPE(Element)  :: Element 
    TYPE(Rotor)  :: Rotor 
    TYPE(Wind)  :: Wind 
    TYPE(InducedVel)  :: InducedVel 
    TYPE(ElOutParms)  :: ElOut 
    LOGICAL  :: Skew 
    LOGICAL  :: DynInit      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: FirstWarn      !< If it's the first warning about AeroDyn not recalculating loads [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredForces 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredMoments 
  END TYPE AD14_MiscVarType
! =======================
! =========  AD14_ParameterType  =======
  TYPE, PUBLIC :: AD14_ParameterType
    CHARACTER(1024)  :: Title      !< Title [-]
    LOGICAL  :: SIUnit 
    LOGICAL  :: Echo = .FALSE. 
    LOGICAL  :: MultiTab 
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: OutputPlottingInfo = .FALSE. 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    REAL(ReKi)  :: TwoPiNB      !< 2*pi/num of blades [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    INTEGER(IntKi)  :: NBlInpSt      !< Number of Blade Input Stations [-]
    LOGICAL  :: ElemPrn 
    LOGICAL  :: DStall      !< FALSE=Steady, TRUE=BEDDOES [-]
    LOGICAL  :: PMoment      !< FALSE=NO_CM, TRUE=USE_CM [-]
    LOGICAL  :: Reynolds 
    LOGICAL  :: DynInfl      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: Wake      !< False unless WAKE or SWIRL [-]
    LOGICAL  :: Swirl      !< False unless WAKE or SWIRL [-]
    REAL(DbKi)  :: DtAero      !< Time interval for aerodynamic calculations [-]
    REAL(ReKi)  :: HubRad      !< Hub radius [m]
    INTEGER(IntKi)  :: UnEc = -1 
    INTEGER(IntKi)  :: UnElem = -1 
    INTEGER(IntKi)  :: UnWndOut = -1 
    INTEGER(IntKi)  :: MAXICOUNT = 1000 
    LOGICAL  :: WrOptFile = .TRUE.      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: DEFAULT_Wind = -1 
    TYPE(AirFoilParms)  :: AirFoil 
    TYPE(BladeParms)  :: Blade 
    TYPE(BeddoesParms)  :: Beddoes 
    TYPE(DynInflowParms)  :: DynInflow 
    TYPE(ElementParms)  :: Element 
    TYPE(TwrPropsParms)  :: TwrProps 
    TYPE(InducedVelParms)  :: InducedVel 
    TYPE(WindParms)  :: Wind 
    TYPE(RotorParms)  :: Rotor 
    TYPE(DWM_ParameterType)  :: DWM 
  END TYPE AD14_ParameterType
! =======================
! =========  AD14_InputType  =======
  TYPE, PUBLIC :: AD14_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: InputMarkers      !< Input Forces and positions for the blades (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_InputMarkers      !< Input Forces and positions for the tower (mesh) [-]
    TYPE(AeroConfig)  :: TurbineComponents      !< Current locations of components [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabLoc 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowVelocity      !< U,V,W wind inflow speeds at all locations on the Inputmarker and Twr_InputMarker meshes [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgInfVel      !< an average disk velocity (depends on wind type and should be removed) [m/s]
  END TYPE AD14_InputType
! =======================
! =========  AD14_OutputType  =======
  TYPE, PUBLIC :: AD14_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: OutputLoads      !< Output Loads (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_OutputLoads      !< Tower Output Loads (mesh) [-]
  END TYPE AD14_OutputType
! =======================
CONTAINS

subroutine AD14_CopyMarker(SrcMarkerData, DstMarkerData, CtrlCode, ErrStat, ErrMsg)
   type(Marker), intent(in) :: SrcMarkerData
   type(Marker), intent(inout) :: DstMarkerData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyMarker'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMarkerData%Position = SrcMarkerData%Position
   DstMarkerData%Orientation = SrcMarkerData%Orientation
   DstMarkerData%TranslationVel = SrcMarkerData%TranslationVel
   DstMarkerData%RotationVel = SrcMarkerData%RotationVel
end subroutine

subroutine AD14_DestroyMarker(MarkerData, ErrStat, ErrMsg)
   type(Marker), intent(inout) :: MarkerData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyMarker'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackMarker(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Marker), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMarker'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Position)
   call RegPack(Buf, InData%Orientation)
   call RegPack(Buf, InData%TranslationVel)
   call RegPack(Buf, InData%RotationVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackMarker(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Marker), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMarker'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Position)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Orientation)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TranslationVel)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RotationVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyAeroConfig(SrcAeroConfigData, DstAeroConfigData, CtrlCode, ErrStat, ErrMsg)
   type(AeroConfig), intent(in) :: SrcAeroConfigData
   type(AeroConfig), intent(inout) :: DstAeroConfigData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyAeroConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAeroConfigData%Blade)) then
      LB(1:1) = lbound(SrcAeroConfigData%Blade)
      UB(1:1) = ubound(SrcAeroConfigData%Blade)
      if (.not. allocated(DstAeroConfigData%Blade)) then
         allocate(DstAeroConfigData%Blade(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroConfigData%Blade.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD14_CopyMarker(SrcAeroConfigData%Blade(i1), DstAeroConfigData%Blade(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   else if (allocated(DstAeroConfigData%Blade)) then
      deallocate(DstAeroConfigData%Blade)
   end if
   call AD14_CopyMarker(SrcAeroConfigData%Hub, DstAeroConfigData%Hub, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%RotorFurl, DstAeroConfigData%RotorFurl, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Nacelle, DstAeroConfigData%Nacelle, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%TailFin, DstAeroConfigData%TailFin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Tower, DstAeroConfigData%Tower, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%SubStructure, DstAeroConfigData%SubStructure, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyMarker(SrcAeroConfigData%Foundation, DstAeroConfigData%Foundation, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstAeroConfigData%BladeLength = SrcAeroConfigData%BladeLength
end subroutine

subroutine AD14_DestroyAeroConfig(AeroConfigData, ErrStat, ErrMsg)
   type(AeroConfig), intent(inout) :: AeroConfigData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyAeroConfig'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AeroConfigData%Blade)) then
      LB(1:1) = lbound(AeroConfigData%Blade)
      UB(1:1) = ubound(AeroConfigData%Blade)
      do i1 = LB(1), UB(1)
         call AD14_DestroyMarker(AeroConfigData%Blade(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroConfigData%Blade)
   end if
end subroutine

subroutine AD14_PackAeroConfig(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AeroConfig), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAeroConfig'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%Blade))
   if (allocated(InData%Blade)) then
      call RegPackBounds(Buf, 1, lbound(InData%Blade), ubound(InData%Blade))
      LB(1:1) = lbound(InData%Blade)
      UB(1:1) = ubound(InData%Blade)
      do i1 = LB(1), UB(1)
         call AD14_PackMarker(Buf, InData%Blade(i1)) 
      end do
   end if
   call AD14_PackMarker(Buf, InData%Hub) 
   call AD14_PackMarker(Buf, InData%RotorFurl) 
   call AD14_PackMarker(Buf, InData%Nacelle) 
   call AD14_PackMarker(Buf, InData%TailFin) 
   call AD14_PackMarker(Buf, InData%Tower) 
   call AD14_PackMarker(Buf, InData%SubStructure) 
   call AD14_PackMarker(Buf, InData%Foundation) 
   call RegPack(Buf, InData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAeroConfig(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AeroConfig), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAeroConfig'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%Blade)) deallocate(OutData%Blade)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Blade(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Blade.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD14_UnpackMarker(Buf, OutData%Blade(i1)) ! Blade 
      end do
   end if
   call AD14_UnpackMarker(Buf, OutData%Hub) ! Hub 
   call AD14_UnpackMarker(Buf, OutData%RotorFurl) ! RotorFurl 
   call AD14_UnpackMarker(Buf, OutData%Nacelle) ! Nacelle 
   call AD14_UnpackMarker(Buf, OutData%TailFin) ! TailFin 
   call AD14_UnpackMarker(Buf, OutData%Tower) ! Tower 
   call AD14_UnpackMarker(Buf, OutData%SubStructure) ! SubStructure 
   call AD14_UnpackMarker(Buf, OutData%Foundation) ! Foundation 
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyAirFoil(SrcAirFoilData, DstAirFoilData, CtrlCode, ErrStat, ErrMsg)
   type(AirFoil), intent(in) :: SrcAirFoilData
   type(AirFoil), intent(inout) :: DstAirFoilData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyAirFoil'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAirFoilData%AL)) then
      LB(1:2) = lbound(SrcAirFoilData%AL)
      UB(1:2) = ubound(SrcAirFoilData%AL)
      if (.not. allocated(DstAirFoilData%AL)) then
         allocate(DstAirFoilData%AL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%AL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%AL = SrcAirFoilData%AL
   else if (allocated(DstAirFoilData%AL)) then
      deallocate(DstAirFoilData%AL)
   end if
   if (allocated(SrcAirFoilData%CD)) then
      LB(1:3) = lbound(SrcAirFoilData%CD)
      UB(1:3) = ubound(SrcAirFoilData%CD)
      if (.not. allocated(DstAirFoilData%CD)) then
         allocate(DstAirFoilData%CD(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CD = SrcAirFoilData%CD
   else if (allocated(DstAirFoilData%CD)) then
      deallocate(DstAirFoilData%CD)
   end if
   if (allocated(SrcAirFoilData%CL)) then
      LB(1:3) = lbound(SrcAirFoilData%CL)
      UB(1:3) = ubound(SrcAirFoilData%CL)
      if (.not. allocated(DstAirFoilData%CL)) then
         allocate(DstAirFoilData%CL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CL = SrcAirFoilData%CL
   else if (allocated(DstAirFoilData%CL)) then
      deallocate(DstAirFoilData%CL)
   end if
   if (allocated(SrcAirFoilData%CM)) then
      LB(1:3) = lbound(SrcAirFoilData%CM)
      UB(1:3) = ubound(SrcAirFoilData%CM)
      if (.not. allocated(DstAirFoilData%CM)) then
         allocate(DstAirFoilData%CM(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilData%CM = SrcAirFoilData%CM
   else if (allocated(DstAirFoilData%CM)) then
      deallocate(DstAirFoilData%CM)
   end if
   DstAirFoilData%PMC = SrcAirFoilData%PMC
   DstAirFoilData%MulTabLoc = SrcAirFoilData%MulTabLoc
end subroutine

subroutine AD14_DestroyAirFoil(AirFoilData, ErrStat, ErrMsg)
   type(AirFoil), intent(inout) :: AirFoilData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyAirFoil'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AirFoilData%AL)) then
      deallocate(AirFoilData%AL)
   end if
   if (allocated(AirFoilData%CD)) then
      deallocate(AirFoilData%CD)
   end if
   if (allocated(AirFoilData%CL)) then
      deallocate(AirFoilData%CL)
   end if
   if (allocated(AirFoilData%CM)) then
      deallocate(AirFoilData%CM)
   end if
end subroutine

subroutine AD14_PackAirFoil(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AirFoil), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoil'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%AL))
   if (allocated(InData%AL)) then
      call RegPackBounds(Buf, 2, lbound(InData%AL), ubound(InData%AL))
      call RegPack(Buf, InData%AL)
   end if
   call RegPack(Buf, allocated(InData%CD))
   if (allocated(InData%CD)) then
      call RegPackBounds(Buf, 3, lbound(InData%CD), ubound(InData%CD))
      call RegPack(Buf, InData%CD)
   end if
   call RegPack(Buf, allocated(InData%CL))
   if (allocated(InData%CL)) then
      call RegPackBounds(Buf, 3, lbound(InData%CL), ubound(InData%CL))
      call RegPack(Buf, InData%CL)
   end if
   call RegPack(Buf, allocated(InData%CM))
   if (allocated(InData%CM)) then
      call RegPackBounds(Buf, 3, lbound(InData%CM), ubound(InData%CM))
      call RegPack(Buf, InData%CM)
   end if
   call RegPack(Buf, InData%PMC)
   call RegPack(Buf, InData%MulTabLoc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoil(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AirFoil), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoil'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%AL)) deallocate(OutData%AL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CD)) deallocate(OutData%CD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CD(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CL)) deallocate(OutData%CL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CM)) deallocate(OutData%CM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CM(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%PMC)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MulTabLoc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyAirFoilParms(SrcAirFoilParmsData, DstAirFoilParmsData, CtrlCode, ErrStat, ErrMsg)
   type(AirFoilParms), intent(in) :: SrcAirFoilParmsData
   type(AirFoilParms), intent(inout) :: DstAirFoilParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyAirFoilParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstAirFoilParmsData%MaxTable = SrcAirFoilParmsData%MaxTable
   if (allocated(SrcAirFoilParmsData%NTables)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NTables)
      UB(1:1) = ubound(SrcAirFoilParmsData%NTables)
      if (.not. allocated(DstAirFoilParmsData%NTables)) then
         allocate(DstAirFoilParmsData%NTables(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NTables.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NTables = SrcAirFoilParmsData%NTables
   else if (allocated(DstAirFoilParmsData%NTables)) then
      deallocate(DstAirFoilParmsData%NTables)
   end if
   if (allocated(SrcAirFoilParmsData%NLift)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NLift)
      UB(1:1) = ubound(SrcAirFoilParmsData%NLift)
      if (.not. allocated(DstAirFoilParmsData%NLift)) then
         allocate(DstAirFoilParmsData%NLift(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NLift.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NLift = SrcAirFoilParmsData%NLift
   else if (allocated(DstAirFoilParmsData%NLift)) then
      deallocate(DstAirFoilParmsData%NLift)
   end if
   DstAirFoilParmsData%NumCL = SrcAirFoilParmsData%NumCL
   DstAirFoilParmsData%NumFoil = SrcAirFoilParmsData%NumFoil
   if (allocated(SrcAirFoilParmsData%NFoil)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%NFoil)
      UB(1:1) = ubound(SrcAirFoilParmsData%NFoil)
      if (.not. allocated(DstAirFoilParmsData%NFoil)) then
         allocate(DstAirFoilParmsData%NFoil(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NFoil.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%NFoil = SrcAirFoilParmsData%NFoil
   else if (allocated(DstAirFoilParmsData%NFoil)) then
      deallocate(DstAirFoilParmsData%NFoil)
   end if
   if (allocated(SrcAirFoilParmsData%MulTabMet)) then
      LB(1:2) = lbound(SrcAirFoilParmsData%MulTabMet)
      UB(1:2) = ubound(SrcAirFoilParmsData%MulTabMet)
      if (.not. allocated(DstAirFoilParmsData%MulTabMet)) then
         allocate(DstAirFoilParmsData%MulTabMet(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%MulTabMet.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%MulTabMet = SrcAirFoilParmsData%MulTabMet
   else if (allocated(DstAirFoilParmsData%MulTabMet)) then
      deallocate(DstAirFoilParmsData%MulTabMet)
   end if
   if (allocated(SrcAirFoilParmsData%FoilNm)) then
      LB(1:1) = lbound(SrcAirFoilParmsData%FoilNm)
      UB(1:1) = ubound(SrcAirFoilParmsData%FoilNm)
      if (.not. allocated(DstAirFoilParmsData%FoilNm)) then
         allocate(DstAirFoilParmsData%FoilNm(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%FoilNm.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAirFoilParmsData%FoilNm = SrcAirFoilParmsData%FoilNm
   else if (allocated(DstAirFoilParmsData%FoilNm)) then
      deallocate(DstAirFoilParmsData%FoilNm)
   end if
end subroutine

subroutine AD14_DestroyAirFoilParms(AirFoilParmsData, ErrStat, ErrMsg)
   type(AirFoilParms), intent(inout) :: AirFoilParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyAirFoilParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AirFoilParmsData%NTables)) then
      deallocate(AirFoilParmsData%NTables)
   end if
   if (allocated(AirFoilParmsData%NLift)) then
      deallocate(AirFoilParmsData%NLift)
   end if
   if (allocated(AirFoilParmsData%NFoil)) then
      deallocate(AirFoilParmsData%NFoil)
   end if
   if (allocated(AirFoilParmsData%MulTabMet)) then
      deallocate(AirFoilParmsData%MulTabMet)
   end if
   if (allocated(AirFoilParmsData%FoilNm)) then
      deallocate(AirFoilParmsData%FoilNm)
   end if
end subroutine

subroutine AD14_PackAirFoilParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AirFoilParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoilParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%MaxTable)
   call RegPack(Buf, allocated(InData%NTables))
   if (allocated(InData%NTables)) then
      call RegPackBounds(Buf, 1, lbound(InData%NTables), ubound(InData%NTables))
      call RegPack(Buf, InData%NTables)
   end if
   call RegPack(Buf, allocated(InData%NLift))
   if (allocated(InData%NLift)) then
      call RegPackBounds(Buf, 1, lbound(InData%NLift), ubound(InData%NLift))
      call RegPack(Buf, InData%NLift)
   end if
   call RegPack(Buf, InData%NumCL)
   call RegPack(Buf, InData%NumFoil)
   call RegPack(Buf, allocated(InData%NFoil))
   if (allocated(InData%NFoil)) then
      call RegPackBounds(Buf, 1, lbound(InData%NFoil), ubound(InData%NFoil))
      call RegPack(Buf, InData%NFoil)
   end if
   call RegPack(Buf, allocated(InData%MulTabMet))
   if (allocated(InData%MulTabMet)) then
      call RegPackBounds(Buf, 2, lbound(InData%MulTabMet), ubound(InData%MulTabMet))
      call RegPack(Buf, InData%MulTabMet)
   end if
   call RegPack(Buf, allocated(InData%FoilNm))
   if (allocated(InData%FoilNm)) then
      call RegPackBounds(Buf, 1, lbound(InData%FoilNm), ubound(InData%FoilNm))
      call RegPack(Buf, InData%FoilNm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoilParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AirFoilParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoilParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%MaxTable)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%NTables)) deallocate(OutData%NTables)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NTables(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTables.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NTables)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%NLift)) deallocate(OutData%NLift)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NLift(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NLift.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NLift)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NumCL)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumFoil)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%NFoil)) deallocate(OutData%NFoil)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NFoil(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NFoil.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NFoil)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%MulTabMet)) deallocate(OutData%MulTabMet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MulTabMet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabMet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MulTabMet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FoilNm)) deallocate(OutData%FoilNm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FoilNm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FoilNm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FoilNm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD14_CopyBeddoes(SrcBeddoesData, DstBeddoesData, CtrlCode, ErrStat, ErrMsg)
   type(Beddoes), intent(in) :: SrcBeddoesData
   type(Beddoes), intent(inout) :: DstBeddoesData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyBeddoes'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBeddoesData%ADOT)) then
      LB(1:2) = lbound(SrcBeddoesData%ADOT)
      UB(1:2) = ubound(SrcBeddoesData%ADOT)
      if (.not. allocated(DstBeddoesData%ADOT)) then
         allocate(DstBeddoesData%ADOT(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ADOT = SrcBeddoesData%ADOT
   else if (allocated(DstBeddoesData%ADOT)) then
      deallocate(DstBeddoesData%ADOT)
   end if
   if (allocated(SrcBeddoesData%ADOT1)) then
      LB(1:2) = lbound(SrcBeddoesData%ADOT1)
      UB(1:2) = ubound(SrcBeddoesData%ADOT1)
      if (.not. allocated(DstBeddoesData%ADOT1)) then
         allocate(DstBeddoesData%ADOT1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ADOT1 = SrcBeddoesData%ADOT1
   else if (allocated(DstBeddoesData%ADOT1)) then
      deallocate(DstBeddoesData%ADOT1)
   end if
   if (allocated(SrcBeddoesData%AFE)) then
      LB(1:2) = lbound(SrcBeddoesData%AFE)
      UB(1:2) = ubound(SrcBeddoesData%AFE)
      if (.not. allocated(DstBeddoesData%AFE)) then
         allocate(DstBeddoesData%AFE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AFE = SrcBeddoesData%AFE
   else if (allocated(DstBeddoesData%AFE)) then
      deallocate(DstBeddoesData%AFE)
   end if
   if (allocated(SrcBeddoesData%AFE1)) then
      LB(1:2) = lbound(SrcBeddoesData%AFE1)
      UB(1:2) = ubound(SrcBeddoesData%AFE1)
      if (.not. allocated(DstBeddoesData%AFE1)) then
         allocate(DstBeddoesData%AFE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AFE1 = SrcBeddoesData%AFE1
   else if (allocated(DstBeddoesData%AFE1)) then
      deallocate(DstBeddoesData%AFE1)
   end if
   DstBeddoesData%AN = SrcBeddoesData%AN
   if (allocated(SrcBeddoesData%ANE)) then
      LB(1:2) = lbound(SrcBeddoesData%ANE)
      UB(1:2) = ubound(SrcBeddoesData%ANE)
      if (.not. allocated(DstBeddoesData%ANE)) then
         allocate(DstBeddoesData%ANE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ANE = SrcBeddoesData%ANE
   else if (allocated(DstBeddoesData%ANE)) then
      deallocate(DstBeddoesData%ANE)
   end if
   if (allocated(SrcBeddoesData%ANE1)) then
      LB(1:2) = lbound(SrcBeddoesData%ANE1)
      UB(1:2) = ubound(SrcBeddoesData%ANE1)
      if (.not. allocated(DstBeddoesData%ANE1)) then
         allocate(DstBeddoesData%ANE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%ANE1 = SrcBeddoesData%ANE1
   else if (allocated(DstBeddoesData%ANE1)) then
      deallocate(DstBeddoesData%ANE1)
   end if
   if (allocated(SrcBeddoesData%AOD)) then
      LB(1:2) = lbound(SrcBeddoesData%AOD)
      UB(1:2) = ubound(SrcBeddoesData%AOD)
      if (.not. allocated(DstBeddoesData%AOD)) then
         allocate(DstBeddoesData%AOD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AOD = SrcBeddoesData%AOD
   else if (allocated(DstBeddoesData%AOD)) then
      deallocate(DstBeddoesData%AOD)
   end if
   if (allocated(SrcBeddoesData%AOL)) then
      LB(1:2) = lbound(SrcBeddoesData%AOL)
      UB(1:2) = ubound(SrcBeddoesData%AOL)
      if (.not. allocated(DstBeddoesData%AOL)) then
         allocate(DstBeddoesData%AOL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%AOL = SrcBeddoesData%AOL
   else if (allocated(DstBeddoesData%AOL)) then
      deallocate(DstBeddoesData%AOL)
   end if
   if (allocated(SrcBeddoesData%BEDSEP)) then
      LB(1:2) = lbound(SrcBeddoesData%BEDSEP)
      UB(1:2) = ubound(SrcBeddoesData%BEDSEP)
      if (.not. allocated(DstBeddoesData%BEDSEP)) then
         allocate(DstBeddoesData%BEDSEP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%BEDSEP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%BEDSEP = SrcBeddoesData%BEDSEP
   else if (allocated(DstBeddoesData%BEDSEP)) then
      deallocate(DstBeddoesData%BEDSEP)
   end if
   if (allocated(SrcBeddoesData%OLDSEP)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDSEP)
      UB(1:2) = ubound(SrcBeddoesData%OLDSEP)
      if (.not. allocated(DstBeddoesData%OLDSEP)) then
         allocate(DstBeddoesData%OLDSEP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDSEP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDSEP = SrcBeddoesData%OLDSEP
   else if (allocated(DstBeddoesData%OLDSEP)) then
      deallocate(DstBeddoesData%OLDSEP)
   end if
   DstBeddoesData%CC = SrcBeddoesData%CC
   if (allocated(SrcBeddoesData%CDO)) then
      LB(1:2) = lbound(SrcBeddoesData%CDO)
      UB(1:2) = ubound(SrcBeddoesData%CDO)
      if (.not. allocated(DstBeddoesData%CDO)) then
         allocate(DstBeddoesData%CDO(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CDO.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CDO = SrcBeddoesData%CDO
   else if (allocated(DstBeddoesData%CDO)) then
      deallocate(DstBeddoesData%CDO)
   end if
   DstBeddoesData%CMI = SrcBeddoesData%CMI
   DstBeddoesData%CMQ = SrcBeddoesData%CMQ
   DstBeddoesData%CN = SrcBeddoesData%CN
   if (allocated(SrcBeddoesData%CNA)) then
      LB(1:2) = lbound(SrcBeddoesData%CNA)
      UB(1:2) = ubound(SrcBeddoesData%CNA)
      if (.not. allocated(DstBeddoesData%CNA)) then
         allocate(DstBeddoesData%CNA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNA = SrcBeddoesData%CNA
   else if (allocated(DstBeddoesData%CNA)) then
      deallocate(DstBeddoesData%CNA)
   end if
   DstBeddoesData%CNCP = SrcBeddoesData%CNCP
   DstBeddoesData%CNIQ = SrcBeddoesData%CNIQ
   if (allocated(SrcBeddoesData%CNP)) then
      LB(1:2) = lbound(SrcBeddoesData%CNP)
      UB(1:2) = ubound(SrcBeddoesData%CNP)
      if (.not. allocated(DstBeddoesData%CNP)) then
         allocate(DstBeddoesData%CNP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNP = SrcBeddoesData%CNP
   else if (allocated(DstBeddoesData%CNP)) then
      deallocate(DstBeddoesData%CNP)
   end if
   if (allocated(SrcBeddoesData%CNP1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNP1)
      UB(1:2) = ubound(SrcBeddoesData%CNP1)
      if (.not. allocated(DstBeddoesData%CNP1)) then
         allocate(DstBeddoesData%CNP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNP1 = SrcBeddoesData%CNP1
   else if (allocated(DstBeddoesData%CNP1)) then
      deallocate(DstBeddoesData%CNP1)
   end if
   if (allocated(SrcBeddoesData%CNPD)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPD)
      UB(1:2) = ubound(SrcBeddoesData%CNPD)
      if (.not. allocated(DstBeddoesData%CNPD)) then
         allocate(DstBeddoesData%CNPD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPD = SrcBeddoesData%CNPD
   else if (allocated(DstBeddoesData%CNPD)) then
      deallocate(DstBeddoesData%CNPD)
   end if
   if (allocated(SrcBeddoesData%CNPD1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPD1)
      UB(1:2) = ubound(SrcBeddoesData%CNPD1)
      if (.not. allocated(DstBeddoesData%CNPD1)) then
         allocate(DstBeddoesData%CNPD1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPD1 = SrcBeddoesData%CNPD1
   else if (allocated(DstBeddoesData%CNPD1)) then
      deallocate(DstBeddoesData%CNPD1)
   end if
   if (allocated(SrcBeddoesData%CNPOT)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPOT)
      UB(1:2) = ubound(SrcBeddoesData%CNPOT)
      if (.not. allocated(DstBeddoesData%CNPOT)) then
         allocate(DstBeddoesData%CNPOT(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPOT = SrcBeddoesData%CNPOT
   else if (allocated(DstBeddoesData%CNPOT)) then
      deallocate(DstBeddoesData%CNPOT)
   end if
   if (allocated(SrcBeddoesData%CNPOT1)) then
      LB(1:2) = lbound(SrcBeddoesData%CNPOT1)
      UB(1:2) = ubound(SrcBeddoesData%CNPOT1)
      if (.not. allocated(DstBeddoesData%CNPOT1)) then
         allocate(DstBeddoesData%CNPOT1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNPOT1 = SrcBeddoesData%CNPOT1
   else if (allocated(DstBeddoesData%CNPOT1)) then
      deallocate(DstBeddoesData%CNPOT1)
   end if
   if (allocated(SrcBeddoesData%CNS)) then
      LB(1:2) = lbound(SrcBeddoesData%CNS)
      UB(1:2) = ubound(SrcBeddoesData%CNS)
      if (.not. allocated(DstBeddoesData%CNS)) then
         allocate(DstBeddoesData%CNS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNS = SrcBeddoesData%CNS
   else if (allocated(DstBeddoesData%CNS)) then
      deallocate(DstBeddoesData%CNS)
   end if
   if (allocated(SrcBeddoesData%CNSL)) then
      LB(1:2) = lbound(SrcBeddoesData%CNSL)
      UB(1:2) = ubound(SrcBeddoesData%CNSL)
      if (.not. allocated(DstBeddoesData%CNSL)) then
         allocate(DstBeddoesData%CNSL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNSL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNSL = SrcBeddoesData%CNSL
   else if (allocated(DstBeddoesData%CNSL)) then
      deallocate(DstBeddoesData%CNSL)
   end if
   if (allocated(SrcBeddoesData%CNV)) then
      LB(1:2) = lbound(SrcBeddoesData%CNV)
      UB(1:2) = ubound(SrcBeddoesData%CNV)
      if (.not. allocated(DstBeddoesData%CNV)) then
         allocate(DstBeddoesData%CNV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CNV = SrcBeddoesData%CNV
   else if (allocated(DstBeddoesData%CNV)) then
      deallocate(DstBeddoesData%CNV)
   end if
   if (allocated(SrcBeddoesData%CVN)) then
      LB(1:2) = lbound(SrcBeddoesData%CVN)
      UB(1:2) = ubound(SrcBeddoesData%CVN)
      if (.not. allocated(DstBeddoesData%CVN)) then
         allocate(DstBeddoesData%CVN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CVN = SrcBeddoesData%CVN
   else if (allocated(DstBeddoesData%CVN)) then
      deallocate(DstBeddoesData%CVN)
   end if
   if (allocated(SrcBeddoesData%CVN1)) then
      LB(1:2) = lbound(SrcBeddoesData%CVN1)
      UB(1:2) = ubound(SrcBeddoesData%CVN1)
      if (.not. allocated(DstBeddoesData%CVN1)) then
         allocate(DstBeddoesData%CVN1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%CVN1 = SrcBeddoesData%CVN1
   else if (allocated(DstBeddoesData%CVN1)) then
      deallocate(DstBeddoesData%CVN1)
   end if
   if (allocated(SrcBeddoesData%DF)) then
      LB(1:2) = lbound(SrcBeddoesData%DF)
      UB(1:2) = ubound(SrcBeddoesData%DF)
      if (.not. allocated(DstBeddoesData%DF)) then
         allocate(DstBeddoesData%DF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DF = SrcBeddoesData%DF
   else if (allocated(DstBeddoesData%DF)) then
      deallocate(DstBeddoesData%DF)
   end if
   if (allocated(SrcBeddoesData%DFAFE)) then
      LB(1:2) = lbound(SrcBeddoesData%DFAFE)
      UB(1:2) = ubound(SrcBeddoesData%DFAFE)
      if (.not. allocated(DstBeddoesData%DFAFE)) then
         allocate(DstBeddoesData%DFAFE(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFAFE = SrcBeddoesData%DFAFE
   else if (allocated(DstBeddoesData%DFAFE)) then
      deallocate(DstBeddoesData%DFAFE)
   end if
   if (allocated(SrcBeddoesData%DFAFE1)) then
      LB(1:2) = lbound(SrcBeddoesData%DFAFE1)
      UB(1:2) = ubound(SrcBeddoesData%DFAFE1)
      if (.not. allocated(DstBeddoesData%DFAFE1)) then
         allocate(DstBeddoesData%DFAFE1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFAFE1 = SrcBeddoesData%DFAFE1
   else if (allocated(DstBeddoesData%DFAFE1)) then
      deallocate(DstBeddoesData%DFAFE1)
   end if
   if (allocated(SrcBeddoesData%DFC)) then
      LB(1:2) = lbound(SrcBeddoesData%DFC)
      UB(1:2) = ubound(SrcBeddoesData%DFC)
      if (.not. allocated(DstBeddoesData%DFC)) then
         allocate(DstBeddoesData%DFC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DFC = SrcBeddoesData%DFC
   else if (allocated(DstBeddoesData%DFC)) then
      deallocate(DstBeddoesData%DFC)
   end if
   if (allocated(SrcBeddoesData%DN)) then
      LB(1:2) = lbound(SrcBeddoesData%DN)
      UB(1:2) = ubound(SrcBeddoesData%DN)
      if (.not. allocated(DstBeddoesData%DN)) then
         allocate(DstBeddoesData%DN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DN = SrcBeddoesData%DN
   else if (allocated(DstBeddoesData%DN)) then
      deallocate(DstBeddoesData%DN)
   end if
   if (allocated(SrcBeddoesData%DPP)) then
      LB(1:2) = lbound(SrcBeddoesData%DPP)
      UB(1:2) = ubound(SrcBeddoesData%DPP)
      if (.not. allocated(DstBeddoesData%DPP)) then
         allocate(DstBeddoesData%DPP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DPP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DPP = SrcBeddoesData%DPP
   else if (allocated(DstBeddoesData%DPP)) then
      deallocate(DstBeddoesData%DPP)
   end if
   if (allocated(SrcBeddoesData%DQ)) then
      LB(1:2) = lbound(SrcBeddoesData%DQ)
      UB(1:2) = ubound(SrcBeddoesData%DQ)
      if (.not. allocated(DstBeddoesData%DQ)) then
         allocate(DstBeddoesData%DQ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQ = SrcBeddoesData%DQ
   else if (allocated(DstBeddoesData%DQ)) then
      deallocate(DstBeddoesData%DQ)
   end if
   if (allocated(SrcBeddoesData%DQP)) then
      LB(1:2) = lbound(SrcBeddoesData%DQP)
      UB(1:2) = ubound(SrcBeddoesData%DQP)
      if (.not. allocated(DstBeddoesData%DQP)) then
         allocate(DstBeddoesData%DQP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQP = SrcBeddoesData%DQP
   else if (allocated(DstBeddoesData%DQP)) then
      deallocate(DstBeddoesData%DQP)
   end if
   if (allocated(SrcBeddoesData%DQP1)) then
      LB(1:2) = lbound(SrcBeddoesData%DQP1)
      UB(1:2) = ubound(SrcBeddoesData%DQP1)
      if (.not. allocated(DstBeddoesData%DQP1)) then
         allocate(DstBeddoesData%DQP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%DQP1 = SrcBeddoesData%DQP1
   else if (allocated(DstBeddoesData%DQP1)) then
      deallocate(DstBeddoesData%DQP1)
   end if
   DstBeddoesData%DS = SrcBeddoesData%DS
   DstBeddoesData%FK = SrcBeddoesData%FK
   DstBeddoesData%FP = SrcBeddoesData%FP
   DstBeddoesData%FPC = SrcBeddoesData%FPC
   if (allocated(SrcBeddoesData%FSP)) then
      LB(1:2) = lbound(SrcBeddoesData%FSP)
      UB(1:2) = ubound(SrcBeddoesData%FSP)
      if (.not. allocated(DstBeddoesData%FSP)) then
         allocate(DstBeddoesData%FSP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSP = SrcBeddoesData%FSP
   else if (allocated(DstBeddoesData%FSP)) then
      deallocate(DstBeddoesData%FSP)
   end if
   if (allocated(SrcBeddoesData%FSP1)) then
      LB(1:2) = lbound(SrcBeddoesData%FSP1)
      UB(1:2) = ubound(SrcBeddoesData%FSP1)
      if (.not. allocated(DstBeddoesData%FSP1)) then
         allocate(DstBeddoesData%FSP1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSP1 = SrcBeddoesData%FSP1
   else if (allocated(DstBeddoesData%FSP1)) then
      deallocate(DstBeddoesData%FSP1)
   end if
   if (allocated(SrcBeddoesData%FSPC)) then
      LB(1:2) = lbound(SrcBeddoesData%FSPC)
      UB(1:2) = ubound(SrcBeddoesData%FSPC)
      if (.not. allocated(DstBeddoesData%FSPC)) then
         allocate(DstBeddoesData%FSPC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSPC = SrcBeddoesData%FSPC
   else if (allocated(DstBeddoesData%FSPC)) then
      deallocate(DstBeddoesData%FSPC)
   end if
   if (allocated(SrcBeddoesData%FSPC1)) then
      LB(1:2) = lbound(SrcBeddoesData%FSPC1)
      UB(1:2) = ubound(SrcBeddoesData%FSPC1)
      if (.not. allocated(DstBeddoesData%FSPC1)) then
         allocate(DstBeddoesData%FSPC1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FSPC1 = SrcBeddoesData%FSPC1
   else if (allocated(DstBeddoesData%FSPC1)) then
      deallocate(DstBeddoesData%FSPC1)
   end if
   if (allocated(SrcBeddoesData%FTB)) then
      LB(1:3) = lbound(SrcBeddoesData%FTB)
      UB(1:3) = ubound(SrcBeddoesData%FTB)
      if (.not. allocated(DstBeddoesData%FTB)) then
         allocate(DstBeddoesData%FTB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FTB = SrcBeddoesData%FTB
   else if (allocated(DstBeddoesData%FTB)) then
      deallocate(DstBeddoesData%FTB)
   end if
   if (allocated(SrcBeddoesData%FTBC)) then
      LB(1:3) = lbound(SrcBeddoesData%FTBC)
      UB(1:3) = ubound(SrcBeddoesData%FTBC)
      if (.not. allocated(DstBeddoesData%FTBC)) then
         allocate(DstBeddoesData%FTBC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTBC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%FTBC = SrcBeddoesData%FTBC
   else if (allocated(DstBeddoesData%FTBC)) then
      deallocate(DstBeddoesData%FTBC)
   end if
   if (allocated(SrcBeddoesData%OLDCNV)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDCNV)
      UB(1:2) = ubound(SrcBeddoesData%OLDCNV)
      if (.not. allocated(DstBeddoesData%OLDCNV)) then
         allocate(DstBeddoesData%OLDCNV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDCNV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDCNV = SrcBeddoesData%OLDCNV
   else if (allocated(DstBeddoesData%OLDCNV)) then
      deallocate(DstBeddoesData%OLDCNV)
   end if
   if (allocated(SrcBeddoesData%OLDDF)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDF)
      UB(1:2) = ubound(SrcBeddoesData%OLDDF)
      if (.not. allocated(DstBeddoesData%OLDDF)) then
         allocate(DstBeddoesData%OLDDF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDF = SrcBeddoesData%OLDDF
   else if (allocated(DstBeddoesData%OLDDF)) then
      deallocate(DstBeddoesData%OLDDF)
   end if
   if (allocated(SrcBeddoesData%OLDDFC)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDFC)
      UB(1:2) = ubound(SrcBeddoesData%OLDDFC)
      if (.not. allocated(DstBeddoesData%OLDDFC)) then
         allocate(DstBeddoesData%OLDDFC(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDFC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDFC = SrcBeddoesData%OLDDFC
   else if (allocated(DstBeddoesData%OLDDFC)) then
      deallocate(DstBeddoesData%OLDDFC)
   end if
   if (allocated(SrcBeddoesData%OLDDN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDN)
      UB(1:2) = ubound(SrcBeddoesData%OLDDN)
      if (.not. allocated(DstBeddoesData%OLDDN)) then
         allocate(DstBeddoesData%OLDDN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDN = SrcBeddoesData%OLDDN
   else if (allocated(DstBeddoesData%OLDDN)) then
      deallocate(DstBeddoesData%OLDDN)
   end if
   if (allocated(SrcBeddoesData%OLDDPP)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDPP)
      UB(1:2) = ubound(SrcBeddoesData%OLDDPP)
      if (.not. allocated(DstBeddoesData%OLDDPP)) then
         allocate(DstBeddoesData%OLDDPP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDPP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDPP = SrcBeddoesData%OLDDPP
   else if (allocated(DstBeddoesData%OLDDPP)) then
      deallocate(DstBeddoesData%OLDDPP)
   end if
   if (allocated(SrcBeddoesData%OLDDQ)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDDQ)
      UB(1:2) = ubound(SrcBeddoesData%OLDDQ)
      if (.not. allocated(DstBeddoesData%OLDDQ)) then
         allocate(DstBeddoesData%OLDDQ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDQ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDDQ = SrcBeddoesData%OLDDQ
   else if (allocated(DstBeddoesData%OLDDQ)) then
      deallocate(DstBeddoesData%OLDDQ)
   end if
   if (allocated(SrcBeddoesData%OLDTAU)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDTAU)
      UB(1:2) = ubound(SrcBeddoesData%OLDTAU)
      if (.not. allocated(DstBeddoesData%OLDTAU)) then
         allocate(DstBeddoesData%OLDTAU(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDTAU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDTAU = SrcBeddoesData%OLDTAU
   else if (allocated(DstBeddoesData%OLDTAU)) then
      deallocate(DstBeddoesData%OLDTAU)
   end if
   if (allocated(SrcBeddoesData%OLDXN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDXN)
      UB(1:2) = ubound(SrcBeddoesData%OLDXN)
      if (.not. allocated(DstBeddoesData%OLDXN)) then
         allocate(DstBeddoesData%OLDXN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDXN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDXN = SrcBeddoesData%OLDXN
   else if (allocated(DstBeddoesData%OLDXN)) then
      deallocate(DstBeddoesData%OLDXN)
   end if
   if (allocated(SrcBeddoesData%OLDYN)) then
      LB(1:2) = lbound(SrcBeddoesData%OLDYN)
      UB(1:2) = ubound(SrcBeddoesData%OLDYN)
      if (.not. allocated(DstBeddoesData%OLDYN)) then
         allocate(DstBeddoesData%OLDYN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDYN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%OLDYN = SrcBeddoesData%OLDYN
   else if (allocated(DstBeddoesData%OLDYN)) then
      deallocate(DstBeddoesData%OLDYN)
   end if
   if (allocated(SrcBeddoesData%QX)) then
      LB(1:2) = lbound(SrcBeddoesData%QX)
      UB(1:2) = ubound(SrcBeddoesData%QX)
      if (.not. allocated(DstBeddoesData%QX)) then
         allocate(DstBeddoesData%QX(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%QX = SrcBeddoesData%QX
   else if (allocated(DstBeddoesData%QX)) then
      deallocate(DstBeddoesData%QX)
   end if
   if (allocated(SrcBeddoesData%QX1)) then
      LB(1:2) = lbound(SrcBeddoesData%QX1)
      UB(1:2) = ubound(SrcBeddoesData%QX1)
      if (.not. allocated(DstBeddoesData%QX1)) then
         allocate(DstBeddoesData%QX1(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%QX1 = SrcBeddoesData%QX1
   else if (allocated(DstBeddoesData%QX1)) then
      deallocate(DstBeddoesData%QX1)
   end if
   if (allocated(SrcBeddoesData%TAU)) then
      LB(1:2) = lbound(SrcBeddoesData%TAU)
      UB(1:2) = ubound(SrcBeddoesData%TAU)
      if (.not. allocated(DstBeddoesData%TAU)) then
         allocate(DstBeddoesData%TAU(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%TAU.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%TAU = SrcBeddoesData%TAU
   else if (allocated(DstBeddoesData%TAU)) then
      deallocate(DstBeddoesData%TAU)
   end if
   if (allocated(SrcBeddoesData%XN)) then
      LB(1:2) = lbound(SrcBeddoesData%XN)
      UB(1:2) = ubound(SrcBeddoesData%XN)
      if (.not. allocated(DstBeddoesData%XN)) then
         allocate(DstBeddoesData%XN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%XN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%XN = SrcBeddoesData%XN
   else if (allocated(DstBeddoesData%XN)) then
      deallocate(DstBeddoesData%XN)
   end if
   if (allocated(SrcBeddoesData%YN)) then
      LB(1:2) = lbound(SrcBeddoesData%YN)
      UB(1:2) = ubound(SrcBeddoesData%YN)
      if (.not. allocated(DstBeddoesData%YN)) then
         allocate(DstBeddoesData%YN(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%YN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeddoesData%YN = SrcBeddoesData%YN
   else if (allocated(DstBeddoesData%YN)) then
      deallocate(DstBeddoesData%YN)
   end if
   DstBeddoesData%SHIFT = SrcBeddoesData%SHIFT
   DstBeddoesData%VOR = SrcBeddoesData%VOR
end subroutine

subroutine AD14_DestroyBeddoes(BeddoesData, ErrStat, ErrMsg)
   type(Beddoes), intent(inout) :: BeddoesData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBeddoes'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BeddoesData%ADOT)) then
      deallocate(BeddoesData%ADOT)
   end if
   if (allocated(BeddoesData%ADOT1)) then
      deallocate(BeddoesData%ADOT1)
   end if
   if (allocated(BeddoesData%AFE)) then
      deallocate(BeddoesData%AFE)
   end if
   if (allocated(BeddoesData%AFE1)) then
      deallocate(BeddoesData%AFE1)
   end if
   if (allocated(BeddoesData%ANE)) then
      deallocate(BeddoesData%ANE)
   end if
   if (allocated(BeddoesData%ANE1)) then
      deallocate(BeddoesData%ANE1)
   end if
   if (allocated(BeddoesData%AOD)) then
      deallocate(BeddoesData%AOD)
   end if
   if (allocated(BeddoesData%AOL)) then
      deallocate(BeddoesData%AOL)
   end if
   if (allocated(BeddoesData%BEDSEP)) then
      deallocate(BeddoesData%BEDSEP)
   end if
   if (allocated(BeddoesData%OLDSEP)) then
      deallocate(BeddoesData%OLDSEP)
   end if
   if (allocated(BeddoesData%CDO)) then
      deallocate(BeddoesData%CDO)
   end if
   if (allocated(BeddoesData%CNA)) then
      deallocate(BeddoesData%CNA)
   end if
   if (allocated(BeddoesData%CNP)) then
      deallocate(BeddoesData%CNP)
   end if
   if (allocated(BeddoesData%CNP1)) then
      deallocate(BeddoesData%CNP1)
   end if
   if (allocated(BeddoesData%CNPD)) then
      deallocate(BeddoesData%CNPD)
   end if
   if (allocated(BeddoesData%CNPD1)) then
      deallocate(BeddoesData%CNPD1)
   end if
   if (allocated(BeddoesData%CNPOT)) then
      deallocate(BeddoesData%CNPOT)
   end if
   if (allocated(BeddoesData%CNPOT1)) then
      deallocate(BeddoesData%CNPOT1)
   end if
   if (allocated(BeddoesData%CNS)) then
      deallocate(BeddoesData%CNS)
   end if
   if (allocated(BeddoesData%CNSL)) then
      deallocate(BeddoesData%CNSL)
   end if
   if (allocated(BeddoesData%CNV)) then
      deallocate(BeddoesData%CNV)
   end if
   if (allocated(BeddoesData%CVN)) then
      deallocate(BeddoesData%CVN)
   end if
   if (allocated(BeddoesData%CVN1)) then
      deallocate(BeddoesData%CVN1)
   end if
   if (allocated(BeddoesData%DF)) then
      deallocate(BeddoesData%DF)
   end if
   if (allocated(BeddoesData%DFAFE)) then
      deallocate(BeddoesData%DFAFE)
   end if
   if (allocated(BeddoesData%DFAFE1)) then
      deallocate(BeddoesData%DFAFE1)
   end if
   if (allocated(BeddoesData%DFC)) then
      deallocate(BeddoesData%DFC)
   end if
   if (allocated(BeddoesData%DN)) then
      deallocate(BeddoesData%DN)
   end if
   if (allocated(BeddoesData%DPP)) then
      deallocate(BeddoesData%DPP)
   end if
   if (allocated(BeddoesData%DQ)) then
      deallocate(BeddoesData%DQ)
   end if
   if (allocated(BeddoesData%DQP)) then
      deallocate(BeddoesData%DQP)
   end if
   if (allocated(BeddoesData%DQP1)) then
      deallocate(BeddoesData%DQP1)
   end if
   if (allocated(BeddoesData%FSP)) then
      deallocate(BeddoesData%FSP)
   end if
   if (allocated(BeddoesData%FSP1)) then
      deallocate(BeddoesData%FSP1)
   end if
   if (allocated(BeddoesData%FSPC)) then
      deallocate(BeddoesData%FSPC)
   end if
   if (allocated(BeddoesData%FSPC1)) then
      deallocate(BeddoesData%FSPC1)
   end if
   if (allocated(BeddoesData%FTB)) then
      deallocate(BeddoesData%FTB)
   end if
   if (allocated(BeddoesData%FTBC)) then
      deallocate(BeddoesData%FTBC)
   end if
   if (allocated(BeddoesData%OLDCNV)) then
      deallocate(BeddoesData%OLDCNV)
   end if
   if (allocated(BeddoesData%OLDDF)) then
      deallocate(BeddoesData%OLDDF)
   end if
   if (allocated(BeddoesData%OLDDFC)) then
      deallocate(BeddoesData%OLDDFC)
   end if
   if (allocated(BeddoesData%OLDDN)) then
      deallocate(BeddoesData%OLDDN)
   end if
   if (allocated(BeddoesData%OLDDPP)) then
      deallocate(BeddoesData%OLDDPP)
   end if
   if (allocated(BeddoesData%OLDDQ)) then
      deallocate(BeddoesData%OLDDQ)
   end if
   if (allocated(BeddoesData%OLDTAU)) then
      deallocate(BeddoesData%OLDTAU)
   end if
   if (allocated(BeddoesData%OLDXN)) then
      deallocate(BeddoesData%OLDXN)
   end if
   if (allocated(BeddoesData%OLDYN)) then
      deallocate(BeddoesData%OLDYN)
   end if
   if (allocated(BeddoesData%QX)) then
      deallocate(BeddoesData%QX)
   end if
   if (allocated(BeddoesData%QX1)) then
      deallocate(BeddoesData%QX1)
   end if
   if (allocated(BeddoesData%TAU)) then
      deallocate(BeddoesData%TAU)
   end if
   if (allocated(BeddoesData%XN)) then
      deallocate(BeddoesData%XN)
   end if
   if (allocated(BeddoesData%YN)) then
      deallocate(BeddoesData%YN)
   end if
end subroutine

subroutine AD14_PackBeddoes(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Beddoes), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoes'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%ADOT))
   if (allocated(InData%ADOT)) then
      call RegPackBounds(Buf, 2, lbound(InData%ADOT), ubound(InData%ADOT))
      call RegPack(Buf, InData%ADOT)
   end if
   call RegPack(Buf, allocated(InData%ADOT1))
   if (allocated(InData%ADOT1)) then
      call RegPackBounds(Buf, 2, lbound(InData%ADOT1), ubound(InData%ADOT1))
      call RegPack(Buf, InData%ADOT1)
   end if
   call RegPack(Buf, allocated(InData%AFE))
   if (allocated(InData%AFE)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFE), ubound(InData%AFE))
      call RegPack(Buf, InData%AFE)
   end if
   call RegPack(Buf, allocated(InData%AFE1))
   if (allocated(InData%AFE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFE1), ubound(InData%AFE1))
      call RegPack(Buf, InData%AFE1)
   end if
   call RegPack(Buf, InData%AN)
   call RegPack(Buf, allocated(InData%ANE))
   if (allocated(InData%ANE)) then
      call RegPackBounds(Buf, 2, lbound(InData%ANE), ubound(InData%ANE))
      call RegPack(Buf, InData%ANE)
   end if
   call RegPack(Buf, allocated(InData%ANE1))
   if (allocated(InData%ANE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%ANE1), ubound(InData%ANE1))
      call RegPack(Buf, InData%ANE1)
   end if
   call RegPack(Buf, allocated(InData%AOD))
   if (allocated(InData%AOD)) then
      call RegPackBounds(Buf, 2, lbound(InData%AOD), ubound(InData%AOD))
      call RegPack(Buf, InData%AOD)
   end if
   call RegPack(Buf, allocated(InData%AOL))
   if (allocated(InData%AOL)) then
      call RegPackBounds(Buf, 2, lbound(InData%AOL), ubound(InData%AOL))
      call RegPack(Buf, InData%AOL)
   end if
   call RegPack(Buf, allocated(InData%BEDSEP))
   if (allocated(InData%BEDSEP)) then
      call RegPackBounds(Buf, 2, lbound(InData%BEDSEP), ubound(InData%BEDSEP))
      call RegPack(Buf, InData%BEDSEP)
   end if
   call RegPack(Buf, allocated(InData%OLDSEP))
   if (allocated(InData%OLDSEP)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDSEP), ubound(InData%OLDSEP))
      call RegPack(Buf, InData%OLDSEP)
   end if
   call RegPack(Buf, InData%CC)
   call RegPack(Buf, allocated(InData%CDO))
   if (allocated(InData%CDO)) then
      call RegPackBounds(Buf, 2, lbound(InData%CDO), ubound(InData%CDO))
      call RegPack(Buf, InData%CDO)
   end if
   call RegPack(Buf, InData%CMI)
   call RegPack(Buf, InData%CMQ)
   call RegPack(Buf, InData%CN)
   call RegPack(Buf, allocated(InData%CNA))
   if (allocated(InData%CNA)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNA), ubound(InData%CNA))
      call RegPack(Buf, InData%CNA)
   end if
   call RegPack(Buf, InData%CNCP)
   call RegPack(Buf, InData%CNIQ)
   call RegPack(Buf, allocated(InData%CNP))
   if (allocated(InData%CNP)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNP), ubound(InData%CNP))
      call RegPack(Buf, InData%CNP)
   end if
   call RegPack(Buf, allocated(InData%CNP1))
   if (allocated(InData%CNP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNP1), ubound(InData%CNP1))
      call RegPack(Buf, InData%CNP1)
   end if
   call RegPack(Buf, allocated(InData%CNPD))
   if (allocated(InData%CNPD)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPD), ubound(InData%CNPD))
      call RegPack(Buf, InData%CNPD)
   end if
   call RegPack(Buf, allocated(InData%CNPD1))
   if (allocated(InData%CNPD1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPD1), ubound(InData%CNPD1))
      call RegPack(Buf, InData%CNPD1)
   end if
   call RegPack(Buf, allocated(InData%CNPOT))
   if (allocated(InData%CNPOT)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPOT), ubound(InData%CNPOT))
      call RegPack(Buf, InData%CNPOT)
   end if
   call RegPack(Buf, allocated(InData%CNPOT1))
   if (allocated(InData%CNPOT1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPOT1), ubound(InData%CNPOT1))
      call RegPack(Buf, InData%CNPOT1)
   end if
   call RegPack(Buf, allocated(InData%CNS))
   if (allocated(InData%CNS)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNS), ubound(InData%CNS))
      call RegPack(Buf, InData%CNS)
   end if
   call RegPack(Buf, allocated(InData%CNSL))
   if (allocated(InData%CNSL)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNSL), ubound(InData%CNSL))
      call RegPack(Buf, InData%CNSL)
   end if
   call RegPack(Buf, allocated(InData%CNV))
   if (allocated(InData%CNV)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNV), ubound(InData%CNV))
      call RegPack(Buf, InData%CNV)
   end if
   call RegPack(Buf, allocated(InData%CVN))
   if (allocated(InData%CVN)) then
      call RegPackBounds(Buf, 2, lbound(InData%CVN), ubound(InData%CVN))
      call RegPack(Buf, InData%CVN)
   end if
   call RegPack(Buf, allocated(InData%CVN1))
   if (allocated(InData%CVN1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CVN1), ubound(InData%CVN1))
      call RegPack(Buf, InData%CVN1)
   end if
   call RegPack(Buf, allocated(InData%DF))
   if (allocated(InData%DF)) then
      call RegPackBounds(Buf, 2, lbound(InData%DF), ubound(InData%DF))
      call RegPack(Buf, InData%DF)
   end if
   call RegPack(Buf, allocated(InData%DFAFE))
   if (allocated(InData%DFAFE)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFAFE), ubound(InData%DFAFE))
      call RegPack(Buf, InData%DFAFE)
   end if
   call RegPack(Buf, allocated(InData%DFAFE1))
   if (allocated(InData%DFAFE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFAFE1), ubound(InData%DFAFE1))
      call RegPack(Buf, InData%DFAFE1)
   end if
   call RegPack(Buf, allocated(InData%DFC))
   if (allocated(InData%DFC)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFC), ubound(InData%DFC))
      call RegPack(Buf, InData%DFC)
   end if
   call RegPack(Buf, allocated(InData%DN))
   if (allocated(InData%DN)) then
      call RegPackBounds(Buf, 2, lbound(InData%DN), ubound(InData%DN))
      call RegPack(Buf, InData%DN)
   end if
   call RegPack(Buf, allocated(InData%DPP))
   if (allocated(InData%DPP)) then
      call RegPackBounds(Buf, 2, lbound(InData%DPP), ubound(InData%DPP))
      call RegPack(Buf, InData%DPP)
   end if
   call RegPack(Buf, allocated(InData%DQ))
   if (allocated(InData%DQ)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQ), ubound(InData%DQ))
      call RegPack(Buf, InData%DQ)
   end if
   call RegPack(Buf, allocated(InData%DQP))
   if (allocated(InData%DQP)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQP), ubound(InData%DQP))
      call RegPack(Buf, InData%DQP)
   end if
   call RegPack(Buf, allocated(InData%DQP1))
   if (allocated(InData%DQP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQP1), ubound(InData%DQP1))
      call RegPack(Buf, InData%DQP1)
   end if
   call RegPack(Buf, InData%DS)
   call RegPack(Buf, InData%FK)
   call RegPack(Buf, InData%FP)
   call RegPack(Buf, InData%FPC)
   call RegPack(Buf, allocated(InData%FSP))
   if (allocated(InData%FSP)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSP), ubound(InData%FSP))
      call RegPack(Buf, InData%FSP)
   end if
   call RegPack(Buf, allocated(InData%FSP1))
   if (allocated(InData%FSP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSP1), ubound(InData%FSP1))
      call RegPack(Buf, InData%FSP1)
   end if
   call RegPack(Buf, allocated(InData%FSPC))
   if (allocated(InData%FSPC)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSPC), ubound(InData%FSPC))
      call RegPack(Buf, InData%FSPC)
   end if
   call RegPack(Buf, allocated(InData%FSPC1))
   if (allocated(InData%FSPC1)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSPC1), ubound(InData%FSPC1))
      call RegPack(Buf, InData%FSPC1)
   end if
   call RegPack(Buf, allocated(InData%FTB))
   if (allocated(InData%FTB)) then
      call RegPackBounds(Buf, 3, lbound(InData%FTB), ubound(InData%FTB))
      call RegPack(Buf, InData%FTB)
   end if
   call RegPack(Buf, allocated(InData%FTBC))
   if (allocated(InData%FTBC)) then
      call RegPackBounds(Buf, 3, lbound(InData%FTBC), ubound(InData%FTBC))
      call RegPack(Buf, InData%FTBC)
   end if
   call RegPack(Buf, allocated(InData%OLDCNV))
   if (allocated(InData%OLDCNV)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDCNV), ubound(InData%OLDCNV))
      call RegPack(Buf, InData%OLDCNV)
   end if
   call RegPack(Buf, allocated(InData%OLDDF))
   if (allocated(InData%OLDDF)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDF), ubound(InData%OLDDF))
      call RegPack(Buf, InData%OLDDF)
   end if
   call RegPack(Buf, allocated(InData%OLDDFC))
   if (allocated(InData%OLDDFC)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDFC), ubound(InData%OLDDFC))
      call RegPack(Buf, InData%OLDDFC)
   end if
   call RegPack(Buf, allocated(InData%OLDDN))
   if (allocated(InData%OLDDN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDN), ubound(InData%OLDDN))
      call RegPack(Buf, InData%OLDDN)
   end if
   call RegPack(Buf, allocated(InData%OLDDPP))
   if (allocated(InData%OLDDPP)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDPP), ubound(InData%OLDDPP))
      call RegPack(Buf, InData%OLDDPP)
   end if
   call RegPack(Buf, allocated(InData%OLDDQ))
   if (allocated(InData%OLDDQ)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDQ), ubound(InData%OLDDQ))
      call RegPack(Buf, InData%OLDDQ)
   end if
   call RegPack(Buf, allocated(InData%OLDTAU))
   if (allocated(InData%OLDTAU)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDTAU), ubound(InData%OLDTAU))
      call RegPack(Buf, InData%OLDTAU)
   end if
   call RegPack(Buf, allocated(InData%OLDXN))
   if (allocated(InData%OLDXN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDXN), ubound(InData%OLDXN))
      call RegPack(Buf, InData%OLDXN)
   end if
   call RegPack(Buf, allocated(InData%OLDYN))
   if (allocated(InData%OLDYN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDYN), ubound(InData%OLDYN))
      call RegPack(Buf, InData%OLDYN)
   end if
   call RegPack(Buf, allocated(InData%QX))
   if (allocated(InData%QX)) then
      call RegPackBounds(Buf, 2, lbound(InData%QX), ubound(InData%QX))
      call RegPack(Buf, InData%QX)
   end if
   call RegPack(Buf, allocated(InData%QX1))
   if (allocated(InData%QX1)) then
      call RegPackBounds(Buf, 2, lbound(InData%QX1), ubound(InData%QX1))
      call RegPack(Buf, InData%QX1)
   end if
   call RegPack(Buf, allocated(InData%TAU))
   if (allocated(InData%TAU)) then
      call RegPackBounds(Buf, 2, lbound(InData%TAU), ubound(InData%TAU))
      call RegPack(Buf, InData%TAU)
   end if
   call RegPack(Buf, allocated(InData%XN))
   if (allocated(InData%XN)) then
      call RegPackBounds(Buf, 2, lbound(InData%XN), ubound(InData%XN))
      call RegPack(Buf, InData%XN)
   end if
   call RegPack(Buf, allocated(InData%YN))
   if (allocated(InData%YN)) then
      call RegPackBounds(Buf, 2, lbound(InData%YN), ubound(InData%YN))
      call RegPack(Buf, InData%YN)
   end if
   call RegPack(Buf, InData%SHIFT)
   call RegPack(Buf, InData%VOR)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoes(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Beddoes), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoes'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%ADOT)) deallocate(OutData%ADOT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADOT(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADOT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ADOT1)) deallocate(OutData%ADOT1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADOT1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADOT1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AFE)) deallocate(OutData%AFE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AFE1)) deallocate(OutData%AFE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%AN)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%ANE)) deallocate(OutData%ANE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ANE1)) deallocate(OutData%ANE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AOD)) deallocate(OutData%AOD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AOD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AOD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AOL)) deallocate(OutData%AOL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AOL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AOL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BEDSEP)) deallocate(OutData%BEDSEP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BEDSEP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BEDSEP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BEDSEP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDSEP)) deallocate(OutData%OLDSEP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDSEP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDSEP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDSEP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%CC)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%CDO)) deallocate(OutData%CDO)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CDO(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDO.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CDO)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%CMI)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CMQ)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CN)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%CNA)) deallocate(OutData%CNA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%CNCP)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CNIQ)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%CNP)) deallocate(OutData%CNP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNP1)) deallocate(OutData%CNP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNPD)) deallocate(OutData%CNPD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNPD1)) deallocate(OutData%CNPD1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPD1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPD1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNPOT)) deallocate(OutData%CNPOT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPOT(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPOT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNPOT1)) deallocate(OutData%CNPOT1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPOT1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPOT1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNS)) deallocate(OutData%CNS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNSL)) deallocate(OutData%CNSL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNSL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNSL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNSL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNV)) deallocate(OutData%CNV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNV(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CVN)) deallocate(OutData%CVN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CVN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CVN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CVN1)) deallocate(OutData%CVN1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CVN1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CVN1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DF)) deallocate(OutData%DF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DFAFE)) deallocate(OutData%DFAFE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFAFE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFAFE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DFAFE1)) deallocate(OutData%DFAFE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFAFE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFAFE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DFC)) deallocate(OutData%DFC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DN)) deallocate(OutData%DN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DPP)) deallocate(OutData%DPP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DPP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DPP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DPP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DQ)) deallocate(OutData%DQ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DQP)) deallocate(OutData%DQP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DQP1)) deallocate(OutData%DQP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%DS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FK)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FP)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FPC)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%FSP)) deallocate(OutData%FSP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FSP1)) deallocate(OutData%FSP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FSPC)) deallocate(OutData%FSPC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSPC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSPC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FSPC1)) deallocate(OutData%FSPC1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSPC1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSPC1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FTB)) deallocate(OutData%FTB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FTB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FTB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FTBC)) deallocate(OutData%FTBC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FTBC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTBC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FTBC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDCNV)) deallocate(OutData%OLDCNV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDCNV(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDCNV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDCNV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDDF)) deallocate(OutData%OLDDF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDDFC)) deallocate(OutData%OLDDFC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDFC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDFC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDFC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDDN)) deallocate(OutData%OLDDN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDDPP)) deallocate(OutData%OLDDPP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDPP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDPP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDPP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDDQ)) deallocate(OutData%OLDDQ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDQ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDQ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDQ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDTAU)) deallocate(OutData%OLDTAU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDTAU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDTAU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDTAU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDXN)) deallocate(OutData%OLDXN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDXN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDXN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDXN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLDYN)) deallocate(OutData%OLDYN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDYN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDYN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDYN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%QX)) deallocate(OutData%QX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%QX(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%QX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%QX1)) deallocate(OutData%QX1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%QX1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%QX1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TAU)) deallocate(OutData%TAU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TAU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TAU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TAU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%XN)) deallocate(OutData%XN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%XN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%XN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%XN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%YN)) deallocate(OutData%YN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%YN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%YN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%YN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%SHIFT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VOR)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyBeddoesParms(SrcBeddoesParmsData, DstBeddoesParmsData, CtrlCode, ErrStat, ErrMsg)
   type(BeddoesParms), intent(in) :: SrcBeddoesParmsData
   type(BeddoesParms), intent(inout) :: DstBeddoesParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyBeddoesParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstBeddoesParmsData%AS = SrcBeddoesParmsData%AS
   DstBeddoesParmsData%TF = SrcBeddoesParmsData%TF
   DstBeddoesParmsData%TP = SrcBeddoesParmsData%TP
   DstBeddoesParmsData%TV = SrcBeddoesParmsData%TV
   DstBeddoesParmsData%TVL = SrcBeddoesParmsData%TVL
end subroutine

subroutine AD14_DestroyBeddoesParms(BeddoesParmsData, ErrStat, ErrMsg)
   type(BeddoesParms), intent(inout) :: BeddoesParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBeddoesParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackBeddoesParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BeddoesParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoesParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%AS)
   call RegPack(Buf, InData%TF)
   call RegPack(Buf, InData%TP)
   call RegPack(Buf, InData%TV)
   call RegPack(Buf, InData%TVL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoesParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BeddoesParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoesParms'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%AS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TF)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TP)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TVL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyBladeParms(SrcBladeParmsData, DstBladeParmsData, CtrlCode, ErrStat, ErrMsg)
   type(BladeParms), intent(in) :: SrcBladeParmsData
   type(BladeParms), intent(inout) :: DstBladeParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyBladeParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBladeParmsData%C)) then
      LB(1:1) = lbound(SrcBladeParmsData%C)
      UB(1:1) = ubound(SrcBladeParmsData%C)
      if (.not. allocated(DstBladeParmsData%C)) then
         allocate(DstBladeParmsData%C(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%C.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeParmsData%C = SrcBladeParmsData%C
   else if (allocated(DstBladeParmsData%C)) then
      deallocate(DstBladeParmsData%C)
   end if
   if (allocated(SrcBladeParmsData%DR)) then
      LB(1:1) = lbound(SrcBladeParmsData%DR)
      UB(1:1) = ubound(SrcBladeParmsData%DR)
      if (.not. allocated(DstBladeParmsData%DR)) then
         allocate(DstBladeParmsData%DR(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%DR.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeParmsData%DR = SrcBladeParmsData%DR
   else if (allocated(DstBladeParmsData%DR)) then
      deallocate(DstBladeParmsData%DR)
   end if
   DstBladeParmsData%R = SrcBladeParmsData%R
   DstBladeParmsData%BladeLength = SrcBladeParmsData%BladeLength
end subroutine

subroutine AD14_DestroyBladeParms(BladeParmsData, ErrStat, ErrMsg)
   type(BladeParms), intent(inout) :: BladeParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyBladeParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladeParmsData%C)) then
      deallocate(BladeParmsData%C)
   end if
   if (allocated(BladeParmsData%DR)) then
      deallocate(BladeParmsData%DR)
   end if
end subroutine

subroutine AD14_PackBladeParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BladeParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBladeParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%C))
   if (allocated(InData%C)) then
      call RegPackBounds(Buf, 1, lbound(InData%C), ubound(InData%C))
      call RegPack(Buf, InData%C)
   end if
   call RegPack(Buf, allocated(InData%DR))
   if (allocated(InData%DR)) then
      call RegPackBounds(Buf, 1, lbound(InData%DR), ubound(InData%DR))
      call RegPack(Buf, InData%DR)
   end if
   call RegPack(Buf, InData%R)
   call RegPack(Buf, InData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBladeParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BladeParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBladeParms'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%C)) deallocate(OutData%C)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DR)) deallocate(OutData%DR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DR(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%R)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyDynInflow(SrcDynInflowData, DstDynInflowData, CtrlCode, ErrStat, ErrMsg)
   type(DynInflow), intent(in) :: SrcDynInflowData
   type(DynInflow), intent(inout) :: DstDynInflowData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyDynInflow'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDynInflowData%dAlph_dt = SrcDynInflowData%dAlph_dt
   DstDynInflowData%dBeta_dt = SrcDynInflowData%dBeta_dt
   DstDynInflowData%DTO = SrcDynInflowData%DTO
   DstDynInflowData%old_Alph = SrcDynInflowData%old_Alph
   DstDynInflowData%old_Beta = SrcDynInflowData%old_Beta
   DstDynInflowData%old_LmdM = SrcDynInflowData%old_LmdM
   DstDynInflowData%oldKai = SrcDynInflowData%oldKai
   DstDynInflowData%PhiLqC = SrcDynInflowData%PhiLqC
   DstDynInflowData%PhiLqS = SrcDynInflowData%PhiLqS
   DstDynInflowData%Pzero = SrcDynInflowData%Pzero
   if (allocated(SrcDynInflowData%RMC_SAVE)) then
      LB(1:3) = lbound(SrcDynInflowData%RMC_SAVE)
      UB(1:3) = ubound(SrcDynInflowData%RMC_SAVE)
      if (.not. allocated(DstDynInflowData%RMC_SAVE)) then
         allocate(DstDynInflowData%RMC_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMC_SAVE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstDynInflowData%RMC_SAVE = SrcDynInflowData%RMC_SAVE
   else if (allocated(DstDynInflowData%RMC_SAVE)) then
      deallocate(DstDynInflowData%RMC_SAVE)
   end if
   if (allocated(SrcDynInflowData%RMS_SAVE)) then
      LB(1:3) = lbound(SrcDynInflowData%RMS_SAVE)
      UB(1:3) = ubound(SrcDynInflowData%RMS_SAVE)
      if (.not. allocated(DstDynInflowData%RMS_SAVE)) then
         allocate(DstDynInflowData%RMS_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMS_SAVE.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstDynInflowData%RMS_SAVE = SrcDynInflowData%RMS_SAVE
   else if (allocated(DstDynInflowData%RMS_SAVE)) then
      deallocate(DstDynInflowData%RMS_SAVE)
   end if
   DstDynInflowData%TipSpeed = SrcDynInflowData%TipSpeed
   DstDynInflowData%totalInf = SrcDynInflowData%totalInf
   DstDynInflowData%Vparam = SrcDynInflowData%Vparam
   DstDynInflowData%Vtotal = SrcDynInflowData%Vtotal
   DstDynInflowData%xAlpha = SrcDynInflowData%xAlpha
   DstDynInflowData%xBeta = SrcDynInflowData%xBeta
   DstDynInflowData%xKai = SrcDynInflowData%xKai
   DstDynInflowData%XLAMBDA_M = SrcDynInflowData%XLAMBDA_M
   DstDynInflowData%xLcos = SrcDynInflowData%xLcos
   DstDynInflowData%xLsin = SrcDynInflowData%xLsin
   DstDynInflowData%MminR = SrcDynInflowData%MminR
   DstDynInflowData%MminusR = SrcDynInflowData%MminusR
   DstDynInflowData%MplusR = SrcDynInflowData%MplusR
   DstDynInflowData%GAMMA = SrcDynInflowData%GAMMA
end subroutine

subroutine AD14_DestroyDynInflow(DynInflowData, ErrStat, ErrMsg)
   type(DynInflow), intent(inout) :: DynInflowData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyDynInflow'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(DynInflowData%RMC_SAVE)) then
      deallocate(DynInflowData%RMC_SAVE)
   end if
   if (allocated(DynInflowData%RMS_SAVE)) then
      deallocate(DynInflowData%RMS_SAVE)
   end if
end subroutine

subroutine AD14_PackDynInflow(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(DynInflow), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflow'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%dAlph_dt)
   call RegPack(Buf, InData%dBeta_dt)
   call RegPack(Buf, InData%DTO)
   call RegPack(Buf, InData%old_Alph)
   call RegPack(Buf, InData%old_Beta)
   call RegPack(Buf, InData%old_LmdM)
   call RegPack(Buf, InData%oldKai)
   call RegPack(Buf, InData%PhiLqC)
   call RegPack(Buf, InData%PhiLqS)
   call RegPack(Buf, InData%Pzero)
   call RegPack(Buf, allocated(InData%RMC_SAVE))
   if (allocated(InData%RMC_SAVE)) then
      call RegPackBounds(Buf, 3, lbound(InData%RMC_SAVE), ubound(InData%RMC_SAVE))
      call RegPack(Buf, InData%RMC_SAVE)
   end if
   call RegPack(Buf, allocated(InData%RMS_SAVE))
   if (allocated(InData%RMS_SAVE)) then
      call RegPackBounds(Buf, 3, lbound(InData%RMS_SAVE), ubound(InData%RMS_SAVE))
      call RegPack(Buf, InData%RMS_SAVE)
   end if
   call RegPack(Buf, InData%TipSpeed)
   call RegPack(Buf, InData%totalInf)
   call RegPack(Buf, InData%Vparam)
   call RegPack(Buf, InData%Vtotal)
   call RegPack(Buf, InData%xAlpha)
   call RegPack(Buf, InData%xBeta)
   call RegPack(Buf, InData%xKai)
   call RegPack(Buf, InData%XLAMBDA_M)
   call RegPack(Buf, InData%xLcos)
   call RegPack(Buf, InData%xLsin)
   call RegPack(Buf, InData%MminR)
   call RegPack(Buf, InData%MminusR)
   call RegPack(Buf, InData%MplusR)
   call RegPack(Buf, InData%GAMMA)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflow(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(DynInflow), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflow'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%dAlph_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%dBeta_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DTO)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%old_Alph)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%old_Beta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%old_LmdM)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%oldKai)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PhiLqC)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PhiLqS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Pzero)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%RMC_SAVE)) deallocate(OutData%RMC_SAVE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RMC_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMC_SAVE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RMC_SAVE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%RMS_SAVE)) deallocate(OutData%RMS_SAVE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RMS_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMS_SAVE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RMS_SAVE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%TipSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%totalInf)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Vparam)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Vtotal)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xBeta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xKai)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%XLAMBDA_M)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xLcos)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xLsin)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MminR)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MminusR)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MplusR)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%GAMMA)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyDynInflowParms(SrcDynInflowParmsData, DstDynInflowParmsData, CtrlCode, ErrStat, ErrMsg)
   type(DynInflowParms), intent(in) :: SrcDynInflowParmsData
   type(DynInflowParms), intent(inout) :: DstDynInflowParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyDynInflowParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDynInflowParmsData%MAXINFLO = SrcDynInflowParmsData%MAXINFLO
   DstDynInflowParmsData%xMinv = SrcDynInflowParmsData%xMinv
end subroutine

subroutine AD14_DestroyDynInflowParms(DynInflowParmsData, ErrStat, ErrMsg)
   type(DynInflowParms), intent(inout) :: DynInflowParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyDynInflowParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackDynInflowParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(DynInflowParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflowParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%MAXINFLO)
   call RegPack(Buf, InData%xMinv)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflowParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(DynInflowParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflowParms'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%MAXINFLO)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%xMinv)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyElement(SrcElementData, DstElementData, CtrlCode, ErrStat, ErrMsg)
   type(Element), intent(in) :: SrcElementData
   type(Element), intent(inout) :: DstElementData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElement'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcElementData%A)) then
      LB(1:2) = lbound(SrcElementData%A)
      UB(1:2) = ubound(SrcElementData%A)
      if (.not. allocated(DstElementData%A)) then
         allocate(DstElementData%A(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%A.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%A = SrcElementData%A
   else if (allocated(DstElementData%A)) then
      deallocate(DstElementData%A)
   end if
   if (allocated(SrcElementData%AP)) then
      LB(1:2) = lbound(SrcElementData%AP)
      UB(1:2) = ubound(SrcElementData%AP)
      if (.not. allocated(DstElementData%AP)) then
         allocate(DstElementData%AP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%AP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%AP = SrcElementData%AP
   else if (allocated(DstElementData%AP)) then
      deallocate(DstElementData%AP)
   end if
   if (allocated(SrcElementData%ALPHA)) then
      LB(1:2) = lbound(SrcElementData%ALPHA)
      UB(1:2) = ubound(SrcElementData%ALPHA)
      if (.not. allocated(DstElementData%ALPHA)) then
         allocate(DstElementData%ALPHA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%ALPHA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%ALPHA = SrcElementData%ALPHA
   else if (allocated(DstElementData%ALPHA)) then
      deallocate(DstElementData%ALPHA)
   end if
   if (allocated(SrcElementData%W2)) then
      LB(1:2) = lbound(SrcElementData%W2)
      UB(1:2) = ubound(SrcElementData%W2)
      if (.not. allocated(DstElementData%W2)) then
         allocate(DstElementData%W2(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%W2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%W2 = SrcElementData%W2
   else if (allocated(DstElementData%W2)) then
      deallocate(DstElementData%W2)
   end if
   if (allocated(SrcElementData%OLD_A_NS)) then
      LB(1:2) = lbound(SrcElementData%OLD_A_NS)
      UB(1:2) = ubound(SrcElementData%OLD_A_NS)
      if (.not. allocated(DstElementData%OLD_A_NS)) then
         allocate(DstElementData%OLD_A_NS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_A_NS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%OLD_A_NS = SrcElementData%OLD_A_NS
   else if (allocated(DstElementData%OLD_A_NS)) then
      deallocate(DstElementData%OLD_A_NS)
   end if
   if (allocated(SrcElementData%OLD_AP_NS)) then
      LB(1:2) = lbound(SrcElementData%OLD_AP_NS)
      UB(1:2) = ubound(SrcElementData%OLD_AP_NS)
      if (.not. allocated(DstElementData%OLD_AP_NS)) then
         allocate(DstElementData%OLD_AP_NS(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_AP_NS.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%OLD_AP_NS = SrcElementData%OLD_AP_NS
   else if (allocated(DstElementData%OLD_AP_NS)) then
      deallocate(DstElementData%OLD_AP_NS)
   end if
   if (allocated(SrcElementData%PITNOW)) then
      LB(1:2) = lbound(SrcElementData%PITNOW)
      UB(1:2) = ubound(SrcElementData%PITNOW)
      if (.not. allocated(DstElementData%PITNOW)) then
         allocate(DstElementData%PITNOW(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%PITNOW.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementData%PITNOW = SrcElementData%PITNOW
   else if (allocated(DstElementData%PITNOW)) then
      deallocate(DstElementData%PITNOW)
   end if
end subroutine

subroutine AD14_DestroyElement(ElementData, ErrStat, ErrMsg)
   type(Element), intent(inout) :: ElementData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElement'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElementData%A)) then
      deallocate(ElementData%A)
   end if
   if (allocated(ElementData%AP)) then
      deallocate(ElementData%AP)
   end if
   if (allocated(ElementData%ALPHA)) then
      deallocate(ElementData%ALPHA)
   end if
   if (allocated(ElementData%W2)) then
      deallocate(ElementData%W2)
   end if
   if (allocated(ElementData%OLD_A_NS)) then
      deallocate(ElementData%OLD_A_NS)
   end if
   if (allocated(ElementData%OLD_AP_NS)) then
      deallocate(ElementData%OLD_AP_NS)
   end if
   if (allocated(ElementData%PITNOW)) then
      deallocate(ElementData%PITNOW)
   end if
end subroutine

subroutine AD14_PackElement(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Element), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElement'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%A))
   if (allocated(InData%A)) then
      call RegPackBounds(Buf, 2, lbound(InData%A), ubound(InData%A))
      call RegPack(Buf, InData%A)
   end if
   call RegPack(Buf, allocated(InData%AP))
   if (allocated(InData%AP)) then
      call RegPackBounds(Buf, 2, lbound(InData%AP), ubound(InData%AP))
      call RegPack(Buf, InData%AP)
   end if
   call RegPack(Buf, allocated(InData%ALPHA))
   if (allocated(InData%ALPHA)) then
      call RegPackBounds(Buf, 2, lbound(InData%ALPHA), ubound(InData%ALPHA))
      call RegPack(Buf, InData%ALPHA)
   end if
   call RegPack(Buf, allocated(InData%W2))
   if (allocated(InData%W2)) then
      call RegPackBounds(Buf, 2, lbound(InData%W2), ubound(InData%W2))
      call RegPack(Buf, InData%W2)
   end if
   call RegPack(Buf, allocated(InData%OLD_A_NS))
   if (allocated(InData%OLD_A_NS)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLD_A_NS), ubound(InData%OLD_A_NS))
      call RegPack(Buf, InData%OLD_A_NS)
   end if
   call RegPack(Buf, allocated(InData%OLD_AP_NS))
   if (allocated(InData%OLD_AP_NS)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLD_AP_NS), ubound(InData%OLD_AP_NS))
      call RegPack(Buf, InData%OLD_AP_NS)
   end if
   call RegPack(Buf, allocated(InData%PITNOW))
   if (allocated(InData%PITNOW)) then
      call RegPackBounds(Buf, 2, lbound(InData%PITNOW), ubound(InData%PITNOW))
      call RegPack(Buf, InData%PITNOW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElement(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Element), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElement'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%A)) deallocate(OutData%A)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%A(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%A.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%A)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AP)) deallocate(OutData%AP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ALPHA)) deallocate(OutData%ALPHA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ALPHA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALPHA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ALPHA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%W2)) deallocate(OutData%W2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W2(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLD_A_NS)) deallocate(OutData%OLD_A_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLD_A_NS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_A_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLD_A_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%OLD_AP_NS)) deallocate(OutData%OLD_AP_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLD_AP_NS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_AP_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLD_AP_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%PITNOW)) deallocate(OutData%PITNOW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PITNOW(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PITNOW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PITNOW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD14_CopyElementParms(SrcElementParmsData, DstElementParmsData, CtrlCode, ErrStat, ErrMsg)
   type(ElementParms), intent(in) :: SrcElementParmsData
   type(ElementParms), intent(inout) :: DstElementParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElementParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstElementParmsData%NELM = SrcElementParmsData%NELM
   if (allocated(SrcElementParmsData%TWIST)) then
      LB(1:1) = lbound(SrcElementParmsData%TWIST)
      UB(1:1) = ubound(SrcElementParmsData%TWIST)
      if (.not. allocated(DstElementParmsData%TWIST)) then
         allocate(DstElementParmsData%TWIST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TWIST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%TWIST = SrcElementParmsData%TWIST
   else if (allocated(DstElementParmsData%TWIST)) then
      deallocate(DstElementParmsData%TWIST)
   end if
   if (allocated(SrcElementParmsData%RELM)) then
      LB(1:1) = lbound(SrcElementParmsData%RELM)
      UB(1:1) = ubound(SrcElementParmsData%RELM)
      if (.not. allocated(DstElementParmsData%RELM)) then
         allocate(DstElementParmsData%RELM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%RELM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%RELM = SrcElementParmsData%RELM
   else if (allocated(DstElementParmsData%RELM)) then
      deallocate(DstElementParmsData%RELM)
   end if
   if (allocated(SrcElementParmsData%HLCNST)) then
      LB(1:1) = lbound(SrcElementParmsData%HLCNST)
      UB(1:1) = ubound(SrcElementParmsData%HLCNST)
      if (.not. allocated(DstElementParmsData%HLCNST)) then
         allocate(DstElementParmsData%HLCNST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%HLCNST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%HLCNST = SrcElementParmsData%HLCNST
   else if (allocated(DstElementParmsData%HLCNST)) then
      deallocate(DstElementParmsData%HLCNST)
   end if
   if (allocated(SrcElementParmsData%TLCNST)) then
      LB(1:1) = lbound(SrcElementParmsData%TLCNST)
      UB(1:1) = ubound(SrcElementParmsData%TLCNST)
      if (.not. allocated(DstElementParmsData%TLCNST)) then
         allocate(DstElementParmsData%TLCNST(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TLCNST.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElementParmsData%TLCNST = SrcElementParmsData%TLCNST
   else if (allocated(DstElementParmsData%TLCNST)) then
      deallocate(DstElementParmsData%TLCNST)
   end if
end subroutine

subroutine AD14_DestroyElementParms(ElementParmsData, ErrStat, ErrMsg)
   type(ElementParms), intent(inout) :: ElementParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElementParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElementParmsData%TWIST)) then
      deallocate(ElementParmsData%TWIST)
   end if
   if (allocated(ElementParmsData%RELM)) then
      deallocate(ElementParmsData%RELM)
   end if
   if (allocated(ElementParmsData%HLCNST)) then
      deallocate(ElementParmsData%HLCNST)
   end if
   if (allocated(ElementParmsData%TLCNST)) then
      deallocate(ElementParmsData%TLCNST)
   end if
end subroutine

subroutine AD14_PackElementParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElementParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElementParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%NELM)
   call RegPack(Buf, allocated(InData%TWIST))
   if (allocated(InData%TWIST)) then
      call RegPackBounds(Buf, 1, lbound(InData%TWIST), ubound(InData%TWIST))
      call RegPack(Buf, InData%TWIST)
   end if
   call RegPack(Buf, allocated(InData%RELM))
   if (allocated(InData%RELM)) then
      call RegPackBounds(Buf, 1, lbound(InData%RELM), ubound(InData%RELM))
      call RegPack(Buf, InData%RELM)
   end if
   call RegPack(Buf, allocated(InData%HLCNST))
   if (allocated(InData%HLCNST)) then
      call RegPackBounds(Buf, 1, lbound(InData%HLCNST), ubound(InData%HLCNST))
      call RegPack(Buf, InData%HLCNST)
   end if
   call RegPack(Buf, allocated(InData%TLCNST))
   if (allocated(InData%TLCNST)) then
      call RegPackBounds(Buf, 1, lbound(InData%TLCNST), ubound(InData%TLCNST))
      call RegPack(Buf, InData%TLCNST)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElementParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElementParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElementParms'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%NELM)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%TWIST)) deallocate(OutData%TWIST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TWIST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TWIST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TWIST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%RELM)) deallocate(OutData%RELM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RELM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RELM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RELM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%HLCNST)) deallocate(OutData%HLCNST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HLCNST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HLCNST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HLCNST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TLCNST)) deallocate(OutData%TLCNST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TLCNST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TLCNST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TLCNST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD14_CopyElOutParms(SrcElOutParmsData, DstElOutParmsData, CtrlCode, ErrStat, ErrMsg)
   type(ElOutParms), intent(in) :: SrcElOutParmsData
   type(ElOutParms), intent(inout) :: DstElOutParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyElOutParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcElOutParmsData%AAA)) then
      LB(1:1) = lbound(SrcElOutParmsData%AAA)
      UB(1:1) = ubound(SrcElOutParmsData%AAA)
      if (.not. allocated(DstElOutParmsData%AAA)) then
         allocate(DstElOutParmsData%AAA(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%AAA = SrcElOutParmsData%AAA
   else if (allocated(DstElOutParmsData%AAA)) then
      deallocate(DstElOutParmsData%AAA)
   end if
   if (allocated(SrcElOutParmsData%AAP)) then
      LB(1:1) = lbound(SrcElOutParmsData%AAP)
      UB(1:1) = ubound(SrcElOutParmsData%AAP)
      if (.not. allocated(DstElOutParmsData%AAP)) then
         allocate(DstElOutParmsData%AAP(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%AAP = SrcElOutParmsData%AAP
   else if (allocated(DstElOutParmsData%AAP)) then
      deallocate(DstElOutParmsData%AAP)
   end if
   if (allocated(SrcElOutParmsData%ALF)) then
      LB(1:1) = lbound(SrcElOutParmsData%ALF)
      UB(1:1) = ubound(SrcElOutParmsData%ALF)
      if (.not. allocated(DstElOutParmsData%ALF)) then
         allocate(DstElOutParmsData%ALF(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ALF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ALF = SrcElOutParmsData%ALF
   else if (allocated(DstElOutParmsData%ALF)) then
      deallocate(DstElOutParmsData%ALF)
   end if
   if (allocated(SrcElOutParmsData%CDD)) then
      LB(1:1) = lbound(SrcElOutParmsData%CDD)
      UB(1:1) = ubound(SrcElOutParmsData%CDD)
      if (.not. allocated(DstElOutParmsData%CDD)) then
         allocate(DstElOutParmsData%CDD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CDD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CDD = SrcElOutParmsData%CDD
   else if (allocated(DstElOutParmsData%CDD)) then
      deallocate(DstElOutParmsData%CDD)
   end if
   if (allocated(SrcElOutParmsData%CLL)) then
      LB(1:1) = lbound(SrcElOutParmsData%CLL)
      UB(1:1) = ubound(SrcElOutParmsData%CLL)
      if (.not. allocated(DstElOutParmsData%CLL)) then
         allocate(DstElOutParmsData%CLL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CLL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CLL = SrcElOutParmsData%CLL
   else if (allocated(DstElOutParmsData%CLL)) then
      deallocate(DstElOutParmsData%CLL)
   end if
   if (allocated(SrcElOutParmsData%CMM)) then
      LB(1:1) = lbound(SrcElOutParmsData%CMM)
      UB(1:1) = ubound(SrcElOutParmsData%CMM)
      if (.not. allocated(DstElOutParmsData%CMM)) then
         allocate(DstElOutParmsData%CMM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CMM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CMM = SrcElOutParmsData%CMM
   else if (allocated(DstElOutParmsData%CMM)) then
      deallocate(DstElOutParmsData%CMM)
   end if
   if (allocated(SrcElOutParmsData%CNN)) then
      LB(1:1) = lbound(SrcElOutParmsData%CNN)
      UB(1:1) = ubound(SrcElOutParmsData%CNN)
      if (.not. allocated(DstElOutParmsData%CNN)) then
         allocate(DstElOutParmsData%CNN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CNN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CNN = SrcElOutParmsData%CNN
   else if (allocated(DstElOutParmsData%CNN)) then
      deallocate(DstElOutParmsData%CNN)
   end if
   if (allocated(SrcElOutParmsData%CTT)) then
      LB(1:1) = lbound(SrcElOutParmsData%CTT)
      UB(1:1) = ubound(SrcElOutParmsData%CTT)
      if (.not. allocated(DstElOutParmsData%CTT)) then
         allocate(DstElOutParmsData%CTT(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CTT.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%CTT = SrcElOutParmsData%CTT
   else if (allocated(DstElOutParmsData%CTT)) then
      deallocate(DstElOutParmsData%CTT)
   end if
   if (allocated(SrcElOutParmsData%DFNSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%DFNSAV)
      UB(1:1) = ubound(SrcElOutParmsData%DFNSAV)
      if (.not. allocated(DstElOutParmsData%DFNSAV)) then
         allocate(DstElOutParmsData%DFNSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFNSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DFNSAV = SrcElOutParmsData%DFNSAV
   else if (allocated(DstElOutParmsData%DFNSAV)) then
      deallocate(DstElOutParmsData%DFNSAV)
   end if
   if (allocated(SrcElOutParmsData%DFTSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%DFTSAV)
      UB(1:1) = ubound(SrcElOutParmsData%DFTSAV)
      if (.not. allocated(DstElOutParmsData%DFTSAV)) then
         allocate(DstElOutParmsData%DFTSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFTSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DFTSAV = SrcElOutParmsData%DFTSAV
   else if (allocated(DstElOutParmsData%DFTSAV)) then
      deallocate(DstElOutParmsData%DFTSAV)
   end if
   if (allocated(SrcElOutParmsData%DynPres)) then
      LB(1:1) = lbound(SrcElOutParmsData%DynPres)
      UB(1:1) = ubound(SrcElOutParmsData%DynPres)
      if (.not. allocated(DstElOutParmsData%DynPres)) then
         allocate(DstElOutParmsData%DynPres(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DynPres.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%DynPres = SrcElOutParmsData%DynPres
   else if (allocated(DstElOutParmsData%DynPres)) then
      deallocate(DstElOutParmsData%DynPres)
   end if
   if (allocated(SrcElOutParmsData%PMM)) then
      LB(1:1) = lbound(SrcElOutParmsData%PMM)
      UB(1:1) = ubound(SrcElOutParmsData%PMM)
      if (.not. allocated(DstElOutParmsData%PMM)) then
         allocate(DstElOutParmsData%PMM(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PMM.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%PMM = SrcElOutParmsData%PMM
   else if (allocated(DstElOutParmsData%PMM)) then
      deallocate(DstElOutParmsData%PMM)
   end if
   if (allocated(SrcElOutParmsData%PITSAV)) then
      LB(1:1) = lbound(SrcElOutParmsData%PITSAV)
      UB(1:1) = ubound(SrcElOutParmsData%PITSAV)
      if (.not. allocated(DstElOutParmsData%PITSAV)) then
         allocate(DstElOutParmsData%PITSAV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PITSAV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%PITSAV = SrcElOutParmsData%PITSAV
   else if (allocated(DstElOutParmsData%PITSAV)) then
      deallocate(DstElOutParmsData%PITSAV)
   end if
   if (allocated(SrcElOutParmsData%ReyNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%ReyNum)
      UB(1:1) = ubound(SrcElOutParmsData%ReyNum)
      if (.not. allocated(DstElOutParmsData%ReyNum)) then
         allocate(DstElOutParmsData%ReyNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ReyNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ReyNum = SrcElOutParmsData%ReyNum
   else if (allocated(DstElOutParmsData%ReyNum)) then
      deallocate(DstElOutParmsData%ReyNum)
   end if
   if (allocated(SrcElOutParmsData%Gamma)) then
      LB(1:1) = lbound(SrcElOutParmsData%Gamma)
      UB(1:1) = ubound(SrcElOutParmsData%Gamma)
      if (.not. allocated(DstElOutParmsData%Gamma)) then
         allocate(DstElOutParmsData%Gamma(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%Gamma.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%Gamma = SrcElOutParmsData%Gamma
   else if (allocated(DstElOutParmsData%Gamma)) then
      deallocate(DstElOutParmsData%Gamma)
   end if
   if (allocated(SrcElOutParmsData%SaveVX)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVX)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVX)
      if (.not. allocated(DstElOutParmsData%SaveVX)) then
         allocate(DstElOutParmsData%SaveVX(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVX = SrcElOutParmsData%SaveVX
   else if (allocated(DstElOutParmsData%SaveVX)) then
      deallocate(DstElOutParmsData%SaveVX)
   end if
   if (allocated(SrcElOutParmsData%SaveVY)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVY)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVY)
      if (.not. allocated(DstElOutParmsData%SaveVY)) then
         allocate(DstElOutParmsData%SaveVY(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVY.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVY = SrcElOutParmsData%SaveVY
   else if (allocated(DstElOutParmsData%SaveVY)) then
      deallocate(DstElOutParmsData%SaveVY)
   end if
   if (allocated(SrcElOutParmsData%SaveVZ)) then
      LB(1:2) = lbound(SrcElOutParmsData%SaveVZ)
      UB(1:2) = ubound(SrcElOutParmsData%SaveVZ)
      if (.not. allocated(DstElOutParmsData%SaveVZ)) then
         allocate(DstElOutParmsData%SaveVZ(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVZ.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%SaveVZ = SrcElOutParmsData%SaveVZ
   else if (allocated(DstElOutParmsData%SaveVZ)) then
      deallocate(DstElOutParmsData%SaveVZ)
   end if
   DstElOutParmsData%VXSAV = SrcElOutParmsData%VXSAV
   DstElOutParmsData%VYSAV = SrcElOutParmsData%VYSAV
   DstElOutParmsData%VZSAV = SrcElOutParmsData%VZSAV
   DstElOutParmsData%NumWndElOut = SrcElOutParmsData%NumWndElOut
   if (allocated(SrcElOutParmsData%WndElPrList)) then
      LB(1:1) = lbound(SrcElOutParmsData%WndElPrList)
      UB(1:1) = ubound(SrcElOutParmsData%WndElPrList)
      if (.not. allocated(DstElOutParmsData%WndElPrList)) then
         allocate(DstElOutParmsData%WndElPrList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%WndElPrList = SrcElOutParmsData%WndElPrList
   else if (allocated(DstElOutParmsData%WndElPrList)) then
      deallocate(DstElOutParmsData%WndElPrList)
   end if
   if (allocated(SrcElOutParmsData%WndElPrNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%WndElPrNum)
      UB(1:1) = ubound(SrcElOutParmsData%WndElPrNum)
      if (.not. allocated(DstElOutParmsData%WndElPrNum)) then
         allocate(DstElOutParmsData%WndElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%WndElPrNum = SrcElOutParmsData%WndElPrNum
   else if (allocated(DstElOutParmsData%WndElPrNum)) then
      deallocate(DstElOutParmsData%WndElPrNum)
   end if
   if (allocated(SrcElOutParmsData%ElPrList)) then
      LB(1:1) = lbound(SrcElOutParmsData%ElPrList)
      UB(1:1) = ubound(SrcElOutParmsData%ElPrList)
      if (.not. allocated(DstElOutParmsData%ElPrList)) then
         allocate(DstElOutParmsData%ElPrList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ElPrList = SrcElOutParmsData%ElPrList
   else if (allocated(DstElOutParmsData%ElPrList)) then
      deallocate(DstElOutParmsData%ElPrList)
   end if
   if (allocated(SrcElOutParmsData%ElPrNum)) then
      LB(1:1) = lbound(SrcElOutParmsData%ElPrNum)
      UB(1:1) = ubound(SrcElOutParmsData%ElPrNum)
      if (.not. allocated(DstElOutParmsData%ElPrNum)) then
         allocate(DstElOutParmsData%ElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElOutParmsData%ElPrNum = SrcElOutParmsData%ElPrNum
   else if (allocated(DstElOutParmsData%ElPrNum)) then
      deallocate(DstElOutParmsData%ElPrNum)
   end if
   DstElOutParmsData%NumElOut = SrcElOutParmsData%NumElOut
end subroutine

subroutine AD14_DestroyElOutParms(ElOutParmsData, ErrStat, ErrMsg)
   type(ElOutParms), intent(inout) :: ElOutParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyElOutParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElOutParmsData%AAA)) then
      deallocate(ElOutParmsData%AAA)
   end if
   if (allocated(ElOutParmsData%AAP)) then
      deallocate(ElOutParmsData%AAP)
   end if
   if (allocated(ElOutParmsData%ALF)) then
      deallocate(ElOutParmsData%ALF)
   end if
   if (allocated(ElOutParmsData%CDD)) then
      deallocate(ElOutParmsData%CDD)
   end if
   if (allocated(ElOutParmsData%CLL)) then
      deallocate(ElOutParmsData%CLL)
   end if
   if (allocated(ElOutParmsData%CMM)) then
      deallocate(ElOutParmsData%CMM)
   end if
   if (allocated(ElOutParmsData%CNN)) then
      deallocate(ElOutParmsData%CNN)
   end if
   if (allocated(ElOutParmsData%CTT)) then
      deallocate(ElOutParmsData%CTT)
   end if
   if (allocated(ElOutParmsData%DFNSAV)) then
      deallocate(ElOutParmsData%DFNSAV)
   end if
   if (allocated(ElOutParmsData%DFTSAV)) then
      deallocate(ElOutParmsData%DFTSAV)
   end if
   if (allocated(ElOutParmsData%DynPres)) then
      deallocate(ElOutParmsData%DynPres)
   end if
   if (allocated(ElOutParmsData%PMM)) then
      deallocate(ElOutParmsData%PMM)
   end if
   if (allocated(ElOutParmsData%PITSAV)) then
      deallocate(ElOutParmsData%PITSAV)
   end if
   if (allocated(ElOutParmsData%ReyNum)) then
      deallocate(ElOutParmsData%ReyNum)
   end if
   if (allocated(ElOutParmsData%Gamma)) then
      deallocate(ElOutParmsData%Gamma)
   end if
   if (allocated(ElOutParmsData%SaveVX)) then
      deallocate(ElOutParmsData%SaveVX)
   end if
   if (allocated(ElOutParmsData%SaveVY)) then
      deallocate(ElOutParmsData%SaveVY)
   end if
   if (allocated(ElOutParmsData%SaveVZ)) then
      deallocate(ElOutParmsData%SaveVZ)
   end if
   if (allocated(ElOutParmsData%WndElPrList)) then
      deallocate(ElOutParmsData%WndElPrList)
   end if
   if (allocated(ElOutParmsData%WndElPrNum)) then
      deallocate(ElOutParmsData%WndElPrNum)
   end if
   if (allocated(ElOutParmsData%ElPrList)) then
      deallocate(ElOutParmsData%ElPrList)
   end if
   if (allocated(ElOutParmsData%ElPrNum)) then
      deallocate(ElOutParmsData%ElPrNum)
   end if
end subroutine

subroutine AD14_PackElOutParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElOutParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElOutParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%AAA))
   if (allocated(InData%AAA)) then
      call RegPackBounds(Buf, 1, lbound(InData%AAA), ubound(InData%AAA))
      call RegPack(Buf, InData%AAA)
   end if
   call RegPack(Buf, allocated(InData%AAP))
   if (allocated(InData%AAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%AAP), ubound(InData%AAP))
      call RegPack(Buf, InData%AAP)
   end if
   call RegPack(Buf, allocated(InData%ALF))
   if (allocated(InData%ALF)) then
      call RegPackBounds(Buf, 1, lbound(InData%ALF), ubound(InData%ALF))
      call RegPack(Buf, InData%ALF)
   end if
   call RegPack(Buf, allocated(InData%CDD))
   if (allocated(InData%CDD)) then
      call RegPackBounds(Buf, 1, lbound(InData%CDD), ubound(InData%CDD))
      call RegPack(Buf, InData%CDD)
   end if
   call RegPack(Buf, allocated(InData%CLL))
   if (allocated(InData%CLL)) then
      call RegPackBounds(Buf, 1, lbound(InData%CLL), ubound(InData%CLL))
      call RegPack(Buf, InData%CLL)
   end if
   call RegPack(Buf, allocated(InData%CMM))
   if (allocated(InData%CMM)) then
      call RegPackBounds(Buf, 1, lbound(InData%CMM), ubound(InData%CMM))
      call RegPack(Buf, InData%CMM)
   end if
   call RegPack(Buf, allocated(InData%CNN))
   if (allocated(InData%CNN)) then
      call RegPackBounds(Buf, 1, lbound(InData%CNN), ubound(InData%CNN))
      call RegPack(Buf, InData%CNN)
   end if
   call RegPack(Buf, allocated(InData%CTT))
   if (allocated(InData%CTT)) then
      call RegPackBounds(Buf, 1, lbound(InData%CTT), ubound(InData%CTT))
      call RegPack(Buf, InData%CTT)
   end if
   call RegPack(Buf, allocated(InData%DFNSAV))
   if (allocated(InData%DFNSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%DFNSAV), ubound(InData%DFNSAV))
      call RegPack(Buf, InData%DFNSAV)
   end if
   call RegPack(Buf, allocated(InData%DFTSAV))
   if (allocated(InData%DFTSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%DFTSAV), ubound(InData%DFTSAV))
      call RegPack(Buf, InData%DFTSAV)
   end if
   call RegPack(Buf, allocated(InData%DynPres))
   if (allocated(InData%DynPres)) then
      call RegPackBounds(Buf, 1, lbound(InData%DynPres), ubound(InData%DynPres))
      call RegPack(Buf, InData%DynPres)
   end if
   call RegPack(Buf, allocated(InData%PMM))
   if (allocated(InData%PMM)) then
      call RegPackBounds(Buf, 1, lbound(InData%PMM), ubound(InData%PMM))
      call RegPack(Buf, InData%PMM)
   end if
   call RegPack(Buf, allocated(InData%PITSAV))
   if (allocated(InData%PITSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%PITSAV), ubound(InData%PITSAV))
      call RegPack(Buf, InData%PITSAV)
   end if
   call RegPack(Buf, allocated(InData%ReyNum))
   if (allocated(InData%ReyNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ReyNum), ubound(InData%ReyNum))
      call RegPack(Buf, InData%ReyNum)
   end if
   call RegPack(Buf, allocated(InData%Gamma))
   if (allocated(InData%Gamma)) then
      call RegPackBounds(Buf, 1, lbound(InData%Gamma), ubound(InData%Gamma))
      call RegPack(Buf, InData%Gamma)
   end if
   call RegPack(Buf, allocated(InData%SaveVX))
   if (allocated(InData%SaveVX)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVX), ubound(InData%SaveVX))
      call RegPack(Buf, InData%SaveVX)
   end if
   call RegPack(Buf, allocated(InData%SaveVY))
   if (allocated(InData%SaveVY)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVY), ubound(InData%SaveVY))
      call RegPack(Buf, InData%SaveVY)
   end if
   call RegPack(Buf, allocated(InData%SaveVZ))
   if (allocated(InData%SaveVZ)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVZ), ubound(InData%SaveVZ))
      call RegPack(Buf, InData%SaveVZ)
   end if
   call RegPack(Buf, InData%VXSAV)
   call RegPack(Buf, InData%VYSAV)
   call RegPack(Buf, InData%VZSAV)
   call RegPack(Buf, InData%NumWndElOut)
   call RegPack(Buf, allocated(InData%WndElPrList))
   if (allocated(InData%WndElPrList)) then
      call RegPackBounds(Buf, 1, lbound(InData%WndElPrList), ubound(InData%WndElPrList))
      call RegPack(Buf, InData%WndElPrList)
   end if
   call RegPack(Buf, allocated(InData%WndElPrNum))
   if (allocated(InData%WndElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%WndElPrNum), ubound(InData%WndElPrNum))
      call RegPack(Buf, InData%WndElPrNum)
   end if
   call RegPack(Buf, allocated(InData%ElPrList))
   if (allocated(InData%ElPrList)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrList), ubound(InData%ElPrList))
      call RegPack(Buf, InData%ElPrList)
   end if
   call RegPack(Buf, allocated(InData%ElPrNum))
   if (allocated(InData%ElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrNum), ubound(InData%ElPrNum))
      call RegPack(Buf, InData%ElPrNum)
   end if
   call RegPack(Buf, InData%NumElOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElOutParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElOutParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElOutParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%AAA)) deallocate(OutData%AAA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AAA(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AAA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AAP)) deallocate(OutData%AAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AAP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ALF)) deallocate(OutData%ALF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ALF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ALF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CDD)) deallocate(OutData%CDD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CDD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CDD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CLL)) deallocate(OutData%CLL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CLL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CLL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CLL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CMM)) deallocate(OutData%CMM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CMM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CMM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CNN)) deallocate(OutData%CNN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CTT)) deallocate(OutData%CTT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CTT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CTT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CTT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DFNSAV)) deallocate(OutData%DFNSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFNSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFNSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFNSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DFTSAV)) deallocate(OutData%DFTSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFTSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFTSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFTSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%DynPres)) deallocate(OutData%DynPres)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DynPres(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DynPres.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DynPres)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%PMM)) deallocate(OutData%PMM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PMM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PMM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PMM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%PITSAV)) deallocate(OutData%PITSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PITSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PITSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PITSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ReyNum)) deallocate(OutData%ReyNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ReyNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ReyNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ReyNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Gamma)) deallocate(OutData%Gamma)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%SaveVX)) deallocate(OutData%SaveVX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVX(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%SaveVY)) deallocate(OutData%SaveVY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVY(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%SaveVZ)) deallocate(OutData%SaveVZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVZ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%VXSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VYSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VZSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumWndElOut)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WndElPrList)) deallocate(OutData%WndElPrList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WndElPrList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WndElPrList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WndElPrNum)) deallocate(OutData%WndElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WndElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WndElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ElPrList)) deallocate(OutData%ElPrList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ElPrNum)) deallocate(OutData%ElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NumElOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyInducedVel(SrcInducedVelData, DstInducedVelData, CtrlCode, ErrStat, ErrMsg)
   type(InducedVel), intent(in) :: SrcInducedVelData
   type(InducedVel), intent(inout) :: DstInducedVelData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyInducedVel'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInducedVelData%SumInFl = SrcInducedVelData%SumInFl
end subroutine

subroutine AD14_DestroyInducedVel(InducedVelData, ErrStat, ErrMsg)
   type(InducedVel), intent(inout) :: InducedVelData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyInducedVel'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackInducedVel(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(InducedVel), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVel'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%SumInFl)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVel(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(InducedVel), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVel'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%SumInFl)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyInducedVelParms(SrcInducedVelParmsData, DstInducedVelParmsData, CtrlCode, ErrStat, ErrMsg)
   type(InducedVelParms), intent(in) :: SrcInducedVelParmsData
   type(InducedVelParms), intent(inout) :: DstInducedVelParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyInducedVelParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInducedVelParmsData%AToler = SrcInducedVelParmsData%AToler
   DstInducedVelParmsData%EqAIDmult = SrcInducedVelParmsData%EqAIDmult
   DstInducedVelParmsData%EquilDA = SrcInducedVelParmsData%EquilDA
   DstInducedVelParmsData%EquilDT = SrcInducedVelParmsData%EquilDT
   DstInducedVelParmsData%TLoss = SrcInducedVelParmsData%TLoss
   DstInducedVelParmsData%GTech = SrcInducedVelParmsData%GTech
   DstInducedVelParmsData%HLoss = SrcInducedVelParmsData%HLoss
end subroutine

subroutine AD14_DestroyInducedVelParms(InducedVelParmsData, ErrStat, ErrMsg)
   type(InducedVelParms), intent(inout) :: InducedVelParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyInducedVelParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackInducedVelParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(InducedVelParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVelParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%AToler)
   call RegPack(Buf, InData%EqAIDmult)
   call RegPack(Buf, InData%EquilDA)
   call RegPack(Buf, InData%EquilDT)
   call RegPack(Buf, InData%TLoss)
   call RegPack(Buf, InData%GTech)
   call RegPack(Buf, InData%HLoss)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVelParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(InducedVelParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVelParms'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%AToler)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%EqAIDmult)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%EquilDA)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%EquilDT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%GTech)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HLoss)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyRotor(SrcRotorData, DstRotorData, CtrlCode, ErrStat, ErrMsg)
   type(Rotor), intent(in) :: SrcRotorData
   type(Rotor), intent(inout) :: DstRotorData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyRotor'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotorData%AVGINFL = SrcRotorData%AVGINFL
   DstRotorData%CTILT = SrcRotorData%CTILT
   DstRotorData%CYaw = SrcRotorData%CYaw
   DstRotorData%REVS = SrcRotorData%REVS
   DstRotorData%STILT = SrcRotorData%STILT
   DstRotorData%SYaw = SrcRotorData%SYaw
   DstRotorData%TILT = SrcRotorData%TILT
   DstRotorData%YawAng = SrcRotorData%YawAng
   DstRotorData%YawVEL = SrcRotorData%YawVEL
end subroutine

subroutine AD14_DestroyRotor(RotorData, ErrStat, ErrMsg)
   type(Rotor), intent(inout) :: RotorData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyRotor'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackRotor(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Rotor), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotor'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%AVGINFL)
   call RegPack(Buf, InData%CTILT)
   call RegPack(Buf, InData%CYaw)
   call RegPack(Buf, InData%REVS)
   call RegPack(Buf, InData%STILT)
   call RegPack(Buf, InData%SYaw)
   call RegPack(Buf, InData%TILT)
   call RegPack(Buf, InData%YawAng)
   call RegPack(Buf, InData%YawVEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotor(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Rotor), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotor'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%AVGINFL)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CTILT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%REVS)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%STILT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TILT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%YawAng)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%YawVEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyRotorParms(SrcRotorParmsData, DstRotorParmsData, CtrlCode, ErrStat, ErrMsg)
   type(RotorParms), intent(in) :: SrcRotorParmsData
   type(RotorParms), intent(inout) :: DstRotorParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyRotorParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotorParmsData%HH = SrcRotorParmsData%HH
end subroutine

subroutine AD14_DestroyRotorParms(RotorParmsData, ErrStat, ErrMsg)
   type(RotorParms), intent(inout) :: RotorParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyRotorParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackRotorParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotorParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotorParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%HH)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotorParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotorParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotorParms'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%HH)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyTwrPropsParms(SrcTwrPropsParmsData, DstTwrPropsParmsData, CtrlCode, ErrStat, ErrMsg)
   type(TwrPropsParms), intent(in) :: SrcTwrPropsParmsData
   type(TwrPropsParms), intent(inout) :: DstTwrPropsParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD14_CopyTwrPropsParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcTwrPropsParmsData%TwrHtFr)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrHtFr)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrHtFr)
      if (.not. allocated(DstTwrPropsParmsData%TwrHtFr)) then
         allocate(DstTwrPropsParmsData%TwrHtFr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrHtFr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrHtFr = SrcTwrPropsParmsData%TwrHtFr
   else if (allocated(DstTwrPropsParmsData%TwrHtFr)) then
      deallocate(DstTwrPropsParmsData%TwrHtFr)
   end if
   if (allocated(SrcTwrPropsParmsData%TwrWid)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrWid)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrWid)
      if (.not. allocated(DstTwrPropsParmsData%TwrWid)) then
         allocate(DstTwrPropsParmsData%TwrWid(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrWid.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrWid = SrcTwrPropsParmsData%TwrWid
   else if (allocated(DstTwrPropsParmsData%TwrWid)) then
      deallocate(DstTwrPropsParmsData%TwrWid)
   end if
   if (allocated(SrcTwrPropsParmsData%TwrCD)) then
      LB(1:2) = lbound(SrcTwrPropsParmsData%TwrCD)
      UB(1:2) = ubound(SrcTwrPropsParmsData%TwrCD)
      if (.not. allocated(DstTwrPropsParmsData%TwrCD)) then
         allocate(DstTwrPropsParmsData%TwrCD(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrCD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrCD = SrcTwrPropsParmsData%TwrCD
   else if (allocated(DstTwrPropsParmsData%TwrCD)) then
      deallocate(DstTwrPropsParmsData%TwrCD)
   end if
   if (allocated(SrcTwrPropsParmsData%TwrRe)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrRe)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrRe)
      if (.not. allocated(DstTwrPropsParmsData%TwrRe)) then
         allocate(DstTwrPropsParmsData%TwrRe(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrRe.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrRe = SrcTwrPropsParmsData%TwrRe
   else if (allocated(DstTwrPropsParmsData%TwrRe)) then
      deallocate(DstTwrPropsParmsData%TwrRe)
   end if
   DstTwrPropsParmsData%VTwr = SrcTwrPropsParmsData%VTwr
   DstTwrPropsParmsData%Tower_Wake_Constant = SrcTwrPropsParmsData%Tower_Wake_Constant
   if (allocated(SrcTwrPropsParmsData%NTwrCDCol)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%NTwrCDCol)
      UB(1:1) = ubound(SrcTwrPropsParmsData%NTwrCDCol)
      if (.not. allocated(DstTwrPropsParmsData%NTwrCDCol)) then
         allocate(DstTwrPropsParmsData%NTwrCDCol(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%NTwrCDCol.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%NTwrCDCol = SrcTwrPropsParmsData%NTwrCDCol
   else if (allocated(DstTwrPropsParmsData%NTwrCDCol)) then
      deallocate(DstTwrPropsParmsData%NTwrCDCol)
   end if
   DstTwrPropsParmsData%NTwrHT = SrcTwrPropsParmsData%NTwrHT
   DstTwrPropsParmsData%NTwrRe = SrcTwrPropsParmsData%NTwrRe
   DstTwrPropsParmsData%NTwrCD = SrcTwrPropsParmsData%NTwrCD
   DstTwrPropsParmsData%TwrPotent = SrcTwrPropsParmsData%TwrPotent
   DstTwrPropsParmsData%TwrShadow = SrcTwrPropsParmsData%TwrShadow
   DstTwrPropsParmsData%ShadHWid = SrcTwrPropsParmsData%ShadHWid
   DstTwrPropsParmsData%TShadC1 = SrcTwrPropsParmsData%TShadC1
   DstTwrPropsParmsData%TShadC2 = SrcTwrPropsParmsData%TShadC2
   DstTwrPropsParmsData%TwrShad = SrcTwrPropsParmsData%TwrShad
   DstTwrPropsParmsData%PJM_Version = SrcTwrPropsParmsData%PJM_Version
   DstTwrPropsParmsData%TwrFile = SrcTwrPropsParmsData%TwrFile
   DstTwrPropsParmsData%T_Shad_Refpt = SrcTwrPropsParmsData%T_Shad_Refpt
   DstTwrPropsParmsData%CalcTwrAero = SrcTwrPropsParmsData%CalcTwrAero
   DstTwrPropsParmsData%NumTwrNodes = SrcTwrPropsParmsData%NumTwrNodes
   if (allocated(SrcTwrPropsParmsData%TwrNodeWidth)) then
      LB(1:1) = lbound(SrcTwrPropsParmsData%TwrNodeWidth)
      UB(1:1) = ubound(SrcTwrPropsParmsData%TwrNodeWidth)
      if (.not. allocated(DstTwrPropsParmsData%TwrNodeWidth)) then
         allocate(DstTwrPropsParmsData%TwrNodeWidth(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrNodeWidth.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTwrPropsParmsData%TwrNodeWidth = SrcTwrPropsParmsData%TwrNodeWidth
   else if (allocated(DstTwrPropsParmsData%TwrNodeWidth)) then
      deallocate(DstTwrPropsParmsData%TwrNodeWidth)
   end if
end subroutine

subroutine AD14_DestroyTwrPropsParms(TwrPropsParmsData, ErrStat, ErrMsg)
   type(TwrPropsParms), intent(inout) :: TwrPropsParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyTwrPropsParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(TwrPropsParmsData%TwrHtFr)) then
      deallocate(TwrPropsParmsData%TwrHtFr)
   end if
   if (allocated(TwrPropsParmsData%TwrWid)) then
      deallocate(TwrPropsParmsData%TwrWid)
   end if
   if (allocated(TwrPropsParmsData%TwrCD)) then
      deallocate(TwrPropsParmsData%TwrCD)
   end if
   if (allocated(TwrPropsParmsData%TwrRe)) then
      deallocate(TwrPropsParmsData%TwrRe)
   end if
   if (allocated(TwrPropsParmsData%NTwrCDCol)) then
      deallocate(TwrPropsParmsData%NTwrCDCol)
   end if
   if (allocated(TwrPropsParmsData%TwrNodeWidth)) then
      deallocate(TwrPropsParmsData%TwrNodeWidth)
   end if
end subroutine

subroutine AD14_PackTwrPropsParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TwrPropsParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackTwrPropsParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%TwrHtFr))
   if (allocated(InData%TwrHtFr)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrHtFr), ubound(InData%TwrHtFr))
      call RegPack(Buf, InData%TwrHtFr)
   end if
   call RegPack(Buf, allocated(InData%TwrWid))
   if (allocated(InData%TwrWid)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrWid), ubound(InData%TwrWid))
      call RegPack(Buf, InData%TwrWid)
   end if
   call RegPack(Buf, allocated(InData%TwrCD))
   if (allocated(InData%TwrCD)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrCD), ubound(InData%TwrCD))
      call RegPack(Buf, InData%TwrCD)
   end if
   call RegPack(Buf, allocated(InData%TwrRe))
   if (allocated(InData%TwrRe)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrRe), ubound(InData%TwrRe))
      call RegPack(Buf, InData%TwrRe)
   end if
   call RegPack(Buf, InData%VTwr)
   call RegPack(Buf, InData%Tower_Wake_Constant)
   call RegPack(Buf, allocated(InData%NTwrCDCol))
   if (allocated(InData%NTwrCDCol)) then
      call RegPackBounds(Buf, 1, lbound(InData%NTwrCDCol), ubound(InData%NTwrCDCol))
      call RegPack(Buf, InData%NTwrCDCol)
   end if
   call RegPack(Buf, InData%NTwrHT)
   call RegPack(Buf, InData%NTwrRe)
   call RegPack(Buf, InData%NTwrCD)
   call RegPack(Buf, InData%TwrPotent)
   call RegPack(Buf, InData%TwrShadow)
   call RegPack(Buf, InData%ShadHWid)
   call RegPack(Buf, InData%TShadC1)
   call RegPack(Buf, InData%TShadC2)
   call RegPack(Buf, InData%TwrShad)
   call RegPack(Buf, InData%PJM_Version)
   call RegPack(Buf, InData%TwrFile)
   call RegPack(Buf, InData%T_Shad_Refpt)
   call RegPack(Buf, InData%CalcTwrAero)
   call RegPack(Buf, InData%NumTwrNodes)
   call RegPack(Buf, allocated(InData%TwrNodeWidth))
   if (allocated(InData%TwrNodeWidth)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrNodeWidth), ubound(InData%TwrNodeWidth))
      call RegPack(Buf, InData%TwrNodeWidth)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackTwrPropsParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TwrPropsParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackTwrPropsParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%TwrHtFr)) deallocate(OutData%TwrHtFr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrHtFr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrHtFr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrHtFr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrWid)) deallocate(OutData%TwrWid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrWid(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrWid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrWid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrCD)) deallocate(OutData%TwrCD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrRe)) deallocate(OutData%TwrRe)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrRe(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRe.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrRe)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%VTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Tower_Wake_Constant)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%NTwrCDCol)) deallocate(OutData%NTwrCDCol)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NTwrCDCol(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTwrCDCol.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NTwrCDCol)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NTwrHT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NTwrRe)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NTwrCD)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ShadHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TShadC1)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TShadC2)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrShad)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PJM_Version)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%T_Shad_Refpt)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CalcTwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%TwrNodeWidth)) deallocate(OutData%TwrNodeWidth)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrNodeWidth(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeWidth.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrNodeWidth)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD14_CopyWind(SrcWindData, DstWindData, CtrlCode, ErrStat, ErrMsg)
   type(Wind), intent(in) :: SrcWindData
   type(Wind), intent(inout) :: DstWindData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyWind'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWindData%ANGFLW = SrcWindData%ANGFLW
   DstWindData%CDEL = SrcWindData%CDEL
   DstWindData%VROTORX = SrcWindData%VROTORX
   DstWindData%VROTORY = SrcWindData%VROTORY
   DstWindData%VROTORZ = SrcWindData%VROTORZ
   DstWindData%SDEL = SrcWindData%SDEL
end subroutine

subroutine AD14_DestroyWind(WindData, ErrStat, ErrMsg)
   type(Wind), intent(inout) :: WindData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyWind'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackWind(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wind), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWind'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%ANGFLW)
   call RegPack(Buf, InData%CDEL)
   call RegPack(Buf, InData%VROTORX)
   call RegPack(Buf, InData%VROTORY)
   call RegPack(Buf, InData%VROTORZ)
   call RegPack(Buf, InData%SDEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackWind(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wind), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWind'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%ANGFLW)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CDEL)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VROTORX)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VROTORY)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VROTORZ)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SDEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyWindParms(SrcWindParmsData, DstWindParmsData, CtrlCode, ErrStat, ErrMsg)
   type(WindParms), intent(in) :: SrcWindParmsData
   type(WindParms), intent(inout) :: DstWindParmsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyWindParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstWindParmsData%Rho = SrcWindParmsData%Rho
   DstWindParmsData%KinVisc = SrcWindParmsData%KinVisc
end subroutine

subroutine AD14_DestroyWindParms(WindParmsData, ErrStat, ErrMsg)
   type(WindParms), intent(inout) :: WindParmsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyWindParms'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackWindParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WindParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWindParms'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Rho)
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackWindParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WindParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWindParms'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Rho)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyPositionType(SrcPositionTypeData, DstPositionTypeData, CtrlCode, ErrStat, ErrMsg)
   type(PositionType), intent(in) :: SrcPositionTypeData
   type(PositionType), intent(inout) :: DstPositionTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyPositionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstPositionTypeData%Pos = SrcPositionTypeData%Pos
end subroutine

subroutine AD14_DestroyPositionType(PositionTypeData, ErrStat, ErrMsg)
   type(PositionType), intent(inout) :: PositionTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyPositionType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackPositionType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(PositionType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackPositionType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Pos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackPositionType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(PositionType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackPositionType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Pos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyOrientationType(SrcOrientationTypeData, DstOrientationTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OrientationType), intent(in) :: SrcOrientationTypeData
   type(OrientationType), intent(inout) :: DstOrientationTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_CopyOrientationType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOrientationTypeData%Orient = SrcOrientationTypeData%Orient
end subroutine

subroutine AD14_DestroyOrientationType(OrientationTypeData, ErrStat, ErrMsg)
   type(OrientationType), intent(inout) :: OrientationTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD14_DestroyOrientationType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackOrientationType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OrientationType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOrientationType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Orient)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOrientationType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OrientationType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOrientationType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Orient)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InitInputType), intent(in) :: SrcInitInputData
   type(AD14_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%Title = SrcInitInputData%Title
   DstInitInputData%OutRootName = SrcInitInputData%OutRootName
   DstInitInputData%ADFileName = SrcInitInputData%ADFileName
   DstInitInputData%WrSumFile = SrcInitInputData%WrSumFile
   DstInitInputData%NumBl = SrcInitInputData%NumBl
   DstInitInputData%BladeLength = SrcInitInputData%BladeLength
   DstInitInputData%LinearizeFlag = SrcInitInputData%LinearizeFlag
   DstInitInputData%UseDWM = SrcInitInputData%UseDWM
   call AD14_CopyAeroConfig(SrcInitInputData%TurbineComponents, DstInitInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitInputData%NumTwrNodes = SrcInitInputData%NumTwrNodes
   if (allocated(SrcInitInputData%TwrNodeLocs)) then
      LB(1:2) = lbound(SrcInitInputData%TwrNodeLocs)
      UB(1:2) = ubound(SrcInitInputData%TwrNodeLocs)
      if (.not. allocated(DstInitInputData%TwrNodeLocs)) then
         allocate(DstInitInputData%TwrNodeLocs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TwrNodeLocs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%TwrNodeLocs = SrcInitInputData%TwrNodeLocs
   else if (allocated(DstInitInputData%TwrNodeLocs)) then
      deallocate(DstInitInputData%TwrNodeLocs)
   end if
   DstInitInputData%HubHt = SrcInitInputData%HubHt
   call DWM_CopyInitInput(SrcInitInputData%DWM, DstInitInputData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(AD14_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%TwrNodeLocs)) then
      deallocate(InitInputData%TwrNodeLocs)
   end if
end subroutine

subroutine AD14_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Title)
   call RegPack(Buf, InData%OutRootName)
   call RegPack(Buf, InData%ADFileName)
   call RegPack(Buf, InData%WrSumFile)
   call RegPack(Buf, InData%NumBl)
   call RegPack(Buf, InData%BladeLength)
   call RegPack(Buf, InData%LinearizeFlag)
   call RegPack(Buf, InData%UseDWM)
   call AD14_PackAeroConfig(Buf, InData%TurbineComponents) 
   call RegPack(Buf, InData%NumTwrNodes)
   call RegPack(Buf, allocated(InData%TwrNodeLocs))
   if (allocated(InData%TwrNodeLocs)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrNodeLocs), ubound(InData%TwrNodeLocs))
      call RegPack(Buf, InData%TwrNodeLocs)
   end if
   call RegPack(Buf, InData%HubHt)
   call DWM_PackInitInput(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ADFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrSumFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   call AD14_UnpackAeroConfig(Buf, OutData%TurbineComponents) ! TurbineComponents 
   call RegUnpack(Buf, OutData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%TwrNodeLocs)) deallocate(OutData%TwrNodeLocs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrNodeLocs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeLocs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrNodeLocs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%HubHt)
   if (RegCheckErr(Buf, RoutineName)) return
   call DWM_UnpackInitInput(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InitOutputType), intent(in) :: SrcInitOutputData
   type(AD14_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyInitOutput(SrcInitOutputData%DWM, DstInitOutputData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitOutputData%AirDens = SrcInitOutputData%AirDens
end subroutine

subroutine AD14_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(AD14_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   call DWM_PackInitOutput(Buf, InData%DWM) 
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   call DWM_UnpackInitOutput(Buf, OutData%DWM) ! DWM 
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ContinuousStateType), intent(in) :: SrcContStateData
   type(AD14_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyContState(SrcContStateData%DWM, DstContStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(AD14_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   call DWM_PackContState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   call DWM_UnpackContState(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(AD14_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyDiscState(SrcDiscStateData%DWM, DstDiscStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(AD14_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   call DWM_PackDiscState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   call DWM_UnpackDiscState(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(AD14_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyConstrState(SrcConstrStateData%DWM, DstConstrStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(AD14_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   call DWM_PackConstrState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   call DWM_UnpackConstrState(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_OtherStateType), intent(in) :: SrcOtherStateData
   type(AD14_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyOtherState(SrcOtherStateData%DWM, DstOtherStateData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(AD14_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   call DWM_PackOtherState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   call DWM_UnpackOtherState(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_MiscVarType), intent(in) :: SrcMiscData
   type(AD14_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call DWM_CopyMisc(SrcMiscData%DWM, DstMiscData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyInput(SrcMiscData%DWM_Inputs, DstMiscData%DWM_Inputs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyOutput(SrcMiscData%DWM_Outputs, DstMiscData%DWM_Outputs, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%DT = SrcMiscData%DT
   if (allocated(SrcMiscData%ElPrNum)) then
      LB(1:1) = lbound(SrcMiscData%ElPrNum)
      UB(1:1) = ubound(SrcMiscData%ElPrNum)
      if (.not. allocated(DstMiscData%ElPrNum)) then
         allocate(DstMiscData%ElPrNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ElPrNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%ElPrNum = SrcMiscData%ElPrNum
   else if (allocated(DstMiscData%ElPrNum)) then
      deallocate(DstMiscData%ElPrNum)
   end if
   DstMiscData%OldTime = SrcMiscData%OldTime
   DstMiscData%HubLoss = SrcMiscData%HubLoss
   DstMiscData%Loss = SrcMiscData%Loss
   DstMiscData%TipLoss = SrcMiscData%TipLoss
   DstMiscData%TLpt7 = SrcMiscData%TLpt7
   DstMiscData%FirstPassGTL = SrcMiscData%FirstPassGTL
   DstMiscData%SuperSonic = SrcMiscData%SuperSonic
   DstMiscData%AFLAGVinderr = SrcMiscData%AFLAGVinderr
   DstMiscData%AFLAGTwrInflu = SrcMiscData%AFLAGTwrInflu
   DstMiscData%OnePassDynDbg = SrcMiscData%OnePassDynDbg
   DstMiscData%NoLoadsCalculated = SrcMiscData%NoLoadsCalculated
   DstMiscData%NERRORS = SrcMiscData%NERRORS
   call AD14_CopyAirFoil(SrcMiscData%AirFoil, DstMiscData%AirFoil, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBeddoes(SrcMiscData%Beddoes, DstMiscData%Beddoes, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyDynInflow(SrcMiscData%DynInflow, DstMiscData%DynInflow, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElement(SrcMiscData%Element, DstMiscData%Element, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyRotor(SrcMiscData%Rotor, DstMiscData%Rotor, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyWind(SrcMiscData%Wind, DstMiscData%Wind, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyInducedVel(SrcMiscData%InducedVel, DstMiscData%InducedVel, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElOutParms(SrcMiscData%ElOut, DstMiscData%ElOut, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%Skew = SrcMiscData%Skew
   DstMiscData%DynInit = SrcMiscData%DynInit
   DstMiscData%FirstWarn = SrcMiscData%FirstWarn
   if (allocated(SrcMiscData%StoredForces)) then
      LB(1:3) = lbound(SrcMiscData%StoredForces)
      UB(1:3) = ubound(SrcMiscData%StoredForces)
      if (.not. allocated(DstMiscData%StoredForces)) then
         allocate(DstMiscData%StoredForces(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredForces.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%StoredForces = SrcMiscData%StoredForces
   else if (allocated(DstMiscData%StoredForces)) then
      deallocate(DstMiscData%StoredForces)
   end if
   if (allocated(SrcMiscData%StoredMoments)) then
      LB(1:3) = lbound(SrcMiscData%StoredMoments)
      UB(1:3) = ubound(SrcMiscData%StoredMoments)
      if (.not. allocated(DstMiscData%StoredMoments)) then
         allocate(DstMiscData%StoredMoments(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredMoments.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%StoredMoments = SrcMiscData%StoredMoments
   else if (allocated(DstMiscData%StoredMoments)) then
      deallocate(DstMiscData%StoredMoments)
   end if
end subroutine

subroutine AD14_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(AD14_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%ElPrNum)) then
      deallocate(MiscData%ElPrNum)
   end if
   if (allocated(MiscData%StoredForces)) then
      deallocate(MiscData%StoredForces)
   end if
   if (allocated(MiscData%StoredMoments)) then
      deallocate(MiscData%StoredMoments)
   end if
end subroutine

subroutine AD14_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   call DWM_PackMisc(Buf, InData%DWM) 
   call DWM_PackInput(Buf, InData%DWM_Inputs) 
   call DWM_PackOutput(Buf, InData%DWM_Outputs) 
   call RegPack(Buf, InData%DT)
   call RegPack(Buf, allocated(InData%ElPrNum))
   if (allocated(InData%ElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrNum), ubound(InData%ElPrNum))
      call RegPack(Buf, InData%ElPrNum)
   end if
   call RegPack(Buf, InData%OldTime)
   call RegPack(Buf, InData%HubLoss)
   call RegPack(Buf, InData%Loss)
   call RegPack(Buf, InData%TipLoss)
   call RegPack(Buf, InData%TLpt7)
   call RegPack(Buf, InData%FirstPassGTL)
   call RegPack(Buf, InData%SuperSonic)
   call RegPack(Buf, InData%AFLAGVinderr)
   call RegPack(Buf, InData%AFLAGTwrInflu)
   call RegPack(Buf, InData%OnePassDynDbg)
   call RegPack(Buf, InData%NoLoadsCalculated)
   call RegPack(Buf, InData%NERRORS)
   call AD14_PackAirFoil(Buf, InData%AirFoil) 
   call AD14_PackBeddoes(Buf, InData%Beddoes) 
   call AD14_PackDynInflow(Buf, InData%DynInflow) 
   call AD14_PackElement(Buf, InData%Element) 
   call AD14_PackRotor(Buf, InData%Rotor) 
   call AD14_PackWind(Buf, InData%Wind) 
   call AD14_PackInducedVel(Buf, InData%InducedVel) 
   call AD14_PackElOutParms(Buf, InData%ElOut) 
   call RegPack(Buf, InData%Skew)
   call RegPack(Buf, InData%DynInit)
   call RegPack(Buf, InData%FirstWarn)
   call RegPack(Buf, allocated(InData%StoredForces))
   if (allocated(InData%StoredForces)) then
      call RegPackBounds(Buf, 3, lbound(InData%StoredForces), ubound(InData%StoredForces))
      call RegPack(Buf, InData%StoredForces)
   end if
   call RegPack(Buf, allocated(InData%StoredMoments))
   if (allocated(InData%StoredMoments)) then
      call RegPackBounds(Buf, 3, lbound(InData%StoredMoments), ubound(InData%StoredMoments))
      call RegPack(Buf, InData%StoredMoments)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMisc'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call DWM_UnpackMisc(Buf, OutData%DWM) ! DWM 
   call DWM_UnpackInput(Buf, OutData%DWM_Inputs) ! DWM_Inputs 
   call DWM_UnpackOutput(Buf, OutData%DWM_Outputs) ! DWM_Outputs 
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%ElPrNum)) deallocate(OutData%ElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%OldTime)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Loss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TLpt7)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FirstPassGTL)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SuperSonic)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AFLAGVinderr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AFLAGTwrInflu)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OnePassDynDbg)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NoLoadsCalculated)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NERRORS)
   if (RegCheckErr(Buf, RoutineName)) return
   call AD14_UnpackAirFoil(Buf, OutData%AirFoil) ! AirFoil 
   call AD14_UnpackBeddoes(Buf, OutData%Beddoes) ! Beddoes 
   call AD14_UnpackDynInflow(Buf, OutData%DynInflow) ! DynInflow 
   call AD14_UnpackElement(Buf, OutData%Element) ! Element 
   call AD14_UnpackRotor(Buf, OutData%Rotor) ! Rotor 
   call AD14_UnpackWind(Buf, OutData%Wind) ! Wind 
   call AD14_UnpackInducedVel(Buf, OutData%InducedVel) ! InducedVel 
   call AD14_UnpackElOutParms(Buf, OutData%ElOut) ! ElOut 
   call RegUnpack(Buf, OutData%Skew)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DynInit)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FirstWarn)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%StoredForces)) deallocate(OutData%StoredForces)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StoredForces(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredForces.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StoredForces)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%StoredMoments)) deallocate(OutData%StoredMoments)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StoredMoments(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredMoments.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StoredMoments)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD14_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_ParameterType), intent(in) :: SrcParamData
   type(AD14_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%Title = SrcParamData%Title
   DstParamData%SIUnit = SrcParamData%SIUnit
   DstParamData%Echo = SrcParamData%Echo
   DstParamData%MultiTab = SrcParamData%MultiTab
   DstParamData%LinearizeFlag = SrcParamData%LinearizeFlag
   DstParamData%OutputPlottingInfo = SrcParamData%OutputPlottingInfo
   DstParamData%UseDWM = SrcParamData%UseDWM
   DstParamData%TwoPiNB = SrcParamData%TwoPiNB
   DstParamData%NumBl = SrcParamData%NumBl
   DstParamData%NBlInpSt = SrcParamData%NBlInpSt
   DstParamData%ElemPrn = SrcParamData%ElemPrn
   DstParamData%DStall = SrcParamData%DStall
   DstParamData%PMoment = SrcParamData%PMoment
   DstParamData%Reynolds = SrcParamData%Reynolds
   DstParamData%DynInfl = SrcParamData%DynInfl
   DstParamData%Wake = SrcParamData%Wake
   DstParamData%Swirl = SrcParamData%Swirl
   DstParamData%DtAero = SrcParamData%DtAero
   DstParamData%HubRad = SrcParamData%HubRad
   DstParamData%UnEc = SrcParamData%UnEc
   DstParamData%UnElem = SrcParamData%UnElem
   DstParamData%UnWndOut = SrcParamData%UnWndOut
   DstParamData%MAXICOUNT = SrcParamData%MAXICOUNT
   DstParamData%WrOptFile = SrcParamData%WrOptFile
   DstParamData%DEFAULT_Wind = SrcParamData%DEFAULT_Wind
   call AD14_CopyAirFoilParms(SrcParamData%AirFoil, DstParamData%AirFoil, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBladeParms(SrcParamData%Blade, DstParamData%Blade, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyBeddoesParms(SrcParamData%Beddoes, DstParamData%Beddoes, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyDynInflowParms(SrcParamData%DynInflow, DstParamData%DynInflow, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyElementParms(SrcParamData%Element, DstParamData%Element, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyTwrPropsParms(SrcParamData%TwrProps, DstParamData%TwrProps, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyInducedVelParms(SrcParamData%InducedVel, DstParamData%InducedVel, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyWindParms(SrcParamData%Wind, DstParamData%Wind, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyRotorParms(SrcParamData%Rotor, DstParamData%Rotor, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DWM_CopyParam(SrcParamData%DWM, DstParamData%DWM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(AD14_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD14_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Title)
   call RegPack(Buf, InData%SIUnit)
   call RegPack(Buf, InData%Echo)
   call RegPack(Buf, InData%MultiTab)
   call RegPack(Buf, InData%LinearizeFlag)
   call RegPack(Buf, InData%OutputPlottingInfo)
   call RegPack(Buf, InData%UseDWM)
   call RegPack(Buf, InData%TwoPiNB)
   call RegPack(Buf, InData%NumBl)
   call RegPack(Buf, InData%NBlInpSt)
   call RegPack(Buf, InData%ElemPrn)
   call RegPack(Buf, InData%DStall)
   call RegPack(Buf, InData%PMoment)
   call RegPack(Buf, InData%Reynolds)
   call RegPack(Buf, InData%DynInfl)
   call RegPack(Buf, InData%Wake)
   call RegPack(Buf, InData%Swirl)
   call RegPack(Buf, InData%DtAero)
   call RegPack(Buf, InData%HubRad)
   call RegPack(Buf, InData%UnEc)
   call RegPack(Buf, InData%UnElem)
   call RegPack(Buf, InData%UnWndOut)
   call RegPack(Buf, InData%MAXICOUNT)
   call RegPack(Buf, InData%WrOptFile)
   call RegPack(Buf, InData%DEFAULT_Wind)
   call AD14_PackAirFoilParms(Buf, InData%AirFoil) 
   call AD14_PackBladeParms(Buf, InData%Blade) 
   call AD14_PackBeddoesParms(Buf, InData%Beddoes) 
   call AD14_PackDynInflowParms(Buf, InData%DynInflow) 
   call AD14_PackElementParms(Buf, InData%Element) 
   call AD14_PackTwrPropsParms(Buf, InData%TwrProps) 
   call AD14_PackInducedVelParms(Buf, InData%InducedVel) 
   call AD14_PackWindParms(Buf, InData%Wind) 
   call AD14_PackRotorParms(Buf, InData%Rotor) 
   call DWM_PackParam(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackParam'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SIUnit)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MultiTab)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%OutputPlottingInfo)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwoPiNB)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NBlInpSt)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%ElemPrn)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DStall)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PMoment)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Reynolds)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DynInfl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DtAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubRad)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UnEc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UnElem)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UnWndOut)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MAXICOUNT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WrOptFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DEFAULT_Wind)
   if (RegCheckErr(Buf, RoutineName)) return
   call AD14_UnpackAirFoilParms(Buf, OutData%AirFoil) ! AirFoil 
   call AD14_UnpackBladeParms(Buf, OutData%Blade) ! Blade 
   call AD14_UnpackBeddoesParms(Buf, OutData%Beddoes) ! Beddoes 
   call AD14_UnpackDynInflowParms(Buf, OutData%DynInflow) ! DynInflow 
   call AD14_UnpackElementParms(Buf, OutData%Element) ! Element 
   call AD14_UnpackTwrPropsParms(Buf, OutData%TwrProps) ! TwrProps 
   call AD14_UnpackInducedVelParms(Buf, OutData%InducedVel) ! InducedVel 
   call AD14_UnpackWindParms(Buf, OutData%Wind) ! Wind 
   call AD14_UnpackRotorParms(Buf, OutData%Rotor) ! Rotor 
   call DWM_UnpackParam(Buf, OutData%DWM) ! DWM 
end subroutine

subroutine AD14_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_InputType), intent(inout) :: SrcInputData
   type(AD14_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInputData%InputMarkers)) then
      LB(1:1) = lbound(SrcInputData%InputMarkers)
      UB(1:1) = ubound(SrcInputData%InputMarkers)
      if (.not. allocated(DstInputData%InputMarkers)) then
         allocate(DstInputData%InputMarkers(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InputMarkers.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcInputData%InputMarkers(i1), DstInputData%InputMarkers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   else if (allocated(DstInputData%InputMarkers)) then
      deallocate(DstInputData%InputMarkers)
   end if
   call MeshCopy(SrcInputData%Twr_InputMarkers, DstInputData%Twr_InputMarkers, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD14_CopyAeroConfig(SrcInputData%TurbineComponents, DstInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInputData%MulTabLoc)) then
      LB(1:2) = lbound(SrcInputData%MulTabLoc)
      UB(1:2) = ubound(SrcInputData%MulTabLoc)
      if (.not. allocated(DstInputData%MulTabLoc)) then
         allocate(DstInputData%MulTabLoc(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MulTabLoc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%MulTabLoc = SrcInputData%MulTabLoc
   else if (allocated(DstInputData%MulTabLoc)) then
      deallocate(DstInputData%MulTabLoc)
   end if
   if (allocated(SrcInputData%InflowVelocity)) then
      LB(1:2) = lbound(SrcInputData%InflowVelocity)
      UB(1:2) = ubound(SrcInputData%InflowVelocity)
      if (.not. allocated(DstInputData%InflowVelocity)) then
         allocate(DstInputData%InflowVelocity(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowVelocity.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%InflowVelocity = SrcInputData%InflowVelocity
   else if (allocated(DstInputData%InflowVelocity)) then
      deallocate(DstInputData%InflowVelocity)
   end if
   DstInputData%AvgInfVel = SrcInputData%AvgInfVel
end subroutine

subroutine AD14_DestroyInput(InputData, ErrStat, ErrMsg)
   type(AD14_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%InputMarkers)) then
      LB(1:1) = lbound(InputData%InputMarkers)
      UB(1:1) = ubound(InputData%InputMarkers)
      do i1 = LB(1), UB(1)
         call MeshDestroy( InputData%InputMarkers(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InputData%InputMarkers)
   end if
   if (allocated(InputData%MulTabLoc)) then
      deallocate(InputData%MulTabLoc)
   end if
   if (allocated(InputData%InflowVelocity)) then
      deallocate(InputData%InflowVelocity)
   end if
end subroutine

subroutine AD14_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%InputMarkers))
   if (allocated(InData%InputMarkers)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputMarkers), ubound(InData%InputMarkers))
      LB(1:1) = lbound(InData%InputMarkers)
      UB(1:1) = ubound(InData%InputMarkers)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%InputMarkers(i1)) 
      end do
   end if
   call MeshPack(Buf, InData%Twr_InputMarkers) 
   call AD14_PackAeroConfig(Buf, InData%TurbineComponents) 
   call RegPack(Buf, allocated(InData%MulTabLoc))
   if (allocated(InData%MulTabLoc)) then
      call RegPackBounds(Buf, 2, lbound(InData%MulTabLoc), ubound(InData%MulTabLoc))
      call RegPack(Buf, InData%MulTabLoc)
   end if
   call RegPack(Buf, allocated(InData%InflowVelocity))
   if (allocated(InData%InflowVelocity)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowVelocity), ubound(InData%InflowVelocity))
      call RegPack(Buf, InData%InflowVelocity)
   end if
   call RegPack(Buf, InData%AvgInfVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%InputMarkers)) deallocate(OutData%InputMarkers)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputMarkers(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputMarkers.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%InputMarkers(i1)) ! InputMarkers 
      end do
   end if
   call MeshUnpack(Buf, OutData%Twr_InputMarkers) ! Twr_InputMarkers 
   call AD14_UnpackAeroConfig(Buf, OutData%TurbineComponents) ! TurbineComponents 
   if (allocated(OutData%MulTabLoc)) deallocate(OutData%MulTabLoc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MulTabLoc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabLoc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MulTabLoc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%InflowVelocity)) deallocate(OutData%InflowVelocity)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowVelocity(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowVelocity.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowVelocity)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%AvgInfVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD14_OutputType), intent(inout) :: SrcOutputData
   type(AD14_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%OutputLoads)) then
      LB(1:1) = lbound(SrcOutputData%OutputLoads)
      UB(1:1) = ubound(SrcOutputData%OutputLoads)
      if (.not. allocated(DstOutputData%OutputLoads)) then
         allocate(DstOutputData%OutputLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%OutputLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%OutputLoads(i1), DstOutputData%OutputLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   else if (allocated(DstOutputData%OutputLoads)) then
      deallocate(DstOutputData%OutputLoads)
   end if
   call MeshCopy(SrcOutputData%Twr_OutputLoads, DstOutputData%Twr_OutputLoads, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD14_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(AD14_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD14_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%OutputLoads)) then
      LB(1:1) = lbound(OutputData%OutputLoads)
      UB(1:1) = ubound(OutputData%OutputLoads)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%OutputLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%OutputLoads)
   end if
end subroutine

subroutine AD14_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%OutputLoads))
   if (allocated(InData%OutputLoads)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutputLoads), ubound(InData%OutputLoads))
      LB(1:1) = lbound(InData%OutputLoads)
      UB(1:1) = ubound(InData%OutputLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%OutputLoads(i1)) 
      end do
   end if
   call MeshPack(Buf, InData%Twr_OutputLoads) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%OutputLoads)) deallocate(OutData%OutputLoads)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutputLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutputLoads.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%OutputLoads(i1)) ! OutputLoads 
      end do
   end if
   call MeshUnpack(Buf, OutData%Twr_OutputLoads) ! Twr_OutputLoads 
end subroutine

 SUBROUTINE AD14_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Input_ExtrapInterp


 SUBROUTINE AD14_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i1 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp1(u1%InputMarkers(i1), u2%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(u1%Twr_InputMarkers, u2%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Position,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Position,1)
    b = -(u1%TurbineComponents%Blade(i11)%Position(i1) - u2%TurbineComponents%Blade(i11)%Position(i1))
    u_out%TurbineComponents%Blade(i11)%Position(i1) = u1%TurbineComponents%Blade(i11)%Position(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i2 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1)
      b = -(u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) - u2%TurbineComponents%Blade(i11)%Orientation(i1,i2))
      u_out%TurbineComponents%Blade(i11)%Orientation(i1,i2) = u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)
    b = -(u1%TurbineComponents%Blade(i11)%TranslationVel(i1) - u2%TurbineComponents%Blade(i11)%TranslationVel(i1))
    u_out%TurbineComponents%Blade(i11)%TranslationVel(i1) = u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1)
    b = -(u1%TurbineComponents%Blade(i11)%RotationVel(i1) - u2%TurbineComponents%Blade(i11)%RotationVel(i1))
    u_out%TurbineComponents%Blade(i11)%RotationVel(i1) = u1%TurbineComponents%Blade(i11)%RotationVel(i1) + b * ScaleFactor
  END DO
  ENDDO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%Position,1),UBOUND(u_out%TurbineComponents%Hub%Position,1)
    b = -(u1%TurbineComponents%Hub%Position(i1) - u2%TurbineComponents%Hub%Position(i1))
    u_out%TurbineComponents%Hub%Position(i1) = u1%TurbineComponents%Hub%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Hub%Orientation,2),UBOUND(u_out%TurbineComponents%Hub%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Hub%Orientation,1),UBOUND(u_out%TurbineComponents%Hub%Orientation,1)
      b = -(u1%TurbineComponents%Hub%Orientation(i1,i2) - u2%TurbineComponents%Hub%Orientation(i1,i2))
      u_out%TurbineComponents%Hub%Orientation(i1,i2) = u1%TurbineComponents%Hub%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%TranslationVel,1),UBOUND(u_out%TurbineComponents%Hub%TranslationVel,1)
    b = -(u1%TurbineComponents%Hub%TranslationVel(i1) - u2%TurbineComponents%Hub%TranslationVel(i1))
    u_out%TurbineComponents%Hub%TranslationVel(i1) = u1%TurbineComponents%Hub%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%RotationVel,1),UBOUND(u_out%TurbineComponents%Hub%RotationVel,1)
    b = -(u1%TurbineComponents%Hub%RotationVel(i1) - u2%TurbineComponents%Hub%RotationVel(i1))
    u_out%TurbineComponents%Hub%RotationVel(i1) = u1%TurbineComponents%Hub%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Position,1),UBOUND(u_out%TurbineComponents%RotorFurl%Position,1)
    b = -(u1%TurbineComponents%RotorFurl%Position(i1) - u2%TurbineComponents%RotorFurl%Position(i1))
    u_out%TurbineComponents%RotorFurl%Position(i1) = u1%TurbineComponents%RotorFurl%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1)
      b = -(u1%TurbineComponents%RotorFurl%Orientation(i1,i2) - u2%TurbineComponents%RotorFurl%Orientation(i1,i2))
      u_out%TurbineComponents%RotorFurl%Orientation(i1,i2) = u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1)
    b = -(u1%TurbineComponents%RotorFurl%TranslationVel(i1) - u2%TurbineComponents%RotorFurl%TranslationVel(i1))
    u_out%TurbineComponents%RotorFurl%TranslationVel(i1) = u1%TurbineComponents%RotorFurl%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1)
    b = -(u1%TurbineComponents%RotorFurl%RotationVel(i1) - u2%TurbineComponents%RotorFurl%RotationVel(i1))
    u_out%TurbineComponents%RotorFurl%RotationVel(i1) = u1%TurbineComponents%RotorFurl%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Position,1),UBOUND(u_out%TurbineComponents%Nacelle%Position,1)
    b = -(u1%TurbineComponents%Nacelle%Position(i1) - u2%TurbineComponents%Nacelle%Position(i1))
    u_out%TurbineComponents%Nacelle%Position(i1) = u1%TurbineComponents%Nacelle%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,2),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,1),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,1)
      b = -(u1%TurbineComponents%Nacelle%Orientation(i1,i2) - u2%TurbineComponents%Nacelle%Orientation(i1,i2))
      u_out%TurbineComponents%Nacelle%Orientation(i1,i2) = u1%TurbineComponents%Nacelle%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1)
    b = -(u1%TurbineComponents%Nacelle%TranslationVel(i1) - u2%TurbineComponents%Nacelle%TranslationVel(i1))
    u_out%TurbineComponents%Nacelle%TranslationVel(i1) = u1%TurbineComponents%Nacelle%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1)
    b = -(u1%TurbineComponents%Nacelle%RotationVel(i1) - u2%TurbineComponents%Nacelle%RotationVel(i1))
    u_out%TurbineComponents%Nacelle%RotationVel(i1) = u1%TurbineComponents%Nacelle%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Position,1),UBOUND(u_out%TurbineComponents%TailFin%Position,1)
    b = -(u1%TurbineComponents%TailFin%Position(i1) - u2%TurbineComponents%TailFin%Position(i1))
    u_out%TurbineComponents%TailFin%Position(i1) = u1%TurbineComponents%TailFin%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,2),UBOUND(u_out%TurbineComponents%TailFin%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,1),UBOUND(u_out%TurbineComponents%TailFin%Orientation,1)
      b = -(u1%TurbineComponents%TailFin%Orientation(i1,i2) - u2%TurbineComponents%TailFin%Orientation(i1,i2))
      u_out%TurbineComponents%TailFin%Orientation(i1,i2) = u1%TurbineComponents%TailFin%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1),UBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1)
    b = -(u1%TurbineComponents%TailFin%TranslationVel(i1) - u2%TurbineComponents%TailFin%TranslationVel(i1))
    u_out%TurbineComponents%TailFin%TranslationVel(i1) = u1%TurbineComponents%TailFin%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%RotationVel,1),UBOUND(u_out%TurbineComponents%TailFin%RotationVel,1)
    b = -(u1%TurbineComponents%TailFin%RotationVel(i1) - u2%TurbineComponents%TailFin%RotationVel(i1))
    u_out%TurbineComponents%TailFin%RotationVel(i1) = u1%TurbineComponents%TailFin%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%Position,1),UBOUND(u_out%TurbineComponents%Tower%Position,1)
    b = -(u1%TurbineComponents%Tower%Position(i1) - u2%TurbineComponents%Tower%Position(i1))
    u_out%TurbineComponents%Tower%Position(i1) = u1%TurbineComponents%Tower%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Tower%Orientation,2),UBOUND(u_out%TurbineComponents%Tower%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Tower%Orientation,1),UBOUND(u_out%TurbineComponents%Tower%Orientation,1)
      b = -(u1%TurbineComponents%Tower%Orientation(i1,i2) - u2%TurbineComponents%Tower%Orientation(i1,i2))
      u_out%TurbineComponents%Tower%Orientation(i1,i2) = u1%TurbineComponents%Tower%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%TranslationVel,1),UBOUND(u_out%TurbineComponents%Tower%TranslationVel,1)
    b = -(u1%TurbineComponents%Tower%TranslationVel(i1) - u2%TurbineComponents%Tower%TranslationVel(i1))
    u_out%TurbineComponents%Tower%TranslationVel(i1) = u1%TurbineComponents%Tower%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%RotationVel,1),UBOUND(u_out%TurbineComponents%Tower%RotationVel,1)
    b = -(u1%TurbineComponents%Tower%RotationVel(i1) - u2%TurbineComponents%Tower%RotationVel(i1))
    u_out%TurbineComponents%Tower%RotationVel(i1) = u1%TurbineComponents%Tower%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Position,1),UBOUND(u_out%TurbineComponents%SubStructure%Position,1)
    b = -(u1%TurbineComponents%SubStructure%Position(i1) - u2%TurbineComponents%SubStructure%Position(i1))
    u_out%TurbineComponents%SubStructure%Position(i1) = u1%TurbineComponents%SubStructure%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,2),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,1),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,1)
      b = -(u1%TurbineComponents%SubStructure%Orientation(i1,i2) - u2%TurbineComponents%SubStructure%Orientation(i1,i2))
      u_out%TurbineComponents%SubStructure%Orientation(i1,i2) = u1%TurbineComponents%SubStructure%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1)
    b = -(u1%TurbineComponents%SubStructure%TranslationVel(i1) - u2%TurbineComponents%SubStructure%TranslationVel(i1))
    u_out%TurbineComponents%SubStructure%TranslationVel(i1) = u1%TurbineComponents%SubStructure%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1)
    b = -(u1%TurbineComponents%SubStructure%RotationVel(i1) - u2%TurbineComponents%SubStructure%RotationVel(i1))
    u_out%TurbineComponents%SubStructure%RotationVel(i1) = u1%TurbineComponents%SubStructure%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Position,1),UBOUND(u_out%TurbineComponents%Foundation%Position,1)
    b = -(u1%TurbineComponents%Foundation%Position(i1) - u2%TurbineComponents%Foundation%Position(i1))
    u_out%TurbineComponents%Foundation%Position(i1) = u1%TurbineComponents%Foundation%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,2),UBOUND(u_out%TurbineComponents%Foundation%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,1),UBOUND(u_out%TurbineComponents%Foundation%Orientation,1)
      b = -(u1%TurbineComponents%Foundation%Orientation(i1,i2) - u2%TurbineComponents%Foundation%Orientation(i1,i2))
      u_out%TurbineComponents%Foundation%Orientation(i1,i2) = u1%TurbineComponents%Foundation%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1),UBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1)
    b = -(u1%TurbineComponents%Foundation%TranslationVel(i1) - u2%TurbineComponents%Foundation%TranslationVel(i1))
    u_out%TurbineComponents%Foundation%TranslationVel(i1) = u1%TurbineComponents%Foundation%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%RotationVel,1),UBOUND(u_out%TurbineComponents%Foundation%RotationVel,1)
    b = -(u1%TurbineComponents%Foundation%RotationVel(i1) - u2%TurbineComponents%Foundation%RotationVel(i1))
    u_out%TurbineComponents%Foundation%RotationVel(i1) = u1%TurbineComponents%Foundation%RotationVel(i1) + b * ScaleFactor
  END DO
  b = -(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength)
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b * ScaleFactor
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  DO i2 = LBOUND(u_out%MulTabLoc,2),UBOUND(u_out%MulTabLoc,2)
    DO i1 = LBOUND(u_out%MulTabLoc,1),UBOUND(u_out%MulTabLoc,1)
      b = -(u1%MulTabLoc(i1,i2) - u2%MulTabLoc(i1,i2))
      u_out%MulTabLoc(i1,i2) = u1%MulTabLoc(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  DO i2 = LBOUND(u_out%InflowVelocity,2),UBOUND(u_out%InflowVelocity,2)
    DO i1 = LBOUND(u_out%InflowVelocity,1),UBOUND(u_out%InflowVelocity,1)
      b = -(u1%InflowVelocity(i1,i2) - u2%InflowVelocity(i1,i2))
      u_out%InflowVelocity(i1,i2) = u1%InflowVelocity(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%AvgInfVel,1),UBOUND(u_out%AvgInfVel,1)
    b = -(u1%AvgInfVel(i1) - u2%AvgInfVel(i1))
    u_out%AvgInfVel(i1) = u1%AvgInfVel(i1) + b * ScaleFactor
  END DO
 END SUBROUTINE AD14_Input_ExtrapInterp1


 SUBROUTINE AD14_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i1 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp2(u1%InputMarkers(i1), u2%InputMarkers(i1), u3%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(u1%Twr_InputMarkers, u2%Twr_InputMarkers, u3%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Position,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Position(i1) - u2%TurbineComponents%Blade(i11)%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Position(i1) + u3%TurbineComponents%Blade(i11)%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Position(i1) + t(3)*u2%TurbineComponents%Blade(i11)%Position(i1) - t(2)*u3%TurbineComponents%Blade(i11)%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%Position(i1) = u1%TurbineComponents%Blade(i11)%Position(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i2 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) - u2%TurbineComponents%Blade(i11)%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + u3%TurbineComponents%Blade(i11)%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Blade(i11)%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Blade(i11)%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Blade(i11)%Orientation(i1,i2) = u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%TranslationVel(i1) - u2%TurbineComponents%Blade(i11)%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + u3%TurbineComponents%Blade(i11)%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + t(3)*u2%TurbineComponents%Blade(i11)%TranslationVel(i1) - t(2)*u3%TurbineComponents%Blade(i11)%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%TranslationVel(i1) = u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%RotationVel(i1) - u2%TurbineComponents%Blade(i11)%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%RotationVel(i1) + u3%TurbineComponents%Blade(i11)%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%RotationVel(i1) + t(3)*u2%TurbineComponents%Blade(i11)%RotationVel(i1) - t(2)*u3%TurbineComponents%Blade(i11)%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%RotationVel(i1) = u1%TurbineComponents%Blade(i11)%RotationVel(i1) + b  + c * t_out
  END DO
  ENDDO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%Position,1),UBOUND(u_out%TurbineComponents%Hub%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%Position(i1) - u2%TurbineComponents%Hub%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%Position(i1) + u3%TurbineComponents%Hub%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Position(i1) + t(3)*u2%TurbineComponents%Hub%Position(i1) - t(2)*u3%TurbineComponents%Hub%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%Position(i1) = u1%TurbineComponents%Hub%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Hub%Orientation,2),UBOUND(u_out%TurbineComponents%Hub%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Hub%Orientation,1),UBOUND(u_out%TurbineComponents%Hub%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Hub%Orientation(i1,i2) - u2%TurbineComponents%Hub%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Hub%Orientation(i1,i2) + u3%TurbineComponents%Hub%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Hub%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Hub%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Hub%Orientation(i1,i2) = u1%TurbineComponents%Hub%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%TranslationVel,1),UBOUND(u_out%TurbineComponents%Hub%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%TranslationVel(i1) - u2%TurbineComponents%Hub%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%TranslationVel(i1) + u3%TurbineComponents%Hub%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%TranslationVel(i1) + t(3)*u2%TurbineComponents%Hub%TranslationVel(i1) - t(2)*u3%TurbineComponents%Hub%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%TranslationVel(i1) = u1%TurbineComponents%Hub%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%RotationVel,1),UBOUND(u_out%TurbineComponents%Hub%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%RotationVel(i1) - u2%TurbineComponents%Hub%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%RotationVel(i1) + u3%TurbineComponents%Hub%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%RotationVel(i1) + t(3)*u2%TurbineComponents%Hub%RotationVel(i1) - t(2)*u3%TurbineComponents%Hub%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%RotationVel(i1) = u1%TurbineComponents%Hub%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Position,1),UBOUND(u_out%TurbineComponents%RotorFurl%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%Position(i1) - u2%TurbineComponents%RotorFurl%Position(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Position(i1) + u3%TurbineComponents%RotorFurl%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Position(i1) + t(3)*u2%TurbineComponents%RotorFurl%Position(i1) - t(2)*u3%TurbineComponents%RotorFurl%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%Position(i1) = u1%TurbineComponents%RotorFurl%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%RotorFurl%Orientation(i1,i2) - u2%TurbineComponents%RotorFurl%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + u3%TurbineComponents%RotorFurl%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + t(3)*u2%TurbineComponents%RotorFurl%Orientation(i1,i2) - t(2)*u3%TurbineComponents%RotorFurl%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%RotorFurl%Orientation(i1,i2) = u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%TranslationVel(i1) - u2%TurbineComponents%RotorFurl%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%TranslationVel(i1) + u3%TurbineComponents%RotorFurl%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%TranslationVel(i1) + t(3)*u2%TurbineComponents%RotorFurl%TranslationVel(i1) - t(2)*u3%TurbineComponents%RotorFurl%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%TranslationVel(i1) = u1%TurbineComponents%RotorFurl%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%RotationVel(i1) - u2%TurbineComponents%RotorFurl%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%RotationVel(i1) + u3%TurbineComponents%RotorFurl%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%RotationVel(i1) + t(3)*u2%TurbineComponents%RotorFurl%RotationVel(i1) - t(2)*u3%TurbineComponents%RotorFurl%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%RotationVel(i1) = u1%TurbineComponents%RotorFurl%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Position,1),UBOUND(u_out%TurbineComponents%Nacelle%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%Position(i1) - u2%TurbineComponents%Nacelle%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%Position(i1) + u3%TurbineComponents%Nacelle%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Position(i1) + t(3)*u2%TurbineComponents%Nacelle%Position(i1) - t(2)*u3%TurbineComponents%Nacelle%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%Position(i1) = u1%TurbineComponents%Nacelle%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,2),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,1),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Nacelle%Orientation(i1,i2) - u2%TurbineComponents%Nacelle%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Nacelle%Orientation(i1,i2) + u3%TurbineComponents%Nacelle%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Nacelle%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Nacelle%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Nacelle%Orientation(i1,i2) = u1%TurbineComponents%Nacelle%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%TranslationVel(i1) - u2%TurbineComponents%Nacelle%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%TranslationVel(i1) + u3%TurbineComponents%Nacelle%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%TranslationVel(i1) + t(3)*u2%TurbineComponents%Nacelle%TranslationVel(i1) - t(2)*u3%TurbineComponents%Nacelle%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%TranslationVel(i1) = u1%TurbineComponents%Nacelle%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%RotationVel(i1) - u2%TurbineComponents%Nacelle%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%RotationVel(i1) + u3%TurbineComponents%Nacelle%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%RotationVel(i1) + t(3)*u2%TurbineComponents%Nacelle%RotationVel(i1) - t(2)*u3%TurbineComponents%Nacelle%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%RotationVel(i1) = u1%TurbineComponents%Nacelle%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Position,1),UBOUND(u_out%TurbineComponents%TailFin%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%Position(i1) - u2%TurbineComponents%TailFin%Position(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%Position(i1) + u3%TurbineComponents%TailFin%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Position(i1) + t(3)*u2%TurbineComponents%TailFin%Position(i1) - t(2)*u3%TurbineComponents%TailFin%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%Position(i1) = u1%TurbineComponents%TailFin%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,2),UBOUND(u_out%TurbineComponents%TailFin%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,1),UBOUND(u_out%TurbineComponents%TailFin%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%TailFin%Orientation(i1,i2) - u2%TurbineComponents%TailFin%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%TailFin%Orientation(i1,i2) + u3%TurbineComponents%TailFin%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Orientation(i1,i2) + t(3)*u2%TurbineComponents%TailFin%Orientation(i1,i2) - t(2)*u3%TurbineComponents%TailFin%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%TailFin%Orientation(i1,i2) = u1%TurbineComponents%TailFin%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1),UBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%TranslationVel(i1) - u2%TurbineComponents%TailFin%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%TranslationVel(i1) + u3%TurbineComponents%TailFin%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%TranslationVel(i1) + t(3)*u2%TurbineComponents%TailFin%TranslationVel(i1) - t(2)*u3%TurbineComponents%TailFin%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%TranslationVel(i1) = u1%TurbineComponents%TailFin%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%RotationVel,1),UBOUND(u_out%TurbineComponents%TailFin%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%RotationVel(i1) - u2%TurbineComponents%TailFin%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%RotationVel(i1) + u3%TurbineComponents%TailFin%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%RotationVel(i1) + t(3)*u2%TurbineComponents%TailFin%RotationVel(i1) - t(2)*u3%TurbineComponents%TailFin%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%RotationVel(i1) = u1%TurbineComponents%TailFin%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%Position,1),UBOUND(u_out%TurbineComponents%Tower%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%Position(i1) - u2%TurbineComponents%Tower%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%Position(i1) + u3%TurbineComponents%Tower%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Position(i1) + t(3)*u2%TurbineComponents%Tower%Position(i1) - t(2)*u3%TurbineComponents%Tower%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%Position(i1) = u1%TurbineComponents%Tower%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Tower%Orientation,2),UBOUND(u_out%TurbineComponents%Tower%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Tower%Orientation,1),UBOUND(u_out%TurbineComponents%Tower%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Tower%Orientation(i1,i2) - u2%TurbineComponents%Tower%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Tower%Orientation(i1,i2) + u3%TurbineComponents%Tower%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Tower%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Tower%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Tower%Orientation(i1,i2) = u1%TurbineComponents%Tower%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%TranslationVel,1),UBOUND(u_out%TurbineComponents%Tower%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%TranslationVel(i1) - u2%TurbineComponents%Tower%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%TranslationVel(i1) + u3%TurbineComponents%Tower%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%TranslationVel(i1) + t(3)*u2%TurbineComponents%Tower%TranslationVel(i1) - t(2)*u3%TurbineComponents%Tower%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%TranslationVel(i1) = u1%TurbineComponents%Tower%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%RotationVel,1),UBOUND(u_out%TurbineComponents%Tower%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%RotationVel(i1) - u2%TurbineComponents%Tower%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%RotationVel(i1) + u3%TurbineComponents%Tower%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%RotationVel(i1) + t(3)*u2%TurbineComponents%Tower%RotationVel(i1) - t(2)*u3%TurbineComponents%Tower%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%RotationVel(i1) = u1%TurbineComponents%Tower%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Position,1),UBOUND(u_out%TurbineComponents%SubStructure%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%Position(i1) - u2%TurbineComponents%SubStructure%Position(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%Position(i1) + u3%TurbineComponents%SubStructure%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Position(i1) + t(3)*u2%TurbineComponents%SubStructure%Position(i1) - t(2)*u3%TurbineComponents%SubStructure%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%Position(i1) = u1%TurbineComponents%SubStructure%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,2),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,1),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%SubStructure%Orientation(i1,i2) - u2%TurbineComponents%SubStructure%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%SubStructure%Orientation(i1,i2) + u3%TurbineComponents%SubStructure%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Orientation(i1,i2) + t(3)*u2%TurbineComponents%SubStructure%Orientation(i1,i2) - t(2)*u3%TurbineComponents%SubStructure%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%SubStructure%Orientation(i1,i2) = u1%TurbineComponents%SubStructure%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%TranslationVel(i1) - u2%TurbineComponents%SubStructure%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%TranslationVel(i1) + u3%TurbineComponents%SubStructure%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%TranslationVel(i1) + t(3)*u2%TurbineComponents%SubStructure%TranslationVel(i1) - t(2)*u3%TurbineComponents%SubStructure%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%TranslationVel(i1) = u1%TurbineComponents%SubStructure%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%RotationVel(i1) - u2%TurbineComponents%SubStructure%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%RotationVel(i1) + u3%TurbineComponents%SubStructure%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%RotationVel(i1) + t(3)*u2%TurbineComponents%SubStructure%RotationVel(i1) - t(2)*u3%TurbineComponents%SubStructure%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%RotationVel(i1) = u1%TurbineComponents%SubStructure%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Position,1),UBOUND(u_out%TurbineComponents%Foundation%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%Position(i1) - u2%TurbineComponents%Foundation%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%Position(i1) + u3%TurbineComponents%Foundation%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Position(i1) + t(3)*u2%TurbineComponents%Foundation%Position(i1) - t(2)*u3%TurbineComponents%Foundation%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%Position(i1) = u1%TurbineComponents%Foundation%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,2),UBOUND(u_out%TurbineComponents%Foundation%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,1),UBOUND(u_out%TurbineComponents%Foundation%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Foundation%Orientation(i1,i2) - u2%TurbineComponents%Foundation%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Foundation%Orientation(i1,i2) + u3%TurbineComponents%Foundation%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Foundation%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Foundation%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Foundation%Orientation(i1,i2) = u1%TurbineComponents%Foundation%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1),UBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%TranslationVel(i1) - u2%TurbineComponents%Foundation%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%TranslationVel(i1) + u3%TurbineComponents%Foundation%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%TranslationVel(i1) + t(3)*u2%TurbineComponents%Foundation%TranslationVel(i1) - t(2)*u3%TurbineComponents%Foundation%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%TranslationVel(i1) = u1%TurbineComponents%Foundation%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%RotationVel,1),UBOUND(u_out%TurbineComponents%Foundation%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%RotationVel(i1) - u2%TurbineComponents%Foundation%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%RotationVel(i1) + u3%TurbineComponents%Foundation%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%RotationVel(i1) + t(3)*u2%TurbineComponents%Foundation%RotationVel(i1) - t(2)*u3%TurbineComponents%Foundation%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%RotationVel(i1) = u1%TurbineComponents%Foundation%RotationVel(i1) + b  + c * t_out
  END DO
  b = (t(3)**2*(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength) + t(2)**2*(-u1%TurbineComponents%BladeLength + u3%TurbineComponents%BladeLength))* scaleFactor
  c = ( (t(2)-t(3))*u1%TurbineComponents%BladeLength + t(3)*u2%TurbineComponents%BladeLength - t(2)*u3%TurbineComponents%BladeLength ) * scaleFactor
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b  + c * t_out
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  DO i2 = LBOUND(u_out%MulTabLoc,2),UBOUND(u_out%MulTabLoc,2)
    DO i1 = LBOUND(u_out%MulTabLoc,1),UBOUND(u_out%MulTabLoc,1)
      b = (t(3)**2*(u1%MulTabLoc(i1,i2) - u2%MulTabLoc(i1,i2)) + t(2)**2*(-u1%MulTabLoc(i1,i2) + u3%MulTabLoc(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%MulTabLoc(i1,i2) + t(3)*u2%MulTabLoc(i1,i2) - t(2)*u3%MulTabLoc(i1,i2) ) * scaleFactor
      u_out%MulTabLoc(i1,i2) = u1%MulTabLoc(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  DO i2 = LBOUND(u_out%InflowVelocity,2),UBOUND(u_out%InflowVelocity,2)
    DO i1 = LBOUND(u_out%InflowVelocity,1),UBOUND(u_out%InflowVelocity,1)
      b = (t(3)**2*(u1%InflowVelocity(i1,i2) - u2%InflowVelocity(i1,i2)) + t(2)**2*(-u1%InflowVelocity(i1,i2) + u3%InflowVelocity(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%InflowVelocity(i1,i2) + t(3)*u2%InflowVelocity(i1,i2) - t(2)*u3%InflowVelocity(i1,i2) ) * scaleFactor
      u_out%InflowVelocity(i1,i2) = u1%InflowVelocity(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%AvgInfVel,1),UBOUND(u_out%AvgInfVel,1)
    b = (t(3)**2*(u1%AvgInfVel(i1) - u2%AvgInfVel(i1)) + t(2)**2*(-u1%AvgInfVel(i1) + u3%AvgInfVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%AvgInfVel(i1) + t(3)*u2%AvgInfVel(i1) - t(2)*u3%AvgInfVel(i1) ) * scaleFactor
    u_out%AvgInfVel(i1) = u1%AvgInfVel(i1) + b  + c * t_out
  END DO
 END SUBROUTINE AD14_Input_ExtrapInterp2


 SUBROUTINE AD14_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Output_ExtrapInterp


 SUBROUTINE AD14_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i1 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp1(y1%OutputLoads(i1), y2%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(y1%Twr_OutputLoads, y2%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp1


 SUBROUTINE AD14_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i1 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp2(y1%OutputLoads(i1), y2%OutputLoads(i1), y3%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(y1%Twr_OutputLoads, y2%Twr_OutputLoads, y3%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp2

END MODULE AeroDyn14_Types
!ENDOFREGISTRYGENERATEDFILE
