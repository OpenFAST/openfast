!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2020  National Renewable Energy Laboratory
!
!    This file is part of SoilDyn.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
MODULE SoilDyn_IO

   USE   SoilDyn_Types
   USE   NWTC_Library

   IMPLICIT NONE



! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 12-Mar-2020 13:30:14.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =   0


     ! Forces:

   INTEGER(IntKi), PARAMETER      :: Sld1Fxg   =   1
   INTEGER(IntKi), PARAMETER      :: Sld1Fyg   =   2
   INTEGER(IntKi), PARAMETER      :: Sld1Fzg   =   3
   INTEGER(IntKi), PARAMETER      :: Sld1Mxg   =   4
   INTEGER(IntKi), PARAMETER      :: Sld1Myg   =   5
   INTEGER(IntKi), PARAMETER      :: Sld1Mzg   =   6
   INTEGER(IntKi), PARAMETER      :: Sld2Fxg   =   7
   INTEGER(IntKi), PARAMETER      :: Sld2Fyg   =   8
   INTEGER(IntKi), PARAMETER      :: Sld2Fzg   =   9
   INTEGER(IntKi), PARAMETER      :: Sld2Mxg   =  10
   INTEGER(IntKi), PARAMETER      :: Sld2Myg   =  11
   INTEGER(IntKi), PARAMETER      :: Sld2Mzg   =  12
   INTEGER(IntKi), PARAMETER      :: Sld3Fxg   =  13
   INTEGER(IntKi), PARAMETER      :: Sld3Fyg   =  14
   INTEGER(IntKi), PARAMETER      :: Sld3Fzg   =  15
   INTEGER(IntKi), PARAMETER      :: Sld3Mxg   =  16
   INTEGER(IntKi), PARAMETER      :: Sld3Myg   =  17
   INTEGER(IntKi), PARAMETER      :: Sld3Mzg   =  18
   INTEGER(IntKi), PARAMETER      :: Sld4Fxg   =  19
   INTEGER(IntKi), PARAMETER      :: Sld4Fyg   =  20
   INTEGER(IntKi), PARAMETER      :: Sld4Fzg   =  21
   INTEGER(IntKi), PARAMETER      :: Sld4Mxg   =  22
   INTEGER(IntKi), PARAMETER      :: Sld4Myg   =  23
   INTEGER(IntKi), PARAMETER      :: Sld4Mzg   =  24
   INTEGER(IntKi), PARAMETER      :: Sld5Fxg   =  25
   INTEGER(IntKi), PARAMETER      :: Sld5Fyg   =  26
   INTEGER(IntKi), PARAMETER      :: Sld5Fzg   =  27
   INTEGER(IntKi), PARAMETER      :: Sld5Mxg   =  28
   INTEGER(IntKi), PARAMETER      :: Sld5Myg   =  29
   INTEGER(IntKi), PARAMETER      :: Sld5Mzg   =  30
   INTEGER(IntKi), PARAMETER      :: Sld6Fxg   =  31
   INTEGER(IntKi), PARAMETER      :: Sld6Fyg   =  32
   INTEGER(IntKi), PARAMETER      :: Sld6Fzg   =  33
   INTEGER(IntKi), PARAMETER      :: Sld6Mxg   =  34
   INTEGER(IntKi), PARAMETER      :: Sld6Myg   =  35
   INTEGER(IntKi), PARAMETER      :: Sld6Mzg   =  36
   INTEGER(IntKi), PARAMETER      :: Sld7Fxg   =  37
   INTEGER(IntKi), PARAMETER      :: Sld7Fyg   =  38
   INTEGER(IntKi), PARAMETER      :: Sld7Fzg   =  39
   INTEGER(IntKi), PARAMETER      :: Sld7Mxg   =  40
   INTEGER(IntKi), PARAMETER      :: Sld7Myg   =  41
   INTEGER(IntKi), PARAMETER      :: Sld7Mzg   =  42
   INTEGER(IntKi), PARAMETER      :: Sld8Fxg   =  43
   INTEGER(IntKi), PARAMETER      :: Sld8Fyg   =  44
   INTEGER(IntKi), PARAMETER      :: Sld8Fzg   =  45
   INTEGER(IntKi), PARAMETER      :: Sld8Mxg   =  46
   INTEGER(IntKi), PARAMETER      :: Sld8Myg   =  47
   INTEGER(IntKi), PARAMETER      :: Sld8Mzg   =  48
   INTEGER(IntKi), PARAMETER      :: Sld9Fxg   =  49
   INTEGER(IntKi), PARAMETER      :: Sld9Fyg   =  50
   INTEGER(IntKi), PARAMETER      :: Sld9Fzg   =  51
   INTEGER(IntKi), PARAMETER      :: Sld9Mxg   =  52
   INTEGER(IntKi), PARAMETER      :: Sld9Myg   =  53
   INTEGER(IntKi), PARAMETER      :: Sld9Mzg   =  54


     ! Displacements:

   INTEGER(IntKi), PARAMETER      :: Sld1TDxg  =  55
   INTEGER(IntKi), PARAMETER      :: Sld1TDyg  =  56
   INTEGER(IntKi), PARAMETER      :: Sld1TDzg  =  57
   INTEGER(IntKi), PARAMETER      :: Sld1RDxg  =  58
   INTEGER(IntKi), PARAMETER      :: Sld1RDyg  =  59
   INTEGER(IntKi), PARAMETER      :: Sld1RDzg  =  60
   INTEGER(IntKi), PARAMETER      :: Sld2TDxg  =  61
   INTEGER(IntKi), PARAMETER      :: Sld2TDyg  =  62
   INTEGER(IntKi), PARAMETER      :: Sld2TDzg  =  63
   INTEGER(IntKi), PARAMETER      :: Sld2RDxg  =  64
   INTEGER(IntKi), PARAMETER      :: Sld2RDyg  =  65
   INTEGER(IntKi), PARAMETER      :: Sld2RDzg  =  66
   INTEGER(IntKi), PARAMETER      :: Sld3TDxg  =  67
   INTEGER(IntKi), PARAMETER      :: Sld3TDyg  =  68
   INTEGER(IntKi), PARAMETER      :: Sld3TDzg  =  69
   INTEGER(IntKi), PARAMETER      :: Sld3RDxg  =  70
   INTEGER(IntKi), PARAMETER      :: Sld3RDyg  =  71
   INTEGER(IntKi), PARAMETER      :: Sld3RDzg  =  72
   INTEGER(IntKi), PARAMETER      :: Sld4TDxg  =  73
   INTEGER(IntKi), PARAMETER      :: Sld4TDyg  =  74
   INTEGER(IntKi), PARAMETER      :: Sld4TDzg  =  75
   INTEGER(IntKi), PARAMETER      :: Sld4RDxg  =  76
   INTEGER(IntKi), PARAMETER      :: Sld4RDyg  =  77
   INTEGER(IntKi), PARAMETER      :: Sld4RDzg  =  78
   INTEGER(IntKi), PARAMETER      :: Sld5TDxg  =  79
   INTEGER(IntKi), PARAMETER      :: Sld5TDyg  =  80
   INTEGER(IntKi), PARAMETER      :: Sld5TDzg  =  81
   INTEGER(IntKi), PARAMETER      :: Sld5RDxg  =  82
   INTEGER(IntKi), PARAMETER      :: Sld5RDyg  =  83
   INTEGER(IntKi), PARAMETER      :: Sld5RDzg  =  84
   INTEGER(IntKi), PARAMETER      :: Sld6TDxg  =  85
   INTEGER(IntKi), PARAMETER      :: Sld6TDyg  =  86
   INTEGER(IntKi), PARAMETER      :: Sld6TDzg  =  87
   INTEGER(IntKi), PARAMETER      :: Sld6RDxg  =  88
   INTEGER(IntKi), PARAMETER      :: Sld6RDyg  =  89
   INTEGER(IntKi), PARAMETER      :: Sld6RDzg  =  90
   INTEGER(IntKi), PARAMETER      :: Sld7TDxg  =  91
   INTEGER(IntKi), PARAMETER      :: Sld7TDyg  =  92
   INTEGER(IntKi), PARAMETER      :: Sld7TDzg  =  93
   INTEGER(IntKi), PARAMETER      :: Sld7RDxg  =  94
   INTEGER(IntKi), PARAMETER      :: Sld7RDyg  =  95
   INTEGER(IntKi), PARAMETER      :: Sld7RDzg  =  96
   INTEGER(IntKi), PARAMETER      :: Sld8TDxg  =  97
   INTEGER(IntKi), PARAMETER      :: Sld8TDyg  =  98
   INTEGER(IntKi), PARAMETER      :: Sld8TDzg  =  99
   INTEGER(IntKi), PARAMETER      :: Sld8RDxg  = 100
   INTEGER(IntKi), PARAMETER      :: Sld8RDyg  = 101
   INTEGER(IntKi), PARAMETER      :: Sld8RDzg  = 102
   INTEGER(IntKi), PARAMETER      :: Sld9TDxg  = 103
   INTEGER(IntKi), PARAMETER      :: Sld9TDyg  = 104
   INTEGER(IntKi), PARAMETER      :: Sld9TDzg  = 105
   INTEGER(IntKi), PARAMETER      :: Sld9RDxg  = 106
   INTEGER(IntKi), PARAMETER      :: Sld9RDyg  = 107
   INTEGER(IntKi), PARAMETER      :: Sld9RDzg  = 108


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts = 108

!End of code generated by Matlab script
! ===================================================================================================
   ! The following simplify my output assigning later in the WriteOutput routine
   integer(IntKi), parameter      :: MaxNumberOfOutputLocations = 9     ! This is based on our coding of 1 digit on output point number
   integer(IntKi), parameter      :: SoilPtF(6,MaxNumberOfOutputLocations) = reshape( (/        &     ! Forces and moments indices
                                       SlD1Fxg, SlD1Fyg, SlD1Fzg, SlD1Mxg, SlD1Myg, SlD1Mzg,    &     ! SoilPt 1
                                       SlD2Fxg, SlD2Fyg, SlD2Fzg, SlD2Mxg, SlD2Myg, SlD2Mzg,    &     ! SoilPt 2
                                       SlD3Fxg, SlD3Fyg, SlD3Fzg, SlD3Mxg, SlD3Myg, SlD3Mzg,    &     ! SoilPt 3
                                       SlD4Fxg, SlD4Fyg, SlD4Fzg, SlD4Mxg, SlD4Myg, SlD4Mzg,    &     ! SoilPt 4
                                       SlD5Fxg, SlD5Fyg, SlD5Fzg, SlD5Mxg, SlD5Myg, SlD5Mzg,    &     ! SoilPt 5
                                       SlD6Fxg, SlD6Fyg, SlD6Fzg, SlD6Mxg, SlD6Myg, SlD6Mzg,    &     ! SoilPt 6
                                       SlD7Fxg, SlD7Fyg, SlD7Fzg, SlD7Mxg, SlD7Myg, SlD7Mzg,    &     ! SoilPt 7
                                       SlD8Fxg, SlD8Fyg, SlD8Fzg, SlD8Mxg, SlD8Myg, SlD8Mzg,    &     ! SoilPt 8
                                       SlD9Fxg, SlD9Fyg, SlD9Fzg, SlD9Mxg, SlD9Myg, SlD9Mzg     &     ! SoilPt 9
                                    /), (/6,MaxNumberOfOutputLocations/) )
   integer(IntKi), parameter      :: SoilPtD(6,MaxNumberOfOutputLocations) = reshape( (/        &     !  Soil point displacements indices
                                       SlD1TDxg,SlD1TDyg,SlD1TDzg,SlD1RDxg,SlD1RDyg,SlD1RDzg,   &     ! SoilPt 1
                                       SlD2TDxg,SlD2TDyg,SlD2TDzg,SlD2RDxg,SlD2RDyg,SlD2RDzg,   &     ! SoilPt 2
                                       SlD3TDxg,SlD3TDyg,SlD3TDzg,SlD3RDxg,SlD3RDyg,SlD3RDzg,   &     ! SoilPt 3
                                       SlD4TDxg,SlD4TDyg,SlD4TDzg,SlD4RDxg,SlD4RDyg,SlD4RDzg,   &     ! SoilPt 4
                                       SlD5TDxg,SlD5TDyg,SlD5TDzg,SlD5RDxg,SlD5RDyg,SlD5RDzg,   &     ! SoilPt 5
                                       SlD6TDxg,SlD6TDyg,SlD6TDzg,SlD6RDxg,SlD6RDyg,SlD6RDzg,   &     ! SoilPt 6
                                       SlD7TDxg,SlD7TDyg,SlD7TDzg,SlD7RDxg,SlD7RDyg,SlD7RDzg,   &     ! SoilPt 7
                                       SlD8TDxg,SlD8TDyg,SlD8TDzg,SlD8RDxg,SlD8RDyg,SlD8RDzg,   &     ! SoilPt 8
                                       SlD9TDxg,SlD9TDyg,SlD9TDzg,SlD9RDxg,SlD9RDyg,SlD9RDzg    &     ! SoilPt 9
                                    /), (/6,MaxNumberOfOutputLocations/) )
! ===================================================================================================

CONTAINS


!====================================================================================================
!>  This public subroutine reads the input required for SoilDyn from the file whose name is an
!!     input parameter.
subroutine SlD_ReadInput( InputFileName, EchoFileName, InputFileData, ErrStat, ErrMsg )

   character(*),                       intent(in   )  :: InputFileName        !< name of the input file
   character(*),                       intent(in   )  :: EchoFileName         !< name of the echo file
   type(SlD_InputFile),                intent(inout)  :: InputFileData        !< The data for initialization
   integer(IntKi),                     intent(  out)  :: ErrStat              !< Returned error status  from this subroutine
   character(*),                       intent(  out)  :: ErrMsg               !< Returned error message from this subroutine

   integer(IntKi)                                     :: UnitInput            !< Unit number for the input file
   integer(IntKi)                                     :: UnitEcho             !< The local unit number for this module's echo file
   character(35)                                      :: Frmt                 !< Output format for logical parameters. (matches NWTC Subroutine Library format)
   character(200)                                     :: Line                 !< Temporary storage of a line from the input file (to compare with "default")
   integer(IntKi)                                     :: LineLen              !< Length of the line read
   integer(IntKi)                                     :: i                    !< Generic counter

   integer(IntKi)                                     :: TmpErrStat           !< Temporary error status
   integer(IntKi)                                     :: IOS                  !< Temporary error status
   character(ErrMsgLen)                               :: TmpErrMsg            !< Temporary error message
   character(1024)                                    :: PriPath              !< Path name of the primary file
   character(*),                       PARAMETER      :: RoutineName="SlD_ReadInput"


      ! Initialize local data

   UnitEcho                = -1
   Frmt                    = "( 2X, L11, 2X, A, T30, ' - ', A )"
   ErrStat                 = ErrID_None
   ErrMsg                  = ""
   InputFileData%EchoFlag  = .FALSE.  ! initialize for error handling (cleanup() routine)
   CALL GetPath( InputFileName, PriPath )    ! Input files will be relative to the path where the primary input file is located.


      ! allocate the array for the OutList
   CALL AllocAry( InputFileData%OutList, MaxOutPts, "SoilDyn Input File's OutList", TmpErrStat, TmpErrMsg ); if (Failed()) return;

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL GetNewUnit( UnitInput, TmpErrStat, TmpErrMsg ); if (Failed()) return;
   CALL OpenFInpFile( UnitInput, TRIM(InputFileName), TmpErrStat, TmpErrMsg ); if (Failed()) return;


   !-------------------------------------------------------------------------------------------------
   ! File header
   !-------------------------------------------------------------------------------------------------

   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file header line 1',   TmpErrStat, TmpErrMsg );   if (Failed()) return;
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file header line 2',   TmpErrStat, TmpErrMsg );   if (Failed()) return;
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg );   if (Failed()) return;

     ! Echo Input Files.
   call ReadVar ( UnitInput, InputFileName, InputFileData%EchoFlag, 'Echo', 'Echo Input', TmpErrStat, TmpErrMsg ); if (Failed()) return;

      ! If we are Echoing the input then we should re-read the first three lines so that we can echo them
      ! using the NWTC_Library routines.  The echoing is done inside those routines via a global variable
      ! which we must store, set, and then replace on error or completion.
   IF ( InputFileData%EchoFlag ) THEN
      call OpenEcho ( UnitEcho, TRIM(EchoFileName), TmpErrStat, TmpErrMsg ); if (Failed()) return;
      rewind(UnitInput)

      call ReadCom( UnitInput, InputFileName, 'SoilDyn input file header line 1',   TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;
      call ReadCom( UnitInput, InputFileName, 'SoilDyn input file header line 2',   TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;
      call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;

         ! Echo Input Files.
      call ReadVar ( UnitInput, InputFileName, InputFileData%EchoFlag, 'Echo', 'Echo the input file data', TmpErrStat, TmpErrMsg, UnitEcho ); if (Failed()) return;
   end if

      ! DT - Time interval for SoilDyn calculations {or default} (s):
   CALL ReadVar( UnitInput, InputFileName, Line, "DT", "Time interval for soil calculations {or default} (s)", TmpErrStat, TmpErrMsg, UnitEcho); if (Failed()) return;
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTAero
         READ( Line, *, IOSTAT=IOS) InputFileData%DT
            CALL CheckIOS ( IOS, InputFileName, 'DT', NumType, TmpErrStat, TmpErrMsg ); if (Failed()) return;
      END IF

      ! CalcOption -- option on which calculation methodology to use {1: Stiffness / Damping matrices, 2: P-Y curves [unavailable], 3: coupled REDWIN DLL}
   call ReadVar( UnitInput, InputFileName, InputFileData%CalcOption, "CalcOption", "Calculation methodology to use", TmpErrStat, TmpErrMsg, UnitEcho); if (Failed()) return;


   !-------------------------------------------------------------------------------------------------
   !> Read Stiffness / Damping section [ CalcOption == 1 only ]      Calc_StiffDamp
   !-------------------------------------------------------------------------------------------------

   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;

      ! In general, the stiffness and damping matrices will have the following symetries:
   !  K11 = K22
   !  K15 = -K24
   !  K51 = -K42
   !  K55 = K44

      ! Location
      !NOTE: only 1 SD_location allowed at present. TODO allow multiple SD_locations
   allocate( InputFileData%SD_locations(3,1), STAT=TmpErrStat )      ! InputFileData%SD_NumPoints
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate SD_locations', ErrStat, ErrMsg, RoutineName)
   call ReadAry( UnitInput, InputFileName, InputFileData%SD_locations(1:3,1), 3, 'SD_locations', 'Stiffness Damping location', TmpErrStat, TmpErrMsg, UnitEcho); if (Failed()) return;

      ! Stiffness
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   call AllocAry( InputFileData%Stiffness, 6, 6, 1, 'Stiffness matrices', TmpErrStat, TmpErrMsg ); if (Failed()) return;
   do i=1,6
      call ReadAry( UnitInput, InputFileName, InputFileData%Stiffness(i,:,1), 6, 'Stiffness', 'Elastic stiffness matrix', TmpErrStat, TmpErrMsg, UnitEcho); if (Failed()) return;
   enddo

      ! Damping
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   call AllocAry( InputFileData%Damping, 6, 6, 1, 'Damping matrices', TmpErrStat, TmpErrMsg ); if (Failed()) return;
   do i=1,6
      call ReadAry( UnitInput, InputFileName, InputFileData%Damping(i,:,1), 6, 'Damping', 'Elastic damping ratio (-)',    TmpErrStat, TmpErrMsg, UnitEcho); if (Failed()) return;
   enddo

   !-------------------------------------------------------------------------------------------------
   !> Read P-Y curve section  [ CalcOption == 2 only ]               Calc_PYcurve  
   !-------------------------------------------------------------------------------------------------

   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   call ReadVar( UnitInput, InputFileName, InputFileData%PY_NumPoints, "PY_NumPoints", "Number of PY curve points", TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;

      ! Allocate arrays to hold the information that will be read in next
   allocate( InputFileData%PY_locations(3,InputFileData%PY_NumPoints), STAT=TmpErrStat )
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate PY_locations', ErrStat, ErrMsg, RoutineName)
   allocate( InputFileData%PY_inputFile(InputFileData%PY_NumPoints), STAT=TmpErrStat )
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate PY_inputFile', ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) then
      call CleanUp()
      return
   endif

      ! Now read in the set of PY curves
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line in PY curve data',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;

      ! Read in each line of location and input file ( ---- Location (x,y,z) ------- Point InputFile ------------- )
   do i=1,InputFileData%PY_NumPoints
      call ReadLine( UnitInput, '', Line, LineLen, TmpErrStat )
      if (TmpErrStat /= 0) then
         call SetErrStat( ErrID_Fatal, 'Error reading PY_curve line '//trim(Num2LStr(i))//' from '//InputFileName//'.', ErrStat, ErrMsg, RoutineName)
         return
      endif
      READ( Line, *, IOSTAT=IOS) InputFileData%PY_locations(1:3,i), InputFileData%PY_inputFile(i)
      CALL CheckIOS ( IOS, InputFileName, 'DT', NumType, TmpErrStat, TmpErrMsg ); if (Failed()) return;        ! NOTE: unclear if the message returned will match what was misread.

         ! Check for relative paths in the file names
      if ( PathIsRelative( InputFileData%PY_inputFile(i) ) ) InputFileData%PY_inputFile(i) = TRIM(PriPath)//TRIM(InputFileData%PY_inputFile(i))

         ! Add stuff to echo file if it is used
      if ( InputFileData%EchoFlag ) then
         write(UnitEcho,*) '              Location ('//trim(Num2LStr(i))//')'
         write(UnitEcho,*) InputFileData%PY_locations(1:3,i), trim(InputFileData%PY_inputFile(i))
      endif
   enddo


   !-------------------------------------------------------------------------------------------------
   !> Read REDWIN interface for DLL  section  [ CalcOption == 3 only ]     Calc_REDWIN   
   !-------------------------------------------------------------------------------------------------


   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;

!FIXME: parse out the 's' option.
      ! DLL model, and optionally only use stiffness matrix in response calcs
   call ReadVar( UnitInput, InputFileName, InputFileData%DLL_modelChr,  "DLL_Model",      "REDWIN DLL model to use",    TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;
   call Conv2UC( InputFileData%DLL_modelChr )    ! Convert Line to upper case.

   call ReadVar( UnitInput, InputFileName, InputFileData%DLL_FileName,  "DLL_FileName",   "REDWIN DLL model used",      TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;
   call ReadVar( UnitInput, InputFileName, InputFileData%DLL_NumPoints, "DLL_NumPoints",  "Number of DLL interfaces",   TmpErrStat, TmpErrMsg, UnitEcho );  if (Failed()) return;

      ! Allocate arrays to hold the information that will be read in next
   allocate( InputFileData%DLL_locations(3,InputFileData%DLL_NumPoints), STAT=TmpErrStat )
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate DLL_locations', ErrStat, ErrMsg, RoutineName)
   allocate( InputFileData%DLL_PropsFile(InputFileData%DLL_NumPoints), STAT=TmpErrStat )
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate DLL_PropsFile', ErrStat, ErrMsg, RoutineName)
   allocate( InputFileData%DLL_LDispFile(InputFileData%DLL_NumPoints), STAT=TmpErrStat )
   if (TmpErrStat /= 0)    call SetErrStat(ErrID_Fatal, 'Could not allocate DLL_LDispFile', ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) then
      call CleanUp()
      return
   endif

      ! Now read in the set of DLL connections
   call ReadCom( UnitInput, InputFileName, 'SoilDyn input file separator line in DLL data',  TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;

      ! Read in each line of location and input file ( ---- Location (x,y,z) ------- Point InputFile ------------- )
   do i=1,InputFileData%DLL_NumPoints
      call ReadLine( UnitInput, '', Line, LineLen, TmpErrStat )
      if (TmpErrStat /= 0) then
         call SetErrStat( ErrID_Fatal, 'Error reading DLL_curve line '//trim(Num2LStr(i))//' from '//InputFileName//'.', ErrStat, ErrMsg, RoutineName)
         return
      endif
      READ( Line, *, IOSTAT=IOS) InputFileData%DLL_locations(1:3,i), InputFileData%DLL_PropsFile(i), InputFileData%DLL_LDispFile(i)
      CALL CheckIOS ( IOS, InputFileName, 'DLL info', NumType, TmpErrStat, TmpErrMsg ); if (Failed()) return;        ! NOTE: unclear if the message returned will match what was misread.

         ! Check for relative paths in the file names
      if ( PathIsRelative( InputFileData%DLL_PropsFile(i) ) ) InputFileData%DLL_PropsFile(i) = TRIM(PriPath)//TRIM(InputFileData%DLL_PropsFile(i))
      if ( PathIsRelative( InputFileData%DLL_LDispFile(i) ) ) InputFileData%DLL_LDispFile(i) = TRIM(PriPath)//TRIM(InputFileData%DLL_LDispFile(i))

         ! Add stuff to echo file if it is used
      if ( InputFileData%EchoFlag ) then
         write(UnitEcho,*) '              Location ('//trim(Num2LStr(i))//')'
         write(UnitEcho,*) InputFileData%DLL_locations(1:3,i), trim(InputFileData%DLL_PropsFile(i)), '               ',trim(InputFileData%DLL_LDispFile(i)), '               ',trim(InputFileData%DLL_FileName)
      endif
   enddo

   InputFileData%DLL_ProcName = 'INTERFACEFOUNDATION'       ! This is hard coded for now

   !---------------------- OUTPUT --------------------------------------------------
   CALL ReadCom( UnitInput, InputFileName, 'Section Header: Output', TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   CALL SetErrStat( TmpErrStat, TmpErrMsg, ErrStat, ErrMsg, RoutineName )

      ! SumPrint - Print summary data to <RootName>.IfW.sum (flag):
   CALL ReadVar( UnitInput, InputFileName, InputFileData%SumPrint, "SumPrint", "Print summary data to <RootName>.SlD.sum (flag)", TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   CALL SetErrStat( TmpErrStat, TmpErrMsg, ErrStat, ErrMsg, RoutineName )


   !---------------------- OUTLIST  --------------------------------------------
   CALL ReadCom( UnitInput, InputFileName, 'Section Header: OutList', TmpErrStat, TmpErrMsg, UnitEcho );   if (Failed()) return;
   CALL SetErrStat( TmpErrStat, TmpErrMsg, ErrStat, ErrMsg, RoutineName )

      ! OutList - List of user-requested output channels (-):     -- uses routine from the NWTC_Library
   CALL ReadOutputList ( UnitInput, InputFileName, InputFileData%OutList, InputFileData%NumOuts, 'OutList',    &
               "List of user-requested output channels", TmpErrStat, TmpErrMsg, UnitEcho  );   if (Failed()) return;



   !-------------------------------------------------------------------------------------------------
   ! This is the end of the input file
   !-------------------------------------------------------------------------------------------------

   call Cleanup()
   return

      CONTAINS
         logical function Failed()
            call SetErrStat( TmpErrStat, TmpErrMsg, ErrStat, ErrMsg, RoutineName )
            Failed =  ErrStat >= AbortErrLev
            if (ErrStat >= AbortErrLev) call CleanUp()
         end function Failed
         subroutine Cleanup()
               ! Close input file
            close ( UnitInput )
               ! Cleanup the Echo file and global variables
            if ( InputFileData%EchoFlag ) then
               close(UnitEcho)
            end if
         end subroutine Cleanup

END SUBROUTINE SlD_ReadInput


!====================================================================================================
!> This private subroutine verifies the input required for SoilDyn is correctly specified.  This
!! routine checkes all the parameters that are common with all the wind types, then calls subroutines
!! that check the parameters specific to each wind type.  Only the parameters corresponding to the
!! desired wind type are evaluated; the rest are ignored.  Additional checks will be performed after
!! the respective wind file has been read in, but these checks will be performed within the respective
!! wind module.
!
!  The reason for structuring it this way is to allow for relocating the validation routines for the
!  wind type into their respective modules. It might also prove useful later if we change languages
!  but retain the fortran wind modules.
SUBROUTINE SlD_ValidateInput( InitInp, InputFileData, ErrStat, ErrMsg )
   TYPE(SlD_InitInputType),            INTENT(IN   )  :: InitInp              !< Input data for initialization
   TYPE(SlD_InputFile),                INTENT(INOUT)  :: InputFileData        !< The data for initialization
   INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat              !< Error status  from this subroutine
   CHARACTER(*),                       INTENT(  OUT)  :: ErrMsg               !< Error message from this subroutine
   INTEGER(IntKi)                                     :: ErrStat2             !< Temporary error status  for subroutine and function calls
   CHARACTER(ErrMsgLen)                               :: ErrMsg2              !< Temporary error message for subroutine and function calls
   INTEGER(IntKi)                                     :: I                    !< Generic counter
   CHARACTER(*),                       PARAMETER      :: RoutineName="SlD_ValidateInput"
   integer(IntKi)                                     :: IOS                  !< Temporary error status

      ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""

    select case(InputFileData%CalcOption)
      case (Calc_StiffDamp)
         call ValidateStiffnessMatrix()
      case (Calc_PYcurve)
         call ValidatePYcurves()
      case (Calc_REDWIN)
         call ValidateDLL()
   end select


CONTAINS
   subroutine ValidateStiffnessMatrix()
      call CheckWtrDepth( InputFileData%SD_locations, 'SD locations', ErrStat2, ErrMsg2)
         call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      ! Notify user that damping does not yet work
      if (maxval(abs(InputFileData%Damping)) > epsilon(1.0_ReKi)) then
         call SetErrStat( ErrID_Severe, 'Damping matrix not supported yet with CalcOption==1 in SoilDyn.  Ignoring values entered.', ErrStat, ErrMsg, RoutineName)
      endif
   end subroutine ValidateStiffnessMatrix

   subroutine ValidatePYcurves()
      call CheckWtrDepth( InputFileData%PY_locations, 'PY locations', ErrStat2, ErrMsg2)
         call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      ! Placeholder
   end subroutine ValidatePYcurves

   subroutine ValidateDLL()
      call CheckWtrDepth( InputFileData%DLL_locations, 'DLL locations', ErrStat2, ErrMsg2)
         call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)

      ! Check the model
      read( InputFileData%DLL_modelChr(1:1), *, IOSTAT=IOS ) InputFileData%DLL_model
         call CheckIOS ( IOS, "", 'DLL_model', NumType, ErrStat2, ErrMsg2 )
         call SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         if ( ErrStat >= AbortErrLev ) return
      if ( InputFileData%DLL_model > 3_IntKi .or. InputFileData%DLL_model < 1_IntKi ) then
         call SetErrStat( ErrID_Fatal,' DLL_Model must be 1, 2, or 3', ErrStat,ErrMsg,RoutineName)
      endif
      ! Disable option 1 and 3
      if ( InputFileData%DLL_model /= 2_IntKi ) then
         call SetErrStat( ErrID_Fatal,' Only DLL_Model 2 is currently supported and validated.', ErrStat,ErrMsg,RoutineName)
         return
      endif
      InputFileData%DLL_OnlyStiff = .false.
      if (LEN_TRIM(InputFileData%DLL_modelChr) > 1_IntKi ) then
         if ( InputFileData%DLL_modelChr(2:2) == 'S' ) then
            InputFileData%DLL_OnlyStiff = .true.
            call SetErrStat( ErrID_Info, ' Using only the stiffness matrices from the REDWIN DLL', ErrStat,ErrMsg,RoutineName )
         else
            call SetErrStat( ErrID_Fatal, ' Unknown option '''//InputFileData%DLL_modelChr(2:2)//''' on the DLL_model', ErrStat,ErrMsg,RoutineName)
         endif
      endif

   end subroutine ValidateDLL

   subroutine CheckWtrDepth(Depths,InfoDesc,ErrStat3,ErrMsg3)
      real(ReKi),             intent(in   ) :: Depths(:,:)
      character(*),           intent(in   ) :: InfoDesc
      integer(IntKi),         intent(  out) :: ErrStat3
      character(ErrMsgLen),   intent(  out)  :: ErrMsg3
      ErrStat3 = ErrID_None
      ErrMsg3  = ''
      do i = 1,size(Depths,dim=2)
         if (Depths(3,i) > -abs(InitInp%WtrDpth)) then
            call SetErrStat( ErrID_Fatal, ' Soil location '//trim(Num2LStr(i))//' ('//trim(Num2LStr(Depths(3,i)))//  &
                  ' m) for '//trim(InfoDesc)//' is above mudline',ErrStat3,ErrMsg3,'')
         endif
      enddo
      if (ErrStat3 /= ErrID_None)   ErrMsg3=trim(ErrMsg3)//NewLine//'Water depth passed to SoilDyn = '//trim(Num2LStr(InitInp%WtrDpth))//' m'
      return
   end subroutine CheckWtrDepth

END SUBROUTINE SlD_ValidateInput



!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
!! warning if any of the channels are not available outputs from the module.
!!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!!  the sign is set to 0 if the channel is invalid.
!! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!! 
!! This routine was generated by Write_ChckOutLst.m using the parameters listed in OutListParameters.xlsx at 12-Mar-2020 13:30:14.
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN   )  :: OutList(:)                          !< The list out user-requested outputs
   TYPE(SlD_ParameterType),   INTENT(INOUT)  :: p                                   !< The module parameters
   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat                             !< The error status code
   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg                              !< The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(108) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "SLD1FXG  ","SLD1FYG  ","SLD1FZG  ","SLD1MXG  ","SLD1MYG  ","SLD1MZG  ","SLD1RDXG ", &
                               "SLD1RDYG ","SLD1RDZG ","SLD1TDXG ","SLD1TDYG ","SLD1TDZG ","SLD2FXG  ","SLD2FYG  ", &
                               "SLD2FZG  ","SLD2MXG  ","SLD2MYG  ","SLD2MZG  ","SLD2RDXG ","SLD2RDYG ","SLD2RDZG ", &
                               "SLD2TDXG ","SLD2TDYG ","SLD2TDZG ","SLD3FXG  ","SLD3FYG  ","SLD3FZG  ","SLD3MXG  ", &
                               "SLD3MYG  ","SLD3MZG  ","SLD3RDXG ","SLD3RDYG ","SLD3RDZG ","SLD3TDXG ","SLD3TDYG ", &
                               "SLD3TDZG ","SLD4FXG  ","SLD4FYG  ","SLD4FZG  ","SLD4MXG  ","SLD4MYG  ","SLD4MZG  ", &
                               "SLD4RDXG ","SLD4RDYG ","SLD4RDZG ","SLD4TDXG ","SLD4TDYG ","SLD4TDZG ","SLD5FXG  ", &
                               "SLD5FYG  ","SLD5FZG  ","SLD5MXG  ","SLD5MYG  ","SLD5MZG  ","SLD5RDXG ","SLD5RDYG ", &
                               "SLD5RDZG ","SLD5TDXG ","SLD5TDYG ","SLD5TDZG ","SLD6FXG  ","SLD6FYG  ","SLD6FZG  ", &
                               "SLD6MXG  ","SLD6MYG  ","SLD6MZG  ","SLD6RDXG ","SLD6RDYG ","SLD6RDZG ","SLD6TDXG ", &
                               "SLD6TDYG ","SLD6TDZG ","SLD7FXG  ","SLD7FYG  ","SLD7FZG  ","SLD7MXG  ","SLD7MYG  ", &
                               "SLD7MZG  ","SLD7RDXG ","SLD7RDYG ","SLD7RDZG ","SLD7TDXG ","SLD7TDYG ","SLD7TDZG ", &
                               "SLD8FXG  ","SLD8FYG  ","SLD8FZG  ","SLD8MXG  ","SLD8MYG  ","SLD8MZG  ","SLD8RDXG ", &
                               "SLD8RDYG ","SLD8RDZG ","SLD8TDXG ","SLD8TDYG ","SLD8TDZG ","SLD9FXG  ","SLD9FYG  ", &
                               "SLD9FZG  ","SLD9MXG  ","SLD9MYG  ","SLD9MZG  ","SLD9RDXG ","SLD9RDYG ","SLD9RDZG ", &
                               "SLD9TDXG ","SLD9TDYG ","SLD9TDZG "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(108) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                  Sld1Fxg ,   Sld1Fyg ,   Sld1Fzg ,   Sld1Mxg ,   Sld1Myg ,   Sld1Mzg ,  Sld1RDxg , &
                                 Sld1RDyg ,  Sld1RDzg ,  Sld1TDxg ,  Sld1TDyg ,  Sld1TDzg ,   Sld2Fxg ,   Sld2Fyg , &
                                  Sld2Fzg ,   Sld2Mxg ,   Sld2Myg ,   Sld2Mzg ,  Sld2RDxg ,  Sld2RDyg ,  Sld2RDzg , &
                                 Sld2TDxg ,  Sld2TDyg ,  Sld2TDzg ,   Sld3Fxg ,   Sld3Fyg ,   Sld3Fzg ,   Sld3Mxg , &
                                  Sld3Myg ,   Sld3Mzg ,  Sld3RDxg ,  Sld3RDyg ,  Sld3RDzg ,  Sld3TDxg ,  Sld3TDyg , &
                                 Sld3TDzg ,   Sld4Fxg ,   Sld4Fyg ,   Sld4Fzg ,   Sld4Mxg ,   Sld4Myg ,   Sld4Mzg , &
                                 Sld4RDxg ,  Sld4RDyg ,  Sld4RDzg ,  Sld4TDxg ,  Sld4TDyg ,  Sld4TDzg ,   Sld5Fxg , &
                                  Sld5Fyg ,   Sld5Fzg ,   Sld5Mxg ,   Sld5Myg ,   Sld5Mzg ,  Sld5RDxg ,  Sld5RDyg , &
                                 Sld5RDzg ,  Sld5TDxg ,  Sld5TDyg ,  Sld5TDzg ,   Sld6Fxg ,   Sld6Fyg ,   Sld6Fzg , &
                                  Sld6Mxg ,   Sld6Myg ,   Sld6Mzg ,  Sld6RDxg ,  Sld6RDyg ,  Sld6RDzg ,  Sld6TDxg , &
                                 Sld6TDyg ,  Sld6TDzg ,   Sld7Fxg ,   Sld7Fyg ,   Sld7Fzg ,   Sld7Mxg ,   Sld7Myg , &
                                  Sld7Mzg ,  Sld7RDxg ,  Sld7RDyg ,  Sld7RDzg ,  Sld7TDxg ,  Sld7TDyg ,  Sld7TDzg , &
                                  Sld8Fxg ,   Sld8Fyg ,   Sld8Fzg ,   Sld8Mxg ,   Sld8Myg ,   Sld8Mzg ,  Sld8RDxg , &
                                 Sld8RDyg ,  Sld8RDzg ,  Sld8TDxg ,  Sld8TDyg ,  Sld8TDzg ,   Sld9Fxg ,   Sld9Fyg , &
                                  Sld9Fzg ,   Sld9Mxg ,   Sld9Myg ,   Sld9Mzg ,  Sld9RDxg ,  Sld9RDyg ,  Sld9RDzg , &
                                 Sld9TDxg ,  Sld9TDyg ,  Sld9TDzg /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(108) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(kN)      ","(kN)      ","(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ", &
                               "(deg)     ","(deg)     ","(m)       ","(m)       ","(m)       ","(kN)      ","(kN)      ", &
                               "(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ","(deg)     ","(deg)     ", &
                               "(m)       ","(m)       ","(m)       ","(kN)      ","(kN)      ","(kN)      ","(kN-m)    ", &
                               "(kN-m)    ","(kN-m)    ","(deg)     ","(deg)     ","(deg)     ","(m)       ","(m)       ", &
                               "(m)       ","(kN)      ","(kN)      ","(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ", &
                               "(deg)     ","(deg)     ","(deg)     ","(m)       ","(m)       ","(m)       ","(kN)      ", &
                               "(kN)      ","(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ","(deg)     ", &
                               "(deg)     ","(m)       ","(m)       ","(m)       ","(kN)      ","(kN)      ","(kN)      ", &
                               "(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ","(deg)     ","(deg)     ","(m)       ", &
                               "(m)       ","(m)       ","(kN)      ","(kN)      ","(kN)      ","(kN-m)    ","(kN-m)    ", &
                               "(kN-m)    ","(deg)     ","(deg)     ","(deg)     ","(m)       ","(m)       ","(m)       ", &
                               "(kN)      ","(kN)      ","(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ", &
                               "(deg)     ","(deg)     ","(m)       ","(m)       ","(m)       ","(kN)      ","(kN)      ", &
                               "(kN)      ","(kN-m)    ","(kN-m)    ","(kN-m)    ","(deg)     ","(deg)     ","(deg)     ", &
                               "(m)       ","(m)       ","(m)       "/)

   character(4) :: TmpPrefix

      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....
      ! Check outputs based on how many points (p%NumPoints) we are interfacing with soil
      ! --> Loop through possible output names and check leading prefix.
      !     If it is above the number of points interfacing to soil, mark invalid.
   do I=p%NumPoints+1,MaxNumberOfOutputLocations
      TmpPrefix='SLD'//trim(Num2LStr(I))
      do J=1,MaxOutPts
         if ( INDEX(TmpPrefix, ValidParamAry(J)(1:len(TmpPrefix))) == 1 )     InvalidOutput( ParamIndxAry(J) ) = .TRUE.
      enddo
   enddo
!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the SoilDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************


!====================================================================================================
SUBROUTINE SlD_OpenSumFile( SumFileUnit, SummaryName, IfW_Prog, WindType, ErrStat, ErrMsg )
   INTEGER(IntKi),                  INTENT(  OUT)  :: SumFileUnit    !< the unit number for the SoilDynsummary file
   CHARACTER(*),                    INTENT(IN   )  :: SummaryName    !< the name of the SoilDyn summary file
   TYPE(ProgDesc),                  INTENT(IN   )  :: IfW_Prog       !< the name/version/date of the SoilDyn program
   INTEGER(IntKi),                  INTENT(IN   )  :: WindType       !< type identifying what wind we are using
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat        !< returns a non-zero value when an error occurs
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None
   INTEGER(IntKi)                                  :: TmpErrStat     !< Temporary error status for checking how the WRITE worked

       ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""

   SumFileUnit = -1
   CALL GetNewUnit( SumFileUnit )
   CALL OpenFOutFile ( SumFileUnit, SummaryName, ErrStat, ErrMsg )
   IF (ErrStat >=AbortErrLev) RETURN

         ! Write the summary file header
   WRITE(SumFileUnit,'(/,A/)',IOSTAT=TmpErrStat)   'This summary file was generated by '//TRIM( IfW_Prog%Name )//&
                     ' '//TRIM( IfW_Prog%Ver )//' on '//CurDate()//' at '//CurTime()//'.'
   WRITE(SumFileUnit,'(A14,I1)',IOSTAT=TmpErrStat) '  WindType:   ',WindType
   IF ( TmpErrStat /= 0 ) THEN
      CALL SetErrStat(ErrID_Fatal,'Error writing to summary file.',ErrStat,ErrMsg,'')
      RETURN
   END IF
END SUBROUTINE SlD_OpenSumFile
!====================================================================================================
SUBROUTINE SlD_CloseSumFile( SumFileUnit, ErrStat, ErrMsg )
   INTEGER(IntKi),                  INTENT(INOUT)  :: SumFileUnit    !< the unit number for the SoilDynsummary file
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat        !< returns a non-zero value when an error occurs
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None
   INTEGER(IntKi)                                  :: TmpErrStat
   CHARACTER(1024)                                 :: TmpErrMsg

      ! Initialize ErrStat
   ErrStat     = ErrID_None
   ErrMsg      = ''
   TmpErrStat  = ErrID_None
   TmpErrMsg   = ''

      ! Write any closing information in the summary file
   IF ( SumFileUnit > 0_IntKi ) THEN
      WRITE (SumFileUnit,'(/,A/)', IOSTAT=TmpErrStat)  'This summary file was closed on '//CurDate()//' at '//CurTime()//'.'
      IF (TmpErrStat /= 0_IntKi)    CALL SetErrStat( ErrID_Fatal, 'Problem writing to the SoilDyn summary file.', ErrStat, ErrMsg, '' )

         ! Close the file
      CLOSE( SumFileUnit, IOSTAT=TmpErrStat )
      IF (TmpErrStat /= 0_IntKi)    CALL SetErrStat( ErrID_Fatal, 'Problem closing the SoilDyn summary file.', ErrStat, ErrMsg, '' )
   END IF
END SUBROUTINE SlD_CloseSumFile
!====================================================================================================

!> Set the output channels
!! Note:    there is an assumption here that only small angle deflections will occur
subroutine SlD_WriteOutput(p, AllOuts, u, y, m, ErrStat, ErrMsg )

   type(SlD_ParameterType),      intent(in   )  :: p                                !< The module parameters
   real(ReKi),                   intent(inout)  :: AllOuts(0:)                      !< array of values to potentially write to file
   type(SlD_InputType),          intent(in   )  :: u                                !< inputs
   type(SlD_OutputType),         intent(in   )  :: y                                !< outputs
   type(SlD_MiscVarType),        intent(inout)  :: m                                !< misc/optimization variables (for computing mesh transfers)
   integer(IntKi),               intent(  out)  :: ErrStat                          !< The error status code
   character(*),                 intent(  out)  :: ErrMsg                           !< The error message, if an error occurred

      ! local variables
   character(*), parameter                      :: RoutineName = 'SlD_WriteOutput'
   integer(IntKi)                               :: i,j                              !  generic counters
   real(ReKi)                                   :: Theta(3)                         !  euler angle extraction (small angle assumption required for this module anyhow)

   ErrStat  =  ErrID_None
   ErrMsg   =  ''
   AllOuts  = 0.0_ReKi
   if (p%NumOuts < 1)   return

      ! Cycle through the soil interaction points only (all the others are marked invalid anyhow)
   do i=1,p%NumPoints
         ! Forces
      do j=1,3
         AllOuts( SoilPtF(j,i) )  =  real( -m%ForceTotal(j,i) / 1000.0_ReKi, SiKi )
      enddo

         ! Moments
      do j=4,6
         AllOuts( SoilPtF(j,i) )  =  real( -m%ForceTotal(j,i) / 1000.0_ReKi, SiKi )
      enddo

         ! Translation displacement
      do j=1,3
         AllOuts( SoilPtD(j  ,i) )  =  real( u%SoilMesh%TranslationDisp(j,i), SiKi )
      enddo

         ! We have defined the referene orientatation aligned with XYZ, so we don't need as much math here.
         ! Small angle assumption must be valid for computations in this module, so GetSmllRotAngs extract is sufficient
      Theta =  real( GetSmllRotAngs(u%SoilMesh%Orientation(1:3,1:3,i), ErrStat, ErrMsg), ReKi)       ! orientations are double
      do j=1,3
         AllOuts( SoilPtD(j+3,i) )  =  Theta(j)*R2D
      enddo
   enddo




end subroutine SlD_WriteOutput
!**********************************************************************************************************************************
END MODULE SoilDyn_IO
