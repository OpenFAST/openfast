!STARTOFREGISTRYGENERATEDFILE 'Current_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Current_Types
!.................................................................................................................................
! This file is part of Current.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Current. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Current_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Current_InitInputType  =======
  TYPE, PUBLIC :: Current_InitInputType
    REAL(SiKi)  :: CurrSSV0 = 0.0_R4Ki      !<  [-]
    CHARACTER(80)  :: CurrSSDirChr      !<  [-]
    REAL(SiKi)  :: CurrSSDir = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: CurrNSRef = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: CurrNSV0 = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: CurrNSDir = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: CurrDIV = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: CurrDIDir = 0.0_R4Ki      !<  [-]
    INTEGER(IntKi)  :: CurrMod = 0_IntKi      !<  [-]
    REAL(SiKi)  :: WtrDpth = 0.0_R4Ki      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridzi      !<  [-]
    INTEGER(IntKi)  :: NGridPts = 0_IntKi      !<  [-]
    CHARACTER(1024)  :: DirRoot      !<  [-]
  END TYPE Current_InitInputType
! =======================
! =========  Current_InitOutputType  =======
  TYPE, PUBLIC :: Current_InitOutputType
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVxi      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVyi      !<  [-]
    REAL(SiKi)  :: PCurrVxiPz0 = 0.0_R4Ki      !<  [-]
    REAL(SiKi)  :: PCurrVyiPz0 = 0.0_R4Ki      !<  [-]
  END TYPE Current_InitOutputType
! =======================
CONTAINS

subroutine Current_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(Current_InitInputType), intent(in) :: SrcInitInputData
   type(Current_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Current_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%CurrSSV0 = SrcInitInputData%CurrSSV0
   DstInitInputData%CurrSSDirChr = SrcInitInputData%CurrSSDirChr
   DstInitInputData%CurrSSDir = SrcInitInputData%CurrSSDir
   DstInitInputData%CurrNSRef = SrcInitInputData%CurrNSRef
   DstInitInputData%CurrNSV0 = SrcInitInputData%CurrNSV0
   DstInitInputData%CurrNSDir = SrcInitInputData%CurrNSDir
   DstInitInputData%CurrDIV = SrcInitInputData%CurrDIV
   DstInitInputData%CurrDIDir = SrcInitInputData%CurrDIDir
   DstInitInputData%CurrMod = SrcInitInputData%CurrMod
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   if (allocated(SrcInitInputData%WaveKinGridzi)) then
      LB(1:1) = lbound(SrcInitInputData%WaveKinGridzi)
      UB(1:1) = ubound(SrcInitInputData%WaveKinGridzi)
      if (.not. allocated(DstInitInputData%WaveKinGridzi)) then
         allocate(DstInitInputData%WaveKinGridzi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridzi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%WaveKinGridzi = SrcInitInputData%WaveKinGridzi
   end if
   DstInitInputData%NGridPts = SrcInitInputData%NGridPts
   DstInitInputData%DirRoot = SrcInitInputData%DirRoot
end subroutine

subroutine Current_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(Current_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Current_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%WaveKinGridzi)) then
      deallocate(InitInputData%WaveKinGridzi)
   end if
end subroutine

subroutine Current_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Current_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Current_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%CurrSSV0)
   call RegPack(Buf, InData%CurrSSDirChr)
   call RegPack(Buf, InData%CurrSSDir)
   call RegPack(Buf, InData%CurrNSRef)
   call RegPack(Buf, InData%CurrNSV0)
   call RegPack(Buf, InData%CurrNSDir)
   call RegPack(Buf, InData%CurrDIV)
   call RegPack(Buf, InData%CurrDIDir)
   call RegPack(Buf, InData%CurrMod)
   call RegPack(Buf, InData%WtrDpth)
   call RegPack(Buf, allocated(InData%WaveKinGridzi))
   if (allocated(InData%WaveKinGridzi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinGridzi), ubound(InData%WaveKinGridzi))
      call RegPack(Buf, InData%WaveKinGridzi)
   end if
   call RegPack(Buf, InData%NGridPts)
   call RegPack(Buf, InData%DirRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Current_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Current_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Current_UnPackInitInput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%CurrSSV0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrSSDirChr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrSSDir)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrNSRef)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrNSV0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrNSDir)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrDIV)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrDIDir)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CurrMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WaveKinGridzi)) deallocate(OutData%WaveKinGridzi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinGridzi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridzi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinGridzi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NGridPts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DirRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Current_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Current_InitOutputType), intent(in) :: SrcInitOutputData
   type(Current_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Current_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitOutputData%CurrVxi)) then
      LB(1:1) = lbound(SrcInitOutputData%CurrVxi)
      UB(1:1) = ubound(SrcInitOutputData%CurrVxi)
      if (.not. allocated(DstInitOutputData%CurrVxi)) then
         allocate(DstInitOutputData%CurrVxi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%CurrVxi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%CurrVxi = SrcInitOutputData%CurrVxi
   end if
   if (allocated(SrcInitOutputData%CurrVyi)) then
      LB(1:1) = lbound(SrcInitOutputData%CurrVyi)
      UB(1:1) = ubound(SrcInitOutputData%CurrVyi)
      if (.not. allocated(DstInitOutputData%CurrVyi)) then
         allocate(DstInitOutputData%CurrVyi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%CurrVyi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%CurrVyi = SrcInitOutputData%CurrVyi
   end if
   DstInitOutputData%PCurrVxiPz0 = SrcInitOutputData%PCurrVxiPz0
   DstInitOutputData%PCurrVyiPz0 = SrcInitOutputData%PCurrVyiPz0
end subroutine

subroutine Current_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(Current_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Current_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitOutputData%CurrVxi)) then
      deallocate(InitOutputData%CurrVxi)
   end if
   if (allocated(InitOutputData%CurrVyi)) then
      deallocate(InitOutputData%CurrVyi)
   end if
end subroutine

subroutine Current_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Current_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Current_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%CurrVxi))
   if (allocated(InData%CurrVxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%CurrVxi), ubound(InData%CurrVxi))
      call RegPack(Buf, InData%CurrVxi)
   end if
   call RegPack(Buf, allocated(InData%CurrVyi))
   if (allocated(InData%CurrVyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%CurrVyi), ubound(InData%CurrVyi))
      call RegPack(Buf, InData%CurrVyi)
   end if
   call RegPack(Buf, InData%PCurrVxiPz0)
   call RegPack(Buf, InData%PCurrVyiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Current_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Current_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Current_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%CurrVxi)) deallocate(OutData%CurrVxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CurrVxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CurrVxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CurrVyi)) deallocate(OutData%CurrVyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CurrVyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CurrVyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%PCurrVxiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%PCurrVyiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE Current_Types
!ENDOFREGISTRYGENERATEDFILE
