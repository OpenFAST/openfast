!STARTOFREGISTRYGENERATEDFILE 'SeaState_Interp_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! SeaState_Interp_Types
!.................................................................................................................................
! This file is part of SeaState_Interp.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in SeaState_Interp. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE SeaState_Interp_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  SeaSt_Interp_InitInputType  =======
  TYPE, PUBLIC :: SeaSt_Interp_InitInputType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of grid points in the t, x, y, and z directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction (time, x, y, z) [s,m,m,m]
    REAL(ReKi) , DIMENSION(1:4)  :: pZero      !< fixed position of the time-X-Y-Z grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(ReKi)  :: Z_Depth      !< grid depth [m]
  END TYPE SeaSt_Interp_InitInputType
! =======================
! =========  SeaSt_Interp_InitOutputType  =======
  TYPE, PUBLIC :: SeaSt_Interp_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< Version information of this submodule [-]
  END TYPE SeaSt_Interp_InitOutputType
! =======================
! =========  SeaSt_Interp_MiscVarType  =======
  TYPE, PUBLIC :: SeaSt_Interp_MiscVarType
    REAL(SiKi) , DIMENSION(1:8)  :: N3D      !< this is the 3-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    REAL(SiKi) , DIMENSION(1:16)  :: N4D      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: Indx_Lo      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: Indx_Hi      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    LOGICAL  :: FirstWarn_Clamp = .true.      !< used to avoid too many 'Position has been clamped to the grid boundary' warning messages  [-]
  END TYPE SeaSt_Interp_MiscVarType
! =======================
! =========  SeaSt_Interp_ParameterType  =======
  TYPE, PUBLIC :: SeaSt_Interp_ParameterType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of evenly-spaced grid points in the t, x, y, and z directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction [s,m,m,m]
    REAL(ReKi) , DIMENSION(1:4)  :: pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(ReKi)  :: Z_Depth      !< grid depth [m]
  END TYPE SeaSt_Interp_ParameterType
! =======================
CONTAINS

subroutine SeaSt_Interp_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(SeaSt_Interp_InitInputType), intent(in) :: SrcInitInputData
   type(SeaSt_Interp_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%n = SrcInitInputData%n
   DstInitInputData%delta = SrcInitInputData%delta
   DstInitInputData%pZero = SrcInitInputData%pZero
   DstInitInputData%Z_Depth = SrcInitInputData%Z_Depth
end subroutine

subroutine SeaSt_Interp_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(SeaSt_Interp_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine SeaSt_Interp_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackInitInput'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(SeaSt_Interp_InitOutputType), intent(in) :: SrcInitOutputData
   type(SeaSt_Interp_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine SeaSt_Interp_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(SeaSt_Interp_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine SeaSt_Interp_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
end subroutine

subroutine SeaSt_Interp_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(SeaSt_Interp_MiscVarType), intent(in) :: SrcMiscData
   type(SeaSt_Interp_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMiscData%N3D = SrcMiscData%N3D
   DstMiscData%N4D = SrcMiscData%N4D
   DstMiscData%Indx_Lo = SrcMiscData%Indx_Lo
   DstMiscData%Indx_Hi = SrcMiscData%Indx_Hi
   DstMiscData%FirstWarn_Clamp = SrcMiscData%FirstWarn_Clamp
end subroutine

subroutine SeaSt_Interp_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(SeaSt_Interp_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine SeaSt_Interp_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%N3D)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%N4D)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%Indx_Lo)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%Indx_Hi)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%FirstWarn_Clamp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%N3D)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%N4D)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Indx_Lo)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Indx_Hi)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FirstWarn_Clamp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(SeaSt_Interp_ParameterType), intent(in) :: SrcParamData
   type(SeaSt_Interp_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%n = SrcParamData%n
   DstParamData%delta = SrcParamData%delta
   DstParamData%pZero = SrcParamData%pZero
   DstParamData%Z_Depth = SrcParamData%Z_Depth
end subroutine

subroutine SeaSt_Interp_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(SeaSt_Interp_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'SeaSt_Interp_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine SeaSt_Interp_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackParam'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE SeaState_Interp_Types
!ENDOFREGISTRYGENERATEDFILE
