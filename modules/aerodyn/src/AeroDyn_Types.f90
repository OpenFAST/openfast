!STARTOFREGISTRYGENERATEDFILE 'AeroDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn_Types
!.................................................................................................................................
! This file is part of AeroDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE BEMT_Types
USE FVW_Types
USE AeroAcoustics_Types
USE InflowWind_Types
USE SeaSt_WaveField_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModelUnknown = -1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_none = 0      ! Wake model - none [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_BEMT = 1      ! Wake model - BEMT (blade elememnt momentum theory) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_DBEMT = 2      ! Wake model - DBEMT (dynamic elememnt momentum theory) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_FVW = 3      ! Wake model - FVW (free vortex wake, OLAF) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AFAeroMod_steady = 1      ! steady model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AFAeroMod_BL_unsteady = 2      ! Beddoes-Leishman unsteady model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_none = 0      ! no tower potential flow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_baseline = 1      ! baseline tower potential flow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_Bak = 2      ! tower potential flow with Bak correction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_none = 0      ! no tower shadow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_Powles = 1      ! Powles tower shadow model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_Eames = 2      ! Eames tower shadow model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_none = 0      ! no tail fin aero [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_polar = 1      ! polar-based tail fin aerodynamics [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_USB = 2      ! unsteady slender body tail fin aerodynamics model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinIndMod_none = 0      ! no induction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinIndMod_rotavg = 1      ! rotor averaged induction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_BEM_NoSweepPitchTwist = 1      ! Original AeroDyn model where momentum balance is done in the WithoutSweepPitchTwist system [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_BEM_Polar = 2      ! Use staggered polar grid for momentum balance in each annulus [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_LiftingLine = 3      ! Use the blade lifting line (i.e. the structural) orientation (currently for OLAF with VAWT) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD_MaxBl_Out = 3      ! Maximum number of blades for information output (or linearization) [-]
! =========  TFinParameterType  =======
  TYPE, PUBLIC :: TFinParameterType
    INTEGER(IntKi)  :: TFinMod = 0_IntKi      !< Tail fin aerodynamics model {0=none, 1=polar-based, 2=USB-based} [(switch)]
    REAL(ReKi)  :: TFinChord = 0.0_ReKi      !< Tail fin chord [used only when TFinMod=1] [m]
    REAL(ReKi)  :: TFinArea = 0.0_ReKi      !< Tail fin planform area [used only when TFinMod=1] [m^2]
    INTEGER(IntKi)  :: TFinIndMod = 0_IntKi      !< Model for induced velocity calculation {0=none, 1=rotor-average} [(switch)]
    INTEGER(IntKi)  :: TFinAFID = 0_IntKi      !< Index of Tail fin airfoil number [1 to NumAFfiles] [-]
  END TYPE TFinParameterType
! =======================
! =========  TFinInputFileType  =======
  TYPE, PUBLIC :: TFinInputFileType
    INTEGER(IntKi)  :: TFinMod = 0_IntKi      !< Tail fin aerodynamics model {0=none, 1=polar-based, 2=USB-based} [(switch)]
    REAL(ReKi)  :: TFinChord = 0.0_ReKi      !< Tail fin chord [used only when TFinMod=1] [m]
    REAL(ReKi)  :: TFinArea = 0.0_ReKi      !< Tail fin planform area [used only when TFinMod=1] [m^2]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinRefP_n = 0.0_ReKi      !< Undeflected position of the tail fin reference point wrt the tower top [m]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinAngles = 0.0_ReKi      !< Tail fin chordline skew, tilt, and bank angles about the reference point [(deg)]
    INTEGER(IntKi)  :: TFinIndMod = 0_IntKi      !< Model for induced velocity calculation {0=none, 1=rotor-average} [(switch)]
    INTEGER(IntKi)  :: TFinAFID = 0_IntKi      !< Index of Tail fin airfoil number [1 to NumAFfiles] [-]
  END TYPE TFinInputFileType
! =======================
! =========  AD_VTK_BLSurfaceType  =======
  TYPE, PUBLIC :: AD_VTK_BLSurfaceType
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x,y coordinates for airfoil around each blade node on a blade (relative to reference) [-]
  END TYPE AD_VTK_BLSurfaceType
! =======================
! =========  AD_VTK_RotSurfaceType  =======
  TYPE, PUBLIC :: AD_VTK_RotSurfaceType
    TYPE(AD_VTK_BLSurfaceType) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< AirfoilCoords for each blade [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: TowerRad      !< radius of each ED tower node [m]
  END TYPE AD_VTK_RotSurfaceType
! =======================
! =========  RotInitInputType  =======
  TYPE, PUBLIC :: RotInitInputType
    INTEGER(IntKi)  :: NumBlades = 0_IntKi      !< Number of blades on the turbine [-]
    REAL(ReKi) , DIMENSION(1:3)  :: HubPosition = 0.0_ReKi      !< X-Y-Z reference position of hub [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: HubOrientation = 0.0_R8Ki      !< DCM reference orientation of hub [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BladeRootPosition      !< X-Y-Z reference position of each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: BladeRootOrientation      !< DCM reference orientation of blade roots (3x3 x NumBlades) [-]
    REAL(R8Ki) , DIMENSION(1:3)  :: NacellePosition = 0.0_R8Ki      !< X-Y-Z reference position of nacelle [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: NacelleOrientation = 0.0_R8Ki      !< DCM reference orientation of nacelle [-]
    INTEGER(IntKi)  :: AeroProjMod = 1      !< Flag to switch between different projection models [-]
    INTEGER(IntKi)  :: AeroBEM_Mod = -1      !< Flag to switch between different BEM Model [-]
  END TYPE RotInitInputType
! =======================
! =========  AD_InitInputType  =======
  TYPE, PUBLIC :: AD_InitInputType
    TYPE(RotInitInputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Init Input Types for rotors [-]
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: UsePrimaryInputFile = .TRUE.      !< Read input file instead of passed data [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
    REAL(ReKi)  :: Gravity = 0.0_ReKi      !< Gravity force [Nm/s^2]
    INTEGER(IntKi)  :: MHK = 0_IntKi      !< MHK turbine type switch [-]
    REAL(ReKi)  :: defFldDens = 0.0_ReKi      !< Default fluid density from the driver; may be overwritten [kg/m^3]
    REAL(ReKi)  :: defKinVisc = 0.0_ReKi      !< Default kinematic viscosity from the driver; may be overwritten [m^2/s]
    REAL(ReKi)  :: defSpdSound = 0.0_ReKi      !< Default speed of sound from the driver; may be overwritten [m/s]
    REAL(ReKi)  :: defPatm = 0.0_ReKi      !< Default atmospheric pressure from the driver; may be overwritten [Pa]
    REAL(ReKi)  :: defPvap = 0.0_ReKi      !< Default vapor pressure from the driver; may be overwritten [Pa]
    REAL(ReKi)  :: WtrDpth = 0.0_ReKi      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL = 0.0_ReKi      !< Offset between still-water level and mean sea level [m]
  END TYPE AD_InitInputType
! =======================
! =========  AD_BladePropsType  =======
  TYPE, PUBLIC :: AD_BladePropsType
    INTEGER(IntKi)  :: NumBlNds = 0_IntKi      !< Number of blade nodes used in the analysis [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlSpn      !< Span at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCrvAC      !< Curve at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlSwpAC      !< Sweep at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCrvAng      !< Curve angle at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlTwist      !< Twist at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlChord      !< Chord at blade node [m]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BlAFID      !< ID of Airfoil at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: t_c      !< Thickness to chord ratio at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCb      !< Coefficient of buoyancy at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCenBn      !< Center of buoyancy normal offset at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCenBt      !< Center of buoyancy tangential offset at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCpn      !< Chordwise coefficient of dynamic pressure at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCpt      !< Edgewise coefficient of dynamic pressure at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCan      !< Chordwise coefficient of added mass at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCat      !< Edgewise coefficient of added mass at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCam      !< Pitch coefficient of added mass at blade node [-]
  END TYPE AD_BladePropsType
! =======================
! =========  AD_BladeShape  =======
  TYPE, PUBLIC :: AD_BladeShape
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x-y coordinates for airfoils, relative to node [m]
  END TYPE AD_BladeShape
! =======================
! =========  RotInitOutputType  =======
  TYPE, PUBLIC :: RotInitOutputType
    REAL(ReKi)  :: AirDens = 0.0_ReKi      !< Air density [kg/m^3]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(AD_BladeShape) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< airfoil coordinates for each blade [m]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the continuous states used in linearization are in the rotating frame (not used for glue) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    TYPE(AD_BladePropsType) , DIMENSION(:), ALLOCATABLE  :: BladeProps      !< blade property information from blade input files [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrElev      !< Elevation at tower node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
  END TYPE RotInitOutputType
! =======================
! =========  AD_InitOutputType  =======
  TYPE, PUBLIC :: AD_InitOutputType
    TYPE(RotInitOutputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Rotor init output type [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
  END TYPE AD_InitOutputType
! =======================
! =========  RotInputFile  =======
  TYPE, PUBLIC :: RotInputFile
    TYPE(AD_BladePropsType) , DIMENSION(:), ALLOCATABLE  :: BladeProps      !< blade property information from blade input files [-]
    INTEGER(IntKi)  :: NumTwrNds = 0_IntKi      !< Number of tower nodes used in the analysis [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrElev      !< Elevation at tower node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCd      !< Coefficient of drag at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTI      !< Turbulence intensity for tower shadow at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCb      !< Coefficient of buoyancy at tower node [-]
<<<<<<< HEAD
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCp      !< Coefficient of dynamic pressure at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCa      !< Coefficient of added mass at tower node [-]
    REAL(ReKi)  :: VolHub      !< Hub volume [m^3]
    REAL(ReKi)  :: HubCenBx      !< Hub center of buoyancy x direction offset [m]
    REAL(ReKi)  :: VolNac      !< Nacelle volume [m^3]
    REAL(ReKi) , DIMENSION(1:3)  :: NacCenB      !< Position of nacelle center of buoyancy from yaw bearing in nacelle coordinates [m]
=======
    REAL(ReKi)  :: VolHub = 0.0_ReKi      !< Hub volume [m^3]
    REAL(ReKi)  :: HubCenBx = 0.0_ReKi      !< Hub center of buoyancy x direction offset [m]
    REAL(ReKi)  :: VolNac = 0.0_ReKi      !< Nacelle volume [m^3]
    REAL(ReKi) , DIMENSION(1:3)  :: NacCenB = 0.0_ReKi      !< Position of nacelle center of buoyancy from yaw bearing in nacelle coordinates [m]
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
    LOGICAL  :: TFinAero = .FALSE.      !< Calculate tail fin aerodynamics model (flag) [flag]
    CHARACTER(1024)  :: TFinFile      !< Input file for tail fin aerodynamics [used only when TFinAero=True] [-]
    TYPE(TFinInputFileType)  :: TFin      !< Input file data for tail fin [-]
  END TYPE RotInputFile
! =======================
! =========  AD_InputFile  =======
  TYPE, PUBLIC :: AD_InputFile
<<<<<<< HEAD
    LOGICAL  :: Echo      !< Echo input file to echo file [-]
    REAL(DbKi)  :: DTAero      !< Time interval for aerodynamic calculations {or "default"} [s]
    INTEGER(IntKi)  :: WakeMod      !< Type of wake/induction model {0=none, 1=BEMT, 2=DBEMT, 3=FVW} [-]
    INTEGER(IntKi)  :: AFAeroMod      !< Type of blade airfoil aerodynamics model {1=steady model, 2=Beddoes-Leishman unsteady model} [-]
    INTEGER(IntKi)  :: TwrPotent      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck      !< Flag that tells us if we want to check for cavitation [-]
    LOGICAL  :: CompAA      !< Compute AeroAcoustic noise [flag]
=======
    LOGICAL  :: Echo = .false.      !< Echo input file to echo file [-]
    REAL(DbKi)  :: DTAero = 0.0_R8Ki      !< Time interval for aerodynamic calculations {or "default"} [s]
    INTEGER(IntKi)  :: WakeMod = 0_IntKi      !< Type of wake/induction model {0=none, 1=BEMT, 2=DBEMT, 3=FVW} [-]
    INTEGER(IntKi)  :: AFAeroMod = 0_IntKi      !< Type of blade airfoil aerodynamics model {1=steady model, 2=Beddoes-Leishman unsteady model} [-]
    INTEGER(IntKi)  :: TwrPotent = 0_IntKi      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow = 0_IntKi      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero = .false.      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake = .false.      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck = .false.      !< Flag that tells us if we want to check for cavitation [-]
    LOGICAL  :: Buoyancy = .false.      !< Include buoyancy effects? [flag]
    LOGICAL  :: CompAA = .false.      !< Compute AeroAcoustic noise [flag]
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
    CHARACTER(1024)  :: AA_InputFile      !< AeroAcoustics input file name [quoted strings]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: ADBlFile      !< AD blade file (NumBl filenames) [quoted strings]
    REAL(ReKi)  :: AirDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    REAL(ReKi)  :: Patm = 0.0_ReKi      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap = 0.0_ReKi      !< Vapour pressure [Pa]
    REAL(ReKi)  :: SpdSound = 0.0_ReKi      !< Speed of sound [m/s]
    INTEGER(IntKi)  :: SkewMod = 0_IntKi      !< Type of skewed-wake correction model {0=orthogonal, 1=uncoupled, 2=Pitt/Peters, 3=coupled} [unused when WakeMod=0] [-]
    REAL(ReKi)  :: SkewModFactor = 0.0_ReKi      !< Constant used in Pitt/Peters skewed wake model (default is 15*pi/32) [-]
    LOGICAL  :: TipLoss = .false.      !< Use the Prandtl tip-loss model? [unused when WakeMod=0] [flag]
    LOGICAL  :: HubLoss = .false.      !< Use the Prandtl hub-loss model? [unused when WakeMod=0] [flag]
    LOGICAL  :: TanInd = .false.      !< Include tangential induction in BEMT calculations? [unused when WakeMod=0] [flag]
    LOGICAL  :: AIDrag = .false.      !< Include the drag term in the axial-induction calculation? [unused when WakeMod=0] [flag]
    LOGICAL  :: TIDrag = .false.      !< Include the drag term in the tangential-induction calculation? [unused when WakeMod=0 or TanInd=FALSE] [flag]
    REAL(ReKi)  :: IndToler = 0.0_ReKi      !< Convergence tolerance for BEM induction factors [unused when WakeMod=0] [-]
    REAL(ReKi)  :: MaxIter = 0.0_ReKi      !< Maximum number of iteration steps [unused when WakeMod=0] [-]
    INTEGER(IntKi)  :: UAMod = 0_IntKi      !< Unsteady Aero Model Switch (switch) {1=Baseline model (Original), 2=Gonzalez's variant (changes in Cn,Cc,Cm), 3=Minnema/Pierce variant (changes in Cc and Cm)} [used only when AFAeroMod=2] [-]
    LOGICAL  :: FLookup = .false.      !< Flag to indicate whether a lookup for f' will be calculated (TRUE) or whether best-fit exponential equations will be used (FALSE); if FALSE S1-S4 must be provided in airfoil input files [used only when AFAeroMod=2] [flag]
    REAL(ReKi)  :: InCol_Alfa = 0.0_ReKi      !< The column in the airfoil tables that contains the angle of attack [-]
    REAL(ReKi)  :: InCol_Cl = 0.0_ReKi      !< The column in the airfoil tables that contains the lift coefficient [-]
    REAL(ReKi)  :: InCol_Cd = 0.0_ReKi      !< The column in the airfoil tables that contains the drag coefficient [-]
    REAL(ReKi)  :: InCol_Cm = 0.0_ReKi      !< The column in the airfoil tables that contains the pitching-moment coefficient; use zero if there is no Cm column [-]
    REAL(ReKi)  :: InCol_Cpmin = 0.0_ReKi      !< The column in the airfoil tables that contains the drag coefficient; use zero if there is no Cpmin column [-]
    INTEGER(IntKi)  :: AFTabMod = 0_IntKi      !< Interpolation method for multiple airfoil tables {1 = 1D on AoA (only first table is used); 2 = 2D on AoA and Re; 3 = 2D on AoA and UserProp} [-]
    INTEGER(IntKi)  :: NumAFfiles = 0_IntKi      !< Number of airfoil files used [-]
    CHARACTER(1024)  :: FVWFileName      !< FVW input filename [quoted string]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: AFNames      !< Airfoil file names (NumAF lines) [quoted strings]
    LOGICAL  :: UseBlCm = .false.      !< Include aerodynamic pitching moment in calculations? [flag]
    LOGICAL  :: SumPrint = .false.      !< Generate a summary file listing input options and interpolated properties to "<rootname>.AD.sum"? [flag]
    INTEGER(IntKi)  :: NBlOuts = 0_IntKi      !< Number of blade node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: BlOutNd = 0_IntKi      !< Blade nodes whose values will be output [-]
    INTEGER(IntKi)  :: NTwOuts = 0_IntKi      !< Number of tower node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: TwOutNd = 0_IntKi      !< Tower nodes whose values will be output [-]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< List of user-requested output channels [-]
    REAL(ReKi)  :: tau1_const = 0.0_ReKi      !< time constant for DBEMT [used only when WakeMod=2 and DBEMT_Mod/=2] [s]
    INTEGER(IntKi)  :: DBEMT_Mod = 0_IntKi      !< Type of dynamic BEMT (DBEMT) model {1=constant tau1, 2=time-dependent tau1} [-]
    INTEGER(IntKi)  :: BldNd_NumOuts = 0_IntKi      !< Number of requested output channels per blade node (AD_AllBldNdOuts) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: BldNd_OutList      !< List of user-requested output channels (AD_AllBldNdOuts) [-]
    CHARACTER(1024)  :: BldNd_BlOutNd_Str      !< String to parse for the blade nodes to actually output (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_BladesOut = 0_IntKi      !< The blades to output (AD_AllBldNdOuts) [-]
    REAL(ReKi)  :: UAStartRad = 0.0_ReKi      !< Starting [radius]
    REAL(ReKi)  :: UAEndRad = 0.0_ReKi      !< Ending [radius]
    TYPE(RotInputFile) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Rotor (blades and tower) input file data [-]
  END TYPE AD_InputFile
! =======================
! =========  RotContinuousStateType  =======
  TYPE, PUBLIC :: RotContinuousStateType
    TYPE(BEMT_ContinuousStateType)  :: BEMT      !< Continuous states from the BEMT module [-]
    TYPE(AA_ContinuousStateType)  :: AA      !< Continuous states from the AA module [-]
  END TYPE RotContinuousStateType
! =======================
! =========  AD_ContinuousStateType  =======
  TYPE, PUBLIC :: AD_ContinuousStateType
    TYPE(RotContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Continuous states for each rotor [-]
    TYPE(FVW_ContinuousStateType)  :: FVW      !< Continuous states from the FVW module [-]
  END TYPE AD_ContinuousStateType
! =======================
! =========  RotDiscreteStateType  =======
  TYPE, PUBLIC :: RotDiscreteStateType
    TYPE(BEMT_DiscreteStateType)  :: BEMT      !< Discrete states from the BEMT module [-]
    TYPE(AA_DiscreteStateType)  :: AA      !< Discrete states from the AA module [-]
  END TYPE RotDiscreteStateType
! =======================
! =========  AD_DiscreteStateType  =======
  TYPE, PUBLIC :: AD_DiscreteStateType
    TYPE(RotDiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Discrete states for each rotor [-]
    TYPE(FVW_DiscreteStateType)  :: FVW      !< Discrete states from the FVW module [-]
  END TYPE AD_DiscreteStateType
! =======================
! =========  RotConstraintStateType  =======
  TYPE, PUBLIC :: RotConstraintStateType
    TYPE(BEMT_ConstraintStateType)  :: BEMT      !< Constraint states from the BEMT module [-]
    TYPE(AA_ConstraintStateType)  :: AA      !< Constraint states from the AA module [-]
  END TYPE RotConstraintStateType
! =======================
! =========  AD_ConstraintStateType  =======
  TYPE, PUBLIC :: AD_ConstraintStateType
    TYPE(RotConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Constraint states for each rotor [-]
    TYPE(FVW_ConstraintStateType)  :: FVW      !< Constraint states from the FVW module [-]
  END TYPE AD_ConstraintStateType
! =======================
! =========  RotOtherStateType  =======
  TYPE, PUBLIC :: RotOtherStateType
    TYPE(BEMT_OtherStateType)  :: BEMT      !< OtherStates from the BEMT module [-]
    TYPE(AA_OtherStateType)  :: AA      !< OtherStates from the AA module [-]
  END TYPE RotOtherStateType
! =======================
! =========  AD_OtherStateType  =======
  TYPE, PUBLIC :: AD_OtherStateType
    TYPE(RotOtherStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< OtherStates from the BEMT module [-]
    TYPE(FVW_OtherStateType)  :: FVW      !< OtherStates from the FVW module [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WakeLocationPoints      !< wake points velocity [m/s]
  END TYPE AD_OtherStateType
! =======================
! =========  RotMiscVarType  =======
  TYPE, PUBLIC :: RotMiscVarType
    TYPE(BEMT_MiscVarType)  :: BEMT      !< MiscVars from the BEMT module [-]
    TYPE(BEMT_OutputType)  :: BEMT_y      !< Outputs from the BEMT module [-]
    TYPE(BEMT_InputType) , DIMENSION(1:2)  :: BEMT_u      !< Inputs to the BEMT module [-]
    TYPE(AA_MiscVarType)  :: AA      !< MiscVars from the AA module [-]
    TYPE(AA_OutputType)  :: AA_y      !< Outputs from the AA module [-]
    TYPE(AA_InputType)  :: AA_u      !< Inputs to the AA module [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: DisturbedInflow      !< InflowOnBlade values modified by tower influence [m/s]
    REAL(R8Ki) , DIMENSION(:,:,:,:), ALLOCATABLE  :: orientationAnnulus      !< Coordinate system equivalent to BladeMotion Orientation, but without live sweep, blade-pitch, and twist angles [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllOuts      !< An array holding the value of all of the calculated (not only selected) output channels [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: W_Twr      !< relative wind speed normal to the tower at node j [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X_Twr      !< local x-component of force per unit length of the jth node in the tower [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y_Twr      !< local y-component of force per unit length of the jth node in the tower [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Curve      !< curvature angle, saved for possible output to file [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrClrnc      !< Distance between tower (including tower radius) and blade node (not including blade width), saved for possible output to file [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X      !< normal force per unit length (normal to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Y      !< tangential force per unit length (tangential to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Z      !< axial force per unit length (tangential to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M      !< pitching moment per unit length of the jth node in the kth blade [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Mx      !< pitching moment per unit length of the jth node in the kth blade (in x direction) [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: My      !< pitching moment per unit length of the jth node in the kth blade  (in y direction) [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Mz      !< pitching moment per unit length of the jth node in the kth blade  (in z direction) [Nm/m]
    REAL(ReKi) , DIMENSION(1:3)  :: V_DiskAvg = 0.0_ReKi      !< disk-average relative wind speed [m/s]
    REAL(ReKi)  :: yaw = 0.0_ReKi      !< Yaw calculated in  SetInputsForBEMT [rad]
    REAL(ReKi)  :: tilt = 0.0_ReKi      !< tilt calculated in  SetInputsForBEMT [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: hub_theta_x_root      !< angles saved for FAST.Farm [rad]
    REAL(ReKi)  :: V_dot_x = 0.0_ReKi 
    TYPE(MeshType)  :: HubLoad      !< mesh at hub; used to compute an integral for mapping the output blade loads to a single point (for writing to file only) [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_L_2_H_P      !< mapping data structure to map each bladeLoad output mesh to the MiscVar%HubLoad mesh [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SigmaCavitCrit      !< critical cavitation number-  inception value (above which cavit will occur) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SigmaCavit      !< cavitation number at node  [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: CavitWarnSet      !< cavitation warning issued  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlFB      !< buoyant force per unit length at blade node [N/m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlMB      !< buoyant moment per unit length at blade node [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrFB      !< buoyant force per unit length at tower node [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrMB      !< buoyant moment per unit length at tower node [Nm/m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HubFB      !< buoyant force at hub node [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HubMB      !< buoyant moment at hub node [Nm]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NacFB      !< buoyant force at nacelle (tower top) node [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NacMB      !< buoyant moment at nacelle (tower top) node [Nm]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlFI      !< inertia force per unit length at blade node [N/m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlFA      !< added mass force per unit length at blade node [N/m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlMA      !< added mass moment per unit length at blade node [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrFI      !< inertia force per unit length at tower node [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrFA      !< added mass force per unit length at tower node [N/m]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootLoad      !< meshes at blade root; used to compute an integral for mapping the output blade loads to single points (for writing to file only) [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_L_2_R_P      !< mapping data structure to map each bladeLoad output mesh to corresponding MiscVar%BladeRootLoad mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeBuoyLoadPoint      !< point mesh for lumped buoyant blade loads [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeBuoyLoad      !< line mesh for per unit length buoyant blade loads [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_P_2_B_L      !< mapping data structure to map buoyant blade point loads (m%BladeBuoyLoadPoint) to buoyant blade line loads (m%BladeBuoyLoad) [-]
    TYPE(MeshType)  :: TwrBuoyLoadPoint      !< point mesh for lumped buoyant tower loads [-]
    TYPE(MeshType)  :: TwrBuoyLoad      !< line mesh for per unit length buoyant tower loads [-]
    TYPE(MeshMapType)  :: T_P_2_T_L      !< mapping data structure to map buoyant tower point loads (m%TwrBuoyLoadPoint) to buoyant tower line loads (m%TwrBuoyLoad) [-]
    LOGICAL  :: FirstWarn_TowerStrike = .false.      !< flag to avoid printing tower strike multiple times [-]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgDiskVel = 0.0_ReKi      !< disk-averaged U,V,W (undisturbed) [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgDiskVelDist = 0.0_ReKi      !< disk-averaged U,V,W (disturbed) [m/s]
    REAL(ReKi)  :: TFinAlpha = 0.0_ReKi      !< Angle of attack for tailfin [-]
    REAL(ReKi)  :: TFinRe = 0.0_ReKi      !< Reynolds number for tailfin [-]
    REAL(ReKi)  :: TFinVrel = 0.0_ReKi      !< Orthogonal relative velocity nrom at the reference point [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVund_i = 0.0_ReKi      !< Undisturbed wind velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVind_i = 0.0_ReKi      !< Induced velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVrel_i = 0.0_ReKi      !< Relative velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinSTV_i = 0.0_ReKi      !< Structural velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinF_i = 0.0_ReKi      !< Forces at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinM_i = 0.0_ReKi      !< Moments at the reference point of the fin in the inertial system [-]
  END TYPE RotMiscVarType
! =======================
! =========  AD_MiscVarType  =======
  TYPE, PUBLIC :: AD_MiscVarType
    TYPE(RotMiscVarType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< MiscVars for each rotor [-]
    TYPE(FVW_InputType) , DIMENSION(:), ALLOCATABLE  :: FVW_u      !< Inputs to the FVW module [-]
    TYPE(FVW_OutputType)  :: FVW_y      !< Outputs from the FVW module [-]
    TYPE(FVW_MiscVarType)  :: FVW      !< MiscVars from the FVW module [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindPos      !< XYZ coordinates to query for wind velocity/acceleration [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindVel      !< XYZ components of wind velocity [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindAcc      !< XYZ components of wind acceleration [-]
  END TYPE AD_MiscVarType
! =======================
! =========  RotParameterType  =======
  TYPE, PUBLIC :: RotParameterType
    INTEGER(IntKi)  :: NumBlades = 0_IntKi      !< Number of blades on the turbine [-]
    INTEGER(IntKi)  :: NumBlNds = 0_IntKi      !< Number of nodes on each blade [-]
    INTEGER(IntKi)  :: NumTwrNds = 0_IntKi      !< Number of nodes on the tower [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCd      !< Coefficient of drag at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTI      !< Turbulence intensity for tower shadow at tower node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlTwist      !< Twist at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCb      !< Coefficient of buoyancy at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCp      !< Coefficient of dynamic pressure at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCa      !< Coefficient of added mass at tower node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlCenBn      !< Normal offset between aerodynamic center and center of buoyancy at blade node [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlCenBt      !< Tangential offset between aerodynamic center and center of buoyancy at blade node [m]
    REAL(ReKi)  :: VolHub = 0.0_ReKi      !< Hub volume [m^3]
    REAL(ReKi)  :: HubCenBx = 0.0_ReKi      !< Hub center of buoyancy x direction offset [m]
    REAL(ReKi)  :: VolNac = 0.0_ReKi      !< Nacelle volume [m^3]
    REAL(ReKi) , DIMENSION(1:3)  :: NacCenB = 0.0_ReKi      !< Position of nacelle center of buoyancy from yaw bearing in nacelle coordinates [m]
    REAL(ReKi)  :: VolBl = 0.0_ReKi      !< Buoyancy volume of all blades [m^3]
    REAL(ReKi)  :: VolTwr = 0.0_ReKi      !< Buoyancy volume of the tower [m^3]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlRad      !< Matrix of equivalent blade radius at each node, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlDL      !< Matrix of blade element length based on CB, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlTaper      !< Matrix of blade element taper, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlAxCent      !< Matrix of blade element axial centroid, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlIN      !< Matrix of blade node normal-to-chord inertia factor [kg/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlIT      !< Matrix of blade node tangential-to-chord inertia factor [kg/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlAN      !< Matrix of blade node normal-to-chord added mass factor [kg/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlAT      !< Matrix of blade node tangential-to-chord added mass factor [kg/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlAM      !< Matrix of blade node pitch added mass factor [kgm]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRad      !< Array of equivalent tower radius at each node, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDL      !< Array of tower element length, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTaper      !< Array of tower element taper, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrAxCent      !< Array of tower element axial centroid, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrIT      !< Array of tower node tangential inertia factor [kg/m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrAT      !< Array of tower node tangential added mass factor [kg/m]
    TYPE(BEMT_ParameterType)  :: BEMT      !< Parameters for BEMT module [-]
    TYPE(AA_ParameterType)  :: AA      !< Parameters for AA module [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
<<<<<<< HEAD
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: NumBl_Lin      !< number of blades in the jacobian [-]
    INTEGER(IntKi)  :: TwrPotent      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck      !< Flag that tells us if we want to check for cavitation [-]
    INTEGER(IntKi)  :: MHK      !< MHK [flag]
    LOGICAL  :: CompAA      !< Compute AeroAcoustic noise [flag]
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    REAL(ReKi)  :: SpdSound      !< Speed of sound [m/s]
    REAL(ReKi)  :: Gravity      !< Gravitational acceleration [m/s^2]
    REAL(ReKi)  :: Patm      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap      !< Vapour pressure [Pa]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL      !< Offset between still-water level and mean sea level [m]
=======
    INTEGER(IntKi)  :: Jac_ny = 0_IntKi      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: NumBl_Lin = 0_IntKi      !< number of blades in the jacobian [-]
    INTEGER(IntKi)  :: TwrPotent = 0_IntKi      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow = 0_IntKi      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero = .false.      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake = .false.      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck = .false.      !< Flag that tells us if we want to check for cavitation [-]
    LOGICAL  :: Buoyancy = .false.      !< Include buoyancy effects? [flag]
    INTEGER(IntKi)  :: MHK = 0_IntKi      !< MHK [flag]
    LOGICAL  :: CompAA = .false.      !< Compute AeroAcoustic noise [flag]
    REAL(ReKi)  :: AirDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc = 0.0_ReKi      !< Kinematic air viscosity [m^2/s]
    REAL(ReKi)  :: SpdSound = 0.0_ReKi      !< Speed of sound [m/s]
    REAL(ReKi)  :: Gravity = 0.0_ReKi      !< Gravitational acceleration [m/s^2]
    REAL(ReKi)  :: Patm = 0.0_ReKi      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap = 0.0_ReKi      !< Vapour pressure [Pa]
    REAL(ReKi)  :: WtrDpth = 0.0_ReKi      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL = 0.0_ReKi      !< Offset between still-water level and mean sea level [m]
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
    INTEGER(IntKi)  :: AeroProjMod = 1      !< Flag to switch between different projection models [-]
    INTEGER(IntKi)  :: AeroBEM_Mod = -1      !< Flag to switch between different BEM Model [-]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    INTEGER(IntKi)  :: NBlOuts = 0_IntKi      !< Number of blade node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: BlOutNd = 0_IntKi      !< Blade nodes whose values will be output [-]
    INTEGER(IntKi)  :: NTwOuts = 0_IntKi      !< Number of tower node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: TwOutNd = 0_IntKi      !< Tower nodes whose values will be output [-]
    INTEGER(IntKi)  :: BldNd_NumOuts = 0_IntKi      !< Number of requested output channels per blade node (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_TotNumOuts = 0_IntKi      !< Total number of requested output channels of blade node information (BldNd_NumOuts * BldNd_BlOutNd * BldNd_BladesOut -- AD_AllBldNdOuts) [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: BldNd_OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BldNd_BlOutNd      !< The blade nodes to actually output (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_BladesOut = 0_IntKi      !< The blades to output (AD_AllBldNdOuts) [-]
    LOGICAL  :: TFinAero = .FALSE.      !< Calculate tail fin aerodynamics model (flag) [flag]
    TYPE(TFinParameterType)  :: TFin      !< Parameters for tail fin of current rotor [-]
  END TYPE RotParameterType
! =======================
! =========  AD_ParameterType  =======
  TYPE, PUBLIC :: AD_ParameterType
    TYPE(RotParameterType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Parameter types for each rotor [-]
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< Time step for continuous state integration & discrete state update [seconds]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(AFI_ParameterType) , DIMENSION(:), ALLOCATABLE  :: AFI      !< AirfoilInfo parameters [-]
    INTEGER(IntKi)  :: SkewMod = 0_IntKi      !< Type of skewed-wake correction model {0=orthogonal, 1=uncoupled, 2=Pitt/Peters, 3=coupled} [unused when WakeMod=0] [-]
    INTEGER(IntKi)  :: WakeMod = 0_IntKi      !< Type of wake/induction model {0=none, 1=BEMT, 2=DBEMT, 3=FVW} [-]
    TYPE(FVW_ParameterType)  :: FVW      !< Parameters for FVW module [-]
    LOGICAL  :: CompAeroMaps = .FALSE.      !< flag to determine if AeroDyn is computing aero maps (true) or running a normal simulation (false) [-]
    LOGICAL  :: UA_Flag = .false.      !< logical flag indicating whether to use UnsteadyAero [-]
    TYPE(FlowFieldType) , POINTER :: FlowField => NULL()      !< Pointer of InflowWinds flow field data type [-]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< Pointer to SeaState wave field data type [-]
  END TYPE AD_ParameterType
! =======================
! =========  BldInputType  =======
  TYPE, PUBLIC :: BldInputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowOnBlade      !< U,V,W at nodes on each blade (note if we change the requirement that NumNodes is the same for each blade, this will need to change) [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AccelOnBlade      !< Wind acceleration at nodes on each blade (note if we change the requirement that NumNodes is the same for each blade, this will need to change) [m/s]
  END TYPE BldInputType
! =======================
! =========  RotInputType  =======
  TYPE, PUBLIC :: RotInputType
    TYPE(MeshType)  :: NacelleMotion      !< motion on the nacelle [-]
    TYPE(MeshType)  :: TowerMotion      !< motion on the tower [-]
    TYPE(MeshType)  :: HubMotion      !< motion on the hub [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootMotion      !< motion on each blade root [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeMotion      !< motion on each blade [-]
    TYPE(MeshType)  :: TFinMotion      !< motion of tail fin (at tail fin ref point) [-]
    TYPE(BldInputType) , DIMENSION(:), ALLOCATABLE  :: Bld      !< Blade Inputs [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowOnTower      !< U,V,W at nodes on the tower [m/s]
<<<<<<< HEAD
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnHub      !< U,V,W at hub [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnNacelle      !< U,V,W at nacelle [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnTailFin      !< U,V,W at tailfin [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccelOnBlade      !< U,V,W accelerations at nodes on each blade (note if we change the requirement that NumNodes is the same for each blade, this will need to change) [m/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AccelOnTower      !< U,V,W accelerations at nodes on the tower [m/s^2]
=======
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AccelOnTower      !< Wind acceleration at nodes on the tower [m/s]
    REAL(ReKi) , DIMENSION(1:3,1:1)  :: InflowOnHub = 0.0_ReKi      !< U,V,W at hub [m/s]
    REAL(ReKi) , DIMENSION(1:3,1:1)  :: InflowOnNacelle = 0.0_ReKi      !< U,V,W at nacelle [m/s]
    REAL(ReKi) , DIMENSION(1:3,1:1)  :: InflowOnTailFin = 0.0_ReKi      !< U,V,W at tailfin [m/s]
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: UserProp      !< Optional user property for interpolating airfoils (per element per blade) [-]
  END TYPE RotInputType
! =======================
! =========  AD_InputType  =======
  TYPE, PUBLIC :: AD_InputType
    TYPE(RotInputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Inputs for each rotor [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowWakeVel      !< U,V,W at wake points [m/s]
  END TYPE AD_InputType
! =======================
! =========  RotOutputType  =======
  TYPE, PUBLIC :: RotOutputType
    TYPE(MeshType)  :: NacelleLoad      !< loads on the nacelle [-]
    TYPE(MeshType)  :: HubLoad      !< loads on the hub [-]
    TYPE(MeshType)  :: TowerLoad      !< loads on the tower [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeLoad      !< loads on each blade [-]
    TYPE(MeshType)  :: TFinLoad      !< loads on tail fin (at tail fin ref point) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
  END TYPE RotOutputType
! =======================
! =========  AD_OutputType  =======
  TYPE, PUBLIC :: AD_OutputType
    TYPE(RotOutputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Ouputs for each rotor [-]
  END TYPE AD_OutputType
! =======================
CONTAINS

subroutine AD_CopyTFinParameterType(SrcTFinParameterTypeData, DstTFinParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TFinParameterType), intent(in) :: SrcTFinParameterTypeData
   type(TFinParameterType), intent(inout) :: DstTFinParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_CopyTFinParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTFinParameterTypeData%TFinMod = SrcTFinParameterTypeData%TFinMod
   DstTFinParameterTypeData%TFinChord = SrcTFinParameterTypeData%TFinChord
   DstTFinParameterTypeData%TFinArea = SrcTFinParameterTypeData%TFinArea
   DstTFinParameterTypeData%TFinIndMod = SrcTFinParameterTypeData%TFinIndMod
   DstTFinParameterTypeData%TFinAFID = SrcTFinParameterTypeData%TFinAFID
end subroutine

subroutine AD_DestroyTFinParameterType(TFinParameterTypeData, ErrStat, ErrMsg)
   type(TFinParameterType), intent(inout) :: TFinParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyTFinParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD_PackTFinParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TFinParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackTFinParameterType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%TFinMod)
   call RegPack(Buf, InData%TFinChord)
   call RegPack(Buf, InData%TFinArea)
   call RegPack(Buf, InData%TFinIndMod)
   call RegPack(Buf, InData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackTFinParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TFinParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackTFinParameterType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_CopyTFinInputFileType(SrcTFinInputFileTypeData, DstTFinInputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(TFinInputFileType), intent(in) :: SrcTFinInputFileTypeData
   type(TFinInputFileType), intent(inout) :: DstTFinInputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_CopyTFinInputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTFinInputFileTypeData%TFinMod = SrcTFinInputFileTypeData%TFinMod
   DstTFinInputFileTypeData%TFinChord = SrcTFinInputFileTypeData%TFinChord
   DstTFinInputFileTypeData%TFinArea = SrcTFinInputFileTypeData%TFinArea
   DstTFinInputFileTypeData%TFinRefP_n = SrcTFinInputFileTypeData%TFinRefP_n
   DstTFinInputFileTypeData%TFinAngles = SrcTFinInputFileTypeData%TFinAngles
   DstTFinInputFileTypeData%TFinIndMod = SrcTFinInputFileTypeData%TFinIndMod
   DstTFinInputFileTypeData%TFinAFID = SrcTFinInputFileTypeData%TFinAFID
end subroutine

subroutine AD_DestroyTFinInputFileType(TFinInputFileTypeData, ErrStat, ErrMsg)
   type(TFinInputFileType), intent(inout) :: TFinInputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyTFinInputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine AD_PackTFinInputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TFinInputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackTFinInputFileType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%TFinMod)
   call RegPack(Buf, InData%TFinChord)
   call RegPack(Buf, InData%TFinArea)
   call RegPack(Buf, InData%TFinRefP_n)
   call RegPack(Buf, InData%TFinAngles)
   call RegPack(Buf, InData%TFinIndMod)
   call RegPack(Buf, InData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackTFinInputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TFinInputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackTFinInputFileType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinRefP_n)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAngles)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_CopyVTK_BLSurfaceType(SrcVTK_BLSurfaceTypeData, DstVTK_BLSurfaceTypeData, CtrlCode, ErrStat, ErrMsg)
   type(AD_VTK_BLSurfaceType), intent(in) :: SrcVTK_BLSurfaceTypeData
   type(AD_VTK_BLSurfaceType), intent(inout) :: DstVTK_BLSurfaceTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD_CopyVTK_BLSurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcVTK_BLSurfaceTypeData%AirfoilCoords)) then
      LB(1:3) = lbound(SrcVTK_BLSurfaceTypeData%AirfoilCoords)
      UB(1:3) = ubound(SrcVTK_BLSurfaceTypeData%AirfoilCoords)
      if (.not. allocated(DstVTK_BLSurfaceTypeData%AirfoilCoords)) then
         allocate(DstVTK_BLSurfaceTypeData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_BLSurfaceTypeData%AirfoilCoords.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_BLSurfaceTypeData%AirfoilCoords = SrcVTK_BLSurfaceTypeData%AirfoilCoords
   end if
end subroutine

subroutine AD_DestroyVTK_BLSurfaceType(VTK_BLSurfaceTypeData, ErrStat, ErrMsg)
   type(AD_VTK_BLSurfaceType), intent(inout) :: VTK_BLSurfaceTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyVTK_BLSurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VTK_BLSurfaceTypeData%AirfoilCoords)) then
      deallocate(VTK_BLSurfaceTypeData%AirfoilCoords)
   end if
end subroutine

subroutine AD_PackVTK_BLSurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_VTK_BLSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackVTK_BLSurfaceType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%AirfoilCoords))
   if (allocated(InData%AirfoilCoords)) then
      call RegPackBounds(Buf, 3, lbound(InData%AirfoilCoords), ubound(InData%AirfoilCoords))
      call RegPack(Buf, InData%AirfoilCoords)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackVTK_BLSurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_VTK_BLSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackVTK_BLSurfaceType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%AirfoilCoords)) deallocate(OutData%AirfoilCoords)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AirfoilCoords.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AirfoilCoords)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyVTK_RotSurfaceType(SrcVTK_RotSurfaceTypeData, DstVTK_RotSurfaceTypeData, CtrlCode, ErrStat, ErrMsg)
   type(AD_VTK_RotSurfaceType), intent(in) :: SrcVTK_RotSurfaceTypeData
   type(AD_VTK_RotSurfaceType), intent(inout) :: DstVTK_RotSurfaceTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyVTK_RotSurfaceType'
   ErrStat = ErrID_None
<<<<<<< HEAD
   ErrMsg  = ""
    DstBladePropsTypeData%NumBlNds = SrcBladePropsTypeData%NumBlNds
IF (ALLOCATED(SrcBladePropsTypeData%BlSpn)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlSpn,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlSpn,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlSpn)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlSpn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSpn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlSpn = SrcBladePropsTypeData%BlSpn
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCrvAC)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCrvAC,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCrvAC,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCrvAC)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCrvAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCrvAC = SrcBladePropsTypeData%BlCrvAC
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlSwpAC)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlSwpAC,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlSwpAC,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlSwpAC)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlSwpAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSwpAC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlSwpAC = SrcBladePropsTypeData%BlSwpAC
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCrvAng)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCrvAng,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCrvAng,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCrvAng)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCrvAng(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAng.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCrvAng = SrcBladePropsTypeData%BlCrvAng
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlTwist)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlTwist,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlTwist,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlTwist)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlTwist(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlTwist = SrcBladePropsTypeData%BlTwist
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlChord)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlChord,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlChord,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlChord)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlChord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlChord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlChord = SrcBladePropsTypeData%BlChord
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlAFID)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlAFID,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlAFID,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlAFID)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlAFID(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlAFID.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlAFID = SrcBladePropsTypeData%BlAFID
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%t_c)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%t_c,1)
  i1_u = UBOUND(SrcBladePropsTypeData%t_c,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%t_c)) THEN 
    ALLOCATE(DstBladePropsTypeData%t_c(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%t_c.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%t_c = SrcBladePropsTypeData%t_c
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCb)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCb,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCb,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCb)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCb = SrcBladePropsTypeData%BlCb
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCenBn)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCenBn,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCenBn,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCenBn)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCenBn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCenBn = SrcBladePropsTypeData%BlCenBn
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCenBt)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCenBt,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCenBt,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCenBt)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCenBt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCenBt = SrcBladePropsTypeData%BlCenBt
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCpn)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCpn,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCpn,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCpn)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCpn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCpn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCpn = SrcBladePropsTypeData%BlCpn
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCpt)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCpt,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCpt,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCpt)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCpt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCpt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCpt = SrcBladePropsTypeData%BlCpt
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCan)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCan,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCan,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCan)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCan.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCan = SrcBladePropsTypeData%BlCan
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCat)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCat,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCat,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCat)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCat(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCat.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCat = SrcBladePropsTypeData%BlCat
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCam)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCam,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCam,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCam)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCam = SrcBladePropsTypeData%BlCam
ENDIF
 END SUBROUTINE AD_CopyBladePropsType

 SUBROUTINE AD_DestroyBladePropsType( BladePropsTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(AD_BladePropsType), INTENT(INOUT) :: BladePropsTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyBladePropsType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(BladePropsTypeData%BlSpn)) THEN
  DEALLOCATE(BladePropsTypeData%BlSpn)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCrvAC)) THEN
  DEALLOCATE(BladePropsTypeData%BlCrvAC)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlSwpAC)) THEN
  DEALLOCATE(BladePropsTypeData%BlSwpAC)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCrvAng)) THEN
  DEALLOCATE(BladePropsTypeData%BlCrvAng)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlTwist)) THEN
  DEALLOCATE(BladePropsTypeData%BlTwist)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlChord)) THEN
  DEALLOCATE(BladePropsTypeData%BlChord)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlAFID)) THEN
  DEALLOCATE(BladePropsTypeData%BlAFID)
ENDIF
IF (ALLOCATED(BladePropsTypeData%t_c)) THEN
  DEALLOCATE(BladePropsTypeData%t_c)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCb)) THEN
  DEALLOCATE(BladePropsTypeData%BlCb)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCenBn)) THEN
  DEALLOCATE(BladePropsTypeData%BlCenBn)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCenBt)) THEN
  DEALLOCATE(BladePropsTypeData%BlCenBt)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCpn)) THEN
  DEALLOCATE(BladePropsTypeData%BlCpn)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCpt)) THEN
  DEALLOCATE(BladePropsTypeData%BlCpt)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCan)) THEN
  DEALLOCATE(BladePropsTypeData%BlCan)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCat)) THEN
  DEALLOCATE(BladePropsTypeData%BlCat)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCam)) THEN
  DEALLOCATE(BladePropsTypeData%BlCam)
ENDIF
 END SUBROUTINE AD_DestroyBladePropsType

 SUBROUTINE AD_PackBladePropsType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_BladePropsType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackBladePropsType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NumBlNds
  Int_BufSz   = Int_BufSz   + 1     ! BlSpn allocated yes/no
  IF ( ALLOCATED(InData%BlSpn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlSpn upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlSpn)  ! BlSpn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCrvAC allocated yes/no
  IF ( ALLOCATED(InData%BlCrvAC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCrvAC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCrvAC)  ! BlCrvAC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlSwpAC allocated yes/no
  IF ( ALLOCATED(InData%BlSwpAC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlSwpAC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlSwpAC)  ! BlSwpAC
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCrvAng allocated yes/no
  IF ( ALLOCATED(InData%BlCrvAng) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCrvAng upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCrvAng)  ! BlCrvAng
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlTwist allocated yes/no
  IF ( ALLOCATED(InData%BlTwist) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlTwist upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlTwist)  ! BlTwist
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlChord allocated yes/no
  IF ( ALLOCATED(InData%BlChord) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlChord upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlChord)  ! BlChord
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlAFID allocated yes/no
  IF ( ALLOCATED(InData%BlAFID) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlAFID upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BlAFID)  ! BlAFID
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! t_c allocated yes/no
  IF ( ALLOCATED(InData%t_c) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! t_c upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%t_c)  ! t_c
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCb allocated yes/no
  IF ( ALLOCATED(InData%BlCb) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCb upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCb)  ! BlCb
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCenBn allocated yes/no
  IF ( ALLOCATED(InData%BlCenBn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCenBn upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCenBn)  ! BlCenBn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCenBt allocated yes/no
  IF ( ALLOCATED(InData%BlCenBt) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCenBt upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCenBt)  ! BlCenBt
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCpn allocated yes/no
  IF ( ALLOCATED(InData%BlCpn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCpn upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCpn)  ! BlCpn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCpt allocated yes/no
  IF ( ALLOCATED(InData%BlCpt) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCpt upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCpt)  ! BlCpt
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCan allocated yes/no
  IF ( ALLOCATED(InData%BlCan) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCan upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCan)  ! BlCan
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCat allocated yes/no
  IF ( ALLOCATED(InData%BlCat) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCat upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCat)  ! BlCat
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCam allocated yes/no
  IF ( ALLOCATED(InData%BlCam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlCam upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCam)  ! BlCam
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%NumBlNds
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%BlSpn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlSpn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlSpn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlSpn,1), UBOUND(InData%BlSpn,1)
        ReKiBuf(Re_Xferred) = InData%BlSpn(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCrvAC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCrvAC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCrvAC,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCrvAC,1), UBOUND(InData%BlCrvAC,1)
        ReKiBuf(Re_Xferred) = InData%BlCrvAC(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlSwpAC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlSwpAC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlSwpAC,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlSwpAC,1), UBOUND(InData%BlSwpAC,1)
        ReKiBuf(Re_Xferred) = InData%BlSwpAC(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCrvAng) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCrvAng,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCrvAng,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCrvAng,1), UBOUND(InData%BlCrvAng,1)
        ReKiBuf(Re_Xferred) = InData%BlCrvAng(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlTwist) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlTwist,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlTwist,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlTwist,1), UBOUND(InData%BlTwist,1)
        ReKiBuf(Re_Xferred) = InData%BlTwist(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlChord) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlChord,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlChord,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlChord,1), UBOUND(InData%BlChord,1)
        ReKiBuf(Re_Xferred) = InData%BlChord(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlAFID) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAFID,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAFID,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlAFID,1), UBOUND(InData%BlAFID,1)
        IntKiBuf(Int_Xferred) = InData%BlAFID(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%t_c) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%t_c,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%t_c,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%t_c,1), UBOUND(InData%t_c,1)
        ReKiBuf(Re_Xferred) = InData%t_c(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCb) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCb,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCb,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCb,1), UBOUND(InData%BlCb,1)
        ReKiBuf(Re_Xferred) = InData%BlCb(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCenBn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCenBn,1), UBOUND(InData%BlCenBn,1)
        ReKiBuf(Re_Xferred) = InData%BlCenBn(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCenBt) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBt,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBt,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCenBt,1), UBOUND(InData%BlCenBt,1)
        ReKiBuf(Re_Xferred) = InData%BlCenBt(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCpn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCpn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCpn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCpn,1), UBOUND(InData%BlCpn,1)
        ReKiBuf(Re_Xferred) = InData%BlCpn(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCpt) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCpt,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCpt,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCpt,1), UBOUND(InData%BlCpt,1)
        ReKiBuf(Re_Xferred) = InData%BlCpt(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCan) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCan,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCan,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCan,1), UBOUND(InData%BlCan,1)
        ReKiBuf(Re_Xferred) = InData%BlCan(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCat) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCat,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCat,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCat,1), UBOUND(InData%BlCat,1)
        ReKiBuf(Re_Xferred) = InData%BlCat(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCam,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BlCam,1), UBOUND(InData%BlCam,1)
        ReKiBuf(Re_Xferred) = InData%BlCam(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE AD_PackBladePropsType

 SUBROUTINE AD_UnPackBladePropsType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_BladePropsType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackBladePropsType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%NumBlNds = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlSpn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlSpn)) DEALLOCATE(OutData%BlSpn)
    ALLOCATE(OutData%BlSpn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSpn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlSpn,1), UBOUND(OutData%BlSpn,1)
        OutData%BlSpn(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCrvAC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCrvAC)) DEALLOCATE(OutData%BlCrvAC)
    ALLOCATE(OutData%BlCrvAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCrvAC,1), UBOUND(OutData%BlCrvAC,1)
        OutData%BlCrvAC(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlSwpAC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlSwpAC)) DEALLOCATE(OutData%BlSwpAC)
    ALLOCATE(OutData%BlSwpAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSwpAC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlSwpAC,1), UBOUND(OutData%BlSwpAC,1)
        OutData%BlSwpAC(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCrvAng not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCrvAng)) DEALLOCATE(OutData%BlCrvAng)
    ALLOCATE(OutData%BlCrvAng(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAng.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCrvAng,1), UBOUND(OutData%BlCrvAng,1)
        OutData%BlCrvAng(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlTwist not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlTwist)) DEALLOCATE(OutData%BlTwist)
    ALLOCATE(OutData%BlTwist(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlTwist,1), UBOUND(OutData%BlTwist,1)
        OutData%BlTwist(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlChord not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlChord)) DEALLOCATE(OutData%BlChord)
    ALLOCATE(OutData%BlChord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlChord.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlChord,1), UBOUND(OutData%BlChord,1)
        OutData%BlChord(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlAFID not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlAFID)) DEALLOCATE(OutData%BlAFID)
    ALLOCATE(OutData%BlAFID(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAFID.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlAFID,1), UBOUND(OutData%BlAFID,1)
        OutData%BlAFID(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! t_c not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%t_c)) DEALLOCATE(OutData%t_c)
    ALLOCATE(OutData%t_c(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%t_c.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%t_c,1), UBOUND(OutData%t_c,1)
        OutData%t_c(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCb not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCb)) DEALLOCATE(OutData%BlCb)
    ALLOCATE(OutData%BlCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCb.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCb,1), UBOUND(OutData%BlCb,1)
        OutData%BlCb(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCenBn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCenBn)) DEALLOCATE(OutData%BlCenBn)
    ALLOCATE(OutData%BlCenBn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCenBn,1), UBOUND(OutData%BlCenBn,1)
        OutData%BlCenBn(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCenBt not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCenBt)) DEALLOCATE(OutData%BlCenBt)
    ALLOCATE(OutData%BlCenBt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCenBt,1), UBOUND(OutData%BlCenBt,1)
        OutData%BlCenBt(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCpn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCpn)) DEALLOCATE(OutData%BlCpn)
    ALLOCATE(OutData%BlCpn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCpn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCpn,1), UBOUND(OutData%BlCpn,1)
        OutData%BlCpn(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCpt not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCpt)) DEALLOCATE(OutData%BlCpt)
    ALLOCATE(OutData%BlCpt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCpt.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCpt,1), UBOUND(OutData%BlCpt,1)
        OutData%BlCpt(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCan not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCan)) DEALLOCATE(OutData%BlCan)
    ALLOCATE(OutData%BlCan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCan.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCan,1), UBOUND(OutData%BlCan,1)
        OutData%BlCan(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCat not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCat)) DEALLOCATE(OutData%BlCat)
    ALLOCATE(OutData%BlCat(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCat.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCat,1), UBOUND(OutData%BlCat,1)
        OutData%BlCat(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCam)) DEALLOCATE(OutData%BlCam)
    ALLOCATE(OutData%BlCam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BlCam,1), UBOUND(OutData%BlCam,1)
        OutData%BlCam(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE AD_UnPackBladePropsType

 SUBROUTINE AD_CopyBladeShape( SrcBladeShapeData, DstBladeShapeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_BladeShape), INTENT(IN) :: SrcBladeShapeData
   TYPE(AD_BladeShape), INTENT(INOUT) :: DstBladeShapeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyBladeShape'
! 
=======
   ErrMsg  = ''
   if (allocated(SrcVTK_RotSurfaceTypeData%BladeShape)) then
      LB(1:1) = lbound(SrcVTK_RotSurfaceTypeData%BladeShape)
      UB(1:1) = ubound(SrcVTK_RotSurfaceTypeData%BladeShape)
      if (.not. allocated(DstVTK_RotSurfaceTypeData%BladeShape)) then
         allocate(DstVTK_RotSurfaceTypeData%BladeShape(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_RotSurfaceTypeData%BladeShape.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyVTK_BLSurfaceType(SrcVTK_RotSurfaceTypeData%BladeShape(i1), DstVTK_RotSurfaceTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcVTK_RotSurfaceTypeData%TowerRad)) then
      LB(1:1) = lbound(SrcVTK_RotSurfaceTypeData%TowerRad)
      UB(1:1) = ubound(SrcVTK_RotSurfaceTypeData%TowerRad)
      if (.not. allocated(DstVTK_RotSurfaceTypeData%TowerRad)) then
         allocate(DstVTK_RotSurfaceTypeData%TowerRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_RotSurfaceTypeData%TowerRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_RotSurfaceTypeData%TowerRad = SrcVTK_RotSurfaceTypeData%TowerRad
   end if
end subroutine

subroutine AD_DestroyVTK_RotSurfaceType(VTK_RotSurfaceTypeData, ErrStat, ErrMsg)
   type(AD_VTK_RotSurfaceType), intent(inout) :: VTK_RotSurfaceTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyVTK_RotSurfaceType'
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VTK_RotSurfaceTypeData%BladeShape)) then
      LB(1:1) = lbound(VTK_RotSurfaceTypeData%BladeShape)
      UB(1:1) = ubound(VTK_RotSurfaceTypeData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_DestroyVTK_BLSurfaceType(VTK_RotSurfaceTypeData%BladeShape(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(VTK_RotSurfaceTypeData%BladeShape)
   end if
   if (allocated(VTK_RotSurfaceTypeData%TowerRad)) then
      deallocate(VTK_RotSurfaceTypeData%TowerRad)
   end if
end subroutine

subroutine AD_PackVTK_RotSurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_VTK_RotSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackVTK_RotSurfaceType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_PackVTK_BLSurfaceType(Buf, InData%BladeShape(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%TowerRad))
   if (allocated(InData%TowerRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%TowerRad), ubound(InData%TowerRad))
      call RegPack(Buf, InData%TowerRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackVTK_RotSurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_VTK_RotSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackVTK_RotSurfaceType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackVTK_BLSurfaceType(Buf, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   if (allocated(OutData%TowerRad)) deallocate(OutData%TowerRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TowerRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TowerRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TowerRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotInitInputType(SrcRotInitInputTypeData, DstRotInitInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotInitInputType), intent(in) :: SrcRotInitInputTypeData
   type(RotInitInputType), intent(inout) :: DstRotInitInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD_CopyRotInitInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotInitInputTypeData%NumBlades = SrcRotInitInputTypeData%NumBlades
   DstRotInitInputTypeData%HubPosition = SrcRotInitInputTypeData%HubPosition
   DstRotInitInputTypeData%HubOrientation = SrcRotInitInputTypeData%HubOrientation
   if (allocated(SrcRotInitInputTypeData%BladeRootPosition)) then
      LB(1:2) = lbound(SrcRotInitInputTypeData%BladeRootPosition)
      UB(1:2) = ubound(SrcRotInitInputTypeData%BladeRootPosition)
      if (.not. allocated(DstRotInitInputTypeData%BladeRootPosition)) then
         allocate(DstRotInitInputTypeData%BladeRootPosition(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitInputTypeData%BladeRootPosition.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitInputTypeData%BladeRootPosition = SrcRotInitInputTypeData%BladeRootPosition
   end if
   if (allocated(SrcRotInitInputTypeData%BladeRootOrientation)) then
      LB(1:3) = lbound(SrcRotInitInputTypeData%BladeRootOrientation)
      UB(1:3) = ubound(SrcRotInitInputTypeData%BladeRootOrientation)
      if (.not. allocated(DstRotInitInputTypeData%BladeRootOrientation)) then
         allocate(DstRotInitInputTypeData%BladeRootOrientation(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitInputTypeData%BladeRootOrientation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitInputTypeData%BladeRootOrientation = SrcRotInitInputTypeData%BladeRootOrientation
   end if
   DstRotInitInputTypeData%NacellePosition = SrcRotInitInputTypeData%NacellePosition
   DstRotInitInputTypeData%NacelleOrientation = SrcRotInitInputTypeData%NacelleOrientation
   DstRotInitInputTypeData%AeroProjMod = SrcRotInitInputTypeData%AeroProjMod
   DstRotInitInputTypeData%AeroBEM_Mod = SrcRotInitInputTypeData%AeroBEM_Mod
end subroutine

subroutine AD_DestroyRotInitInputType(RotInitInputTypeData, ErrStat, ErrMsg)
   type(RotInitInputType), intent(inout) :: RotInitInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyRotInitInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(RotInitInputTypeData%BladeRootPosition)) then
      deallocate(RotInitInputTypeData%BladeRootPosition)
   end if
   if (allocated(RotInitInputTypeData%BladeRootOrientation)) then
      deallocate(RotInitInputTypeData%BladeRootOrientation)
   end if
end subroutine

subroutine AD_PackRotInitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%NumBlades)
   call RegPack(Buf, InData%HubPosition)
   call RegPack(Buf, InData%HubOrientation)
   call RegPack(Buf, allocated(InData%BladeRootPosition))
   if (allocated(InData%BladeRootPosition)) then
      call RegPackBounds(Buf, 2, lbound(InData%BladeRootPosition), ubound(InData%BladeRootPosition))
      call RegPack(Buf, InData%BladeRootPosition)
   end if
   call RegPack(Buf, allocated(InData%BladeRootOrientation))
   if (allocated(InData%BladeRootOrientation)) then
      call RegPackBounds(Buf, 3, lbound(InData%BladeRootOrientation), ubound(InData%BladeRootOrientation))
      call RegPack(Buf, InData%BladeRootOrientation)
   end if
   call RegPack(Buf, InData%NacellePosition)
   call RegPack(Buf, InData%NacelleOrientation)
   call RegPack(Buf, InData%AeroProjMod)
   call RegPack(Buf, InData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInitInputType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%BladeRootPosition)) deallocate(OutData%BladeRootPosition)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootPosition(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootPosition.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootPosition)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BladeRootOrientation)) deallocate(OutData%BladeRootOrientation)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootOrientation(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootOrientation.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootOrientation)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%NacellePosition)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NacelleOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD_InitInputType), intent(in) :: SrcInitInputData
   type(AD_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyInitInput'
   ErrStat = ErrID_None
<<<<<<< HEAD
   ErrMsg  = ""
IF (ALLOCATED(SrcRotInputFileData%BladeProps)) THEN
  i1_l = LBOUND(SrcRotInputFileData%BladeProps,1)
  i1_u = UBOUND(SrcRotInputFileData%BladeProps,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%BladeProps)) THEN 
    ALLOCATE(DstRotInputFileData%BladeProps(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%BladeProps.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputFileData%BladeProps,1), UBOUND(SrcRotInputFileData%BladeProps,1)
      CALL AD_Copybladepropstype( SrcRotInputFileData%BladeProps(i1), DstRotInputFileData%BladeProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstRotInputFileData%NumTwrNds = SrcRotInputFileData%NumTwrNds
IF (ALLOCATED(SrcRotInputFileData%TwrElev)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrElev,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrElev,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrElev)) THEN 
    ALLOCATE(DstRotInputFileData%TwrElev(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrElev = SrcRotInputFileData%TwrElev
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrDiam)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrDiam,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrDiam,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrDiam)) THEN 
    ALLOCATE(DstRotInputFileData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrDiam = SrcRotInputFileData%TwrDiam
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCd)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCd,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCd,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCd)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCd = SrcRotInputFileData%TwrCd
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrTI)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrTI,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrTI,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrTI)) THEN 
    ALLOCATE(DstRotInputFileData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrTI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrTI = SrcRotInputFileData%TwrTI
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCb)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCb,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCb,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCb)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCb = SrcRotInputFileData%TwrCb
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCp)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCp,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCp,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCp)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCp = SrcRotInputFileData%TwrCp
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCa)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCa,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCa,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCa)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCa(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCa.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCa = SrcRotInputFileData%TwrCa
ENDIF
    DstRotInputFileData%VolHub = SrcRotInputFileData%VolHub
    DstRotInputFileData%HubCenBx = SrcRotInputFileData%HubCenBx
    DstRotInputFileData%VolNac = SrcRotInputFileData%VolNac
    DstRotInputFileData%NacCenB = SrcRotInputFileData%NacCenB
    DstRotInputFileData%TFinAero = SrcRotInputFileData%TFinAero
    DstRotInputFileData%TFinFile = SrcRotInputFileData%TFinFile
      CALL AD_Copytfininputfiletype( SrcRotInputFileData%TFin, DstRotInputFileData%TFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotInputFile

 SUBROUTINE AD_DestroyRotInputFile( RotInputFileData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(RotInputFile), INTENT(INOUT) :: RotInputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(RotInputFileData%BladeProps)) THEN
DO i1 = LBOUND(RotInputFileData%BladeProps,1), UBOUND(RotInputFileData%BladeProps,1)
  CALL AD_Destroybladepropstype( RotInputFileData%BladeProps(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputFileData%BladeProps)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrElev)) THEN
  DEALLOCATE(RotInputFileData%TwrElev)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrDiam)) THEN
  DEALLOCATE(RotInputFileData%TwrDiam)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCd)) THEN
  DEALLOCATE(RotInputFileData%TwrCd)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrTI)) THEN
  DEALLOCATE(RotInputFileData%TwrTI)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCb)) THEN
  DEALLOCATE(RotInputFileData%TwrCb)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCp)) THEN
  DEALLOCATE(RotInputFileData%TwrCp)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCa)) THEN
  DEALLOCATE(RotInputFileData%TwrCa)
ENDIF
  CALL AD_Destroytfininputfiletype( RotInputFileData%TFin, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotInputFile

 SUBROUTINE AD_PackRotInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RotInputFile),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackRotInputFile'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! BladeProps allocated yes/no
  IF ( ALLOCATED(InData%BladeProps) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeProps upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%BladeProps,1), UBOUND(InData%BladeProps,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeProps: size of buffers for each call to pack subtype
      CALL AD_Packbladepropstype( Re_Buf, Db_Buf, Int_Buf, InData%BladeProps(i1), ErrStat2, ErrMsg2, .TRUE. ) ! BladeProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeProps
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeProps
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeProps
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumTwrNds
  Int_BufSz   = Int_BufSz   + 1     ! TwrElev allocated yes/no
  IF ( ALLOCATED(InData%TwrElev) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrElev upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrElev)  ! TwrElev
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrDiam allocated yes/no
  IF ( ALLOCATED(InData%TwrDiam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrDiam upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrDiam)  ! TwrDiam
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCd allocated yes/no
  IF ( ALLOCATED(InData%TwrCd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCd upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCd)  ! TwrCd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrTI allocated yes/no
  IF ( ALLOCATED(InData%TwrTI) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrTI upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrTI)  ! TwrTI
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCb allocated yes/no
  IF ( ALLOCATED(InData%TwrCb) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCb upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCb)  ! TwrCb
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCp allocated yes/no
  IF ( ALLOCATED(InData%TwrCp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCp upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCp)  ! TwrCp
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCa allocated yes/no
  IF ( ALLOCATED(InData%TwrCa) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCa upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCa)  ! TwrCa
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! VolHub
      Re_BufSz   = Re_BufSz   + 1  ! HubCenBx
      Re_BufSz   = Re_BufSz   + 1  ! VolNac
      Re_BufSz   = Re_BufSz   + SIZE(InData%NacCenB)  ! NacCenB
      Int_BufSz  = Int_BufSz  + 1  ! TFinAero
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%TFinFile)  ! TFinFile
      Int_BufSz   = Int_BufSz + 3  ! TFin: size of buffers for each call to pack subtype
      CALL AD_Packtfininputfiletype( Re_Buf, Db_Buf, Int_Buf, InData%TFin, ErrStat2, ErrMsg2, .TRUE. ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TFin
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TFin
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TFin
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%BladeProps) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeProps,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeProps,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeProps,1), UBOUND(InData%BladeProps,1)
      CALL AD_Packbladepropstype( Re_Buf, Db_Buf, Int_Buf, InData%BladeProps(i1), ErrStat2, ErrMsg2, OnlySize ) ! BladeProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumTwrNds
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%TwrElev) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrElev,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrElev,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrElev,1), UBOUND(InData%TwrElev,1)
        ReKiBuf(Re_Xferred) = InData%TwrElev(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrDiam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrDiam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrDiam,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrDiam,1), UBOUND(InData%TwrDiam,1)
        ReKiBuf(Re_Xferred) = InData%TwrDiam(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCd,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCd,1), UBOUND(InData%TwrCd,1)
        ReKiBuf(Re_Xferred) = InData%TwrCd(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrTI) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrTI,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrTI,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrTI,1), UBOUND(InData%TwrTI,1)
        ReKiBuf(Re_Xferred) = InData%TwrTI(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCb) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCb,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCb,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCb,1), UBOUND(InData%TwrCb,1)
        ReKiBuf(Re_Xferred) = InData%TwrCb(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCp,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCp,1), UBOUND(InData%TwrCp,1)
        ReKiBuf(Re_Xferred) = InData%TwrCp(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCa) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCa,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCa,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCa,1), UBOUND(InData%TwrCa,1)
        ReKiBuf(Re_Xferred) = InData%TwrCa(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%VolHub
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%HubCenBx
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VolNac
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%NacCenB,1), UBOUND(InData%NacCenB,1)
      ReKiBuf(Re_Xferred) = InData%NacCenB(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TFinAero, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%TFinFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%TFinFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
      CALL AD_Packtfininputfiletype( Re_Buf, Db_Buf, Int_Buf, InData%TFin, ErrStat2, ErrMsg2, OnlySize ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD_PackRotInputFile

 SUBROUTINE AD_UnPackRotInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RotInputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackRotInputFile'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeProps not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeProps)) DEALLOCATE(OutData%BladeProps)
    ALLOCATE(OutData%BladeProps(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeProps.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeProps,1), UBOUND(OutData%BladeProps,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD_Unpackbladepropstype( Re_Buf, Db_Buf, Int_Buf, OutData%BladeProps(i1), ErrStat2, ErrMsg2 ) ! BladeProps 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NumTwrNds = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrElev not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrElev)) DEALLOCATE(OutData%TwrElev)
    ALLOCATE(OutData%TwrElev(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrElev.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrElev,1), UBOUND(OutData%TwrElev,1)
        OutData%TwrElev(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrDiam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrDiam)) DEALLOCATE(OutData%TwrDiam)
    ALLOCATE(OutData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrDiam,1), UBOUND(OutData%TwrDiam,1)
        OutData%TwrDiam(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCd)) DEALLOCATE(OutData%TwrCd)
    ALLOCATE(OutData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCd,1), UBOUND(OutData%TwrCd,1)
        OutData%TwrCd(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrTI not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrTI)) DEALLOCATE(OutData%TwrTI)
    ALLOCATE(OutData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrTI,1), UBOUND(OutData%TwrTI,1)
        OutData%TwrTI(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCb not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCb)) DEALLOCATE(OutData%TwrCb)
    ALLOCATE(OutData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCb,1), UBOUND(OutData%TwrCb,1)
        OutData%TwrCb(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCp)) DEALLOCATE(OutData%TwrCp)
    ALLOCATE(OutData%TwrCp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCp,1), UBOUND(OutData%TwrCp,1)
        OutData%TwrCp(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCa not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCa)) DEALLOCATE(OutData%TwrCa)
    ALLOCATE(OutData%TwrCa(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCa.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCa,1), UBOUND(OutData%TwrCa,1)
        OutData%TwrCa(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%VolHub = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%HubCenBx = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VolNac = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%NacCenB,1)
    i1_u = UBOUND(OutData%NacCenB,1)
    DO i1 = LBOUND(OutData%NacCenB,1), UBOUND(OutData%NacCenB,1)
      OutData%NacCenB(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%TFinAero = TRANSFER(IntKiBuf(Int_Xferred), OutData%TFinAero)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%TFinFile)
      OutData%TFinFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD_Unpacktfininputfiletype( Re_Buf, Db_Buf, Int_Buf, OutData%TFin, ErrStat2, ErrMsg2 ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD_UnPackRotInputFile

 SUBROUTINE AD_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(AD_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%DTAero = SrcInputFileData%DTAero
    DstInputFileData%WakeMod = SrcInputFileData%WakeMod
    DstInputFileData%AFAeroMod = SrcInputFileData%AFAeroMod
    DstInputFileData%TwrPotent = SrcInputFileData%TwrPotent
    DstInputFileData%TwrShadow = SrcInputFileData%TwrShadow
    DstInputFileData%TwrAero = SrcInputFileData%TwrAero
    DstInputFileData%FrozenWake = SrcInputFileData%FrozenWake
    DstInputFileData%CavitCheck = SrcInputFileData%CavitCheck
    DstInputFileData%CompAA = SrcInputFileData%CompAA
    DstInputFileData%AA_InputFile = SrcInputFileData%AA_InputFile
IF (ALLOCATED(SrcInputFileData%ADBlFile)) THEN
  i1_l = LBOUND(SrcInputFileData%ADBlFile,1)
  i1_u = UBOUND(SrcInputFileData%ADBlFile,1)
  IF (.NOT. ALLOCATED(DstInputFileData%ADBlFile)) THEN 
    ALLOCATE(DstInputFileData%ADBlFile(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%ADBlFile.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%ADBlFile = SrcInputFileData%ADBlFile
ENDIF
    DstInputFileData%AirDens = SrcInputFileData%AirDens
    DstInputFileData%KinVisc = SrcInputFileData%KinVisc
    DstInputFileData%Patm = SrcInputFileData%Patm
    DstInputFileData%Pvap = SrcInputFileData%Pvap
    DstInputFileData%SpdSound = SrcInputFileData%SpdSound
    DstInputFileData%SkewMod = SrcInputFileData%SkewMod
    DstInputFileData%SkewModFactor = SrcInputFileData%SkewModFactor
    DstInputFileData%TipLoss = SrcInputFileData%TipLoss
    DstInputFileData%HubLoss = SrcInputFileData%HubLoss
    DstInputFileData%TanInd = SrcInputFileData%TanInd
    DstInputFileData%AIDrag = SrcInputFileData%AIDrag
    DstInputFileData%TIDrag = SrcInputFileData%TIDrag
    DstInputFileData%IndToler = SrcInputFileData%IndToler
    DstInputFileData%MaxIter = SrcInputFileData%MaxIter
    DstInputFileData%UAMod = SrcInputFileData%UAMod
    DstInputFileData%FLookup = SrcInputFileData%FLookup
    DstInputFileData%InCol_Alfa = SrcInputFileData%InCol_Alfa
    DstInputFileData%InCol_Cl = SrcInputFileData%InCol_Cl
    DstInputFileData%InCol_Cd = SrcInputFileData%InCol_Cd
    DstInputFileData%InCol_Cm = SrcInputFileData%InCol_Cm
    DstInputFileData%InCol_Cpmin = SrcInputFileData%InCol_Cpmin
    DstInputFileData%AFTabMod = SrcInputFileData%AFTabMod
    DstInputFileData%NumAFfiles = SrcInputFileData%NumAFfiles
    DstInputFileData%FVWFileName = SrcInputFileData%FVWFileName
IF (ALLOCATED(SrcInputFileData%AFNames)) THEN
  i1_l = LBOUND(SrcInputFileData%AFNames,1)
  i1_u = UBOUND(SrcInputFileData%AFNames,1)
  IF (.NOT. ALLOCATED(DstInputFileData%AFNames)) THEN 
    ALLOCATE(DstInputFileData%AFNames(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AFNames.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AFNames = SrcInputFileData%AFNames
ENDIF
    DstInputFileData%UseBlCm = SrcInputFileData%UseBlCm
    DstInputFileData%SumPrint = SrcInputFileData%SumPrint
    DstInputFileData%NBlOuts = SrcInputFileData%NBlOuts
    DstInputFileData%BlOutNd = SrcInputFileData%BlOutNd
    DstInputFileData%NTwOuts = SrcInputFileData%NTwOuts
    DstInputFileData%TwOutNd = SrcInputFileData%TwOutNd
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%tau1_const = SrcInputFileData%tau1_const
    DstInputFileData%DBEMT_Mod = SrcInputFileData%DBEMT_Mod
    DstInputFileData%BldNd_NumOuts = SrcInputFileData%BldNd_NumOuts
IF (ALLOCATED(SrcInputFileData%BldNd_OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%BldNd_OutList,1)
  i1_u = UBOUND(SrcInputFileData%BldNd_OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%BldNd_OutList)) THEN 
    ALLOCATE(DstInputFileData%BldNd_OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BldNd_OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%BldNd_OutList = SrcInputFileData%BldNd_OutList
ENDIF
    DstInputFileData%BldNd_BlOutNd_Str = SrcInputFileData%BldNd_BlOutNd_Str
    DstInputFileData%BldNd_BladesOut = SrcInputFileData%BldNd_BladesOut
    DstInputFileData%UAStartRad = SrcInputFileData%UAStartRad
    DstInputFileData%UAEndRad = SrcInputFileData%UAEndRad
IF (ALLOCATED(SrcInputFileData%rotors)) THEN
  i1_l = LBOUND(SrcInputFileData%rotors,1)
  i1_u = UBOUND(SrcInputFileData%rotors,1)
  IF (.NOT. ALLOCATED(DstInputFileData%rotors)) THEN 
    ALLOCATE(DstInputFileData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputFileData%rotors,1), UBOUND(SrcInputFileData%rotors,1)
      CALL AD_Copyrotinputfile( SrcInputFileData%rotors(i1), DstInputFileData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AD_CopyInputFile
=======
   ErrMsg  = ''
   if (allocated(SrcInitInputData%rotors)) then
      LB(1:1) = lbound(SrcInitInputData%rotors)
      UB(1:1) = ubound(SrcInitInputData%rotors)
      if (.not. allocated(DstInitInputData%rotors)) then
         allocate(DstInitInputData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotInitInputType(SrcInitInputData%rotors(i1), DstInitInputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%UsePrimaryInputFile = SrcInitInputData%UsePrimaryInputFile
   call NWTC_Library_CopyFileInfoType(SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitInputData%Linearize = SrcInitInputData%Linearize
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%MHK = SrcInitInputData%MHK
   DstInitInputData%defFldDens = SrcInitInputData%defFldDens
   DstInitInputData%defKinVisc = SrcInitInputData%defKinVisc
   DstInitInputData%defSpdSound = SrcInitInputData%defSpdSound
   DstInitInputData%defPatm = SrcInitInputData%defPatm
   DstInitInputData%defPvap = SrcInitInputData%defPvap
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
end subroutine

subroutine AD_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(AD_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%rotors)) then
      LB(1:1) = lbound(InitInputData%rotors)
      UB(1:1) = ubound(InitInputData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotInitInputType(InitInputData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%rotors)
   end if
   call NWTC_Library_DestroyFileInfoType(InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine
>>>>>>> luwang00/f/IfW_SeaSt_Coupling

subroutine AD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInitInputType(Buf, InData%rotors(i1)) 
      end do
   end if
   call RegPack(Buf, InData%InputFile)
   call RegPack(Buf, InData%RootName)
   call RegPack(Buf, InData%UsePrimaryInputFile)
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrimaryInputData) 
   call RegPack(Buf, InData%Linearize)
   call RegPack(Buf, InData%Gravity)
   call RegPack(Buf, InData%MHK)
   call RegPack(Buf, InData%defFldDens)
   call RegPack(Buf, InData%defKinVisc)
   call RegPack(Buf, InData%defSpdSound)
   call RegPack(Buf, InData%defPatm)
   call RegPack(Buf, InData%defPvap)
   call RegPack(Buf, InData%WtrDpth)
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInitInputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UsePrimaryInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%defFldDens)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%defKinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%defSpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%defPatm)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%defPvap)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

<<<<<<< HEAD
  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(InputFileData%ADBlFile)) THEN
  DEALLOCATE(InputFileData%ADBlFile)
ENDIF
IF (ALLOCATED(InputFileData%AFNames)) THEN
  DEALLOCATE(InputFileData%AFNames)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
IF (ALLOCATED(InputFileData%BldNd_OutList)) THEN
  DEALLOCATE(InputFileData%BldNd_OutList)
ENDIF
IF (ALLOCATED(InputFileData%rotors)) THEN
DO i1 = LBOUND(InputFileData%rotors,1), UBOUND(InputFileData%rotors,1)
  CALL AD_Destroyrotinputfile( InputFileData%rotors(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputFileData%rotors)
ENDIF
 END SUBROUTINE AD_DestroyInputFile

 SUBROUTINE AD_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_InputFile),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackInputFile'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Echo
      Db_BufSz   = Db_BufSz   + 1  ! DTAero
      Int_BufSz  = Int_BufSz  + 1  ! WakeMod
      Int_BufSz  = Int_BufSz  + 1  ! AFAeroMod
      Int_BufSz  = Int_BufSz  + 1  ! TwrPotent
      Int_BufSz  = Int_BufSz  + 1  ! TwrShadow
      Int_BufSz  = Int_BufSz  + 1  ! TwrAero
      Int_BufSz  = Int_BufSz  + 1  ! FrozenWake
      Int_BufSz  = Int_BufSz  + 1  ! CavitCheck
      Int_BufSz  = Int_BufSz  + 1  ! CompAA
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%AA_InputFile)  ! AA_InputFile
  Int_BufSz   = Int_BufSz   + 1     ! ADBlFile allocated yes/no
  IF ( ALLOCATED(InData%ADBlFile) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ADBlFile upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ADBlFile)*LEN(InData%ADBlFile)  ! ADBlFile
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! AirDens
      Re_BufSz   = Re_BufSz   + 1  ! KinVisc
      Re_BufSz   = Re_BufSz   + 1  ! Patm
      Re_BufSz   = Re_BufSz   + 1  ! Pvap
      Re_BufSz   = Re_BufSz   + 1  ! SpdSound
      Int_BufSz  = Int_BufSz  + 1  ! SkewMod
      Re_BufSz   = Re_BufSz   + 1  ! SkewModFactor
      Int_BufSz  = Int_BufSz  + 1  ! TipLoss
      Int_BufSz  = Int_BufSz  + 1  ! HubLoss
      Int_BufSz  = Int_BufSz  + 1  ! TanInd
      Int_BufSz  = Int_BufSz  + 1  ! AIDrag
      Int_BufSz  = Int_BufSz  + 1  ! TIDrag
      Re_BufSz   = Re_BufSz   + 1  ! IndToler
      Re_BufSz   = Re_BufSz   + 1  ! MaxIter
      Int_BufSz  = Int_BufSz  + 1  ! UAMod
      Int_BufSz  = Int_BufSz  + 1  ! FLookup
      Re_BufSz   = Re_BufSz   + 1  ! InCol_Alfa
      Re_BufSz   = Re_BufSz   + 1  ! InCol_Cl
      Re_BufSz   = Re_BufSz   + 1  ! InCol_Cd
      Re_BufSz   = Re_BufSz   + 1  ! InCol_Cm
      Re_BufSz   = Re_BufSz   + 1  ! InCol_Cpmin
      Int_BufSz  = Int_BufSz  + 1  ! AFTabMod
      Int_BufSz  = Int_BufSz  + 1  ! NumAFfiles
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FVWFileName)  ! FVWFileName
  Int_BufSz   = Int_BufSz   + 1     ! AFNames allocated yes/no
  IF ( ALLOCATED(InData%AFNames) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AFNames upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%AFNames)*LEN(InData%AFNames)  ! AFNames
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! UseBlCm
      Int_BufSz  = Int_BufSz  + 1  ! SumPrint
      Int_BufSz  = Int_BufSz  + 1  ! NBlOuts
      Int_BufSz  = Int_BufSz  + SIZE(InData%BlOutNd)  ! BlOutNd
      Int_BufSz  = Int_BufSz  + 1  ! NTwOuts
      Int_BufSz  = Int_BufSz  + SIZE(InData%TwOutNd)  ! TwOutNd
      Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz   = Int_BufSz   + 1     ! OutList allocated yes/no
  IF ( ALLOCATED(InData%OutList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! OutList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutList)*LEN(InData%OutList)  ! OutList
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! tau1_const
      Int_BufSz  = Int_BufSz  + 1  ! DBEMT_Mod
      Int_BufSz  = Int_BufSz  + 1  ! BldNd_NumOuts
  Int_BufSz   = Int_BufSz   + 1     ! BldNd_OutList allocated yes/no
  IF ( ALLOCATED(InData%BldNd_OutList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BldNd_OutList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BldNd_OutList)*LEN(InData%BldNd_OutList)  ! BldNd_OutList
  END IF
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%BldNd_BlOutNd_Str)  ! BldNd_BlOutNd_Str
      Int_BufSz  = Int_BufSz  + 1  ! BldNd_BladesOut
      Re_BufSz   = Re_BufSz   + 1  ! UAStartRad
      Re_BufSz   = Re_BufSz   + 1  ! UAEndRad
  Int_BufSz   = Int_BufSz   + 1     ! rotors allocated yes/no
  IF ( ALLOCATED(InData%rotors) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! rotors upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%rotors,1), UBOUND(InData%rotors,1)
      Int_BufSz   = Int_BufSz + 3  ! rotors: size of buffers for each call to pack subtype
      CALL AD_Packrotinputfile( Re_Buf, Db_Buf, Int_Buf, InData%rotors(i1), ErrStat2, ErrMsg2, .TRUE. ) ! rotors 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! rotors
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! rotors
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! rotors
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = TRANSFER(InData%Echo, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTAero
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WakeMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AFAeroMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TwrPotent
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TwrShadow
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TwrAero, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FrozenWake, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%CavitCheck, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%CompAA, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%AA_InputFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%AA_InputFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( .NOT. ALLOCATED(InData%ADBlFile) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ADBlFile,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ADBlFile,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ADBlFile,1), UBOUND(InData%ADBlFile,1)
        DO I = 1, LEN(InData%ADBlFile)
          IntKiBuf(Int_Xferred) = ICHAR(InData%ADBlFile(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%AirDens
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%KinVisc
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Patm
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Pvap
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SpdSound
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%SkewMod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SkewModFactor
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TipLoss, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%HubLoss, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TanInd, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%AIDrag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TIDrag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%IndToler
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MaxIter
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%UAMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FLookup, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InCol_Alfa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InCol_Cl
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InCol_Cd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InCol_Cm
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InCol_Cpmin
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AFTabMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumAFfiles
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%FVWFileName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%FVWFileName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( .NOT. ALLOCATED(InData%AFNames) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFNames,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFNames,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%AFNames,1), UBOUND(InData%AFNames,1)
        DO I = 1, LEN(InData%AFNames)
          IntKiBuf(Int_Xferred) = ICHAR(InData%AFNames(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    IntKiBuf(Int_Xferred) = TRANSFER(InData%UseBlCm, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%SumPrint, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NBlOuts
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%BlOutNd,1), UBOUND(InData%BlOutNd,1)
      IntKiBuf(Int_Xferred) = InData%BlOutNd(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%NTwOuts
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%TwOutNd,1), UBOUND(InData%TwOutNd,1)
      IntKiBuf(Int_Xferred) = InData%TwOutNd(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%NumOuts
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%OutList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OutList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OutList,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%OutList,1), UBOUND(InData%OutList,1)
        DO I = 1, LEN(InData%OutList)
          IntKiBuf(Int_Xferred) = ICHAR(InData%OutList(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%tau1_const
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%DBEMT_Mod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%BldNd_NumOuts
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%BldNd_OutList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BldNd_OutList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BldNd_OutList,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BldNd_OutList,1), UBOUND(InData%BldNd_OutList,1)
        DO I = 1, LEN(InData%BldNd_OutList)
          IntKiBuf(Int_Xferred) = ICHAR(InData%BldNd_OutList(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    DO I = 1, LEN(InData%BldNd_BlOutNd_Str)
      IntKiBuf(Int_Xferred) = ICHAR(InData%BldNd_BlOutNd_Str(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = InData%BldNd_BladesOut
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%UAStartRad
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%UAEndRad
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%rotors) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rotors,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rotors,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%rotors,1), UBOUND(InData%rotors,1)
      CALL AD_Packrotinputfile( Re_Buf, Db_Buf, Int_Buf, InData%rotors(i1), ErrStat2, ErrMsg2, OnlySize ) ! rotors 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
 END SUBROUTINE AD_PackInputFile

 SUBROUTINE AD_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackInputFile'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Echo = TRANSFER(IntKiBuf(Int_Xferred), OutData%Echo)
    Int_Xferred = Int_Xferred + 1
    OutData%DTAero = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%WakeMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%AFAeroMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrPotent = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrShadow = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrAero = TRANSFER(IntKiBuf(Int_Xferred), OutData%TwrAero)
    Int_Xferred = Int_Xferred + 1
    OutData%FrozenWake = TRANSFER(IntKiBuf(Int_Xferred), OutData%FrozenWake)
    Int_Xferred = Int_Xferred + 1
    OutData%CavitCheck = TRANSFER(IntKiBuf(Int_Xferred), OutData%CavitCheck)
    Int_Xferred = Int_Xferred + 1
    OutData%CompAA = TRANSFER(IntKiBuf(Int_Xferred), OutData%CompAA)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%AA_InputFile)
      OutData%AA_InputFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ADBlFile not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ADBlFile)) DEALLOCATE(OutData%ADBlFile)
    ALLOCATE(OutData%ADBlFile(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADBlFile.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ADBlFile,1), UBOUND(OutData%ADBlFile,1)
        DO I = 1, LEN(OutData%ADBlFile)
          OutData%ADBlFile(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    OutData%AirDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%KinVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Patm = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Pvap = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SpdSound = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SkewMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%SkewModFactor = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TipLoss = TRANSFER(IntKiBuf(Int_Xferred), OutData%TipLoss)
    Int_Xferred = Int_Xferred + 1
    OutData%HubLoss = TRANSFER(IntKiBuf(Int_Xferred), OutData%HubLoss)
    Int_Xferred = Int_Xferred + 1
    OutData%TanInd = TRANSFER(IntKiBuf(Int_Xferred), OutData%TanInd)
    Int_Xferred = Int_Xferred + 1
    OutData%AIDrag = TRANSFER(IntKiBuf(Int_Xferred), OutData%AIDrag)
    Int_Xferred = Int_Xferred + 1
    OutData%TIDrag = TRANSFER(IntKiBuf(Int_Xferred), OutData%TIDrag)
    Int_Xferred = Int_Xferred + 1
    OutData%IndToler = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MaxIter = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%UAMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FLookup = TRANSFER(IntKiBuf(Int_Xferred), OutData%FLookup)
    Int_Xferred = Int_Xferred + 1
    OutData%InCol_Alfa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InCol_Cl = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InCol_Cd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InCol_Cm = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InCol_Cpmin = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AFTabMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumAFfiles = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%FVWFileName)
      OutData%FVWFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AFNames not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AFNames)) DEALLOCATE(OutData%AFNames)
    ALLOCATE(OutData%AFNames(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFNames.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%AFNames,1), UBOUND(OutData%AFNames,1)
        DO I = 1, LEN(OutData%AFNames)
          OutData%AFNames(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    OutData%UseBlCm = TRANSFER(IntKiBuf(Int_Xferred), OutData%UseBlCm)
    Int_Xferred = Int_Xferred + 1
    OutData%SumPrint = TRANSFER(IntKiBuf(Int_Xferred), OutData%SumPrint)
    Int_Xferred = Int_Xferred + 1
    OutData%NBlOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%BlOutNd,1)
    i1_u = UBOUND(OutData%BlOutNd,1)
    DO i1 = LBOUND(OutData%BlOutNd,1), UBOUND(OutData%BlOutNd,1)
      OutData%BlOutNd(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%NTwOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%TwOutNd,1)
    i1_u = UBOUND(OutData%TwOutNd,1)
    DO i1 = LBOUND(OutData%TwOutNd,1), UBOUND(OutData%TwOutNd,1)
      OutData%TwOutNd(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OutList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OutList)) DEALLOCATE(OutData%OutList)
    ALLOCATE(OutData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%OutList,1), UBOUND(OutData%OutList,1)
        DO I = 1, LEN(OutData%OutList)
          OutData%OutList(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    OutData%tau1_const = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DBEMT_Mod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%BldNd_NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BldNd_OutList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BldNd_OutList)) DEALLOCATE(OutData%BldNd_OutList)
    ALLOCATE(OutData%BldNd_OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BldNd_OutList,1), UBOUND(OutData%BldNd_OutList,1)
        DO I = 1, LEN(OutData%BldNd_OutList)
          OutData%BldNd_OutList(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    DO I = 1, LEN(OutData%BldNd_BlOutNd_Str)
      OutData%BldNd_BlOutNd_Str(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%BldNd_BladesOut = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UAStartRad = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%UAEndRad = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! rotors not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%rotors)) DEALLOCATE(OutData%rotors)
    ALLOCATE(OutData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%rotors,1), UBOUND(OutData%rotors,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD_Unpackrotinputfile( Re_Buf, Db_Buf, Int_Buf, OutData%rotors(i1), ErrStat2, ErrMsg2 ) ! rotors 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
 END SUBROUTINE AD_UnPackInputFile

 SUBROUTINE AD_CopyRotContinuousStateType( SrcRotContinuousStateTypeData, DstRotContinuousStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotContinuousStateType), INTENT(IN) :: SrcRotContinuousStateTypeData
   TYPE(RotContinuousStateType), INTENT(INOUT) :: DstRotContinuousStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotContinuousStateType'
! 
=======
subroutine AD_CopyBladePropsType(SrcBladePropsTypeData, DstBladePropsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(AD_BladePropsType), intent(in) :: SrcBladePropsTypeData
   type(AD_BladePropsType), intent(inout) :: DstBladePropsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD_CopyBladePropsType'
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstBladePropsTypeData%NumBlNds = SrcBladePropsTypeData%NumBlNds
   if (allocated(SrcBladePropsTypeData%BlSpn)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlSpn)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlSpn)
      if (.not. allocated(DstBladePropsTypeData%BlSpn)) then
         allocate(DstBladePropsTypeData%BlSpn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSpn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlSpn = SrcBladePropsTypeData%BlSpn
   end if
   if (allocated(SrcBladePropsTypeData%BlCrvAC)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlCrvAC)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlCrvAC)
      if (.not. allocated(DstBladePropsTypeData%BlCrvAC)) then
         allocate(DstBladePropsTypeData%BlCrvAC(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlCrvAC = SrcBladePropsTypeData%BlCrvAC
   end if
   if (allocated(SrcBladePropsTypeData%BlSwpAC)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlSwpAC)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlSwpAC)
      if (.not. allocated(DstBladePropsTypeData%BlSwpAC)) then
         allocate(DstBladePropsTypeData%BlSwpAC(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSwpAC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlSwpAC = SrcBladePropsTypeData%BlSwpAC
   end if
   if (allocated(SrcBladePropsTypeData%BlCrvAng)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlCrvAng)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlCrvAng)
      if (.not. allocated(DstBladePropsTypeData%BlCrvAng)) then
         allocate(DstBladePropsTypeData%BlCrvAng(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAng.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlCrvAng = SrcBladePropsTypeData%BlCrvAng
   end if
   if (allocated(SrcBladePropsTypeData%BlTwist)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlTwist)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlTwist)
      if (.not. allocated(DstBladePropsTypeData%BlTwist)) then
         allocate(DstBladePropsTypeData%BlTwist(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlTwist.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlTwist = SrcBladePropsTypeData%BlTwist
   end if
   if (allocated(SrcBladePropsTypeData%BlChord)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlChord)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlChord)
      if (.not. allocated(DstBladePropsTypeData%BlChord)) then
         allocate(DstBladePropsTypeData%BlChord(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlChord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlChord = SrcBladePropsTypeData%BlChord
   end if
   if (allocated(SrcBladePropsTypeData%BlAFID)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlAFID)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlAFID)
      if (.not. allocated(DstBladePropsTypeData%BlAFID)) then
         allocate(DstBladePropsTypeData%BlAFID(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlAFID.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlAFID = SrcBladePropsTypeData%BlAFID
   end if
   if (allocated(SrcBladePropsTypeData%BlCb)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlCb)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlCb)
      if (.not. allocated(DstBladePropsTypeData%BlCb)) then
         allocate(DstBladePropsTypeData%BlCb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlCb = SrcBladePropsTypeData%BlCb
   end if
   if (allocated(SrcBladePropsTypeData%BlCenBn)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlCenBn)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlCenBn)
      if (.not. allocated(DstBladePropsTypeData%BlCenBn)) then
         allocate(DstBladePropsTypeData%BlCenBn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlCenBn = SrcBladePropsTypeData%BlCenBn
   end if
   if (allocated(SrcBladePropsTypeData%BlCenBt)) then
      LB(1:1) = lbound(SrcBladePropsTypeData%BlCenBt)
      UB(1:1) = ubound(SrcBladePropsTypeData%BlCenBt)
      if (.not. allocated(DstBladePropsTypeData%BlCenBt)) then
         allocate(DstBladePropsTypeData%BlCenBt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladePropsTypeData%BlCenBt = SrcBladePropsTypeData%BlCenBt
   end if
end subroutine

subroutine AD_DestroyBladePropsType(BladePropsTypeData, ErrStat, ErrMsg)
   type(AD_BladePropsType), intent(inout) :: BladePropsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyBladePropsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladePropsTypeData%BlSpn)) then
      deallocate(BladePropsTypeData%BlSpn)
   end if
   if (allocated(BladePropsTypeData%BlCrvAC)) then
      deallocate(BladePropsTypeData%BlCrvAC)
   end if
   if (allocated(BladePropsTypeData%BlSwpAC)) then
      deallocate(BladePropsTypeData%BlSwpAC)
   end if
   if (allocated(BladePropsTypeData%BlCrvAng)) then
      deallocate(BladePropsTypeData%BlCrvAng)
   end if
   if (allocated(BladePropsTypeData%BlTwist)) then
      deallocate(BladePropsTypeData%BlTwist)
   end if
   if (allocated(BladePropsTypeData%BlChord)) then
      deallocate(BladePropsTypeData%BlChord)
   end if
   if (allocated(BladePropsTypeData%BlAFID)) then
      deallocate(BladePropsTypeData%BlAFID)
   end if
   if (allocated(BladePropsTypeData%BlCb)) then
      deallocate(BladePropsTypeData%BlCb)
   end if
   if (allocated(BladePropsTypeData%BlCenBn)) then
      deallocate(BladePropsTypeData%BlCenBn)
   end if
   if (allocated(BladePropsTypeData%BlCenBt)) then
      deallocate(BladePropsTypeData%BlCenBt)
   end if
end subroutine

subroutine AD_PackBladePropsType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_BladePropsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackBladePropsType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%NumBlNds)
   call RegPack(Buf, allocated(InData%BlSpn))
   if (allocated(InData%BlSpn)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlSpn), ubound(InData%BlSpn))
      call RegPack(Buf, InData%BlSpn)
   end if
   call RegPack(Buf, allocated(InData%BlCrvAC))
   if (allocated(InData%BlCrvAC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCrvAC), ubound(InData%BlCrvAC))
      call RegPack(Buf, InData%BlCrvAC)
   end if
   call RegPack(Buf, allocated(InData%BlSwpAC))
   if (allocated(InData%BlSwpAC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlSwpAC), ubound(InData%BlSwpAC))
      call RegPack(Buf, InData%BlSwpAC)
   end if
   call RegPack(Buf, allocated(InData%BlCrvAng))
   if (allocated(InData%BlCrvAng)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCrvAng), ubound(InData%BlCrvAng))
      call RegPack(Buf, InData%BlCrvAng)
   end if
   call RegPack(Buf, allocated(InData%BlTwist))
   if (allocated(InData%BlTwist)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlTwist), ubound(InData%BlTwist))
      call RegPack(Buf, InData%BlTwist)
   end if
   call RegPack(Buf, allocated(InData%BlChord))
   if (allocated(InData%BlChord)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlChord), ubound(InData%BlChord))
      call RegPack(Buf, InData%BlChord)
   end if
   call RegPack(Buf, allocated(InData%BlAFID))
   if (allocated(InData%BlAFID)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlAFID), ubound(InData%BlAFID))
      call RegPack(Buf, InData%BlAFID)
   end if
   call RegPack(Buf, allocated(InData%BlCb))
   if (allocated(InData%BlCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCb), ubound(InData%BlCb))
      call RegPack(Buf, InData%BlCb)
   end if
   call RegPack(Buf, allocated(InData%BlCenBn))
   if (allocated(InData%BlCenBn)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCenBn), ubound(InData%BlCenBn))
      call RegPack(Buf, InData%BlCenBn)
   end if
   call RegPack(Buf, allocated(InData%BlCenBt))
   if (allocated(InData%BlCenBt)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCenBt), ubound(InData%BlCenBt))
      call RegPack(Buf, InData%BlCenBt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackBladePropsType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_BladePropsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackBladePropsType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%BlSpn)) deallocate(OutData%BlSpn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlSpn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSpn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlSpn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCrvAC)) deallocate(OutData%BlCrvAC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCrvAC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCrvAC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlSwpAC)) deallocate(OutData%BlSwpAC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlSwpAC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSwpAC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlSwpAC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCrvAng)) deallocate(OutData%BlCrvAng)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCrvAng(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAng.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCrvAng)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlTwist)) deallocate(OutData%BlTwist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTwist(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTwist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlChord)) deallocate(OutData%BlChord)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlChord(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlChord.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlChord)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlAFID)) deallocate(OutData%BlAFID)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlAFID(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAFID.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlAFID)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCb)) deallocate(OutData%BlCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCenBn)) deallocate(OutData%BlCenBn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCenBt)) deallocate(OutData%BlCenBt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyBladeShape(SrcBladeShapeData, DstBladeShapeData, CtrlCode, ErrStat, ErrMsg)
   type(AD_BladeShape), intent(in) :: SrcBladeShapeData
   type(AD_BladeShape), intent(inout) :: DstBladeShapeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD_CopyBladeShape'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBladeShapeData%AirfoilCoords)) then
      LB(1:3) = lbound(SrcBladeShapeData%AirfoilCoords)
      UB(1:3) = ubound(SrcBladeShapeData%AirfoilCoords)
      if (.not. allocated(DstBladeShapeData%AirfoilCoords)) then
         allocate(DstBladeShapeData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeShapeData%AirfoilCoords.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeShapeData%AirfoilCoords = SrcBladeShapeData%AirfoilCoords
   end if
end subroutine

subroutine AD_DestroyBladeShape(BladeShapeData, ErrStat, ErrMsg)
   type(AD_BladeShape), intent(inout) :: BladeShapeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyBladeShape'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladeShapeData%AirfoilCoords)) then
      deallocate(BladeShapeData%AirfoilCoords)
   end if
end subroutine

subroutine AD_PackBladeShape(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_BladeShape), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackBladeShape'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%AirfoilCoords))
   if (allocated(InData%AirfoilCoords)) then
      call RegPackBounds(Buf, 3, lbound(InData%AirfoilCoords), ubound(InData%AirfoilCoords))
      call RegPack(Buf, InData%AirfoilCoords)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackBladeShape(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_BladeShape), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackBladeShape'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%AirfoilCoords)) deallocate(OutData%AirfoilCoords)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AirfoilCoords.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AirfoilCoords)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotInitOutputType(SrcRotInitOutputTypeData, DstRotInitOutputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotInitOutputType), intent(in) :: SrcRotInitOutputTypeData
   type(RotInitOutputType), intent(inout) :: DstRotInitOutputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotInitOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotInitOutputTypeData%AirDens = SrcRotInitOutputTypeData%AirDens
   if (allocated(SrcRotInitOutputTypeData%WriteOutputHdr)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%WriteOutputHdr)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%WriteOutputHdr)
      if (.not. allocated(DstRotInitOutputTypeData%WriteOutputHdr)) then
         allocate(DstRotInitOutputTypeData%WriteOutputHdr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%WriteOutputHdr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%WriteOutputHdr = SrcRotInitOutputTypeData%WriteOutputHdr
   end if
   if (allocated(SrcRotInitOutputTypeData%WriteOutputUnt)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%WriteOutputUnt)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%WriteOutputUnt)
      if (.not. allocated(DstRotInitOutputTypeData%WriteOutputUnt)) then
         allocate(DstRotInitOutputTypeData%WriteOutputUnt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%WriteOutputUnt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%WriteOutputUnt = SrcRotInitOutputTypeData%WriteOutputUnt
   end if
   if (allocated(SrcRotInitOutputTypeData%BladeShape)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%BladeShape)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%BladeShape)
      if (.not. allocated(DstRotInitOutputTypeData%BladeShape)) then
         allocate(DstRotInitOutputTypeData%BladeShape(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%BladeShape.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyBladeShape(SrcRotInitOutputTypeData%BladeShape(i1), DstRotInitOutputTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotInitOutputTypeData%LinNames_y)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%LinNames_y)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%LinNames_y)
      if (.not. allocated(DstRotInitOutputTypeData%LinNames_y)) then
         allocate(DstRotInitOutputTypeData%LinNames_y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%LinNames_y = SrcRotInitOutputTypeData%LinNames_y
   end if
   if (allocated(SrcRotInitOutputTypeData%LinNames_x)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%LinNames_x)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%LinNames_x)
      if (.not. allocated(DstRotInitOutputTypeData%LinNames_x)) then
         allocate(DstRotInitOutputTypeData%LinNames_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%LinNames_x = SrcRotInitOutputTypeData%LinNames_x
   end if
   if (allocated(SrcRotInitOutputTypeData%LinNames_u)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%LinNames_u)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%LinNames_u)
      if (.not. allocated(DstRotInitOutputTypeData%LinNames_u)) then
         allocate(DstRotInitOutputTypeData%LinNames_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%LinNames_u = SrcRotInitOutputTypeData%LinNames_u
   end if
   if (allocated(SrcRotInitOutputTypeData%RotFrame_y)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%RotFrame_y)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%RotFrame_y)
      if (.not. allocated(DstRotInitOutputTypeData%RotFrame_y)) then
         allocate(DstRotInitOutputTypeData%RotFrame_y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%RotFrame_y = SrcRotInitOutputTypeData%RotFrame_y
   end if
   if (allocated(SrcRotInitOutputTypeData%RotFrame_x)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%RotFrame_x)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%RotFrame_x)
      if (.not. allocated(DstRotInitOutputTypeData%RotFrame_x)) then
         allocate(DstRotInitOutputTypeData%RotFrame_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%RotFrame_x = SrcRotInitOutputTypeData%RotFrame_x
   end if
   if (allocated(SrcRotInitOutputTypeData%RotFrame_u)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%RotFrame_u)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%RotFrame_u)
      if (.not. allocated(DstRotInitOutputTypeData%RotFrame_u)) then
         allocate(DstRotInitOutputTypeData%RotFrame_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%RotFrame_u = SrcRotInitOutputTypeData%RotFrame_u
   end if
   if (allocated(SrcRotInitOutputTypeData%IsLoad_u)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%IsLoad_u)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%IsLoad_u)
      if (.not. allocated(DstRotInitOutputTypeData%IsLoad_u)) then
         allocate(DstRotInitOutputTypeData%IsLoad_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%IsLoad_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%IsLoad_u = SrcRotInitOutputTypeData%IsLoad_u
   end if
   if (allocated(SrcRotInitOutputTypeData%BladeProps)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%BladeProps)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%BladeProps)
      if (.not. allocated(DstRotInitOutputTypeData%BladeProps)) then
         allocate(DstRotInitOutputTypeData%BladeProps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%BladeProps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyBladePropsType(SrcRotInitOutputTypeData%BladeProps(i1), DstRotInitOutputTypeData%BladeProps(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotInitOutputTypeData%DerivOrder_x)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%DerivOrder_x)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%DerivOrder_x)
      if (.not. allocated(DstRotInitOutputTypeData%DerivOrder_x)) then
         allocate(DstRotInitOutputTypeData%DerivOrder_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%DerivOrder_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%DerivOrder_x = SrcRotInitOutputTypeData%DerivOrder_x
   end if
   if (allocated(SrcRotInitOutputTypeData%TwrElev)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%TwrElev)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%TwrElev)
      if (.not. allocated(DstRotInitOutputTypeData%TwrElev)) then
         allocate(DstRotInitOutputTypeData%TwrElev(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%TwrElev.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%TwrElev = SrcRotInitOutputTypeData%TwrElev
   end if
   if (allocated(SrcRotInitOutputTypeData%TwrDiam)) then
      LB(1:1) = lbound(SrcRotInitOutputTypeData%TwrDiam)
      UB(1:1) = ubound(SrcRotInitOutputTypeData%TwrDiam)
      if (.not. allocated(DstRotInitOutputTypeData%TwrDiam)) then
         allocate(DstRotInitOutputTypeData%TwrDiam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%TwrDiam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInitOutputTypeData%TwrDiam = SrcRotInitOutputTypeData%TwrDiam
   end if
end subroutine

subroutine AD_DestroyRotInitOutputType(RotInitOutputTypeData, ErrStat, ErrMsg)
   type(RotInitOutputType), intent(inout) :: RotInitOutputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotInitOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(RotInitOutputTypeData%WriteOutputHdr)) then
      deallocate(RotInitOutputTypeData%WriteOutputHdr)
   end if
   if (allocated(RotInitOutputTypeData%WriteOutputUnt)) then
      deallocate(RotInitOutputTypeData%WriteOutputUnt)
   end if
   if (allocated(RotInitOutputTypeData%BladeShape)) then
      LB(1:1) = lbound(RotInitOutputTypeData%BladeShape)
      UB(1:1) = ubound(RotInitOutputTypeData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_DestroyBladeShape(RotInitOutputTypeData%BladeShape(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInitOutputTypeData%BladeShape)
   end if
   if (allocated(RotInitOutputTypeData%LinNames_y)) then
      deallocate(RotInitOutputTypeData%LinNames_y)
   end if
   if (allocated(RotInitOutputTypeData%LinNames_x)) then
      deallocate(RotInitOutputTypeData%LinNames_x)
   end if
   if (allocated(RotInitOutputTypeData%LinNames_u)) then
      deallocate(RotInitOutputTypeData%LinNames_u)
   end if
   if (allocated(RotInitOutputTypeData%RotFrame_y)) then
      deallocate(RotInitOutputTypeData%RotFrame_y)
   end if
   if (allocated(RotInitOutputTypeData%RotFrame_x)) then
      deallocate(RotInitOutputTypeData%RotFrame_x)
   end if
   if (allocated(RotInitOutputTypeData%RotFrame_u)) then
      deallocate(RotInitOutputTypeData%RotFrame_u)
   end if
   if (allocated(RotInitOutputTypeData%IsLoad_u)) then
      deallocate(RotInitOutputTypeData%IsLoad_u)
   end if
   if (allocated(RotInitOutputTypeData%BladeProps)) then
      LB(1:1) = lbound(RotInitOutputTypeData%BladeProps)
      UB(1:1) = ubound(RotInitOutputTypeData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_DestroyBladePropsType(RotInitOutputTypeData%BladeProps(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInitOutputTypeData%BladeProps)
   end if
   if (allocated(RotInitOutputTypeData%DerivOrder_x)) then
      deallocate(RotInitOutputTypeData%DerivOrder_x)
   end if
   if (allocated(RotInitOutputTypeData%TwrElev)) then
      deallocate(RotInitOutputTypeData%TwrElev)
   end if
   if (allocated(RotInitOutputTypeData%TwrDiam)) then
      deallocate(RotInitOutputTypeData%TwrDiam)
   end if
end subroutine

subroutine AD_PackRotInitOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInitOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%AirDens)
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   call RegPack(Buf, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_PackBladeShape(Buf, InData%BladeShape(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   call RegPack(Buf, allocated(InData%BladeProps))
   if (allocated(InData%BladeProps)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeProps), ubound(InData%BladeProps))
      LB(1:1) = lbound(InData%BladeProps)
      UB(1:1) = ubound(InData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_PackBladePropsType(Buf, InData%BladeProps(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   call RegPack(Buf, allocated(InData%TwrElev))
   if (allocated(InData%TwrElev)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrElev), ubound(InData%TwrElev))
      call RegPack(Buf, InData%TwrElev)
   end if
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInitOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInitOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladeShape(Buf, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BladeProps)) deallocate(OutData%BladeProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeProps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladePropsType(Buf, OutData%BladeProps(i1)) ! BladeProps 
      end do
   end if
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrElev)) deallocate(OutData%TwrElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrElev(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD_InitOutputType), intent(in) :: SrcInitOutputData
   type(AD_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitOutputData%rotors)) then
      LB(1:1) = lbound(SrcInitOutputData%rotors)
      UB(1:1) = ubound(SrcInitOutputData%rotors)
      if (.not. allocated(DstInitOutputData%rotors)) then
         allocate(DstInitOutputData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotInitOutputType(SrcInitOutputData%rotors(i1), DstInitOutputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(AD_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitOutputData%rotors)) then
      LB(1:1) = lbound(InitOutputData%rotors)
      UB(1:1) = ubound(InitOutputData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotInitOutputType(InitOutputData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitOutputData%rotors)
   end if
   call NWTC_Library_DestroyProgDesc(InitOutputData%Ver, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInitOutputType(Buf, InData%rotors(i1)) 
      end do
   end if
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInitOutputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
end subroutine

subroutine AD_CopyRotInputFile(SrcRotInputFileData, DstRotInputFileData, CtrlCode, ErrStat, ErrMsg)
   type(RotInputFile), intent(in) :: SrcRotInputFileData
   type(RotInputFile), intent(inout) :: DstRotInputFileData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotInputFile'
   ErrStat = ErrID_None
<<<<<<< HEAD
   ErrMsg  = ""
      CALL BEMT_CopyMisc( SrcRotMiscVarTypeData%BEMT, DstRotMiscVarTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL BEMT_CopyOutput( SrcRotMiscVarTypeData%BEMT_y, DstRotMiscVarTypeData%BEMT_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BEMT_u,1), UBOUND(SrcRotMiscVarTypeData%BEMT_u,1)
      CALL BEMT_CopyInput( SrcRotMiscVarTypeData%BEMT_u(i1), DstRotMiscVarTypeData%BEMT_u(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL AA_CopyMisc( SrcRotMiscVarTypeData%AA, DstRotMiscVarTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyOutput( SrcRotMiscVarTypeData%AA_y, DstRotMiscVarTypeData%AA_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyInput( SrcRotMiscVarTypeData%AA_u, DstRotMiscVarTypeData%AA_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotMiscVarTypeData%DisturbedInflow)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%DisturbedInflow)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%DisturbedInflow(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%DisturbedInflow.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%DisturbedInflow = SrcRotMiscVarTypeData%DisturbedInflow
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%orientationAnnulus)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,3)
  i4_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,4)
  i4_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,4)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%orientationAnnulus)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%orientationAnnulus(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%orientationAnnulus.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%orientationAnnulus = SrcRotMiscVarTypeData%orientationAnnulus
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%AllOuts)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%AllOuts,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%AllOuts,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%AllOuts)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%AllOuts(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%AllOuts.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%AllOuts = SrcRotMiscVarTypeData%AllOuts
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%W_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%W_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%W_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%W_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%W_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%W_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%W_Twr = SrcRotMiscVarTypeData%W_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%X_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%X_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%X_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%X_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%X_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%X_Twr = SrcRotMiscVarTypeData%X_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Y_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Y_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Y_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Y_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Y_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Y_Twr = SrcRotMiscVarTypeData%Y_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Curve)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Curve,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Curve,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Curve,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Curve,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Curve)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Curve(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Curve.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Curve = SrcRotMiscVarTypeData%Curve
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrClrnc)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrClrnc,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrClrnc,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrClrnc,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrClrnc,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrClrnc)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrClrnc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrClrnc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrClrnc = SrcRotMiscVarTypeData%TwrClrnc
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%X)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%X,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%X,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%X,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%X,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%X)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%X(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%X = SrcRotMiscVarTypeData%X
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Y)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Y,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Y,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Y,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Y,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Y)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Y = SrcRotMiscVarTypeData%Y
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Z)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Z,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Z,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Z,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Z,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Z)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Z(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Z = SrcRotMiscVarTypeData%Z
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%M)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%M,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%M,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%M,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%M,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%M)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%M = SrcRotMiscVarTypeData%M
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Mx)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Mx,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Mx,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Mx,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Mx,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Mx)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Mx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Mx = SrcRotMiscVarTypeData%Mx
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%My)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%My,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%My,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%My,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%My,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%My)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%My(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%My.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%My = SrcRotMiscVarTypeData%My
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Mz)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Mz,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Mz,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Mz,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Mz,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Mz)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Mz(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Mz = SrcRotMiscVarTypeData%Mz
ENDIF
    DstRotMiscVarTypeData%V_DiskAvg = SrcRotMiscVarTypeData%V_DiskAvg
    DstRotMiscVarTypeData%yaw = SrcRotMiscVarTypeData%yaw
    DstRotMiscVarTypeData%tilt = SrcRotMiscVarTypeData%tilt
IF (ALLOCATED(SrcRotMiscVarTypeData%hub_theta_x_root)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%hub_theta_x_root,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%hub_theta_x_root,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%hub_theta_x_root)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%hub_theta_x_root(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%hub_theta_x_root.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%hub_theta_x_root = SrcRotMiscVarTypeData%hub_theta_x_root
ENDIF
    DstRotMiscVarTypeData%V_dot_x = SrcRotMiscVarTypeData%V_dot_x
      CALL MeshCopy( SrcRotMiscVarTypeData%HubLoad, DstRotMiscVarTypeData%HubLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotMiscVarTypeData%B_L_2_H_P)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_L_2_H_P)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_L_2_H_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_H_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1), UBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_L_2_H_P(i1), DstRotMiscVarTypeData%B_L_2_H_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%SigmaCavitCrit)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%SigmaCavitCrit)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%SigmaCavitCrit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavitCrit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%SigmaCavitCrit = SrcRotMiscVarTypeData%SigmaCavitCrit
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%SigmaCavit)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavit,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavit,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavit,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavit,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%SigmaCavit)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%SigmaCavit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%SigmaCavit = SrcRotMiscVarTypeData%SigmaCavit
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%CavitWarnSet)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%CavitWarnSet,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%CavitWarnSet,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%CavitWarnSet,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%CavitWarnSet,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%CavitWarnSet)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%CavitWarnSet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%CavitWarnSet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%CavitWarnSet = SrcRotMiscVarTypeData%CavitWarnSet
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlFB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlFB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlFB,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlFB,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlFB,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlFB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlFB = SrcRotMiscVarTypeData%BlFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlMB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlMB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlMB,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlMB,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlMB,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlMB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlMB = SrcRotMiscVarTypeData%BlMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrFB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrFB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrFB,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrFB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrFB = SrcRotMiscVarTypeData%TwrFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrMB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrMB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrMB,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrMB = SrcRotMiscVarTypeData%TwrMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%HubFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%HubFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%HubFB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%HubFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%HubFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%HubFB = SrcRotMiscVarTypeData%HubFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%HubMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%HubMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%HubMB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%HubMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%HubMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%HubMB = SrcRotMiscVarTypeData%HubMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%NacFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%NacFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%NacFB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%NacFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%NacFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%NacFB = SrcRotMiscVarTypeData%NacFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%NacMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%NacMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%NacMB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%NacMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%NacMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%NacMB = SrcRotMiscVarTypeData%NacMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlFI)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlFI,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlFI,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlFI,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlFI,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlFI,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlFI,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlFI)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlFI(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlFI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlFI = SrcRotMiscVarTypeData%BlFI
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlFA)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlFA,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlFA,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlFA,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlFA,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlFA,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlFA,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlFA)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlFA(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlFA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlFA = SrcRotMiscVarTypeData%BlFA
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlMA)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlMA,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlMA,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlMA,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlMA,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlMA,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlMA,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlMA)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlMA(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlMA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlMA = SrcRotMiscVarTypeData%BlMA
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrFI)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrFI,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrFI,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrFI,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrFI,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrFI)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrFI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrFI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrFI = SrcRotMiscVarTypeData%TwrFI
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrFA)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrFA,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrFA,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrFA,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrFA,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrFA)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrFA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrFA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrFA = SrcRotMiscVarTypeData%TwrFA
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeRootLoad)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeRootLoad)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeRootLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeRootLoad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1), UBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeRootLoad(i1), DstRotMiscVarTypeData%BladeRootLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%B_L_2_R_P)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_L_2_R_P)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_L_2_R_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_R_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1), UBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_L_2_R_P(i1), DstRotMiscVarTypeData%B_L_2_R_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeBuoyLoadPoint)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeBuoyLoadPoint)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeBuoyLoadPoint(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoadPoint.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1), UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeBuoyLoadPoint(i1), DstRotMiscVarTypeData%BladeBuoyLoadPoint(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeBuoyLoad)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeBuoyLoad)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeBuoyLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1), UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeBuoyLoad(i1), DstRotMiscVarTypeData%BladeBuoyLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%B_P_2_B_L)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_P_2_B_L)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_P_2_B_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_P_2_B_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1), UBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_P_2_B_L(i1), DstRotMiscVarTypeData%B_P_2_B_L(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcRotMiscVarTypeData%TwrBuoyLoadPoint, DstRotMiscVarTypeData%TwrBuoyLoadPoint, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotMiscVarTypeData%TwrBuoyLoad, DstRotMiscVarTypeData%TwrBuoyLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%T_P_2_T_L, DstRotMiscVarTypeData%T_P_2_T_L, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstRotMiscVarTypeData%FirstWarn_TowerStrike = SrcRotMiscVarTypeData%FirstWarn_TowerStrike
    DstRotMiscVarTypeData%AvgDiskVel = SrcRotMiscVarTypeData%AvgDiskVel
    DstRotMiscVarTypeData%AvgDiskVelDist = SrcRotMiscVarTypeData%AvgDiskVelDist
    DstRotMiscVarTypeData%TFinAlpha = SrcRotMiscVarTypeData%TFinAlpha
    DstRotMiscVarTypeData%TFinRe = SrcRotMiscVarTypeData%TFinRe
    DstRotMiscVarTypeData%TFinVrel = SrcRotMiscVarTypeData%TFinVrel
    DstRotMiscVarTypeData%TFinVund_i = SrcRotMiscVarTypeData%TFinVund_i
    DstRotMiscVarTypeData%TFinVind_i = SrcRotMiscVarTypeData%TFinVind_i
    DstRotMiscVarTypeData%TFinVrel_i = SrcRotMiscVarTypeData%TFinVrel_i
    DstRotMiscVarTypeData%TFinSTV_i = SrcRotMiscVarTypeData%TFinSTV_i
    DstRotMiscVarTypeData%TFinF_i = SrcRotMiscVarTypeData%TFinF_i
    DstRotMiscVarTypeData%TFinM_i = SrcRotMiscVarTypeData%TFinM_i
 END SUBROUTINE AD_CopyRotMiscVarType

 SUBROUTINE AD_DestroyRotMiscVarType( RotMiscVarTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(RotMiscVarType), INTENT(INOUT) :: RotMiscVarTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotMiscVarType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
  CALL BEMT_DestroyMisc( RotMiscVarTypeData%BEMT, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL BEMT_DestroyOutput( RotMiscVarTypeData%BEMT_y, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
DO i1 = LBOUND(RotMiscVarTypeData%BEMT_u,1), UBOUND(RotMiscVarTypeData%BEMT_u,1)
  CALL BEMT_DestroyInput( RotMiscVarTypeData%BEMT_u(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL AA_DestroyMisc( RotMiscVarTypeData%AA, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyOutput( RotMiscVarTypeData%AA_y, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyInput( RotMiscVarTypeData%AA_u, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotMiscVarTypeData%DisturbedInflow)) THEN
  DEALLOCATE(RotMiscVarTypeData%DisturbedInflow)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%orientationAnnulus)) THEN
  DEALLOCATE(RotMiscVarTypeData%orientationAnnulus)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%AllOuts)) THEN
  DEALLOCATE(RotMiscVarTypeData%AllOuts)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%W_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%W_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%X_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%X_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Y_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%Y_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Curve)) THEN
  DEALLOCATE(RotMiscVarTypeData%Curve)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrClrnc)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrClrnc)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%X)) THEN
  DEALLOCATE(RotMiscVarTypeData%X)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Y)) THEN
  DEALLOCATE(RotMiscVarTypeData%Y)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Z)) THEN
  DEALLOCATE(RotMiscVarTypeData%Z)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%M)) THEN
  DEALLOCATE(RotMiscVarTypeData%M)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Mx)) THEN
  DEALLOCATE(RotMiscVarTypeData%Mx)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%My)) THEN
  DEALLOCATE(RotMiscVarTypeData%My)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Mz)) THEN
  DEALLOCATE(RotMiscVarTypeData%Mz)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%hub_theta_x_root)) THEN
  DEALLOCATE(RotMiscVarTypeData%hub_theta_x_root)
ENDIF
  CALL MeshDestroy( RotMiscVarTypeData%HubLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotMiscVarTypeData%B_L_2_H_P)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_L_2_H_P,1), UBOUND(RotMiscVarTypeData%B_L_2_H_P,1)
  CALL NWTC_Library_Destroymeshmaptype( RotMiscVarTypeData%B_L_2_H_P(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_L_2_H_P)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%SigmaCavitCrit)) THEN
  DEALLOCATE(RotMiscVarTypeData%SigmaCavitCrit)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%SigmaCavit)) THEN
  DEALLOCATE(RotMiscVarTypeData%SigmaCavit)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%CavitWarnSet)) THEN
  DEALLOCATE(RotMiscVarTypeData%CavitWarnSet)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%HubFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%HubFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%HubMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%HubMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%NacFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%NacFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%NacMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%NacMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlFI)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlFI)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlFA)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlFA)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlMA)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlMA)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrFI)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrFI)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrFA)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrFA)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeRootLoad)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeRootLoad,1), UBOUND(RotMiscVarTypeData%BladeRootLoad,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeRootLoad(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeRootLoad)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%B_L_2_R_P)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_L_2_R_P,1), UBOUND(RotMiscVarTypeData%B_L_2_R_P,1)
  CALL NWTC_Library_Destroymeshmaptype( RotMiscVarTypeData%B_L_2_R_P(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_L_2_R_P)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeBuoyLoadPoint)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeBuoyLoadPoint,1), UBOUND(RotMiscVarTypeData%BladeBuoyLoadPoint,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeBuoyLoadPoint(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeBuoyLoadPoint)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeBuoyLoad)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeBuoyLoad,1), UBOUND(RotMiscVarTypeData%BladeBuoyLoad,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeBuoyLoad(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeBuoyLoad)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%B_P_2_B_L)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_P_2_B_L,1), UBOUND(RotMiscVarTypeData%B_P_2_B_L,1)
  CALL NWTC_Library_Destroymeshmaptype( RotMiscVarTypeData%B_P_2_B_L(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_P_2_B_L)
ENDIF
  CALL MeshDestroy( RotMiscVarTypeData%TwrBuoyLoadPoint, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotMiscVarTypeData%TwrBuoyLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_Destroymeshmaptype( RotMiscVarTypeData%T_P_2_T_L, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotMiscVarType

 SUBROUTINE AD_PackRotMiscVarType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RotMiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackRotMiscVarType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! BEMT: size of buffers for each call to pack subtype
      CALL BEMT_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%BEMT, ErrStat2, ErrMsg2, .TRUE. ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BEMT
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BEMT
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BEMT
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! BEMT_y: size of buffers for each call to pack subtype
      CALL BEMT_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%BEMT_y, ErrStat2, ErrMsg2, .TRUE. ) ! BEMT_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BEMT_y
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BEMT_y
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BEMT_y
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    DO i1 = LBOUND(InData%BEMT_u,1), UBOUND(InData%BEMT_u,1)
      Int_BufSz   = Int_BufSz + 3  ! BEMT_u: size of buffers for each call to pack subtype
      CALL BEMT_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%BEMT_u(i1), ErrStat2, ErrMsg2, .TRUE. ) ! BEMT_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BEMT_u
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BEMT_u
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BEMT_u
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
      Int_BufSz   = Int_BufSz + 3  ! AA: size of buffers for each call to pack subtype
      CALL AA_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%AA, ErrStat2, ErrMsg2, .TRUE. ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! AA_y: size of buffers for each call to pack subtype
      CALL AA_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%AA_y, ErrStat2, ErrMsg2, .TRUE. ) ! AA_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AA_y
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AA_y
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AA_y
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! AA_u: size of buffers for each call to pack subtype
      CALL AA_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%AA_u, ErrStat2, ErrMsg2, .TRUE. ) ! AA_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AA_u
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AA_u
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AA_u
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! DisturbedInflow allocated yes/no
  IF ( ALLOCATED(InData%DisturbedInflow) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! DisturbedInflow upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%DisturbedInflow)  ! DisturbedInflow
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! orientationAnnulus allocated yes/no
  IF ( ALLOCATED(InData%orientationAnnulus) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! orientationAnnulus upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%orientationAnnulus)  ! orientationAnnulus
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AllOuts allocated yes/no
  IF ( ALLOCATED(InData%AllOuts) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AllOuts upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AllOuts)  ! AllOuts
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! W_Twr allocated yes/no
  IF ( ALLOCATED(InData%W_Twr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! W_Twr upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%W_Twr)  ! W_Twr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! X_Twr allocated yes/no
  IF ( ALLOCATED(InData%X_Twr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! X_Twr upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%X_Twr)  ! X_Twr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Y_Twr allocated yes/no
  IF ( ALLOCATED(InData%Y_Twr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Y_Twr upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Y_Twr)  ! Y_Twr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Curve allocated yes/no
  IF ( ALLOCATED(InData%Curve) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Curve upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Curve)  ! Curve
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrClrnc allocated yes/no
  IF ( ALLOCATED(InData%TwrClrnc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrClrnc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrClrnc)  ! TwrClrnc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! X allocated yes/no
  IF ( ALLOCATED(InData%X) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! X upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%X)  ! X
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Y allocated yes/no
  IF ( ALLOCATED(InData%Y) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Y upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Y)  ! Y
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Z allocated yes/no
  IF ( ALLOCATED(InData%Z) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Z upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Z)  ! Z
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! M allocated yes/no
  IF ( ALLOCATED(InData%M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! M upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%M)  ! M
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Mx allocated yes/no
  IF ( ALLOCATED(InData%Mx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Mx upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Mx)  ! Mx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! My allocated yes/no
  IF ( ALLOCATED(InData%My) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! My upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%My)  ! My
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Mz allocated yes/no
  IF ( ALLOCATED(InData%Mz) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Mz upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Mz)  ! Mz
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%V_DiskAvg)  ! V_DiskAvg
      Re_BufSz   = Re_BufSz   + 1  ! yaw
      Re_BufSz   = Re_BufSz   + 1  ! tilt
  Int_BufSz   = Int_BufSz   + 1     ! hub_theta_x_root allocated yes/no
  IF ( ALLOCATED(InData%hub_theta_x_root) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! hub_theta_x_root upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%hub_theta_x_root)  ! hub_theta_x_root
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! V_dot_x
      Int_BufSz   = Int_BufSz + 3  ! HubLoad: size of buffers for each call to pack subtype
      CALL MeshPack( InData%HubLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! HubLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! HubLoad
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! HubLoad
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! HubLoad
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! B_L_2_H_P allocated yes/no
  IF ( ALLOCATED(InData%B_L_2_H_P) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! B_L_2_H_P upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%B_L_2_H_P,1), UBOUND(InData%B_L_2_H_P,1)
      Int_BufSz   = Int_BufSz + 3  ! B_L_2_H_P: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_L_2_H_P(i1), ErrStat2, ErrMsg2, .TRUE. ) ! B_L_2_H_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! B_L_2_H_P
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! B_L_2_H_P
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! B_L_2_H_P
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SigmaCavitCrit allocated yes/no
  IF ( ALLOCATED(InData%SigmaCavitCrit) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SigmaCavitCrit upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SigmaCavitCrit)  ! SigmaCavitCrit
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SigmaCavit allocated yes/no
  IF ( ALLOCATED(InData%SigmaCavit) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SigmaCavit upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SigmaCavit)  ! SigmaCavit
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CavitWarnSet allocated yes/no
  IF ( ALLOCATED(InData%CavitWarnSet) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CavitWarnSet upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%CavitWarnSet)  ! CavitWarnSet
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlFB allocated yes/no
  IF ( ALLOCATED(InData%BlFB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BlFB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlFB)  ! BlFB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlMB allocated yes/no
  IF ( ALLOCATED(InData%BlMB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BlMB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlMB)  ! BlMB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrFB allocated yes/no
  IF ( ALLOCATED(InData%TwrFB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrFB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrFB)  ! TwrFB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrMB allocated yes/no
  IF ( ALLOCATED(InData%TwrMB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrMB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrMB)  ! TwrMB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! HubFB allocated yes/no
  IF ( ALLOCATED(InData%HubFB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! HubFB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%HubFB)  ! HubFB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! HubMB allocated yes/no
  IF ( ALLOCATED(InData%HubMB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! HubMB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%HubMB)  ! HubMB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! NacFB allocated yes/no
  IF ( ALLOCATED(InData%NacFB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NacFB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%NacFB)  ! NacFB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! NacMB allocated yes/no
  IF ( ALLOCATED(InData%NacMB) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NacMB upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%NacMB)  ! NacMB
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlFI allocated yes/no
  IF ( ALLOCATED(InData%BlFI) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BlFI upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlFI)  ! BlFI
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlFA allocated yes/no
  IF ( ALLOCATED(InData%BlFA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BlFA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlFA)  ! BlFA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlMA allocated yes/no
  IF ( ALLOCATED(InData%BlMA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BlMA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlMA)  ! BlMA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrFI allocated yes/no
  IF ( ALLOCATED(InData%TwrFI) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrFI upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrFI)  ! TwrFI
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrFA allocated yes/no
  IF ( ALLOCATED(InData%TwrFA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! TwrFA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrFA)  ! TwrFA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeRootLoad allocated yes/no
  IF ( ALLOCATED(InData%BladeRootLoad) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeRootLoad upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeRootLoad,1), UBOUND(InData%BladeRootLoad,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeRootLoad: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeRootLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeRootLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeRootLoad
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeRootLoad
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeRootLoad
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! B_L_2_R_P allocated yes/no
  IF ( ALLOCATED(InData%B_L_2_R_P) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! B_L_2_R_P upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%B_L_2_R_P,1), UBOUND(InData%B_L_2_R_P,1)
      Int_BufSz   = Int_BufSz + 3  ! B_L_2_R_P: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_L_2_R_P(i1), ErrStat2, ErrMsg2, .TRUE. ) ! B_L_2_R_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! B_L_2_R_P
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! B_L_2_R_P
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! B_L_2_R_P
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeBuoyLoadPoint allocated yes/no
  IF ( ALLOCATED(InData%BladeBuoyLoadPoint) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeBuoyLoadPoint upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeBuoyLoadPoint,1), UBOUND(InData%BladeBuoyLoadPoint,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeBuoyLoadPoint: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeBuoyLoadPoint(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeBuoyLoadPoint
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeBuoyLoadPoint
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeBuoyLoadPoint
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeBuoyLoad allocated yes/no
  IF ( ALLOCATED(InData%BladeBuoyLoad) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeBuoyLoad upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeBuoyLoad,1), UBOUND(InData%BladeBuoyLoad,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeBuoyLoad: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeBuoyLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeBuoyLoad
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeBuoyLoad
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeBuoyLoad
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! B_P_2_B_L allocated yes/no
  IF ( ALLOCATED(InData%B_P_2_B_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! B_P_2_B_L upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%B_P_2_B_L,1), UBOUND(InData%B_P_2_B_L,1)
      Int_BufSz   = Int_BufSz + 3  ! B_P_2_B_L: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_P_2_B_L(i1), ErrStat2, ErrMsg2, .TRUE. ) ! B_P_2_B_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! B_P_2_B_L
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! B_P_2_B_L
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! B_P_2_B_L
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! TwrBuoyLoadPoint: size of buffers for each call to pack subtype
      CALL MeshPack( InData%TwrBuoyLoadPoint, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! TwrBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TwrBuoyLoadPoint
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TwrBuoyLoadPoint
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TwrBuoyLoadPoint
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! TwrBuoyLoad: size of buffers for each call to pack subtype
      CALL MeshPack( InData%TwrBuoyLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! TwrBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TwrBuoyLoad
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TwrBuoyLoad
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TwrBuoyLoad
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! T_P_2_T_L: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%T_P_2_T_L, ErrStat2, ErrMsg2, .TRUE. ) ! T_P_2_T_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! T_P_2_T_L
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! T_P_2_T_L
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! T_P_2_T_L
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! FirstWarn_TowerStrike
      Re_BufSz   = Re_BufSz   + SIZE(InData%AvgDiskVel)  ! AvgDiskVel
      Re_BufSz   = Re_BufSz   + SIZE(InData%AvgDiskVelDist)  ! AvgDiskVelDist
      Re_BufSz   = Re_BufSz   + 1  ! TFinAlpha
      Re_BufSz   = Re_BufSz   + 1  ! TFinRe
      Re_BufSz   = Re_BufSz   + 1  ! TFinVrel
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinVund_i)  ! TFinVund_i
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinVind_i)  ! TFinVind_i
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinVrel_i)  ! TFinVrel_i
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinSTV_i)  ! TFinSTV_i
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinF_i)  ! TFinF_i
      Re_BufSz   = Re_BufSz   + SIZE(InData%TFinM_i)  ! TFinM_i
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL BEMT_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%BEMT, ErrStat2, ErrMsg2, OnlySize ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL BEMT_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%BEMT_y, ErrStat2, ErrMsg2, OnlySize ) ! BEMT_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    DO i1 = LBOUND(InData%BEMT_u,1), UBOUND(InData%BEMT_u,1)
      CALL BEMT_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%BEMT_u(i1), ErrStat2, ErrMsg2, OnlySize ) ! BEMT_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
      CALL AA_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%AA, ErrStat2, ErrMsg2, OnlySize ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AA_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%AA_y, ErrStat2, ErrMsg2, OnlySize ) ! AA_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AA_PackInput( Re_Buf, Db_Buf, Int_Buf, InData%AA_u, ErrStat2, ErrMsg2, OnlySize ) ! AA_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%DisturbedInflow) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DisturbedInflow,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DisturbedInflow,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DisturbedInflow,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DisturbedInflow,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DisturbedInflow,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DisturbedInflow,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%DisturbedInflow,3), UBOUND(InData%DisturbedInflow,3)
        DO i2 = LBOUND(InData%DisturbedInflow,2), UBOUND(InData%DisturbedInflow,2)
          DO i1 = LBOUND(InData%DisturbedInflow,1), UBOUND(InData%DisturbedInflow,1)
            ReKiBuf(Re_Xferred) = InData%DisturbedInflow(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%orientationAnnulus) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%orientationAnnulus,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%orientationAnnulus,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%orientationAnnulus,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%orientationAnnulus,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%orientationAnnulus,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%orientationAnnulus,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%orientationAnnulus,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%orientationAnnulus,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%orientationAnnulus,4), UBOUND(InData%orientationAnnulus,4)
        DO i3 = LBOUND(InData%orientationAnnulus,3), UBOUND(InData%orientationAnnulus,3)
          DO i2 = LBOUND(InData%orientationAnnulus,2), UBOUND(InData%orientationAnnulus,2)
            DO i1 = LBOUND(InData%orientationAnnulus,1), UBOUND(InData%orientationAnnulus,1)
              DbKiBuf(Db_Xferred) = InData%orientationAnnulus(i1,i2,i3,i4)
              Db_Xferred = Db_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AllOuts) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AllOuts,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AllOuts,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%AllOuts,1), UBOUND(InData%AllOuts,1)
        ReKiBuf(Re_Xferred) = InData%AllOuts(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%W_Twr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W_Twr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W_Twr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%W_Twr,1), UBOUND(InData%W_Twr,1)
        ReKiBuf(Re_Xferred) = InData%W_Twr(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%X_Twr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%X_Twr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%X_Twr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%X_Twr,1), UBOUND(InData%X_Twr,1)
        ReKiBuf(Re_Xferred) = InData%X_Twr(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Y_Twr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Y_Twr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Y_Twr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Y_Twr,1), UBOUND(InData%Y_Twr,1)
        ReKiBuf(Re_Xferred) = InData%Y_Twr(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Curve) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Curve,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Curve,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Curve,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Curve,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Curve,2), UBOUND(InData%Curve,2)
        DO i1 = LBOUND(InData%Curve,1), UBOUND(InData%Curve,1)
          ReKiBuf(Re_Xferred) = InData%Curve(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrClrnc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrClrnc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrClrnc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrClrnc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrClrnc,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%TwrClrnc,2), UBOUND(InData%TwrClrnc,2)
        DO i1 = LBOUND(InData%TwrClrnc,1), UBOUND(InData%TwrClrnc,1)
          ReKiBuf(Re_Xferred) = InData%TwrClrnc(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%X) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%X,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%X,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%X,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%X,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%X,2), UBOUND(InData%X,2)
        DO i1 = LBOUND(InData%X,1), UBOUND(InData%X,1)
          ReKiBuf(Re_Xferred) = InData%X(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Y) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Y,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Y,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Y,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Y,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Y,2), UBOUND(InData%Y,2)
        DO i1 = LBOUND(InData%Y,1), UBOUND(InData%Y,1)
          ReKiBuf(Re_Xferred) = InData%Y(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Z) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Z,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Z,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Z,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Z,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Z,2), UBOUND(InData%Z,2)
        DO i1 = LBOUND(InData%Z,1), UBOUND(InData%Z,1)
          ReKiBuf(Re_Xferred) = InData%Z(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%M,2), UBOUND(InData%M,2)
        DO i1 = LBOUND(InData%M,1), UBOUND(InData%M,1)
          ReKiBuf(Re_Xferred) = InData%M(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Mx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Mx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Mx,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Mx,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Mx,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Mx,2), UBOUND(InData%Mx,2)
        DO i1 = LBOUND(InData%Mx,1), UBOUND(InData%Mx,1)
          ReKiBuf(Re_Xferred) = InData%Mx(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%My) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%My,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%My,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%My,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%My,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%My,2), UBOUND(InData%My,2)
        DO i1 = LBOUND(InData%My,1), UBOUND(InData%My,1)
          ReKiBuf(Re_Xferred) = InData%My(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Mz) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Mz,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Mz,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Mz,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Mz,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Mz,2), UBOUND(InData%Mz,2)
        DO i1 = LBOUND(InData%Mz,1), UBOUND(InData%Mz,1)
          ReKiBuf(Re_Xferred) = InData%Mz(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    DO i1 = LBOUND(InData%V_DiskAvg,1), UBOUND(InData%V_DiskAvg,1)
      ReKiBuf(Re_Xferred) = InData%V_DiskAvg(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%yaw
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%tilt
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%hub_theta_x_root) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%hub_theta_x_root,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%hub_theta_x_root,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%hub_theta_x_root,1), UBOUND(InData%hub_theta_x_root,1)
        ReKiBuf(Re_Xferred) = InData%hub_theta_x_root(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%V_dot_x
    Re_Xferred = Re_Xferred + 1
      CALL MeshPack( InData%HubLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! HubLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%B_L_2_H_P) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B_L_2_H_P,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B_L_2_H_P,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%B_L_2_H_P,1), UBOUND(InData%B_L_2_H_P,1)
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_L_2_H_P(i1), ErrStat2, ErrMsg2, OnlySize ) ! B_L_2_H_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SigmaCavitCrit) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SigmaCavitCrit,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SigmaCavitCrit,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SigmaCavitCrit,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SigmaCavitCrit,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%SigmaCavitCrit,2), UBOUND(InData%SigmaCavitCrit,2)
        DO i1 = LBOUND(InData%SigmaCavitCrit,1), UBOUND(InData%SigmaCavitCrit,1)
          ReKiBuf(Re_Xferred) = InData%SigmaCavitCrit(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SigmaCavit) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SigmaCavit,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SigmaCavit,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SigmaCavit,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SigmaCavit,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%SigmaCavit,2), UBOUND(InData%SigmaCavit,2)
        DO i1 = LBOUND(InData%SigmaCavit,1), UBOUND(InData%SigmaCavit,1)
          ReKiBuf(Re_Xferred) = InData%SigmaCavit(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CavitWarnSet) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CavitWarnSet,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CavitWarnSet,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CavitWarnSet,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CavitWarnSet,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%CavitWarnSet,2), UBOUND(InData%CavitWarnSet,2)
        DO i1 = LBOUND(InData%CavitWarnSet,1), UBOUND(InData%CavitWarnSet,1)
          IntKiBuf(Int_Xferred) = TRANSFER(InData%CavitWarnSet(i1,i2), IntKiBuf(1))
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlFB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFB,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFB,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFB,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFB,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFB,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BlFB,3), UBOUND(InData%BlFB,3)
        DO i2 = LBOUND(InData%BlFB,2), UBOUND(InData%BlFB,2)
          DO i1 = LBOUND(InData%BlFB,1), UBOUND(InData%BlFB,1)
            ReKiBuf(Re_Xferred) = InData%BlFB(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlMB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMB,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMB,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMB,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMB,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMB,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BlMB,3), UBOUND(InData%BlMB,3)
        DO i2 = LBOUND(InData%BlMB,2), UBOUND(InData%BlMB,2)
          DO i1 = LBOUND(InData%BlMB,1), UBOUND(InData%BlMB,1)
            ReKiBuf(Re_Xferred) = InData%BlMB(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrFB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFB,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFB,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFB,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%TwrFB,2), UBOUND(InData%TwrFB,2)
        DO i1 = LBOUND(InData%TwrFB,1), UBOUND(InData%TwrFB,1)
          ReKiBuf(Re_Xferred) = InData%TwrFB(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrMB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrMB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrMB,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrMB,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrMB,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%TwrMB,2), UBOUND(InData%TwrMB,2)
        DO i1 = LBOUND(InData%TwrMB,1), UBOUND(InData%TwrMB,1)
          ReKiBuf(Re_Xferred) = InData%TwrMB(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%HubFB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%HubFB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%HubFB,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%HubFB,1), UBOUND(InData%HubFB,1)
        ReKiBuf(Re_Xferred) = InData%HubFB(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%HubMB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%HubMB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%HubMB,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%HubMB,1), UBOUND(InData%HubMB,1)
        ReKiBuf(Re_Xferred) = InData%HubMB(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%NacFB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NacFB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NacFB,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%NacFB,1), UBOUND(InData%NacFB,1)
        ReKiBuf(Re_Xferred) = InData%NacFB(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%NacMB) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NacMB,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NacMB,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%NacMB,1), UBOUND(InData%NacMB,1)
        ReKiBuf(Re_Xferred) = InData%NacMB(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlFI) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFI,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFI,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFI,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFI,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFI,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFI,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BlFI,3), UBOUND(InData%BlFI,3)
        DO i2 = LBOUND(InData%BlFI,2), UBOUND(InData%BlFI,2)
          DO i1 = LBOUND(InData%BlFI,1), UBOUND(InData%BlFI,1)
            ReKiBuf(Re_Xferred) = InData%BlFI(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlFA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFA,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlFA,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlFA,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BlFA,3), UBOUND(InData%BlFA,3)
        DO i2 = LBOUND(InData%BlFA,2), UBOUND(InData%BlFA,2)
          DO i1 = LBOUND(InData%BlFA,1), UBOUND(InData%BlFA,1)
            ReKiBuf(Re_Xferred) = InData%BlFA(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlMA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMA,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlMA,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlMA,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BlMA,3), UBOUND(InData%BlMA,3)
        DO i2 = LBOUND(InData%BlMA,2), UBOUND(InData%BlMA,2)
          DO i1 = LBOUND(InData%BlMA,1), UBOUND(InData%BlMA,1)
            ReKiBuf(Re_Xferred) = InData%BlMA(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrFI) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFI,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFI,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFI,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFI,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%TwrFI,2), UBOUND(InData%TwrFI,2)
        DO i1 = LBOUND(InData%TwrFI,1), UBOUND(InData%TwrFI,1)
          ReKiBuf(Re_Xferred) = InData%TwrFI(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrFA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrFA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrFA,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%TwrFA,2), UBOUND(InData%TwrFA,2)
        DO i1 = LBOUND(InData%TwrFA,1), UBOUND(InData%TwrFA,1)
          ReKiBuf(Re_Xferred) = InData%TwrFA(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BladeRootLoad) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeRootLoad,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeRootLoad,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeRootLoad,1), UBOUND(InData%BladeRootLoad,1)
      CALL MeshPack( InData%BladeRootLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeRootLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%B_L_2_R_P) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B_L_2_R_P,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B_L_2_R_P,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%B_L_2_R_P,1), UBOUND(InData%B_L_2_R_P,1)
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_L_2_R_P(i1), ErrStat2, ErrMsg2, OnlySize ) ! B_L_2_R_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BladeBuoyLoadPoint) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeBuoyLoadPoint,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeBuoyLoadPoint,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeBuoyLoadPoint,1), UBOUND(InData%BladeBuoyLoadPoint,1)
      CALL MeshPack( InData%BladeBuoyLoadPoint(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BladeBuoyLoad) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeBuoyLoad,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeBuoyLoad,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeBuoyLoad,1), UBOUND(InData%BladeBuoyLoad,1)
      CALL MeshPack( InData%BladeBuoyLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%B_P_2_B_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B_P_2_B_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B_P_2_B_L,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%B_P_2_B_L,1), UBOUND(InData%B_P_2_B_L,1)
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%B_P_2_B_L(i1), ErrStat2, ErrMsg2, OnlySize ) ! B_P_2_B_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL MeshPack( InData%TwrBuoyLoadPoint, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! TwrBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%TwrBuoyLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! TwrBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL NWTC_Library_Packmeshmaptype( Re_Buf, Db_Buf, Int_Buf, InData%T_P_2_T_L, ErrStat2, ErrMsg2, OnlySize ) ! T_P_2_T_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FirstWarn_TowerStrike, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%AvgDiskVel,1), UBOUND(InData%AvgDiskVel,1)
      ReKiBuf(Re_Xferred) = InData%AvgDiskVel(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%AvgDiskVelDist,1), UBOUND(InData%AvgDiskVelDist,1)
      ReKiBuf(Re_Xferred) = InData%AvgDiskVelDist(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%TFinAlpha
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TFinRe
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TFinVrel
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%TFinVund_i,1), UBOUND(InData%TFinVund_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinVund_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TFinVind_i,1), UBOUND(InData%TFinVind_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinVind_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TFinVrel_i,1), UBOUND(InData%TFinVrel_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinVrel_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TFinSTV_i,1), UBOUND(InData%TFinSTV_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinSTV_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TFinF_i,1), UBOUND(InData%TFinF_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinF_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TFinM_i,1), UBOUND(InData%TFinM_i,1)
      ReKiBuf(Re_Xferred) = InData%TFinM_i(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
 END SUBROUTINE AD_PackRotMiscVarType

 SUBROUTINE AD_UnPackRotMiscVarType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RotMiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackRotMiscVarType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL BEMT_UnpackMisc( Re_Buf, Db_Buf, Int_Buf, OutData%BEMT, ErrStat2, ErrMsg2 ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL BEMT_UnpackOutput( Re_Buf, Db_Buf, Int_Buf, OutData%BEMT_y, ErrStat2, ErrMsg2 ) ! BEMT_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    i1_l = LBOUND(OutData%BEMT_u,1)
    i1_u = UBOUND(OutData%BEMT_u,1)
    DO i1 = LBOUND(OutData%BEMT_u,1), UBOUND(OutData%BEMT_u,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL BEMT_UnpackInput( Re_Buf, Db_Buf, Int_Buf, OutData%BEMT_u(i1), ErrStat2, ErrMsg2 ) ! BEMT_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AA_UnpackMisc( Re_Buf, Db_Buf, Int_Buf, OutData%AA, ErrStat2, ErrMsg2 ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AA_UnpackOutput( Re_Buf, Db_Buf, Int_Buf, OutData%AA_y, ErrStat2, ErrMsg2 ) ! AA_y 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AA_UnpackInput( Re_Buf, Db_Buf, Int_Buf, OutData%AA_u, ErrStat2, ErrMsg2 ) ! AA_u 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DisturbedInflow not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DisturbedInflow)) DEALLOCATE(OutData%DisturbedInflow)
    ALLOCATE(OutData%DisturbedInflow(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DisturbedInflow.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%DisturbedInflow,3), UBOUND(OutData%DisturbedInflow,3)
        DO i2 = LBOUND(OutData%DisturbedInflow,2), UBOUND(OutData%DisturbedInflow,2)
          DO i1 = LBOUND(OutData%DisturbedInflow,1), UBOUND(OutData%DisturbedInflow,1)
            OutData%DisturbedInflow(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! orientationAnnulus not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%orientationAnnulus)) DEALLOCATE(OutData%orientationAnnulus)
    ALLOCATE(OutData%orientationAnnulus(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%orientationAnnulus.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%orientationAnnulus,4), UBOUND(OutData%orientationAnnulus,4)
        DO i3 = LBOUND(OutData%orientationAnnulus,3), UBOUND(OutData%orientationAnnulus,3)
          DO i2 = LBOUND(OutData%orientationAnnulus,2), UBOUND(OutData%orientationAnnulus,2)
            DO i1 = LBOUND(OutData%orientationAnnulus,1), UBOUND(OutData%orientationAnnulus,1)
              OutData%orientationAnnulus(i1,i2,i3,i4) = REAL(DbKiBuf(Db_Xferred), R8Ki)
              Db_Xferred = Db_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AllOuts not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AllOuts)) DEALLOCATE(OutData%AllOuts)
    ALLOCATE(OutData%AllOuts(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOuts.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%AllOuts,1), UBOUND(OutData%AllOuts,1)
        OutData%AllOuts(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! W_Twr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%W_Twr)) DEALLOCATE(OutData%W_Twr)
    ALLOCATE(OutData%W_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%W_Twr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%W_Twr,1), UBOUND(OutData%W_Twr,1)
        OutData%W_Twr(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! X_Twr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%X_Twr)) DEALLOCATE(OutData%X_Twr)
    ALLOCATE(OutData%X_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%X_Twr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%X_Twr,1), UBOUND(OutData%X_Twr,1)
        OutData%X_Twr(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Y_Twr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Y_Twr)) DEALLOCATE(OutData%Y_Twr)
    ALLOCATE(OutData%Y_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y_Twr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Y_Twr,1), UBOUND(OutData%Y_Twr,1)
        OutData%Y_Twr(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Curve not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Curve)) DEALLOCATE(OutData%Curve)
    ALLOCATE(OutData%Curve(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Curve.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Curve,2), UBOUND(OutData%Curve,2)
        DO i1 = LBOUND(OutData%Curve,1), UBOUND(OutData%Curve,1)
          OutData%Curve(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrClrnc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrClrnc)) DEALLOCATE(OutData%TwrClrnc)
    ALLOCATE(OutData%TwrClrnc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrClrnc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%TwrClrnc,2), UBOUND(OutData%TwrClrnc,2)
        DO i1 = LBOUND(OutData%TwrClrnc,1), UBOUND(OutData%TwrClrnc,1)
          OutData%TwrClrnc(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! X not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%X)) DEALLOCATE(OutData%X)
    ALLOCATE(OutData%X(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%X.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%X,2), UBOUND(OutData%X,2)
        DO i1 = LBOUND(OutData%X,1), UBOUND(OutData%X,1)
          OutData%X(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Y not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Y)) DEALLOCATE(OutData%Y)
    ALLOCATE(OutData%Y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Y,2), UBOUND(OutData%Y,2)
        DO i1 = LBOUND(OutData%Y,1), UBOUND(OutData%Y,1)
          OutData%Y(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Z not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Z)) DEALLOCATE(OutData%Z)
    ALLOCATE(OutData%Z(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Z,2), UBOUND(OutData%Z,2)
        DO i1 = LBOUND(OutData%Z,1), UBOUND(OutData%Z,1)
          OutData%Z(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%M)) DEALLOCATE(OutData%M)
    ALLOCATE(OutData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%M,2), UBOUND(OutData%M,2)
        DO i1 = LBOUND(OutData%M,1), UBOUND(OutData%M,1)
          OutData%M(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Mx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Mx)) DEALLOCATE(OutData%Mx)
    ALLOCATE(OutData%Mx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Mx,2), UBOUND(OutData%Mx,2)
        DO i1 = LBOUND(OutData%Mx,1), UBOUND(OutData%Mx,1)
          OutData%Mx(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! My not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%My)) DEALLOCATE(OutData%My)
    ALLOCATE(OutData%My(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%My.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%My,2), UBOUND(OutData%My,2)
        DO i1 = LBOUND(OutData%My,1), UBOUND(OutData%My,1)
          OutData%My(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Mz not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Mz)) DEALLOCATE(OutData%Mz)
    ALLOCATE(OutData%Mz(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mz.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Mz,2), UBOUND(OutData%Mz,2)
        DO i1 = LBOUND(OutData%Mz,1), UBOUND(OutData%Mz,1)
          OutData%Mz(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%V_DiskAvg,1)
    i1_u = UBOUND(OutData%V_DiskAvg,1)
    DO i1 = LBOUND(OutData%V_DiskAvg,1), UBOUND(OutData%V_DiskAvg,1)
      OutData%V_DiskAvg(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%yaw = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%tilt = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! hub_theta_x_root not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%hub_theta_x_root)) DEALLOCATE(OutData%hub_theta_x_root)
    ALLOCATE(OutData%hub_theta_x_root(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%hub_theta_x_root.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%hub_theta_x_root,1), UBOUND(OutData%hub_theta_x_root,1)
        OutData%hub_theta_x_root(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%V_dot_x = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%HubLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! HubLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! B_L_2_H_P not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%B_L_2_H_P)) DEALLOCATE(OutData%B_L_2_H_P)
    ALLOCATE(OutData%B_L_2_H_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_H_P.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%B_L_2_H_P,1), UBOUND(OutData%B_L_2_H_P,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackmeshmaptype( Re_Buf, Db_Buf, Int_Buf, OutData%B_L_2_H_P(i1), ErrStat2, ErrMsg2 ) ! B_L_2_H_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SigmaCavitCrit not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SigmaCavitCrit)) DEALLOCATE(OutData%SigmaCavitCrit)
    ALLOCATE(OutData%SigmaCavitCrit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavitCrit.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%SigmaCavitCrit,2), UBOUND(OutData%SigmaCavitCrit,2)
        DO i1 = LBOUND(OutData%SigmaCavitCrit,1), UBOUND(OutData%SigmaCavitCrit,1)
          OutData%SigmaCavitCrit(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SigmaCavit not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SigmaCavit)) DEALLOCATE(OutData%SigmaCavit)
    ALLOCATE(OutData%SigmaCavit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavit.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%SigmaCavit,2), UBOUND(OutData%SigmaCavit,2)
        DO i1 = LBOUND(OutData%SigmaCavit,1), UBOUND(OutData%SigmaCavit,1)
          OutData%SigmaCavit(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CavitWarnSet not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CavitWarnSet)) DEALLOCATE(OutData%CavitWarnSet)
    ALLOCATE(OutData%CavitWarnSet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CavitWarnSet.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%CavitWarnSet,2), UBOUND(OutData%CavitWarnSet,2)
        DO i1 = LBOUND(OutData%CavitWarnSet,1), UBOUND(OutData%CavitWarnSet,1)
          OutData%CavitWarnSet(i1,i2) = TRANSFER(IntKiBuf(Int_Xferred), OutData%CavitWarnSet(i1,i2))
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlFB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlFB)) DEALLOCATE(OutData%BlFB)
    ALLOCATE(OutData%BlFB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlFB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BlFB,3), UBOUND(OutData%BlFB,3)
        DO i2 = LBOUND(OutData%BlFB,2), UBOUND(OutData%BlFB,2)
          DO i1 = LBOUND(OutData%BlFB,1), UBOUND(OutData%BlFB,1)
            OutData%BlFB(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlMB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlMB)) DEALLOCATE(OutData%BlMB)
    ALLOCATE(OutData%BlMB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlMB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BlMB,3), UBOUND(OutData%BlMB,3)
        DO i2 = LBOUND(OutData%BlMB,2), UBOUND(OutData%BlMB,2)
          DO i1 = LBOUND(OutData%BlMB,1), UBOUND(OutData%BlMB,1)
            OutData%BlMB(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrFB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrFB)) DEALLOCATE(OutData%TwrFB)
    ALLOCATE(OutData%TwrFB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrFB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%TwrFB,2), UBOUND(OutData%TwrFB,2)
        DO i1 = LBOUND(OutData%TwrFB,1), UBOUND(OutData%TwrFB,1)
          OutData%TwrFB(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrMB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrMB)) DEALLOCATE(OutData%TwrMB)
    ALLOCATE(OutData%TwrMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrMB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%TwrMB,2), UBOUND(OutData%TwrMB,2)
        DO i1 = LBOUND(OutData%TwrMB,1), UBOUND(OutData%TwrMB,1)
          OutData%TwrMB(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! HubFB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%HubFB)) DEALLOCATE(OutData%HubFB)
    ALLOCATE(OutData%HubFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubFB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%HubFB,1), UBOUND(OutData%HubFB,1)
        OutData%HubFB(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! HubMB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%HubMB)) DEALLOCATE(OutData%HubMB)
    ALLOCATE(OutData%HubMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubMB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%HubMB,1), UBOUND(OutData%HubMB,1)
        OutData%HubMB(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NacFB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NacFB)) DEALLOCATE(OutData%NacFB)
    ALLOCATE(OutData%NacFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacFB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%NacFB,1), UBOUND(OutData%NacFB,1)
        OutData%NacFB(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NacMB not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NacMB)) DEALLOCATE(OutData%NacMB)
    ALLOCATE(OutData%NacMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacMB.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%NacMB,1), UBOUND(OutData%NacMB,1)
        OutData%NacMB(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlFI not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlFI)) DEALLOCATE(OutData%BlFI)
    ALLOCATE(OutData%BlFI(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlFI.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BlFI,3), UBOUND(OutData%BlFI,3)
        DO i2 = LBOUND(OutData%BlFI,2), UBOUND(OutData%BlFI,2)
          DO i1 = LBOUND(OutData%BlFI,1), UBOUND(OutData%BlFI,1)
            OutData%BlFI(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlFA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlFA)) DEALLOCATE(OutData%BlFA)
    ALLOCATE(OutData%BlFA(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlFA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BlFA,3), UBOUND(OutData%BlFA,3)
        DO i2 = LBOUND(OutData%BlFA,2), UBOUND(OutData%BlFA,2)
          DO i1 = LBOUND(OutData%BlFA,1), UBOUND(OutData%BlFA,1)
            OutData%BlFA(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlMA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlMA)) DEALLOCATE(OutData%BlMA)
    ALLOCATE(OutData%BlMA(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlMA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BlMA,3), UBOUND(OutData%BlMA,3)
        DO i2 = LBOUND(OutData%BlMA,2), UBOUND(OutData%BlMA,2)
          DO i1 = LBOUND(OutData%BlMA,1), UBOUND(OutData%BlMA,1)
            OutData%BlMA(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrFI not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrFI)) DEALLOCATE(OutData%TwrFI)
    ALLOCATE(OutData%TwrFI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrFI.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%TwrFI,2), UBOUND(OutData%TwrFI,2)
        DO i1 = LBOUND(OutData%TwrFI,1), UBOUND(OutData%TwrFI,1)
          OutData%TwrFI(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrFA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrFA)) DEALLOCATE(OutData%TwrFA)
    ALLOCATE(OutData%TwrFA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrFA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%TwrFA,2), UBOUND(OutData%TwrFA,2)
        DO i1 = LBOUND(OutData%TwrFA,1), UBOUND(OutData%TwrFA,1)
          OutData%TwrFA(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeRootLoad not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeRootLoad)) DEALLOCATE(OutData%BladeRootLoad)
    ALLOCATE(OutData%BladeRootLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoad.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeRootLoad,1), UBOUND(OutData%BladeRootLoad,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeRootLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeRootLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! B_L_2_R_P not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%B_L_2_R_P)) DEALLOCATE(OutData%B_L_2_R_P)
    ALLOCATE(OutData%B_L_2_R_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_R_P.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%B_L_2_R_P,1), UBOUND(OutData%B_L_2_R_P,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackmeshmaptype( Re_Buf, Db_Buf, Int_Buf, OutData%B_L_2_R_P(i1), ErrStat2, ErrMsg2 ) ! B_L_2_R_P 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeBuoyLoadPoint not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeBuoyLoadPoint)) DEALLOCATE(OutData%BladeBuoyLoadPoint)
    ALLOCATE(OutData%BladeBuoyLoadPoint(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoadPoint.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeBuoyLoadPoint,1), UBOUND(OutData%BladeBuoyLoadPoint,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeBuoyLoadPoint(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeBuoyLoad not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeBuoyLoad)) DEALLOCATE(OutData%BladeBuoyLoad)
    ALLOCATE(OutData%BladeBuoyLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoad.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeBuoyLoad,1), UBOUND(OutData%BladeBuoyLoad,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeBuoyLoad(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! B_P_2_B_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%B_P_2_B_L)) DEALLOCATE(OutData%B_P_2_B_L)
    ALLOCATE(OutData%B_P_2_B_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_P_2_B_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%B_P_2_B_L,1), UBOUND(OutData%B_P_2_B_L,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackmeshmaptype( Re_Buf, Db_Buf, Int_Buf, OutData%B_P_2_B_L(i1), ErrStat2, ErrMsg2 ) ! B_P_2_B_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%TwrBuoyLoadPoint, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! TwrBuoyLoadPoint 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%TwrBuoyLoad, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! TwrBuoyLoad 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackmeshmaptype( Re_Buf, Db_Buf, Int_Buf, OutData%T_P_2_T_L, ErrStat2, ErrMsg2 ) ! T_P_2_T_L 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    OutData%FirstWarn_TowerStrike = TRANSFER(IntKiBuf(Int_Xferred), OutData%FirstWarn_TowerStrike)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%AvgDiskVel,1)
    i1_u = UBOUND(OutData%AvgDiskVel,1)
    DO i1 = LBOUND(OutData%AvgDiskVel,1), UBOUND(OutData%AvgDiskVel,1)
      OutData%AvgDiskVel(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%AvgDiskVelDist,1)
    i1_u = UBOUND(OutData%AvgDiskVelDist,1)
    DO i1 = LBOUND(OutData%AvgDiskVelDist,1), UBOUND(OutData%AvgDiskVelDist,1)
      OutData%AvgDiskVelDist(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%TFinAlpha = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TFinRe = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TFinVrel = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%TFinVund_i,1)
    i1_u = UBOUND(OutData%TFinVund_i,1)
    DO i1 = LBOUND(OutData%TFinVund_i,1), UBOUND(OutData%TFinVund_i,1)
      OutData%TFinVund_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TFinVind_i,1)
    i1_u = UBOUND(OutData%TFinVind_i,1)
    DO i1 = LBOUND(OutData%TFinVind_i,1), UBOUND(OutData%TFinVind_i,1)
      OutData%TFinVind_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TFinVrel_i,1)
    i1_u = UBOUND(OutData%TFinVrel_i,1)
    DO i1 = LBOUND(OutData%TFinVrel_i,1), UBOUND(OutData%TFinVrel_i,1)
      OutData%TFinVrel_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TFinSTV_i,1)
    i1_u = UBOUND(OutData%TFinSTV_i,1)
    DO i1 = LBOUND(OutData%TFinSTV_i,1), UBOUND(OutData%TFinSTV_i,1)
      OutData%TFinSTV_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TFinF_i,1)
    i1_u = UBOUND(OutData%TFinF_i,1)
    DO i1 = LBOUND(OutData%TFinF_i,1), UBOUND(OutData%TFinF_i,1)
      OutData%TFinF_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TFinM_i,1)
    i1_u = UBOUND(OutData%TFinM_i,1)
    DO i1 = LBOUND(OutData%TFinM_i,1), UBOUND(OutData%TFinM_i,1)
      OutData%TFinM_i(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
 END SUBROUTINE AD_UnPackRotMiscVarType

 SUBROUTINE AD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_MiscVarType), INTENT(INOUT) :: SrcMiscData
   TYPE(AD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyMisc'
! 
=======
   ErrMsg  = ''
   if (allocated(SrcRotInputFileData%BladeProps)) then
      LB(1:1) = lbound(SrcRotInputFileData%BladeProps)
      UB(1:1) = ubound(SrcRotInputFileData%BladeProps)
      if (.not. allocated(DstRotInputFileData%BladeProps)) then
         allocate(DstRotInputFileData%BladeProps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%BladeProps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyBladePropsType(SrcRotInputFileData%BladeProps(i1), DstRotInputFileData%BladeProps(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstRotInputFileData%NumTwrNds = SrcRotInputFileData%NumTwrNds
   if (allocated(SrcRotInputFileData%TwrElev)) then
      LB(1:1) = lbound(SrcRotInputFileData%TwrElev)
      UB(1:1) = ubound(SrcRotInputFileData%TwrElev)
      if (.not. allocated(DstRotInputFileData%TwrElev)) then
         allocate(DstRotInputFileData%TwrElev(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrElev.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputFileData%TwrElev = SrcRotInputFileData%TwrElev
   end if
   if (allocated(SrcRotInputFileData%TwrDiam)) then
      LB(1:1) = lbound(SrcRotInputFileData%TwrDiam)
      UB(1:1) = ubound(SrcRotInputFileData%TwrDiam)
      if (.not. allocated(DstRotInputFileData%TwrDiam)) then
         allocate(DstRotInputFileData%TwrDiam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrDiam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputFileData%TwrDiam = SrcRotInputFileData%TwrDiam
   end if
   if (allocated(SrcRotInputFileData%TwrCd)) then
      LB(1:1) = lbound(SrcRotInputFileData%TwrCd)
      UB(1:1) = ubound(SrcRotInputFileData%TwrCd)
      if (.not. allocated(DstRotInputFileData%TwrCd)) then
         allocate(DstRotInputFileData%TwrCd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputFileData%TwrCd = SrcRotInputFileData%TwrCd
   end if
   if (allocated(SrcRotInputFileData%TwrTI)) then
      LB(1:1) = lbound(SrcRotInputFileData%TwrTI)
      UB(1:1) = ubound(SrcRotInputFileData%TwrTI)
      if (.not. allocated(DstRotInputFileData%TwrTI)) then
         allocate(DstRotInputFileData%TwrTI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrTI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputFileData%TwrTI = SrcRotInputFileData%TwrTI
   end if
   if (allocated(SrcRotInputFileData%TwrCb)) then
      LB(1:1) = lbound(SrcRotInputFileData%TwrCb)
      UB(1:1) = ubound(SrcRotInputFileData%TwrCb)
      if (.not. allocated(DstRotInputFileData%TwrCb)) then
         allocate(DstRotInputFileData%TwrCb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputFileData%TwrCb = SrcRotInputFileData%TwrCb
   end if
   DstRotInputFileData%VolHub = SrcRotInputFileData%VolHub
   DstRotInputFileData%HubCenBx = SrcRotInputFileData%HubCenBx
   DstRotInputFileData%VolNac = SrcRotInputFileData%VolNac
   DstRotInputFileData%NacCenB = SrcRotInputFileData%NacCenB
   DstRotInputFileData%TFinAero = SrcRotInputFileData%TFinAero
   DstRotInputFileData%TFinFile = SrcRotInputFileData%TFinFile
   call AD_CopyTFinInputFileType(SrcRotInputFileData%TFin, DstRotInputFileData%TFin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotInputFile(RotInputFileData, ErrStat, ErrMsg)
   type(RotInputFile), intent(inout) :: RotInputFileData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotInputFile'
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(RotInputFileData%BladeProps)) then
      LB(1:1) = lbound(RotInputFileData%BladeProps)
      UB(1:1) = ubound(RotInputFileData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_DestroyBladePropsType(RotInputFileData%BladeProps(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInputFileData%BladeProps)
   end if
   if (allocated(RotInputFileData%TwrElev)) then
      deallocate(RotInputFileData%TwrElev)
   end if
   if (allocated(RotInputFileData%TwrDiam)) then
      deallocate(RotInputFileData%TwrDiam)
   end if
   if (allocated(RotInputFileData%TwrCd)) then
      deallocate(RotInputFileData%TwrCd)
   end if
   if (allocated(RotInputFileData%TwrTI)) then
      deallocate(RotInputFileData%TwrTI)
   end if
   if (allocated(RotInputFileData%TwrCb)) then
      deallocate(RotInputFileData%TwrCb)
   end if
   call AD_DestroyTFinInputFileType(RotInputFileData%TFin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%BladeProps))
   if (allocated(InData%BladeProps)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeProps), ubound(InData%BladeProps))
      LB(1:1) = lbound(InData%BladeProps)
      UB(1:1) = ubound(InData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_PackBladePropsType(Buf, InData%BladeProps(i1)) 
      end do
   end if
   call RegPack(Buf, InData%NumTwrNds)
   call RegPack(Buf, allocated(InData%TwrElev))
   if (allocated(InData%TwrElev)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrElev), ubound(InData%TwrElev))
      call RegPack(Buf, InData%TwrElev)
   end if
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   call RegPack(Buf, allocated(InData%TwrCd))
   if (allocated(InData%TwrCd)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCd), ubound(InData%TwrCd))
      call RegPack(Buf, InData%TwrCd)
   end if
   call RegPack(Buf, allocated(InData%TwrTI))
   if (allocated(InData%TwrTI)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTI), ubound(InData%TwrTI))
      call RegPack(Buf, InData%TwrTI)
   end if
   call RegPack(Buf, allocated(InData%TwrCb))
   if (allocated(InData%TwrCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCb), ubound(InData%TwrCb))
      call RegPack(Buf, InData%TwrCb)
   end if
   call RegPack(Buf, InData%VolHub)
   call RegPack(Buf, InData%HubCenBx)
   call RegPack(Buf, InData%VolNac)
   call RegPack(Buf, InData%NacCenB)
   call RegPack(Buf, InData%TFinAero)
   call RegPack(Buf, InData%TFinFile)
   call AD_PackTFinInputFileType(Buf, InData%TFin) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%BladeProps)) deallocate(OutData%BladeProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeProps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladePropsType(Buf, OutData%BladeProps(i1)) ! BladeProps 
      end do
   end if
   call RegUnpack(Buf, OutData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%TwrElev)) deallocate(OutData%TwrElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrElev(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrCd)) deallocate(OutData%TwrCd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrTI)) deallocate(OutData%TwrTI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrCb)) deallocate(OutData%TwrCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinFile)
   if (RegCheckErr(Buf, RoutineName)) return
   call AD_UnpackTFinInputFileType(Buf, OutData%TFin) ! TFin 
end subroutine

subroutine AD_CopyInputFile(SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg)
   type(AD_InputFile), intent(in) :: SrcInputFileData
   type(AD_InputFile), intent(inout) :: DstInputFileData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyInputFile'
   ErrStat = ErrID_None
<<<<<<< HEAD
   ErrMsg  = ""
    DstRotParameterTypeData%NumBlades = SrcRotParameterTypeData%NumBlades
    DstRotParameterTypeData%NumBlNds = SrcRotParameterTypeData%NumBlNds
    DstRotParameterTypeData%NumTwrNds = SrcRotParameterTypeData%NumTwrNds
IF (ALLOCATED(SrcRotParameterTypeData%TwrDiam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrDiam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrDiam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrDiam)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrDiam = SrcRotParameterTypeData%TwrDiam
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCd)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCd,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCd,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCd)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCd = SrcRotParameterTypeData%TwrCd
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrTI)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrTI,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrTI,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrTI)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrTI = SrcRotParameterTypeData%TwrTI
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlTwist)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlTwist,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlTwist,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlTwist,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlTwist,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlTwist)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlTwist(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlTwist = SrcRotParameterTypeData%BlTwist
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCb)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCb,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCb,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCb)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCb = SrcRotParameterTypeData%TwrCb
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCp)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCp,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCp,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCp)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCp = SrcRotParameterTypeData%TwrCp
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCa)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCa,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCa,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCa)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCa(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCa.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCa = SrcRotParameterTypeData%TwrCa
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlCenBn)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlCenBn,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlCenBn,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlCenBn,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlCenBn,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlCenBn)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlCenBn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlCenBn = SrcRotParameterTypeData%BlCenBn
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlCenBt)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlCenBt,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlCenBt,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlCenBt,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlCenBt,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlCenBt)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlCenBt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlCenBt = SrcRotParameterTypeData%BlCenBt
ENDIF
    DstRotParameterTypeData%VolHub = SrcRotParameterTypeData%VolHub
    DstRotParameterTypeData%HubCenBx = SrcRotParameterTypeData%HubCenBx
    DstRotParameterTypeData%VolNac = SrcRotParameterTypeData%VolNac
    DstRotParameterTypeData%NacCenB = SrcRotParameterTypeData%NacCenB
    DstRotParameterTypeData%VolBl = SrcRotParameterTypeData%VolBl
    DstRotParameterTypeData%VolTwr = SrcRotParameterTypeData%VolTwr
IF (ALLOCATED(SrcRotParameterTypeData%BlRad)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlRad,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlRad,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlRad,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlRad,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlRad)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlRad(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlRad = SrcRotParameterTypeData%BlRad
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlDL)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlDL,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlDL,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlDL,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlDL,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlDL)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlDL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlDL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlDL = SrcRotParameterTypeData%BlDL
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlTaper)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlTaper,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlTaper,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlTaper,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlTaper,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlTaper)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlTaper(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTaper.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlTaper = SrcRotParameterTypeData%BlTaper
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlAxCent)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlAxCent,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlAxCent,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlAxCent,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlAxCent,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlAxCent)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlAxCent(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAxCent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlAxCent = SrcRotParameterTypeData%BlAxCent
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlIN)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlIN,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlIN,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlIN,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlIN,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlIN)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlIN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlIN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlIN = SrcRotParameterTypeData%BlIN
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlIT)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlIT,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlIT,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlIT,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlIT,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlIT)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlIT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlIT = SrcRotParameterTypeData%BlIT
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlAN)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlAN,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlAN,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlAN,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlAN,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlAN)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlAN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlAN = SrcRotParameterTypeData%BlAN
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlAT)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlAT,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlAT,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlAT,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlAT,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlAT)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlAT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlAT = SrcRotParameterTypeData%BlAT
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlAM)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlAM,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlAM,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlAM,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlAM,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlAM)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlAM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlAM = SrcRotParameterTypeData%BlAM
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrRad)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrRad,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrRad,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrRad)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrRad = SrcRotParameterTypeData%TwrRad
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrDL)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrDL,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrDL,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrDL)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrDL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrDL = SrcRotParameterTypeData%TwrDL
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrTaper)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrTaper,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrTaper,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrTaper)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrTaper(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTaper.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrTaper = SrcRotParameterTypeData%TwrTaper
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrAxCent)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrAxCent,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrAxCent,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrAxCent)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrAxCent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrAxCent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrAxCent = SrcRotParameterTypeData%TwrAxCent
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrIT)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrIT,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrIT,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrIT)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrIT = SrcRotParameterTypeData%TwrIT
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrAT)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrAT,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrAT,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrAT)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrAT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrAT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrAT = SrcRotParameterTypeData%TwrAT
ENDIF
      CALL BEMT_CopyParam( SrcRotParameterTypeData%BEMT, DstRotParameterTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyParam( SrcRotParameterTypeData%AA, DstRotParameterTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotParameterTypeData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%Jac_u_indx,1)
  i1_u = UBOUND(SrcRotParameterTypeData%Jac_u_indx,1)
  i2_l = LBOUND(SrcRotParameterTypeData%Jac_u_indx,2)
  i2_u = UBOUND(SrcRotParameterTypeData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%Jac_u_indx)) THEN 
    ALLOCATE(DstRotParameterTypeData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%Jac_u_indx = SrcRotParameterTypeData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%du)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%du,1)
  i1_u = UBOUND(SrcRotParameterTypeData%du,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%du)) THEN 
    ALLOCATE(DstRotParameterTypeData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%du = SrcRotParameterTypeData%du
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%dx)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%dx,1)
  i1_u = UBOUND(SrcRotParameterTypeData%dx,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%dx)) THEN 
    ALLOCATE(DstRotParameterTypeData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%dx = SrcRotParameterTypeData%dx
ENDIF
    DstRotParameterTypeData%Jac_ny = SrcRotParameterTypeData%Jac_ny
    DstRotParameterTypeData%NumBl_Lin = SrcRotParameterTypeData%NumBl_Lin
    DstRotParameterTypeData%TwrPotent = SrcRotParameterTypeData%TwrPotent
    DstRotParameterTypeData%TwrShadow = SrcRotParameterTypeData%TwrShadow
    DstRotParameterTypeData%TwrAero = SrcRotParameterTypeData%TwrAero
    DstRotParameterTypeData%FrozenWake = SrcRotParameterTypeData%FrozenWake
    DstRotParameterTypeData%CavitCheck = SrcRotParameterTypeData%CavitCheck
    DstRotParameterTypeData%MHK = SrcRotParameterTypeData%MHK
    DstRotParameterTypeData%CompAA = SrcRotParameterTypeData%CompAA
    DstRotParameterTypeData%AirDens = SrcRotParameterTypeData%AirDens
    DstRotParameterTypeData%KinVisc = SrcRotParameterTypeData%KinVisc
    DstRotParameterTypeData%SpdSound = SrcRotParameterTypeData%SpdSound
    DstRotParameterTypeData%Gravity = SrcRotParameterTypeData%Gravity
    DstRotParameterTypeData%Patm = SrcRotParameterTypeData%Patm
    DstRotParameterTypeData%Pvap = SrcRotParameterTypeData%Pvap
    DstRotParameterTypeData%WtrDpth = SrcRotParameterTypeData%WtrDpth
    DstRotParameterTypeData%MSL2SWL = SrcRotParameterTypeData%MSL2SWL
    DstRotParameterTypeData%AeroProjMod = SrcRotParameterTypeData%AeroProjMod
    DstRotParameterTypeData%AeroBEM_Mod = SrcRotParameterTypeData%AeroBEM_Mod
    DstRotParameterTypeData%NumOuts = SrcRotParameterTypeData%NumOuts
    DstRotParameterTypeData%RootName = SrcRotParameterTypeData%RootName
IF (ALLOCATED(SrcRotParameterTypeData%OutParam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%OutParam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%OutParam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%OutParam)) THEN 
    ALLOCATE(DstRotParameterTypeData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotParameterTypeData%OutParam,1), UBOUND(SrcRotParameterTypeData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcRotParameterTypeData%OutParam(i1), DstRotParameterTypeData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstRotParameterTypeData%NBlOuts = SrcRotParameterTypeData%NBlOuts
    DstRotParameterTypeData%BlOutNd = SrcRotParameterTypeData%BlOutNd
    DstRotParameterTypeData%NTwOuts = SrcRotParameterTypeData%NTwOuts
    DstRotParameterTypeData%TwOutNd = SrcRotParameterTypeData%TwOutNd
    DstRotParameterTypeData%BldNd_NumOuts = SrcRotParameterTypeData%BldNd_NumOuts
    DstRotParameterTypeData%BldNd_TotNumOuts = SrcRotParameterTypeData%BldNd_TotNumOuts
IF (ALLOCATED(SrcRotParameterTypeData%BldNd_OutParam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BldNd_OutParam)) THEN 
    ALLOCATE(DstRotParameterTypeData%BldNd_OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotParameterTypeData%BldNd_OutParam,1), UBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcRotParameterTypeData%BldNd_OutParam(i1), DstRotParameterTypeData%BldNd_OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BldNd_BlOutNd)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BldNd_BlOutNd,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BldNd_BlOutNd,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BldNd_BlOutNd)) THEN 
    ALLOCATE(DstRotParameterTypeData%BldNd_BlOutNd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_BlOutNd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BldNd_BlOutNd = SrcRotParameterTypeData%BldNd_BlOutNd
ENDIF
    DstRotParameterTypeData%BldNd_BladesOut = SrcRotParameterTypeData%BldNd_BladesOut
    DstRotParameterTypeData%TFinAero = SrcRotParameterTypeData%TFinAero
      CALL AD_Copytfinparametertype( SrcRotParameterTypeData%TFin, DstRotParameterTypeData%TFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotParameterType

 SUBROUTINE AD_DestroyRotParameterType( RotParameterTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(RotParameterType), INTENT(INOUT) :: RotParameterTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotParameterType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(RotParameterTypeData%TwrDiam)) THEN
  DEALLOCATE(RotParameterTypeData%TwrDiam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCd)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCd)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrTI)) THEN
  DEALLOCATE(RotParameterTypeData%TwrTI)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlTwist)) THEN
  DEALLOCATE(RotParameterTypeData%BlTwist)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCb)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCb)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCp)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCp)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCa)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCa)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlCenBn)) THEN
  DEALLOCATE(RotParameterTypeData%BlCenBn)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlCenBt)) THEN
  DEALLOCATE(RotParameterTypeData%BlCenBt)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlRad)) THEN
  DEALLOCATE(RotParameterTypeData%BlRad)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlDL)) THEN
  DEALLOCATE(RotParameterTypeData%BlDL)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlTaper)) THEN
  DEALLOCATE(RotParameterTypeData%BlTaper)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlAxCent)) THEN
  DEALLOCATE(RotParameterTypeData%BlAxCent)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlIN)) THEN
  DEALLOCATE(RotParameterTypeData%BlIN)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlIT)) THEN
  DEALLOCATE(RotParameterTypeData%BlIT)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlAN)) THEN
  DEALLOCATE(RotParameterTypeData%BlAN)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlAT)) THEN
  DEALLOCATE(RotParameterTypeData%BlAT)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlAM)) THEN
  DEALLOCATE(RotParameterTypeData%BlAM)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrRad)) THEN
  DEALLOCATE(RotParameterTypeData%TwrRad)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrDL)) THEN
  DEALLOCATE(RotParameterTypeData%TwrDL)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrTaper)) THEN
  DEALLOCATE(RotParameterTypeData%TwrTaper)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrAxCent)) THEN
  DEALLOCATE(RotParameterTypeData%TwrAxCent)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrIT)) THEN
  DEALLOCATE(RotParameterTypeData%TwrIT)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrAT)) THEN
  DEALLOCATE(RotParameterTypeData%TwrAT)
ENDIF
  CALL BEMT_DestroyParam( RotParameterTypeData%BEMT, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyParam( RotParameterTypeData%AA, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotParameterTypeData%Jac_u_indx)) THEN
  DEALLOCATE(RotParameterTypeData%Jac_u_indx)
ENDIF
IF (ALLOCATED(RotParameterTypeData%du)) THEN
  DEALLOCATE(RotParameterTypeData%du)
ENDIF
IF (ALLOCATED(RotParameterTypeData%dx)) THEN
  DEALLOCATE(RotParameterTypeData%dx)
ENDIF
IF (ALLOCATED(RotParameterTypeData%OutParam)) THEN
DO i1 = LBOUND(RotParameterTypeData%OutParam,1), UBOUND(RotParameterTypeData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( RotParameterTypeData%OutParam(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotParameterTypeData%OutParam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BldNd_OutParam)) THEN
DO i1 = LBOUND(RotParameterTypeData%BldNd_OutParam,1), UBOUND(RotParameterTypeData%BldNd_OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( RotParameterTypeData%BldNd_OutParam(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotParameterTypeData%BldNd_OutParam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BldNd_BlOutNd)) THEN
  DEALLOCATE(RotParameterTypeData%BldNd_BlOutNd)
ENDIF
  CALL AD_Destroytfinparametertype( RotParameterTypeData%TFin, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotParameterType

 SUBROUTINE AD_PackRotParameterType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RotParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackRotParameterType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NumBlades
      Int_BufSz  = Int_BufSz  + 1  ! NumBlNds
      Int_BufSz  = Int_BufSz  + 1  ! NumTwrNds
  Int_BufSz   = Int_BufSz   + 1     ! TwrDiam allocated yes/no
  IF ( ALLOCATED(InData%TwrDiam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrDiam upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrDiam)  ! TwrDiam
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCd allocated yes/no
  IF ( ALLOCATED(InData%TwrCd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCd upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCd)  ! TwrCd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrTI allocated yes/no
  IF ( ALLOCATED(InData%TwrTI) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrTI upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrTI)  ! TwrTI
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlTwist allocated yes/no
  IF ( ALLOCATED(InData%BlTwist) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlTwist upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlTwist)  ! BlTwist
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCb allocated yes/no
  IF ( ALLOCATED(InData%TwrCb) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCb upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCb)  ! TwrCb
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCp allocated yes/no
  IF ( ALLOCATED(InData%TwrCp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCp upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCp)  ! TwrCp
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrCa allocated yes/no
  IF ( ALLOCATED(InData%TwrCa) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrCa upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrCa)  ! TwrCa
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCenBn allocated yes/no
  IF ( ALLOCATED(InData%BlCenBn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlCenBn upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCenBn)  ! BlCenBn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlCenBt allocated yes/no
  IF ( ALLOCATED(InData%BlCenBt) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlCenBt upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlCenBt)  ! BlCenBt
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! VolHub
      Re_BufSz   = Re_BufSz   + 1  ! HubCenBx
      Re_BufSz   = Re_BufSz   + 1  ! VolNac
      Re_BufSz   = Re_BufSz   + SIZE(InData%NacCenB)  ! NacCenB
      Re_BufSz   = Re_BufSz   + 1  ! VolBl
      Re_BufSz   = Re_BufSz   + 1  ! VolTwr
  Int_BufSz   = Int_BufSz   + 1     ! BlRad allocated yes/no
  IF ( ALLOCATED(InData%BlRad) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlRad upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlRad)  ! BlRad
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlDL allocated yes/no
  IF ( ALLOCATED(InData%BlDL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlDL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlDL)  ! BlDL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlTaper allocated yes/no
  IF ( ALLOCATED(InData%BlTaper) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlTaper upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlTaper)  ! BlTaper
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlAxCent allocated yes/no
  IF ( ALLOCATED(InData%BlAxCent) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlAxCent upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlAxCent)  ! BlAxCent
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlIN allocated yes/no
  IF ( ALLOCATED(InData%BlIN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlIN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlIN)  ! BlIN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlIT allocated yes/no
  IF ( ALLOCATED(InData%BlIT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlIT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlIT)  ! BlIT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlAN allocated yes/no
  IF ( ALLOCATED(InData%BlAN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlAN upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlAN)  ! BlAN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlAT allocated yes/no
  IF ( ALLOCATED(InData%BlAT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlAT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlAT)  ! BlAT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlAM allocated yes/no
  IF ( ALLOCATED(InData%BlAM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlAM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlAM)  ! BlAM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrRad allocated yes/no
  IF ( ALLOCATED(InData%TwrRad) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrRad upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrRad)  ! TwrRad
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrDL allocated yes/no
  IF ( ALLOCATED(InData%TwrDL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrDL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrDL)  ! TwrDL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrTaper allocated yes/no
  IF ( ALLOCATED(InData%TwrTaper) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrTaper upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrTaper)  ! TwrTaper
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrAxCent allocated yes/no
  IF ( ALLOCATED(InData%TwrAxCent) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrAxCent upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrAxCent)  ! TwrAxCent
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrIT allocated yes/no
  IF ( ALLOCATED(InData%TwrIT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrIT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrIT)  ! TwrIT
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TwrAT allocated yes/no
  IF ( ALLOCATED(InData%TwrAT) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! TwrAT upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TwrAT)  ! TwrAT
  END IF
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! BEMT: size of buffers for each call to pack subtype
      CALL BEMT_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%BEMT, ErrStat2, ErrMsg2, .TRUE. ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BEMT
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BEMT
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BEMT
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! AA: size of buffers for each call to pack subtype
      CALL AA_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%AA, ErrStat2, ErrMsg2, .TRUE. ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! Jac_u_indx allocated yes/no
  IF ( ALLOCATED(InData%Jac_u_indx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Jac_u_indx upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%Jac_u_indx)  ! Jac_u_indx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! du allocated yes/no
  IF ( ALLOCATED(InData%du) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! du upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%du)  ! du
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! dx allocated yes/no
  IF ( ALLOCATED(InData%dx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! dx upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%dx)  ! dx
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! Jac_ny
      Int_BufSz  = Int_BufSz  + 1  ! NumBl_Lin
      Int_BufSz  = Int_BufSz  + 1  ! TwrPotent
      Int_BufSz  = Int_BufSz  + 1  ! TwrShadow
      Int_BufSz  = Int_BufSz  + 1  ! TwrAero
      Int_BufSz  = Int_BufSz  + 1  ! FrozenWake
      Int_BufSz  = Int_BufSz  + 1  ! CavitCheck
      Int_BufSz  = Int_BufSz  + 1  ! MHK
      Int_BufSz  = Int_BufSz  + 1  ! CompAA
      Re_BufSz   = Re_BufSz   + 1  ! AirDens
      Re_BufSz   = Re_BufSz   + 1  ! KinVisc
      Re_BufSz   = Re_BufSz   + 1  ! SpdSound
      Re_BufSz   = Re_BufSz   + 1  ! Gravity
      Re_BufSz   = Re_BufSz   + 1  ! Patm
      Re_BufSz   = Re_BufSz   + 1  ! Pvap
      Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
      Re_BufSz   = Re_BufSz   + 1  ! MSL2SWL
      Int_BufSz  = Int_BufSz  + 1  ! AeroProjMod
      Int_BufSz  = Int_BufSz  + 1  ! AeroBEM_Mod
      Int_BufSz  = Int_BufSz  + 1  ! NumOuts
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%RootName)  ! RootName
  Int_BufSz   = Int_BufSz   + 1     ! OutParam allocated yes/no
  IF ( ALLOCATED(InData%OutParam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! OutParam upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
      Int_BufSz   = Int_BufSz + 3  ! OutParam: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%OutParam(i1), ErrStat2, ErrMsg2, .TRUE. ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! OutParam
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! OutParam
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! OutParam
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NBlOuts
      Int_BufSz  = Int_BufSz  + SIZE(InData%BlOutNd)  ! BlOutNd
      Int_BufSz  = Int_BufSz  + 1  ! NTwOuts
      Int_BufSz  = Int_BufSz  + SIZE(InData%TwOutNd)  ! TwOutNd
      Int_BufSz  = Int_BufSz  + 1  ! BldNd_NumOuts
      Int_BufSz  = Int_BufSz  + 1  ! BldNd_TotNumOuts
  Int_BufSz   = Int_BufSz   + 1     ! BldNd_OutParam allocated yes/no
  IF ( ALLOCATED(InData%BldNd_OutParam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BldNd_OutParam upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BldNd_OutParam,1), UBOUND(InData%BldNd_OutParam,1)
      Int_BufSz   = Int_BufSz + 3  ! BldNd_OutParam: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%BldNd_OutParam(i1), ErrStat2, ErrMsg2, .TRUE. ) ! BldNd_OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BldNd_OutParam
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BldNd_OutParam
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BldNd_OutParam
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BldNd_BlOutNd allocated yes/no
  IF ( ALLOCATED(InData%BldNd_BlOutNd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BldNd_BlOutNd upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BldNd_BlOutNd)  ! BldNd_BlOutNd
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! BldNd_BladesOut
      Int_BufSz  = Int_BufSz  + 1  ! TFinAero
      Int_BufSz   = Int_BufSz + 3  ! TFin: size of buffers for each call to pack subtype
      CALL AD_Packtfinparametertype( Re_Buf, Db_Buf, Int_Buf, InData%TFin, ErrStat2, ErrMsg2, .TRUE. ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TFin
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TFin
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TFin
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%NumBlades
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumBlNds
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumTwrNds
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%TwrDiam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrDiam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrDiam,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrDiam,1), UBOUND(InData%TwrDiam,1)
        ReKiBuf(Re_Xferred) = InData%TwrDiam(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCd,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCd,1), UBOUND(InData%TwrCd,1)
        ReKiBuf(Re_Xferred) = InData%TwrCd(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrTI) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrTI,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrTI,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrTI,1), UBOUND(InData%TwrTI,1)
        ReKiBuf(Re_Xferred) = InData%TwrTI(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlTwist) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlTwist,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlTwist,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlTwist,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlTwist,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlTwist,2), UBOUND(InData%BlTwist,2)
        DO i1 = LBOUND(InData%BlTwist,1), UBOUND(InData%BlTwist,1)
          ReKiBuf(Re_Xferred) = InData%BlTwist(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCb) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCb,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCb,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCb,1), UBOUND(InData%TwrCb,1)
        ReKiBuf(Re_Xferred) = InData%TwrCb(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCp,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCp,1), UBOUND(InData%TwrCp,1)
        ReKiBuf(Re_Xferred) = InData%TwrCp(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrCa) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrCa,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrCa,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrCa,1), UBOUND(InData%TwrCa,1)
        ReKiBuf(Re_Xferred) = InData%TwrCa(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCenBn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBn,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBn,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBn,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlCenBn,2), UBOUND(InData%BlCenBn,2)
        DO i1 = LBOUND(InData%BlCenBn,1), UBOUND(InData%BlCenBn,1)
          ReKiBuf(Re_Xferred) = InData%BlCenBn(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlCenBt) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBt,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBt,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlCenBt,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlCenBt,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlCenBt,2), UBOUND(InData%BlCenBt,2)
        DO i1 = LBOUND(InData%BlCenBt,1), UBOUND(InData%BlCenBt,1)
          ReKiBuf(Re_Xferred) = InData%BlCenBt(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%VolHub
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%HubCenBx
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VolNac
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%NacCenB,1), UBOUND(InData%NacCenB,1)
      ReKiBuf(Re_Xferred) = InData%NacCenB(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%VolBl
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VolTwr
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%BlRad) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlRad,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlRad,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlRad,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlRad,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlRad,2), UBOUND(InData%BlRad,2)
        DO i1 = LBOUND(InData%BlRad,1), UBOUND(InData%BlRad,1)
          ReKiBuf(Re_Xferred) = InData%BlRad(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlDL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlDL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlDL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlDL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlDL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlDL,2), UBOUND(InData%BlDL,2)
        DO i1 = LBOUND(InData%BlDL,1), UBOUND(InData%BlDL,1)
          ReKiBuf(Re_Xferred) = InData%BlDL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlTaper) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlTaper,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlTaper,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlTaper,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlTaper,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlTaper,2), UBOUND(InData%BlTaper,2)
        DO i1 = LBOUND(InData%BlTaper,1), UBOUND(InData%BlTaper,1)
          ReKiBuf(Re_Xferred) = InData%BlTaper(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlAxCent) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAxCent,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAxCent,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAxCent,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAxCent,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlAxCent,2), UBOUND(InData%BlAxCent,2)
        DO i1 = LBOUND(InData%BlAxCent,1), UBOUND(InData%BlAxCent,1)
          ReKiBuf(Re_Xferred) = InData%BlAxCent(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlIN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlIN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlIN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlIN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlIN,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlIN,2), UBOUND(InData%BlIN,2)
        DO i1 = LBOUND(InData%BlIN,1), UBOUND(InData%BlIN,1)
          ReKiBuf(Re_Xferred) = InData%BlIN(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlIT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlIT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlIT,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlIT,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlIT,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlIT,2), UBOUND(InData%BlIT,2)
        DO i1 = LBOUND(InData%BlIT,1), UBOUND(InData%BlIT,1)
          ReKiBuf(Re_Xferred) = InData%BlIT(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlAN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAN,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAN,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAN,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlAN,2), UBOUND(InData%BlAN,2)
        DO i1 = LBOUND(InData%BlAN,1), UBOUND(InData%BlAN,1)
          ReKiBuf(Re_Xferred) = InData%BlAN(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlAT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAT,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAT,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAT,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlAT,2), UBOUND(InData%BlAT,2)
        DO i1 = LBOUND(InData%BlAT,1), UBOUND(InData%BlAT,1)
          ReKiBuf(Re_Xferred) = InData%BlAT(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BlAM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAM,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlAM,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlAM,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BlAM,2), UBOUND(InData%BlAM,2)
        DO i1 = LBOUND(InData%BlAM,1), UBOUND(InData%BlAM,1)
          ReKiBuf(Re_Xferred) = InData%BlAM(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrRad) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrRad,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrRad,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrRad,1), UBOUND(InData%TwrRad,1)
        ReKiBuf(Re_Xferred) = InData%TwrRad(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrDL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrDL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrDL,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrDL,1), UBOUND(InData%TwrDL,1)
        ReKiBuf(Re_Xferred) = InData%TwrDL(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrTaper) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrTaper,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrTaper,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrTaper,1), UBOUND(InData%TwrTaper,1)
        ReKiBuf(Re_Xferred) = InData%TwrTaper(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrAxCent) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrAxCent,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrAxCent,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrAxCent,1), UBOUND(InData%TwrAxCent,1)
        ReKiBuf(Re_Xferred) = InData%TwrAxCent(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrIT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrIT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrIT,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrIT,1), UBOUND(InData%TwrIT,1)
        ReKiBuf(Re_Xferred) = InData%TwrIT(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TwrAT) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TwrAT,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TwrAT,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%TwrAT,1), UBOUND(InData%TwrAT,1)
        ReKiBuf(Re_Xferred) = InData%TwrAT(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
      CALL BEMT_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%BEMT, ErrStat2, ErrMsg2, OnlySize ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL AA_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%AA, ErrStat2, ErrMsg2, OnlySize ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%Jac_u_indx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Jac_u_indx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Jac_u_indx,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Jac_u_indx,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Jac_u_indx,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Jac_u_indx,2), UBOUND(InData%Jac_u_indx,2)
        DO i1 = LBOUND(InData%Jac_u_indx,1), UBOUND(InData%Jac_u_indx,1)
          IntKiBuf(Int_Xferred) = InData%Jac_u_indx(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%du) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%du,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%du,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%du,1), UBOUND(InData%du,1)
        ReKiBuf(Re_Xferred) = InData%du(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%dx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dx,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%dx,1), UBOUND(InData%dx,1)
        ReKiBuf(Re_Xferred) = InData%dx(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%Jac_ny
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumBl_Lin
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TwrPotent
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TwrShadow
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TwrAero, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FrozenWake, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%CavitCheck, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MHK
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%CompAA, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AirDens
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%KinVisc
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SpdSound
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Gravity
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Patm
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Pvap
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDpth
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MSL2SWL
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AeroProjMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AeroBEM_Mod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumOuts
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%RootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%RootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( .NOT. ALLOCATED(InData%OutParam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OutParam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OutParam,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%OutParam(i1), ErrStat2, ErrMsg2, OnlySize ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NBlOuts
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%BlOutNd,1), UBOUND(InData%BlOutNd,1)
      IntKiBuf(Int_Xferred) = InData%BlOutNd(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%NTwOuts
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%TwOutNd,1), UBOUND(InData%TwOutNd,1)
      IntKiBuf(Int_Xferred) = InData%TwOutNd(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%BldNd_NumOuts
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%BldNd_TotNumOuts
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%BldNd_OutParam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BldNd_OutParam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BldNd_OutParam,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BldNd_OutParam,1), UBOUND(InData%BldNd_OutParam,1)
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%BldNd_OutParam(i1), ErrStat2, ErrMsg2, OnlySize ) ! BldNd_OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BldNd_BlOutNd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BldNd_BlOutNd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BldNd_BlOutNd,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BldNd_BlOutNd,1), UBOUND(InData%BldNd_BlOutNd,1)
        IntKiBuf(Int_Xferred) = InData%BldNd_BlOutNd(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%BldNd_BladesOut
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TFinAero, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
      CALL AD_Packtfinparametertype( Re_Buf, Db_Buf, Int_Buf, InData%TFin, ErrStat2, ErrMsg2, OnlySize ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE AD_PackRotParameterType

 SUBROUTINE AD_UnPackRotParameterType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RotParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackRotParameterType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%NumBlades = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumBlNds = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumTwrNds = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrDiam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrDiam)) DEALLOCATE(OutData%TwrDiam)
    ALLOCATE(OutData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrDiam,1), UBOUND(OutData%TwrDiam,1)
        OutData%TwrDiam(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCd)) DEALLOCATE(OutData%TwrCd)
    ALLOCATE(OutData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCd,1), UBOUND(OutData%TwrCd,1)
        OutData%TwrCd(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrTI not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrTI)) DEALLOCATE(OutData%TwrTI)
    ALLOCATE(OutData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrTI,1), UBOUND(OutData%TwrTI,1)
        OutData%TwrTI(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlTwist not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlTwist)) DEALLOCATE(OutData%BlTwist)
    ALLOCATE(OutData%BlTwist(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlTwist,2), UBOUND(OutData%BlTwist,2)
        DO i1 = LBOUND(OutData%BlTwist,1), UBOUND(OutData%BlTwist,1)
          OutData%BlTwist(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCb not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCb)) DEALLOCATE(OutData%TwrCb)
    ALLOCATE(OutData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCb,1), UBOUND(OutData%TwrCb,1)
        OutData%TwrCb(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCp)) DEALLOCATE(OutData%TwrCp)
    ALLOCATE(OutData%TwrCp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCp,1), UBOUND(OutData%TwrCp,1)
        OutData%TwrCp(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrCa not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrCa)) DEALLOCATE(OutData%TwrCa)
    ALLOCATE(OutData%TwrCa(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCa.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrCa,1), UBOUND(OutData%TwrCa,1)
        OutData%TwrCa(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCenBn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCenBn)) DEALLOCATE(OutData%BlCenBn)
    ALLOCATE(OutData%BlCenBn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlCenBn,2), UBOUND(OutData%BlCenBn,2)
        DO i1 = LBOUND(OutData%BlCenBn,1), UBOUND(OutData%BlCenBn,1)
          OutData%BlCenBn(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlCenBt not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlCenBt)) DEALLOCATE(OutData%BlCenBt)
    ALLOCATE(OutData%BlCenBt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlCenBt,2), UBOUND(OutData%BlCenBt,2)
        DO i1 = LBOUND(OutData%BlCenBt,1), UBOUND(OutData%BlCenBt,1)
          OutData%BlCenBt(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%VolHub = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%HubCenBx = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VolNac = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%NacCenB,1)
    i1_u = UBOUND(OutData%NacCenB,1)
    DO i1 = LBOUND(OutData%NacCenB,1), UBOUND(OutData%NacCenB,1)
      OutData%NacCenB(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%VolBl = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VolTwr = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlRad not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlRad)) DEALLOCATE(OutData%BlRad)
    ALLOCATE(OutData%BlRad(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlRad.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlRad,2), UBOUND(OutData%BlRad,2)
        DO i1 = LBOUND(OutData%BlRad,1), UBOUND(OutData%BlRad,1)
          OutData%BlRad(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlDL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlDL)) DEALLOCATE(OutData%BlDL)
    ALLOCATE(OutData%BlDL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlDL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlDL,2), UBOUND(OutData%BlDL,2)
        DO i1 = LBOUND(OutData%BlDL,1), UBOUND(OutData%BlDL,1)
          OutData%BlDL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlTaper not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlTaper)) DEALLOCATE(OutData%BlTaper)
    ALLOCATE(OutData%BlTaper(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTaper.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlTaper,2), UBOUND(OutData%BlTaper,2)
        DO i1 = LBOUND(OutData%BlTaper,1), UBOUND(OutData%BlTaper,1)
          OutData%BlTaper(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlAxCent not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlAxCent)) DEALLOCATE(OutData%BlAxCent)
    ALLOCATE(OutData%BlAxCent(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAxCent.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlAxCent,2), UBOUND(OutData%BlAxCent,2)
        DO i1 = LBOUND(OutData%BlAxCent,1), UBOUND(OutData%BlAxCent,1)
          OutData%BlAxCent(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlIN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlIN)) DEALLOCATE(OutData%BlIN)
    ALLOCATE(OutData%BlIN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlIN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlIN,2), UBOUND(OutData%BlIN,2)
        DO i1 = LBOUND(OutData%BlIN,1), UBOUND(OutData%BlIN,1)
          OutData%BlIN(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlIT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlIT)) DEALLOCATE(OutData%BlIT)
    ALLOCATE(OutData%BlIT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlIT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlIT,2), UBOUND(OutData%BlIT,2)
        DO i1 = LBOUND(OutData%BlIT,1), UBOUND(OutData%BlIT,1)
          OutData%BlIT(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlAN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlAN)) DEALLOCATE(OutData%BlAN)
    ALLOCATE(OutData%BlAN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlAN,2), UBOUND(OutData%BlAN,2)
        DO i1 = LBOUND(OutData%BlAN,1), UBOUND(OutData%BlAN,1)
          OutData%BlAN(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlAT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlAT)) DEALLOCATE(OutData%BlAT)
    ALLOCATE(OutData%BlAT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlAT,2), UBOUND(OutData%BlAT,2)
        DO i1 = LBOUND(OutData%BlAT,1), UBOUND(OutData%BlAT,1)
          OutData%BlAT(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlAM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlAM)) DEALLOCATE(OutData%BlAM)
    ALLOCATE(OutData%BlAM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BlAM,2), UBOUND(OutData%BlAM,2)
        DO i1 = LBOUND(OutData%BlAM,1), UBOUND(OutData%BlAM,1)
          OutData%BlAM(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrRad not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrRad)) DEALLOCATE(OutData%TwrRad)
    ALLOCATE(OutData%TwrRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRad.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrRad,1), UBOUND(OutData%TwrRad,1)
        OutData%TwrRad(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrDL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrDL)) DEALLOCATE(OutData%TwrDL)
    ALLOCATE(OutData%TwrDL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrDL,1), UBOUND(OutData%TwrDL,1)
        OutData%TwrDL(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrTaper not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrTaper)) DEALLOCATE(OutData%TwrTaper)
    ALLOCATE(OutData%TwrTaper(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTaper.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrTaper,1), UBOUND(OutData%TwrTaper,1)
        OutData%TwrTaper(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrAxCent not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrAxCent)) DEALLOCATE(OutData%TwrAxCent)
    ALLOCATE(OutData%TwrAxCent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrAxCent.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrAxCent,1), UBOUND(OutData%TwrAxCent,1)
        OutData%TwrAxCent(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrIT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrIT)) DEALLOCATE(OutData%TwrIT)
    ALLOCATE(OutData%TwrIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrIT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrIT,1), UBOUND(OutData%TwrIT,1)
        OutData%TwrIT(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TwrAT not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TwrAT)) DEALLOCATE(OutData%TwrAT)
    ALLOCATE(OutData%TwrAT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrAT.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%TwrAT,1), UBOUND(OutData%TwrAT,1)
        OutData%TwrAT(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL BEMT_UnpackParam( Re_Buf, Db_Buf, Int_Buf, OutData%BEMT, ErrStat2, ErrMsg2 ) ! BEMT 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AA_UnpackParam( Re_Buf, Db_Buf, Int_Buf, OutData%AA, ErrStat2, ErrMsg2 ) ! AA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Jac_u_indx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Jac_u_indx)) DEALLOCATE(OutData%Jac_u_indx)
    ALLOCATE(OutData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Jac_u_indx,2), UBOUND(OutData%Jac_u_indx,2)
        DO i1 = LBOUND(OutData%Jac_u_indx,1), UBOUND(OutData%Jac_u_indx,1)
          OutData%Jac_u_indx(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! du not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%du)) DEALLOCATE(OutData%du)
    ALLOCATE(OutData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%du,1), UBOUND(OutData%du,1)
        OutData%du(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dx)) DEALLOCATE(OutData%dx)
    ALLOCATE(OutData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%dx,1), UBOUND(OutData%dx,1)
        OutData%dx(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%Jac_ny = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumBl_Lin = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrPotent = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrShadow = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrAero = TRANSFER(IntKiBuf(Int_Xferred), OutData%TwrAero)
    Int_Xferred = Int_Xferred + 1
    OutData%FrozenWake = TRANSFER(IntKiBuf(Int_Xferred), OutData%FrozenWake)
    Int_Xferred = Int_Xferred + 1
    OutData%CavitCheck = TRANSFER(IntKiBuf(Int_Xferred), OutData%CavitCheck)
    Int_Xferred = Int_Xferred + 1
    OutData%MHK = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CompAA = TRANSFER(IntKiBuf(Int_Xferred), OutData%CompAA)
    Int_Xferred = Int_Xferred + 1
    OutData%AirDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%KinVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SpdSound = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Gravity = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Patm = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Pvap = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDpth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MSL2SWL = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AeroProjMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%AeroBEM_Mod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%RootName)
      OutData%RootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OutParam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OutParam)) DEALLOCATE(OutData%OutParam)
    ALLOCATE(OutData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackoutparmtype( Re_Buf, Db_Buf, Int_Buf, OutData%OutParam(i1), ErrStat2, ErrMsg2 ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NBlOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%BlOutNd,1)
    i1_u = UBOUND(OutData%BlOutNd,1)
    DO i1 = LBOUND(OutData%BlOutNd,1), UBOUND(OutData%BlOutNd,1)
      OutData%BlOutNd(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%NTwOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%TwOutNd,1)
    i1_u = UBOUND(OutData%TwOutNd,1)
    DO i1 = LBOUND(OutData%TwOutNd,1), UBOUND(OutData%TwOutNd,1)
      OutData%TwOutNd(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%BldNd_NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%BldNd_TotNumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BldNd_OutParam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BldNd_OutParam)) DEALLOCATE(OutData%BldNd_OutParam)
    ALLOCATE(OutData%BldNd_OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutParam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BldNd_OutParam,1), UBOUND(OutData%BldNd_OutParam,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackoutparmtype( Re_Buf, Db_Buf, Int_Buf, OutData%BldNd_OutParam(i1), ErrStat2, ErrMsg2 ) ! BldNd_OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BldNd_BlOutNd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BldNd_BlOutNd)) DEALLOCATE(OutData%BldNd_BlOutNd)
    ALLOCATE(OutData%BldNd_BlOutNd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_BlOutNd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BldNd_BlOutNd,1), UBOUND(OutData%BldNd_BlOutNd,1)
        OutData%BldNd_BlOutNd(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    OutData%BldNd_BladesOut = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TFinAero = TRANSFER(IntKiBuf(Int_Xferred), OutData%TFinAero)
    Int_Xferred = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL AD_Unpacktfinparametertype( Re_Buf, Db_Buf, Int_Buf, OutData%TFin, ErrStat2, ErrMsg2 ) ! TFin 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE AD_UnPackRotParameterType

 SUBROUTINE AD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyParam'
! 
=======
   ErrMsg  = ''
   DstInputFileData%Echo = SrcInputFileData%Echo
   DstInputFileData%DTAero = SrcInputFileData%DTAero
   DstInputFileData%WakeMod = SrcInputFileData%WakeMod
   DstInputFileData%AFAeroMod = SrcInputFileData%AFAeroMod
   DstInputFileData%TwrPotent = SrcInputFileData%TwrPotent
   DstInputFileData%TwrShadow = SrcInputFileData%TwrShadow
   DstInputFileData%TwrAero = SrcInputFileData%TwrAero
   DstInputFileData%FrozenWake = SrcInputFileData%FrozenWake
   DstInputFileData%CavitCheck = SrcInputFileData%CavitCheck
   DstInputFileData%Buoyancy = SrcInputFileData%Buoyancy
   DstInputFileData%CompAA = SrcInputFileData%CompAA
   DstInputFileData%AA_InputFile = SrcInputFileData%AA_InputFile
   if (allocated(SrcInputFileData%ADBlFile)) then
      LB(1:1) = lbound(SrcInputFileData%ADBlFile)
      UB(1:1) = ubound(SrcInputFileData%ADBlFile)
      if (.not. allocated(DstInputFileData%ADBlFile)) then
         allocate(DstInputFileData%ADBlFile(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%ADBlFile.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputFileData%ADBlFile = SrcInputFileData%ADBlFile
   end if
   DstInputFileData%AirDens = SrcInputFileData%AirDens
   DstInputFileData%KinVisc = SrcInputFileData%KinVisc
   DstInputFileData%Patm = SrcInputFileData%Patm
   DstInputFileData%Pvap = SrcInputFileData%Pvap
   DstInputFileData%SpdSound = SrcInputFileData%SpdSound
   DstInputFileData%SkewMod = SrcInputFileData%SkewMod
   DstInputFileData%SkewModFactor = SrcInputFileData%SkewModFactor
   DstInputFileData%TipLoss = SrcInputFileData%TipLoss
   DstInputFileData%HubLoss = SrcInputFileData%HubLoss
   DstInputFileData%TanInd = SrcInputFileData%TanInd
   DstInputFileData%AIDrag = SrcInputFileData%AIDrag
   DstInputFileData%TIDrag = SrcInputFileData%TIDrag
   DstInputFileData%IndToler = SrcInputFileData%IndToler
   DstInputFileData%MaxIter = SrcInputFileData%MaxIter
   DstInputFileData%UAMod = SrcInputFileData%UAMod
   DstInputFileData%FLookup = SrcInputFileData%FLookup
   DstInputFileData%InCol_Alfa = SrcInputFileData%InCol_Alfa
   DstInputFileData%InCol_Cl = SrcInputFileData%InCol_Cl
   DstInputFileData%InCol_Cd = SrcInputFileData%InCol_Cd
   DstInputFileData%InCol_Cm = SrcInputFileData%InCol_Cm
   DstInputFileData%InCol_Cpmin = SrcInputFileData%InCol_Cpmin
   DstInputFileData%AFTabMod = SrcInputFileData%AFTabMod
   DstInputFileData%NumAFfiles = SrcInputFileData%NumAFfiles
   DstInputFileData%FVWFileName = SrcInputFileData%FVWFileName
   if (allocated(SrcInputFileData%AFNames)) then
      LB(1:1) = lbound(SrcInputFileData%AFNames)
      UB(1:1) = ubound(SrcInputFileData%AFNames)
      if (.not. allocated(DstInputFileData%AFNames)) then
         allocate(DstInputFileData%AFNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AFNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputFileData%AFNames = SrcInputFileData%AFNames
   end if
   DstInputFileData%UseBlCm = SrcInputFileData%UseBlCm
   DstInputFileData%SumPrint = SrcInputFileData%SumPrint
   DstInputFileData%NBlOuts = SrcInputFileData%NBlOuts
   DstInputFileData%BlOutNd = SrcInputFileData%BlOutNd
   DstInputFileData%NTwOuts = SrcInputFileData%NTwOuts
   DstInputFileData%TwOutNd = SrcInputFileData%TwOutNd
   DstInputFileData%NumOuts = SrcInputFileData%NumOuts
   if (allocated(SrcInputFileData%OutList)) then
      LB(1:1) = lbound(SrcInputFileData%OutList)
      UB(1:1) = ubound(SrcInputFileData%OutList)
      if (.not. allocated(DstInputFileData%OutList)) then
         allocate(DstInputFileData%OutList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputFileData%OutList = SrcInputFileData%OutList
   end if
   DstInputFileData%tau1_const = SrcInputFileData%tau1_const
   DstInputFileData%DBEMT_Mod = SrcInputFileData%DBEMT_Mod
   DstInputFileData%BldNd_NumOuts = SrcInputFileData%BldNd_NumOuts
   if (allocated(SrcInputFileData%BldNd_OutList)) then
      LB(1:1) = lbound(SrcInputFileData%BldNd_OutList)
      UB(1:1) = ubound(SrcInputFileData%BldNd_OutList)
      if (.not. allocated(DstInputFileData%BldNd_OutList)) then
         allocate(DstInputFileData%BldNd_OutList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BldNd_OutList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputFileData%BldNd_OutList = SrcInputFileData%BldNd_OutList
   end if
   DstInputFileData%BldNd_BlOutNd_Str = SrcInputFileData%BldNd_BlOutNd_Str
   DstInputFileData%BldNd_BladesOut = SrcInputFileData%BldNd_BladesOut
   DstInputFileData%UAStartRad = SrcInputFileData%UAStartRad
   DstInputFileData%UAEndRad = SrcInputFileData%UAEndRad
   if (allocated(SrcInputFileData%rotors)) then
      LB(1:1) = lbound(SrcInputFileData%rotors)
      UB(1:1) = ubound(SrcInputFileData%rotors)
      if (.not. allocated(DstInputFileData%rotors)) then
         allocate(DstInputFileData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotInputFile(SrcInputFileData%rotors(i1), DstInputFileData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine AD_DestroyInputFile(InputFileData, ErrStat, ErrMsg)
   type(AD_InputFile), intent(inout) :: InputFileData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyInputFile'
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputFileData%ADBlFile)) then
      deallocate(InputFileData%ADBlFile)
   end if
   if (allocated(InputFileData%AFNames)) then
      deallocate(InputFileData%AFNames)
   end if
   if (allocated(InputFileData%OutList)) then
      deallocate(InputFileData%OutList)
   end if
   if (allocated(InputFileData%BldNd_OutList)) then
      deallocate(InputFileData%BldNd_OutList)
   end if
   if (allocated(InputFileData%rotors)) then
      LB(1:1) = lbound(InputFileData%rotors)
      UB(1:1) = ubound(InputFileData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotInputFile(InputFileData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InputFileData%rotors)
   end if
end subroutine

subroutine AD_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Echo)
   call RegPack(Buf, InData%DTAero)
   call RegPack(Buf, InData%WakeMod)
   call RegPack(Buf, InData%AFAeroMod)
   call RegPack(Buf, InData%TwrPotent)
   call RegPack(Buf, InData%TwrShadow)
   call RegPack(Buf, InData%TwrAero)
   call RegPack(Buf, InData%FrozenWake)
   call RegPack(Buf, InData%CavitCheck)
   call RegPack(Buf, InData%Buoyancy)
   call RegPack(Buf, InData%CompAA)
   call RegPack(Buf, InData%AA_InputFile)
   call RegPack(Buf, allocated(InData%ADBlFile))
   if (allocated(InData%ADBlFile)) then
      call RegPackBounds(Buf, 1, lbound(InData%ADBlFile), ubound(InData%ADBlFile))
      call RegPack(Buf, InData%ADBlFile)
   end if
   call RegPack(Buf, InData%AirDens)
   call RegPack(Buf, InData%KinVisc)
   call RegPack(Buf, InData%Patm)
   call RegPack(Buf, InData%Pvap)
   call RegPack(Buf, InData%SpdSound)
   call RegPack(Buf, InData%SkewMod)
   call RegPack(Buf, InData%SkewModFactor)
   call RegPack(Buf, InData%TipLoss)
   call RegPack(Buf, InData%HubLoss)
   call RegPack(Buf, InData%TanInd)
   call RegPack(Buf, InData%AIDrag)
   call RegPack(Buf, InData%TIDrag)
   call RegPack(Buf, InData%IndToler)
   call RegPack(Buf, InData%MaxIter)
   call RegPack(Buf, InData%UAMod)
   call RegPack(Buf, InData%FLookup)
   call RegPack(Buf, InData%InCol_Alfa)
   call RegPack(Buf, InData%InCol_Cl)
   call RegPack(Buf, InData%InCol_Cd)
   call RegPack(Buf, InData%InCol_Cm)
   call RegPack(Buf, InData%InCol_Cpmin)
   call RegPack(Buf, InData%AFTabMod)
   call RegPack(Buf, InData%NumAFfiles)
   call RegPack(Buf, InData%FVWFileName)
   call RegPack(Buf, allocated(InData%AFNames))
   if (allocated(InData%AFNames)) then
      call RegPackBounds(Buf, 1, lbound(InData%AFNames), ubound(InData%AFNames))
      call RegPack(Buf, InData%AFNames)
   end if
   call RegPack(Buf, InData%UseBlCm)
   call RegPack(Buf, InData%SumPrint)
   call RegPack(Buf, InData%NBlOuts)
   call RegPack(Buf, InData%BlOutNd)
   call RegPack(Buf, InData%NTwOuts)
   call RegPack(Buf, InData%TwOutNd)
   call RegPack(Buf, InData%NumOuts)
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   call RegPack(Buf, InData%tau1_const)
   call RegPack(Buf, InData%DBEMT_Mod)
   call RegPack(Buf, InData%BldNd_NumOuts)
   call RegPack(Buf, allocated(InData%BldNd_OutList))
   if (allocated(InData%BldNd_OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_OutList), ubound(InData%BldNd_OutList))
      call RegPack(Buf, InData%BldNd_OutList)
   end if
   call RegPack(Buf, InData%BldNd_BlOutNd_Str)
   call RegPack(Buf, InData%BldNd_BladesOut)
   call RegPack(Buf, InData%UAStartRad)
   call RegPack(Buf, InData%UAEndRad)
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInputFile(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DTAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AFAeroMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AA_InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%ADBlFile)) deallocate(OutData%ADBlFile)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADBlFile(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADBlFile.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADBlFile)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SkewModFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TanInd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%IndToler)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FLookup)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InCol_Alfa)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InCol_Cl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InCol_Cd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InCol_Cm)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InCol_Cpmin)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AFTabMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumAFfiles)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FVWFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%AFNames)) deallocate(OutData%AFNames)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFNames(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFNames.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFNames)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%UseBlCm)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%tau1_const)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DBEMT_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%BldNd_OutList)) deallocate(OutData%BldNd_OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BldNd_OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%BldNd_BlOutNd_Str)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UAStartRad)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UAEndRad)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInputFile(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
end subroutine

subroutine AD_CopyRotContinuousStateType(SrcRotContinuousStateTypeData, DstRotContinuousStateTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotContinuousStateType), intent(in) :: SrcRotContinuousStateTypeData
   type(RotContinuousStateType), intent(inout) :: DstRotContinuousStateTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotContinuousStateType'
   ErrStat = ErrID_None
<<<<<<< HEAD
   ErrMsg  = ""
      CALL MeshCopy( SrcRotInputTypeData%NacelleMotion, DstRotInputTypeData%NacelleMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotInputTypeData%TowerMotion, DstRotInputTypeData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotInputTypeData%HubMotion, DstRotInputTypeData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotInputTypeData%BladeRootMotion)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%BladeRootMotion,1)
  i1_u = UBOUND(SrcRotInputTypeData%BladeRootMotion,1)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%BladeRootMotion)) THEN 
    ALLOCATE(DstRotInputTypeData%BladeRootMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeRootMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputTypeData%BladeRootMotion,1), UBOUND(SrcRotInputTypeData%BladeRootMotion,1)
      CALL MeshCopy( SrcRotInputTypeData%BladeRootMotion(i1), DstRotInputTypeData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%BladeMotion)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%BladeMotion,1)
  i1_u = UBOUND(SrcRotInputTypeData%BladeMotion,1)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%BladeMotion)) THEN 
    ALLOCATE(DstRotInputTypeData%BladeMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputTypeData%BladeMotion,1), UBOUND(SrcRotInputTypeData%BladeMotion,1)
      CALL MeshCopy( SrcRotInputTypeData%BladeMotion(i1), DstRotInputTypeData%BladeMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcRotInputTypeData%TFinMotion, DstRotInputTypeData%TFinMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotInputTypeData%InflowOnBlade)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,1)
  i1_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,1)
  i2_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,2)
  i2_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,2)
  i3_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,3)
  i3_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,3)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%InflowOnBlade)) THEN 
    ALLOCATE(DstRotInputTypeData%InflowOnBlade(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%InflowOnBlade.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%InflowOnBlade = SrcRotInputTypeData%InflowOnBlade
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%InflowOnTower)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%InflowOnTower,1)
  i1_u = UBOUND(SrcRotInputTypeData%InflowOnTower,1)
  i2_l = LBOUND(SrcRotInputTypeData%InflowOnTower,2)
  i2_u = UBOUND(SrcRotInputTypeData%InflowOnTower,2)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%InflowOnTower)) THEN 
    ALLOCATE(DstRotInputTypeData%InflowOnTower(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%InflowOnTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%InflowOnTower = SrcRotInputTypeData%InflowOnTower
ENDIF
    DstRotInputTypeData%InflowOnHub = SrcRotInputTypeData%InflowOnHub
    DstRotInputTypeData%InflowOnNacelle = SrcRotInputTypeData%InflowOnNacelle
    DstRotInputTypeData%InflowOnTailFin = SrcRotInputTypeData%InflowOnTailFin
IF (ALLOCATED(SrcRotInputTypeData%AccelOnBlade)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%AccelOnBlade,1)
  i1_u = UBOUND(SrcRotInputTypeData%AccelOnBlade,1)
  i2_l = LBOUND(SrcRotInputTypeData%AccelOnBlade,2)
  i2_u = UBOUND(SrcRotInputTypeData%AccelOnBlade,2)
  i3_l = LBOUND(SrcRotInputTypeData%AccelOnBlade,3)
  i3_u = UBOUND(SrcRotInputTypeData%AccelOnBlade,3)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%AccelOnBlade)) THEN 
    ALLOCATE(DstRotInputTypeData%AccelOnBlade(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%AccelOnBlade.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%AccelOnBlade = SrcRotInputTypeData%AccelOnBlade
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%AccelOnTower)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%AccelOnTower,1)
  i1_u = UBOUND(SrcRotInputTypeData%AccelOnTower,1)
  i2_l = LBOUND(SrcRotInputTypeData%AccelOnTower,2)
  i2_u = UBOUND(SrcRotInputTypeData%AccelOnTower,2)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%AccelOnTower)) THEN 
    ALLOCATE(DstRotInputTypeData%AccelOnTower(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%AccelOnTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%AccelOnTower = SrcRotInputTypeData%AccelOnTower
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%UserProp)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%UserProp,1)
  i1_u = UBOUND(SrcRotInputTypeData%UserProp,1)
  i2_l = LBOUND(SrcRotInputTypeData%UserProp,2)
  i2_u = UBOUND(SrcRotInputTypeData%UserProp,2)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%UserProp)) THEN 
    ALLOCATE(DstRotInputTypeData%UserProp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%UserProp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%UserProp = SrcRotInputTypeData%UserProp
ENDIF
 END SUBROUTINE AD_CopyRotInputType

 SUBROUTINE AD_DestroyRotInputType( RotInputTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(RotInputType), INTENT(INOUT) :: RotInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
  CALL MeshDestroy( RotInputTypeData%NacelleMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotInputTypeData%TowerMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotInputTypeData%HubMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotInputTypeData%BladeRootMotion)) THEN
DO i1 = LBOUND(RotInputTypeData%BladeRootMotion,1), UBOUND(RotInputTypeData%BladeRootMotion,1)
  CALL MeshDestroy( RotInputTypeData%BladeRootMotion(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputTypeData%BladeRootMotion)
ENDIF
IF (ALLOCATED(RotInputTypeData%BladeMotion)) THEN
DO i1 = LBOUND(RotInputTypeData%BladeMotion,1), UBOUND(RotInputTypeData%BladeMotion,1)
  CALL MeshDestroy( RotInputTypeData%BladeMotion(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputTypeData%BladeMotion)
ENDIF
  CALL MeshDestroy( RotInputTypeData%TFinMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotInputTypeData%InflowOnBlade)) THEN
  DEALLOCATE(RotInputTypeData%InflowOnBlade)
ENDIF
IF (ALLOCATED(RotInputTypeData%InflowOnTower)) THEN
  DEALLOCATE(RotInputTypeData%InflowOnTower)
ENDIF
IF (ALLOCATED(RotInputTypeData%AccelOnBlade)) THEN
  DEALLOCATE(RotInputTypeData%AccelOnBlade)
ENDIF
IF (ALLOCATED(RotInputTypeData%AccelOnTower)) THEN
  DEALLOCATE(RotInputTypeData%AccelOnTower)
ENDIF
IF (ALLOCATED(RotInputTypeData%UserProp)) THEN
  DEALLOCATE(RotInputTypeData%UserProp)
ENDIF
 END SUBROUTINE AD_DestroyRotInputType

 SUBROUTINE AD_PackRotInputType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RotInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_PackRotInputType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! NacelleMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! NacelleMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! NacelleMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! NacelleMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! TowerMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%TowerMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! TowerMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TowerMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TowerMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TowerMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! HubMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! HubMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! HubMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! HubMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeRootMotion allocated yes/no
  IF ( ALLOCATED(InData%BladeRootMotion) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeRootMotion upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeRootMotion,1), UBOUND(InData%BladeRootMotion,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeRootMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeRootMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeRootMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeRootMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeRootMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeRootMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeMotion allocated yes/no
  IF ( ALLOCATED(InData%BladeMotion) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeMotion upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeMotion,1), UBOUND(InData%BladeMotion,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! TFinMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%TFinMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! TFinMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! TFinMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! TFinMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! TFinMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! InflowOnBlade allocated yes/no
  IF ( ALLOCATED(InData%InflowOnBlade) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! InflowOnBlade upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowOnBlade)  ! InflowOnBlade
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! InflowOnTower allocated yes/no
  IF ( ALLOCATED(InData%InflowOnTower) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! InflowOnTower upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowOnTower)  ! InflowOnTower
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowOnHub)  ! InflowOnHub
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowOnNacelle)  ! InflowOnNacelle
      Re_BufSz   = Re_BufSz   + SIZE(InData%InflowOnTailFin)  ! InflowOnTailFin
  Int_BufSz   = Int_BufSz   + 1     ! AccelOnBlade allocated yes/no
  IF ( ALLOCATED(InData%AccelOnBlade) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! AccelOnBlade upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AccelOnBlade)  ! AccelOnBlade
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AccelOnTower allocated yes/no
  IF ( ALLOCATED(InData%AccelOnTower) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AccelOnTower upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AccelOnTower)  ! AccelOnTower
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! UserProp allocated yes/no
  IF ( ALLOCATED(InData%UserProp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! UserProp upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%UserProp)  ! UserProp
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL MeshPack( InData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%TowerMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! TowerMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%BladeRootMotion) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeRootMotion,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeRootMotion,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeRootMotion,1), UBOUND(InData%BladeRootMotion,1)
      CALL MeshPack( InData%BladeRootMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeRootMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BladeMotion) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeMotion,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeMotion,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeMotion,1), UBOUND(InData%BladeMotion,1)
      CALL MeshPack( InData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL MeshPack( InData%TFinMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! TFinMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%InflowOnBlade) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowOnBlade,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowOnBlade,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowOnBlade,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowOnBlade,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowOnBlade,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowOnBlade,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%InflowOnBlade,3), UBOUND(InData%InflowOnBlade,3)
        DO i2 = LBOUND(InData%InflowOnBlade,2), UBOUND(InData%InflowOnBlade,2)
          DO i1 = LBOUND(InData%InflowOnBlade,1), UBOUND(InData%InflowOnBlade,1)
            ReKiBuf(Re_Xferred) = InData%InflowOnBlade(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%InflowOnTower) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowOnTower,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowOnTower,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InflowOnTower,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InflowOnTower,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%InflowOnTower,2), UBOUND(InData%InflowOnTower,2)
        DO i1 = LBOUND(InData%InflowOnTower,1), UBOUND(InData%InflowOnTower,1)
          ReKiBuf(Re_Xferred) = InData%InflowOnTower(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    DO i1 = LBOUND(InData%InflowOnHub,1), UBOUND(InData%InflowOnHub,1)
      ReKiBuf(Re_Xferred) = InData%InflowOnHub(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%InflowOnNacelle,1), UBOUND(InData%InflowOnNacelle,1)
      ReKiBuf(Re_Xferred) = InData%InflowOnNacelle(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%InflowOnTailFin,1), UBOUND(InData%InflowOnTailFin,1)
      ReKiBuf(Re_Xferred) = InData%InflowOnTailFin(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
  IF ( .NOT. ALLOCATED(InData%AccelOnBlade) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccelOnBlade,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccelOnBlade,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccelOnBlade,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccelOnBlade,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccelOnBlade,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccelOnBlade,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%AccelOnBlade,3), UBOUND(InData%AccelOnBlade,3)
        DO i2 = LBOUND(InData%AccelOnBlade,2), UBOUND(InData%AccelOnBlade,2)
          DO i1 = LBOUND(InData%AccelOnBlade,1), UBOUND(InData%AccelOnBlade,1)
            ReKiBuf(Re_Xferred) = InData%AccelOnBlade(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AccelOnTower) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccelOnTower,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccelOnTower,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccelOnTower,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccelOnTower,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%AccelOnTower,2), UBOUND(InData%AccelOnTower,2)
        DO i1 = LBOUND(InData%AccelOnTower,1), UBOUND(InData%AccelOnTower,1)
          ReKiBuf(Re_Xferred) = InData%AccelOnTower(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%UserProp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%UserProp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%UserProp,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%UserProp,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%UserProp,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%UserProp,2), UBOUND(InData%UserProp,2)
        DO i1 = LBOUND(InData%UserProp,1), UBOUND(InData%UserProp,1)
          ReKiBuf(Re_Xferred) = InData%UserProp(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE AD_PackRotInputType

 SUBROUTINE AD_UnPackRotInputType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RotInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'AD_UnPackRotInputType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%TowerMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! TowerMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeRootMotion not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeRootMotion)) DEALLOCATE(OutData%BladeRootMotion)
    ALLOCATE(OutData%BladeRootMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeRootMotion,1), UBOUND(OutData%BladeRootMotion,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeRootMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeRootMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeMotion not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeMotion)) DEALLOCATE(OutData%BladeMotion)
    ALLOCATE(OutData%BladeMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeMotion.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeMotion,1), UBOUND(OutData%BladeMotion,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%TFinMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! TFinMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InflowOnBlade not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InflowOnBlade)) DEALLOCATE(OutData%InflowOnBlade)
    ALLOCATE(OutData%InflowOnBlade(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnBlade.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%InflowOnBlade,3), UBOUND(OutData%InflowOnBlade,3)
        DO i2 = LBOUND(OutData%InflowOnBlade,2), UBOUND(OutData%InflowOnBlade,2)
          DO i1 = LBOUND(OutData%InflowOnBlade,1), UBOUND(OutData%InflowOnBlade,1)
            OutData%InflowOnBlade(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InflowOnTower not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InflowOnTower)) DEALLOCATE(OutData%InflowOnTower)
    ALLOCATE(OutData%InflowOnTower(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnTower.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%InflowOnTower,2), UBOUND(OutData%InflowOnTower,2)
        DO i1 = LBOUND(OutData%InflowOnTower,1), UBOUND(OutData%InflowOnTower,1)
          OutData%InflowOnTower(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%InflowOnHub,1)
    i1_u = UBOUND(OutData%InflowOnHub,1)
    DO i1 = LBOUND(OutData%InflowOnHub,1), UBOUND(OutData%InflowOnHub,1)
      OutData%InflowOnHub(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%InflowOnNacelle,1)
    i1_u = UBOUND(OutData%InflowOnNacelle,1)
    DO i1 = LBOUND(OutData%InflowOnNacelle,1), UBOUND(OutData%InflowOnNacelle,1)
      OutData%InflowOnNacelle(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%InflowOnTailFin,1)
    i1_u = UBOUND(OutData%InflowOnTailFin,1)
    DO i1 = LBOUND(OutData%InflowOnTailFin,1), UBOUND(OutData%InflowOnTailFin,1)
      OutData%InflowOnTailFin(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AccelOnBlade not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AccelOnBlade)) DEALLOCATE(OutData%AccelOnBlade)
    ALLOCATE(OutData%AccelOnBlade(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccelOnBlade.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%AccelOnBlade,3), UBOUND(OutData%AccelOnBlade,3)
        DO i2 = LBOUND(OutData%AccelOnBlade,2), UBOUND(OutData%AccelOnBlade,2)
          DO i1 = LBOUND(OutData%AccelOnBlade,1), UBOUND(OutData%AccelOnBlade,1)
            OutData%AccelOnBlade(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AccelOnTower not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AccelOnTower)) DEALLOCATE(OutData%AccelOnTower)
    ALLOCATE(OutData%AccelOnTower(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccelOnTower.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%AccelOnTower,2), UBOUND(OutData%AccelOnTower,2)
        DO i1 = LBOUND(OutData%AccelOnTower,1), UBOUND(OutData%AccelOnTower,1)
          OutData%AccelOnTower(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! UserProp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%UserProp)) DEALLOCATE(OutData%UserProp)
    ALLOCATE(OutData%UserProp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%UserProp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%UserProp,2), UBOUND(OutData%UserProp,2)
        DO i1 = LBOUND(OutData%UserProp,1), UBOUND(OutData%UserProp,1)
          OutData%UserProp(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE AD_UnPackRotInputType

 SUBROUTINE AD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(AD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInput'
! 
=======
   ErrMsg  = ''
   call BEMT_CopyContState(SrcRotContinuousStateTypeData%BEMT, DstRotContinuousStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyContState(SrcRotContinuousStateTypeData%AA, DstRotContinuousStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotContinuousStateType(RotContinuousStateTypeData, ErrStat, ErrMsg)
   type(RotContinuousStateType), intent(inout) :: RotContinuousStateTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotContinuousStateType'
>>>>>>> luwang00/f/IfW_SeaSt_Coupling
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_DestroyContState(RotContinuousStateTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyContState(RotContinuousStateTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotContinuousStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotContinuousStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   call BEMT_PackContState(Buf, InData%BEMT) 
   call AA_PackContState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotContinuousStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotContinuousStateType'
   if (Buf%ErrStat /= ErrID_None) return
   call BEMT_UnpackContState(Buf, OutData%BEMT) ! BEMT 
   call AA_UnpackContState(Buf, OutData%AA) ! AA 
end subroutine

subroutine AD_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD_ContinuousStateType), intent(in) :: SrcContStateData
   type(AD_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcContStateData%rotors)) then
      LB(1:1) = lbound(SrcContStateData%rotors)
      UB(1:1) = ubound(SrcContStateData%rotors)
      if (.not. allocated(DstContStateData%rotors)) then
         allocate(DstContStateData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotContinuousStateType(SrcContStateData%rotors(i1), DstContStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FVW_CopyContState(SrcContStateData%FVW, DstContStateData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(AD_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ContStateData%rotors)) then
      LB(1:1) = lbound(ContStateData%rotors)
      UB(1:1) = ubound(ContStateData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotContinuousStateType(ContStateData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ContStateData%rotors)
   end if
   call FVW_DestroyContState(ContStateData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotContinuousStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   call FVW_PackContState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotContinuousStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call FVW_UnpackContState(Buf, OutData%FVW) ! FVW 
end subroutine

subroutine AD_CopyRotDiscreteStateType(SrcRotDiscreteStateTypeData, DstRotDiscreteStateTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotDiscreteStateType), intent(in) :: SrcRotDiscreteStateTypeData
   type(RotDiscreteStateType), intent(inout) :: DstRotDiscreteStateTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotDiscreteStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_CopyDiscState(SrcRotDiscreteStateTypeData%BEMT, DstRotDiscreteStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyDiscState(SrcRotDiscreteStateTypeData%AA, DstRotDiscreteStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotDiscreteStateType(RotDiscreteStateTypeData, ErrStat, ErrMsg)
   type(RotDiscreteStateType), intent(inout) :: RotDiscreteStateTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotDiscreteStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_DestroyDiscState(RotDiscreteStateTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyDiscState(RotDiscreteStateTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotDiscreteStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotDiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotDiscreteStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   call BEMT_PackDiscState(Buf, InData%BEMT) 
   call AA_PackDiscState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotDiscreteStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotDiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotDiscreteStateType'
   if (Buf%ErrStat /= ErrID_None) return
   call BEMT_UnpackDiscState(Buf, OutData%BEMT) ! BEMT 
   call AA_UnpackDiscState(Buf, OutData%AA) ! AA 
end subroutine

subroutine AD_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(AD_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcDiscStateData%rotors)) then
      LB(1:1) = lbound(SrcDiscStateData%rotors)
      UB(1:1) = ubound(SrcDiscStateData%rotors)
      if (.not. allocated(DstDiscStateData%rotors)) then
         allocate(DstDiscStateData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotDiscreteStateType(SrcDiscStateData%rotors(i1), DstDiscStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FVW_CopyDiscState(SrcDiscStateData%FVW, DstDiscStateData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(AD_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(DiscStateData%rotors)) then
      LB(1:1) = lbound(DiscStateData%rotors)
      UB(1:1) = ubound(DiscStateData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotDiscreteStateType(DiscStateData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(DiscStateData%rotors)
   end if
   call FVW_DestroyDiscState(DiscStateData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotDiscreteStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   call FVW_PackDiscState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotDiscreteStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call FVW_UnpackDiscState(Buf, OutData%FVW) ! FVW 
end subroutine

subroutine AD_CopyRotConstraintStateType(SrcRotConstraintStateTypeData, DstRotConstraintStateTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotConstraintStateType), intent(in) :: SrcRotConstraintStateTypeData
   type(RotConstraintStateType), intent(inout) :: DstRotConstraintStateTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotConstraintStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_CopyConstrState(SrcRotConstraintStateTypeData%BEMT, DstRotConstraintStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyConstrState(SrcRotConstraintStateTypeData%AA, DstRotConstraintStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotConstraintStateType(RotConstraintStateTypeData, ErrStat, ErrMsg)
   type(RotConstraintStateType), intent(inout) :: RotConstraintStateTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotConstraintStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_DestroyConstrState(RotConstraintStateTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyConstrState(RotConstraintStateTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotConstraintStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotConstraintStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   call BEMT_PackConstrState(Buf, InData%BEMT) 
   call AA_PackConstrState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotConstraintStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotConstraintStateType'
   if (Buf%ErrStat /= ErrID_None) return
   call BEMT_UnpackConstrState(Buf, OutData%BEMT) ! BEMT 
   call AA_UnpackConstrState(Buf, OutData%AA) ! AA 
end subroutine

subroutine AD_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(AD_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcConstrStateData%rotors)) then
      LB(1:1) = lbound(SrcConstrStateData%rotors)
      UB(1:1) = ubound(SrcConstrStateData%rotors)
      if (.not. allocated(DstConstrStateData%rotors)) then
         allocate(DstConstrStateData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotConstraintStateType(SrcConstrStateData%rotors(i1), DstConstrStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FVW_CopyConstrState(SrcConstrStateData%FVW, DstConstrStateData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(AD_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ConstrStateData%rotors)) then
      LB(1:1) = lbound(ConstrStateData%rotors)
      UB(1:1) = ubound(ConstrStateData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotConstraintStateType(ConstrStateData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ConstrStateData%rotors)
   end if
   call FVW_DestroyConstrState(ConstrStateData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotConstraintStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   call FVW_PackConstrState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotConstraintStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call FVW_UnpackConstrState(Buf, OutData%FVW) ! FVW 
end subroutine

subroutine AD_CopyRotOtherStateType(SrcRotOtherStateTypeData, DstRotOtherStateTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotOtherStateType), intent(in) :: SrcRotOtherStateTypeData
   type(RotOtherStateType), intent(inout) :: DstRotOtherStateTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotOtherStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_CopyOtherState(SrcRotOtherStateTypeData%BEMT, DstRotOtherStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyOtherState(SrcRotOtherStateTypeData%AA, DstRotOtherStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotOtherStateType(RotOtherStateTypeData, ErrStat, ErrMsg)
   type(RotOtherStateType), intent(inout) :: RotOtherStateTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotOtherStateType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_DestroyOtherState(RotOtherStateTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyOtherState(RotOtherStateTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotOtherStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotOtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotOtherStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   call BEMT_PackOtherState(Buf, InData%BEMT) 
   call AA_PackOtherState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotOtherStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotOtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotOtherStateType'
   if (Buf%ErrStat /= ErrID_None) return
   call BEMT_UnpackOtherState(Buf, OutData%BEMT) ! BEMT 
   call AA_UnpackOtherState(Buf, OutData%AA) ! AA 
end subroutine

subroutine AD_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(AD_OtherStateType), intent(in) :: SrcOtherStateData
   type(AD_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOtherStateData%rotors)) then
      LB(1:1) = lbound(SrcOtherStateData%rotors)
      UB(1:1) = ubound(SrcOtherStateData%rotors)
      if (.not. allocated(DstOtherStateData%rotors)) then
         allocate(DstOtherStateData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotOtherStateType(SrcOtherStateData%rotors(i1), DstOtherStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FVW_CopyOtherState(SrcOtherStateData%FVW, DstOtherStateData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcOtherStateData%WakeLocationPoints)) then
      LB(1:2) = lbound(SrcOtherStateData%WakeLocationPoints)
      UB(1:2) = ubound(SrcOtherStateData%WakeLocationPoints)
      if (.not. allocated(DstOtherStateData%WakeLocationPoints)) then
         allocate(DstOtherStateData%WakeLocationPoints(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%WakeLocationPoints.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%WakeLocationPoints = SrcOtherStateData%WakeLocationPoints
   end if
end subroutine

subroutine AD_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(AD_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OtherStateData%rotors)) then
      LB(1:1) = lbound(OtherStateData%rotors)
      UB(1:1) = ubound(OtherStateData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotOtherStateType(OtherStateData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OtherStateData%rotors)
   end if
   call FVW_DestroyOtherState(OtherStateData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(OtherStateData%WakeLocationPoints)) then
      deallocate(OtherStateData%WakeLocationPoints)
   end if
end subroutine

subroutine AD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotOtherStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   call FVW_PackOtherState(Buf, InData%FVW) 
   call RegPack(Buf, allocated(InData%WakeLocationPoints))
   if (allocated(InData%WakeLocationPoints)) then
      call RegPackBounds(Buf, 2, lbound(InData%WakeLocationPoints), ubound(InData%WakeLocationPoints))
      call RegPack(Buf, InData%WakeLocationPoints)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotOtherStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call FVW_UnpackOtherState(Buf, OutData%FVW) ! FVW 
   if (allocated(OutData%WakeLocationPoints)) deallocate(OutData%WakeLocationPoints)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WakeLocationPoints(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WakeLocationPoints.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WakeLocationPoints)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotMiscVarType(SrcRotMiscVarTypeData, DstRotMiscVarTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotMiscVarType), intent(inout) :: SrcRotMiscVarTypeData
   type(RotMiscVarType), intent(inout) :: DstRotMiscVarTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)                 :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotMiscVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_CopyMisc(SrcRotMiscVarTypeData%BEMT, DstRotMiscVarTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call BEMT_CopyOutput(SrcRotMiscVarTypeData%BEMT_y, DstRotMiscVarTypeData%BEMT_y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   LB(1:1) = lbound(SrcRotMiscVarTypeData%BEMT_u)
   UB(1:1) = ubound(SrcRotMiscVarTypeData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_CopyInput(SrcRotMiscVarTypeData%BEMT_u(i1), DstRotMiscVarTypeData%BEMT_u(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   call AA_CopyMisc(SrcRotMiscVarTypeData%AA, DstRotMiscVarTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyOutput(SrcRotMiscVarTypeData%AA_y, DstRotMiscVarTypeData%AA_y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyInput(SrcRotMiscVarTypeData%AA_u, DstRotMiscVarTypeData%AA_u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotMiscVarTypeData%DisturbedInflow)) then
      LB(1:3) = lbound(SrcRotMiscVarTypeData%DisturbedInflow)
      UB(1:3) = ubound(SrcRotMiscVarTypeData%DisturbedInflow)
      if (.not. allocated(DstRotMiscVarTypeData%DisturbedInflow)) then
         allocate(DstRotMiscVarTypeData%DisturbedInflow(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%DisturbedInflow.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%DisturbedInflow = SrcRotMiscVarTypeData%DisturbedInflow
   end if
   if (allocated(SrcRotMiscVarTypeData%orientationAnnulus)) then
      LB(1:4) = lbound(SrcRotMiscVarTypeData%orientationAnnulus)
      UB(1:4) = ubound(SrcRotMiscVarTypeData%orientationAnnulus)
      if (.not. allocated(DstRotMiscVarTypeData%orientationAnnulus)) then
         allocate(DstRotMiscVarTypeData%orientationAnnulus(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%orientationAnnulus.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%orientationAnnulus = SrcRotMiscVarTypeData%orientationAnnulus
   end if
   if (allocated(SrcRotMiscVarTypeData%AllOuts)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%AllOuts)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%AllOuts)
      if (.not. allocated(DstRotMiscVarTypeData%AllOuts)) then
         allocate(DstRotMiscVarTypeData%AllOuts(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%AllOuts.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%AllOuts = SrcRotMiscVarTypeData%AllOuts
   end if
   if (allocated(SrcRotMiscVarTypeData%W_Twr)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%W_Twr)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%W_Twr)
      if (.not. allocated(DstRotMiscVarTypeData%W_Twr)) then
         allocate(DstRotMiscVarTypeData%W_Twr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%W_Twr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%W_Twr = SrcRotMiscVarTypeData%W_Twr
   end if
   if (allocated(SrcRotMiscVarTypeData%X_Twr)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%X_Twr)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%X_Twr)
      if (.not. allocated(DstRotMiscVarTypeData%X_Twr)) then
         allocate(DstRotMiscVarTypeData%X_Twr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X_Twr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%X_Twr = SrcRotMiscVarTypeData%X_Twr
   end if
   if (allocated(SrcRotMiscVarTypeData%Y_Twr)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%Y_Twr)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%Y_Twr)
      if (.not. allocated(DstRotMiscVarTypeData%Y_Twr)) then
         allocate(DstRotMiscVarTypeData%Y_Twr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y_Twr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Y_Twr = SrcRotMiscVarTypeData%Y_Twr
   end if
   if (allocated(SrcRotMiscVarTypeData%Curve)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%Curve)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%Curve)
      if (.not. allocated(DstRotMiscVarTypeData%Curve)) then
         allocate(DstRotMiscVarTypeData%Curve(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Curve.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Curve = SrcRotMiscVarTypeData%Curve
   end if
   if (allocated(SrcRotMiscVarTypeData%TwrClrnc)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%TwrClrnc)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%TwrClrnc)
      if (.not. allocated(DstRotMiscVarTypeData%TwrClrnc)) then
         allocate(DstRotMiscVarTypeData%TwrClrnc(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrClrnc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%TwrClrnc = SrcRotMiscVarTypeData%TwrClrnc
   end if
   if (allocated(SrcRotMiscVarTypeData%X)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%X)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%X)
      if (.not. allocated(DstRotMiscVarTypeData%X)) then
         allocate(DstRotMiscVarTypeData%X(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%X = SrcRotMiscVarTypeData%X
   end if
   if (allocated(SrcRotMiscVarTypeData%Y)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%Y)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%Y)
      if (.not. allocated(DstRotMiscVarTypeData%Y)) then
         allocate(DstRotMiscVarTypeData%Y(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Y = SrcRotMiscVarTypeData%Y
   end if
   if (allocated(SrcRotMiscVarTypeData%Z)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%Z)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%Z)
      if (.not. allocated(DstRotMiscVarTypeData%Z)) then
         allocate(DstRotMiscVarTypeData%Z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Z = SrcRotMiscVarTypeData%Z
   end if
   if (allocated(SrcRotMiscVarTypeData%M)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%M)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%M)
      if (.not. allocated(DstRotMiscVarTypeData%M)) then
         allocate(DstRotMiscVarTypeData%M(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%M.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%M = SrcRotMiscVarTypeData%M
   end if
   if (allocated(SrcRotMiscVarTypeData%Mx)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%Mx)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%Mx)
      if (.not. allocated(DstRotMiscVarTypeData%Mx)) then
         allocate(DstRotMiscVarTypeData%Mx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Mx = SrcRotMiscVarTypeData%Mx
   end if
   if (allocated(SrcRotMiscVarTypeData%My)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%My)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%My)
      if (.not. allocated(DstRotMiscVarTypeData%My)) then
         allocate(DstRotMiscVarTypeData%My(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%My.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%My = SrcRotMiscVarTypeData%My
   end if
   if (allocated(SrcRotMiscVarTypeData%Mz)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%Mz)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%Mz)
      if (.not. allocated(DstRotMiscVarTypeData%Mz)) then
         allocate(DstRotMiscVarTypeData%Mz(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%Mz = SrcRotMiscVarTypeData%Mz
   end if
   DstRotMiscVarTypeData%V_DiskAvg = SrcRotMiscVarTypeData%V_DiskAvg
   DstRotMiscVarTypeData%yaw = SrcRotMiscVarTypeData%yaw
   DstRotMiscVarTypeData%tilt = SrcRotMiscVarTypeData%tilt
   if (allocated(SrcRotMiscVarTypeData%hub_theta_x_root)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%hub_theta_x_root)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%hub_theta_x_root)
      if (.not. allocated(DstRotMiscVarTypeData%hub_theta_x_root)) then
         allocate(DstRotMiscVarTypeData%hub_theta_x_root(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%hub_theta_x_root.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%hub_theta_x_root = SrcRotMiscVarTypeData%hub_theta_x_root
   end if
   DstRotMiscVarTypeData%V_dot_x = SrcRotMiscVarTypeData%V_dot_x
   call MeshCopy(SrcRotMiscVarTypeData%HubLoad, DstRotMiscVarTypeData%HubLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotMiscVarTypeData%B_L_2_H_P)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%B_L_2_H_P)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%B_L_2_H_P)
      if (.not. allocated(DstRotMiscVarTypeData%B_L_2_H_P)) then
         allocate(DstRotMiscVarTypeData%B_L_2_H_P(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_H_P.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyMeshMapType(SrcRotMiscVarTypeData%B_L_2_H_P(i1), DstRotMiscVarTypeData%B_L_2_H_P(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotMiscVarTypeData%SigmaCavitCrit)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%SigmaCavitCrit)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%SigmaCavitCrit)
      if (.not. allocated(DstRotMiscVarTypeData%SigmaCavitCrit)) then
         allocate(DstRotMiscVarTypeData%SigmaCavitCrit(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavitCrit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%SigmaCavitCrit = SrcRotMiscVarTypeData%SigmaCavitCrit
   end if
   if (allocated(SrcRotMiscVarTypeData%SigmaCavit)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%SigmaCavit)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%SigmaCavit)
      if (.not. allocated(DstRotMiscVarTypeData%SigmaCavit)) then
         allocate(DstRotMiscVarTypeData%SigmaCavit(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%SigmaCavit = SrcRotMiscVarTypeData%SigmaCavit
   end if
   if (allocated(SrcRotMiscVarTypeData%CavitWarnSet)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%CavitWarnSet)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%CavitWarnSet)
      if (.not. allocated(DstRotMiscVarTypeData%CavitWarnSet)) then
         allocate(DstRotMiscVarTypeData%CavitWarnSet(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%CavitWarnSet.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%CavitWarnSet = SrcRotMiscVarTypeData%CavitWarnSet
   end if
   if (allocated(SrcRotMiscVarTypeData%BlFB)) then
      LB(1:3) = lbound(SrcRotMiscVarTypeData%BlFB)
      UB(1:3) = ubound(SrcRotMiscVarTypeData%BlFB)
      if (.not. allocated(DstRotMiscVarTypeData%BlFB)) then
         allocate(DstRotMiscVarTypeData%BlFB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlFB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%BlFB = SrcRotMiscVarTypeData%BlFB
   end if
   if (allocated(SrcRotMiscVarTypeData%BlMB)) then
      LB(1:3) = lbound(SrcRotMiscVarTypeData%BlMB)
      UB(1:3) = ubound(SrcRotMiscVarTypeData%BlMB)
      if (.not. allocated(DstRotMiscVarTypeData%BlMB)) then
         allocate(DstRotMiscVarTypeData%BlMB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlMB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%BlMB = SrcRotMiscVarTypeData%BlMB
   end if
   if (allocated(SrcRotMiscVarTypeData%TwrFB)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%TwrFB)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%TwrFB)
      if (.not. allocated(DstRotMiscVarTypeData%TwrFB)) then
         allocate(DstRotMiscVarTypeData%TwrFB(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrFB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%TwrFB = SrcRotMiscVarTypeData%TwrFB
   end if
   if (allocated(SrcRotMiscVarTypeData%TwrMB)) then
      LB(1:2) = lbound(SrcRotMiscVarTypeData%TwrMB)
      UB(1:2) = ubound(SrcRotMiscVarTypeData%TwrMB)
      if (.not. allocated(DstRotMiscVarTypeData%TwrMB)) then
         allocate(DstRotMiscVarTypeData%TwrMB(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrMB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%TwrMB = SrcRotMiscVarTypeData%TwrMB
   end if
   if (allocated(SrcRotMiscVarTypeData%HubFB)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%HubFB)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%HubFB)
      if (.not. allocated(DstRotMiscVarTypeData%HubFB)) then
         allocate(DstRotMiscVarTypeData%HubFB(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubFB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%HubFB = SrcRotMiscVarTypeData%HubFB
   end if
   if (allocated(SrcRotMiscVarTypeData%HubMB)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%HubMB)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%HubMB)
      if (.not. allocated(DstRotMiscVarTypeData%HubMB)) then
         allocate(DstRotMiscVarTypeData%HubMB(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubMB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%HubMB = SrcRotMiscVarTypeData%HubMB
   end if
   if (allocated(SrcRotMiscVarTypeData%NacFB)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%NacFB)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%NacFB)
      if (.not. allocated(DstRotMiscVarTypeData%NacFB)) then
         allocate(DstRotMiscVarTypeData%NacFB(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacFB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%NacFB = SrcRotMiscVarTypeData%NacFB
   end if
   if (allocated(SrcRotMiscVarTypeData%NacMB)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%NacMB)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%NacMB)
      if (.not. allocated(DstRotMiscVarTypeData%NacMB)) then
         allocate(DstRotMiscVarTypeData%NacMB(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacMB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotMiscVarTypeData%NacMB = SrcRotMiscVarTypeData%NacMB
   end if
   if (allocated(SrcRotMiscVarTypeData%BladeRootLoad)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%BladeRootLoad)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%BladeRootLoad)
      if (.not. allocated(DstRotMiscVarTypeData%BladeRootLoad)) then
         allocate(DstRotMiscVarTypeData%BladeRootLoad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeRootLoad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotMiscVarTypeData%BladeRootLoad(i1), DstRotMiscVarTypeData%BladeRootLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotMiscVarTypeData%B_L_2_R_P)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%B_L_2_R_P)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%B_L_2_R_P)
      if (.not. allocated(DstRotMiscVarTypeData%B_L_2_R_P)) then
         allocate(DstRotMiscVarTypeData%B_L_2_R_P(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_R_P.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyMeshMapType(SrcRotMiscVarTypeData%B_L_2_R_P(i1), DstRotMiscVarTypeData%B_L_2_R_P(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotMiscVarTypeData%BladeBuoyLoadPoint)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%BladeBuoyLoadPoint)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%BladeBuoyLoadPoint)
      if (.not. allocated(DstRotMiscVarTypeData%BladeBuoyLoadPoint)) then
         allocate(DstRotMiscVarTypeData%BladeBuoyLoadPoint(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoadPoint.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotMiscVarTypeData%BladeBuoyLoadPoint(i1), DstRotMiscVarTypeData%BladeBuoyLoadPoint(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotMiscVarTypeData%BladeBuoyLoad)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%BladeBuoyLoad)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%BladeBuoyLoad)
      if (.not. allocated(DstRotMiscVarTypeData%BladeBuoyLoad)) then
         allocate(DstRotMiscVarTypeData%BladeBuoyLoad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotMiscVarTypeData%BladeBuoyLoad(i1), DstRotMiscVarTypeData%BladeBuoyLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotMiscVarTypeData%B_P_2_B_L)) then
      LB(1:1) = lbound(SrcRotMiscVarTypeData%B_P_2_B_L)
      UB(1:1) = ubound(SrcRotMiscVarTypeData%B_P_2_B_L)
      if (.not. allocated(DstRotMiscVarTypeData%B_P_2_B_L)) then
         allocate(DstRotMiscVarTypeData%B_P_2_B_L(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_P_2_B_L.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyMeshMapType(SrcRotMiscVarTypeData%B_P_2_B_L(i1), DstRotMiscVarTypeData%B_P_2_B_L(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcRotMiscVarTypeData%TwrBuoyLoadPoint, DstRotMiscVarTypeData%TwrBuoyLoadPoint, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcRotMiscVarTypeData%TwrBuoyLoad, DstRotMiscVarTypeData%TwrBuoyLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcRotMiscVarTypeData%T_P_2_T_L, DstRotMiscVarTypeData%T_P_2_T_L, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstRotMiscVarTypeData%FirstWarn_TowerStrike = SrcRotMiscVarTypeData%FirstWarn_TowerStrike
   DstRotMiscVarTypeData%AvgDiskVel = SrcRotMiscVarTypeData%AvgDiskVel
   DstRotMiscVarTypeData%AvgDiskVelDist = SrcRotMiscVarTypeData%AvgDiskVelDist
   DstRotMiscVarTypeData%TFinAlpha = SrcRotMiscVarTypeData%TFinAlpha
   DstRotMiscVarTypeData%TFinRe = SrcRotMiscVarTypeData%TFinRe
   DstRotMiscVarTypeData%TFinVrel = SrcRotMiscVarTypeData%TFinVrel
   DstRotMiscVarTypeData%TFinVund_i = SrcRotMiscVarTypeData%TFinVund_i
   DstRotMiscVarTypeData%TFinVind_i = SrcRotMiscVarTypeData%TFinVind_i
   DstRotMiscVarTypeData%TFinVrel_i = SrcRotMiscVarTypeData%TFinVrel_i
   DstRotMiscVarTypeData%TFinSTV_i = SrcRotMiscVarTypeData%TFinSTV_i
   DstRotMiscVarTypeData%TFinF_i = SrcRotMiscVarTypeData%TFinF_i
   DstRotMiscVarTypeData%TFinM_i = SrcRotMiscVarTypeData%TFinM_i
end subroutine

subroutine AD_DestroyRotMiscVarType(RotMiscVarTypeData, ErrStat, ErrMsg)
   type(RotMiscVarType), intent(inout) :: RotMiscVarTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotMiscVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call BEMT_DestroyMisc(RotMiscVarTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call BEMT_DestroyOutput(RotMiscVarTypeData%BEMT_y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   LB(1:1) = lbound(RotMiscVarTypeData%BEMT_u)
   UB(1:1) = ubound(RotMiscVarTypeData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_DestroyInput(RotMiscVarTypeData%BEMT_u(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   call AA_DestroyMisc(RotMiscVarTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyOutput(RotMiscVarTypeData%AA_y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyInput(RotMiscVarTypeData%AA_u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotMiscVarTypeData%DisturbedInflow)) then
      deallocate(RotMiscVarTypeData%DisturbedInflow)
   end if
   if (allocated(RotMiscVarTypeData%orientationAnnulus)) then
      deallocate(RotMiscVarTypeData%orientationAnnulus)
   end if
   if (allocated(RotMiscVarTypeData%AllOuts)) then
      deallocate(RotMiscVarTypeData%AllOuts)
   end if
   if (allocated(RotMiscVarTypeData%W_Twr)) then
      deallocate(RotMiscVarTypeData%W_Twr)
   end if
   if (allocated(RotMiscVarTypeData%X_Twr)) then
      deallocate(RotMiscVarTypeData%X_Twr)
   end if
   if (allocated(RotMiscVarTypeData%Y_Twr)) then
      deallocate(RotMiscVarTypeData%Y_Twr)
   end if
   if (allocated(RotMiscVarTypeData%Curve)) then
      deallocate(RotMiscVarTypeData%Curve)
   end if
   if (allocated(RotMiscVarTypeData%TwrClrnc)) then
      deallocate(RotMiscVarTypeData%TwrClrnc)
   end if
   if (allocated(RotMiscVarTypeData%X)) then
      deallocate(RotMiscVarTypeData%X)
   end if
   if (allocated(RotMiscVarTypeData%Y)) then
      deallocate(RotMiscVarTypeData%Y)
   end if
   if (allocated(RotMiscVarTypeData%Z)) then
      deallocate(RotMiscVarTypeData%Z)
   end if
   if (allocated(RotMiscVarTypeData%M)) then
      deallocate(RotMiscVarTypeData%M)
   end if
   if (allocated(RotMiscVarTypeData%Mx)) then
      deallocate(RotMiscVarTypeData%Mx)
   end if
   if (allocated(RotMiscVarTypeData%My)) then
      deallocate(RotMiscVarTypeData%My)
   end if
   if (allocated(RotMiscVarTypeData%Mz)) then
      deallocate(RotMiscVarTypeData%Mz)
   end if
   if (allocated(RotMiscVarTypeData%hub_theta_x_root)) then
      deallocate(RotMiscVarTypeData%hub_theta_x_root)
   end if
   call MeshDestroy( RotMiscVarTypeData%HubLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotMiscVarTypeData%B_L_2_H_P)) then
      LB(1:1) = lbound(RotMiscVarTypeData%B_L_2_H_P)
      UB(1:1) = ubound(RotMiscVarTypeData%B_L_2_H_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyMeshMapType(RotMiscVarTypeData%B_L_2_H_P(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%B_L_2_H_P)
   end if
   if (allocated(RotMiscVarTypeData%SigmaCavitCrit)) then
      deallocate(RotMiscVarTypeData%SigmaCavitCrit)
   end if
   if (allocated(RotMiscVarTypeData%SigmaCavit)) then
      deallocate(RotMiscVarTypeData%SigmaCavit)
   end if
   if (allocated(RotMiscVarTypeData%CavitWarnSet)) then
      deallocate(RotMiscVarTypeData%CavitWarnSet)
   end if
   if (allocated(RotMiscVarTypeData%BlFB)) then
      deallocate(RotMiscVarTypeData%BlFB)
   end if
   if (allocated(RotMiscVarTypeData%BlMB)) then
      deallocate(RotMiscVarTypeData%BlMB)
   end if
   if (allocated(RotMiscVarTypeData%TwrFB)) then
      deallocate(RotMiscVarTypeData%TwrFB)
   end if
   if (allocated(RotMiscVarTypeData%TwrMB)) then
      deallocate(RotMiscVarTypeData%TwrMB)
   end if
   if (allocated(RotMiscVarTypeData%HubFB)) then
      deallocate(RotMiscVarTypeData%HubFB)
   end if
   if (allocated(RotMiscVarTypeData%HubMB)) then
      deallocate(RotMiscVarTypeData%HubMB)
   end if
   if (allocated(RotMiscVarTypeData%NacFB)) then
      deallocate(RotMiscVarTypeData%NacFB)
   end if
   if (allocated(RotMiscVarTypeData%NacMB)) then
      deallocate(RotMiscVarTypeData%NacMB)
   end if
   if (allocated(RotMiscVarTypeData%BladeRootLoad)) then
      LB(1:1) = lbound(RotMiscVarTypeData%BladeRootLoad)
      UB(1:1) = ubound(RotMiscVarTypeData%BladeRootLoad)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotMiscVarTypeData%BladeRootLoad(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%BladeRootLoad)
   end if
   if (allocated(RotMiscVarTypeData%B_L_2_R_P)) then
      LB(1:1) = lbound(RotMiscVarTypeData%B_L_2_R_P)
      UB(1:1) = ubound(RotMiscVarTypeData%B_L_2_R_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyMeshMapType(RotMiscVarTypeData%B_L_2_R_P(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%B_L_2_R_P)
   end if
   if (allocated(RotMiscVarTypeData%BladeBuoyLoadPoint)) then
      LB(1:1) = lbound(RotMiscVarTypeData%BladeBuoyLoadPoint)
      UB(1:1) = ubound(RotMiscVarTypeData%BladeBuoyLoadPoint)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotMiscVarTypeData%BladeBuoyLoadPoint(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%BladeBuoyLoadPoint)
   end if
   if (allocated(RotMiscVarTypeData%BladeBuoyLoad)) then
      LB(1:1) = lbound(RotMiscVarTypeData%BladeBuoyLoad)
      UB(1:1) = ubound(RotMiscVarTypeData%BladeBuoyLoad)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotMiscVarTypeData%BladeBuoyLoad(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%BladeBuoyLoad)
   end if
   if (allocated(RotMiscVarTypeData%B_P_2_B_L)) then
      LB(1:1) = lbound(RotMiscVarTypeData%B_P_2_B_L)
      UB(1:1) = ubound(RotMiscVarTypeData%B_P_2_B_L)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyMeshMapType(RotMiscVarTypeData%B_P_2_B_L(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotMiscVarTypeData%B_P_2_B_L)
   end if
   call MeshDestroy( RotMiscVarTypeData%TwrBuoyLoadPoint, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( RotMiscVarTypeData%TwrBuoyLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(RotMiscVarTypeData%T_P_2_T_L, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotMiscVarType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotMiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotMiscVarType'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   if (Buf%ErrStat >= AbortErrLev) return
   call BEMT_PackMisc(Buf, InData%BEMT) 
   call BEMT_PackOutput(Buf, InData%BEMT_y) 
   LB(1:1) = lbound(InData%BEMT_u)
   UB(1:1) = ubound(InData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_PackInput(Buf, InData%BEMT_u(i1)) 
   end do
   call AA_PackMisc(Buf, InData%AA) 
   call AA_PackOutput(Buf, InData%AA_y) 
   call AA_PackInput(Buf, InData%AA_u) 
   call RegPack(Buf, allocated(InData%DisturbedInflow))
   if (allocated(InData%DisturbedInflow)) then
      call RegPackBounds(Buf, 3, lbound(InData%DisturbedInflow), ubound(InData%DisturbedInflow))
      call RegPack(Buf, InData%DisturbedInflow)
   end if
   call RegPack(Buf, allocated(InData%orientationAnnulus))
   if (allocated(InData%orientationAnnulus)) then
      call RegPackBounds(Buf, 4, lbound(InData%orientationAnnulus), ubound(InData%orientationAnnulus))
      call RegPack(Buf, InData%orientationAnnulus)
   end if
   call RegPack(Buf, allocated(InData%AllOuts))
   if (allocated(InData%AllOuts)) then
      call RegPackBounds(Buf, 1, lbound(InData%AllOuts), ubound(InData%AllOuts))
      call RegPack(Buf, InData%AllOuts)
   end if
   call RegPack(Buf, allocated(InData%W_Twr))
   if (allocated(InData%W_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%W_Twr), ubound(InData%W_Twr))
      call RegPack(Buf, InData%W_Twr)
   end if
   call RegPack(Buf, allocated(InData%X_Twr))
   if (allocated(InData%X_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%X_Twr), ubound(InData%X_Twr))
      call RegPack(Buf, InData%X_Twr)
   end if
   call RegPack(Buf, allocated(InData%Y_Twr))
   if (allocated(InData%Y_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%Y_Twr), ubound(InData%Y_Twr))
      call RegPack(Buf, InData%Y_Twr)
   end if
   call RegPack(Buf, allocated(InData%Curve))
   if (allocated(InData%Curve)) then
      call RegPackBounds(Buf, 2, lbound(InData%Curve), ubound(InData%Curve))
      call RegPack(Buf, InData%Curve)
   end if
   call RegPack(Buf, allocated(InData%TwrClrnc))
   if (allocated(InData%TwrClrnc)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrClrnc), ubound(InData%TwrClrnc))
      call RegPack(Buf, InData%TwrClrnc)
   end if
   call RegPack(Buf, allocated(InData%X))
   if (allocated(InData%X)) then
      call RegPackBounds(Buf, 2, lbound(InData%X), ubound(InData%X))
      call RegPack(Buf, InData%X)
   end if
   call RegPack(Buf, allocated(InData%Y))
   if (allocated(InData%Y)) then
      call RegPackBounds(Buf, 2, lbound(InData%Y), ubound(InData%Y))
      call RegPack(Buf, InData%Y)
   end if
   call RegPack(Buf, allocated(InData%Z))
   if (allocated(InData%Z)) then
      call RegPackBounds(Buf, 2, lbound(InData%Z), ubound(InData%Z))
      call RegPack(Buf, InData%Z)
   end if
   call RegPack(Buf, allocated(InData%M))
   if (allocated(InData%M)) then
      call RegPackBounds(Buf, 2, lbound(InData%M), ubound(InData%M))
      call RegPack(Buf, InData%M)
   end if
   call RegPack(Buf, allocated(InData%Mx))
   if (allocated(InData%Mx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Mx), ubound(InData%Mx))
      call RegPack(Buf, InData%Mx)
   end if
   call RegPack(Buf, allocated(InData%My))
   if (allocated(InData%My)) then
      call RegPackBounds(Buf, 2, lbound(InData%My), ubound(InData%My))
      call RegPack(Buf, InData%My)
   end if
   call RegPack(Buf, allocated(InData%Mz))
   if (allocated(InData%Mz)) then
      call RegPackBounds(Buf, 2, lbound(InData%Mz), ubound(InData%Mz))
      call RegPack(Buf, InData%Mz)
   end if
   call RegPack(Buf, InData%V_DiskAvg)
   call RegPack(Buf, InData%yaw)
   call RegPack(Buf, InData%tilt)
   call RegPack(Buf, allocated(InData%hub_theta_x_root))
   if (allocated(InData%hub_theta_x_root)) then
      call RegPackBounds(Buf, 1, lbound(InData%hub_theta_x_root), ubound(InData%hub_theta_x_root))
      call RegPack(Buf, InData%hub_theta_x_root)
   end if
   call RegPack(Buf, InData%V_dot_x)
   call MeshPack(Buf, InData%HubLoad) 
   call RegPack(Buf, allocated(InData%B_L_2_H_P))
   if (allocated(InData%B_L_2_H_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_L_2_H_P), ubound(InData%B_L_2_H_P))
      LB(1:1) = lbound(InData%B_L_2_H_P)
      UB(1:1) = ubound(InData%B_L_2_H_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_L_2_H_P(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%SigmaCavitCrit))
   if (allocated(InData%SigmaCavitCrit)) then
      call RegPackBounds(Buf, 2, lbound(InData%SigmaCavitCrit), ubound(InData%SigmaCavitCrit))
      call RegPack(Buf, InData%SigmaCavitCrit)
   end if
   call RegPack(Buf, allocated(InData%SigmaCavit))
   if (allocated(InData%SigmaCavit)) then
      call RegPackBounds(Buf, 2, lbound(InData%SigmaCavit), ubound(InData%SigmaCavit))
      call RegPack(Buf, InData%SigmaCavit)
   end if
   call RegPack(Buf, allocated(InData%CavitWarnSet))
   if (allocated(InData%CavitWarnSet)) then
      call RegPackBounds(Buf, 2, lbound(InData%CavitWarnSet), ubound(InData%CavitWarnSet))
      call RegPack(Buf, InData%CavitWarnSet)
   end if
   call RegPack(Buf, allocated(InData%BlFB))
   if (allocated(InData%BlFB)) then
      call RegPackBounds(Buf, 3, lbound(InData%BlFB), ubound(InData%BlFB))
      call RegPack(Buf, InData%BlFB)
   end if
   call RegPack(Buf, allocated(InData%BlMB))
   if (allocated(InData%BlMB)) then
      call RegPackBounds(Buf, 3, lbound(InData%BlMB), ubound(InData%BlMB))
      call RegPack(Buf, InData%BlMB)
   end if
   call RegPack(Buf, allocated(InData%TwrFB))
   if (allocated(InData%TwrFB)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrFB), ubound(InData%TwrFB))
      call RegPack(Buf, InData%TwrFB)
   end if
   call RegPack(Buf, allocated(InData%TwrMB))
   if (allocated(InData%TwrMB)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrMB), ubound(InData%TwrMB))
      call RegPack(Buf, InData%TwrMB)
   end if
   call RegPack(Buf, allocated(InData%HubFB))
   if (allocated(InData%HubFB)) then
      call RegPackBounds(Buf, 1, lbound(InData%HubFB), ubound(InData%HubFB))
      call RegPack(Buf, InData%HubFB)
   end if
   call RegPack(Buf, allocated(InData%HubMB))
   if (allocated(InData%HubMB)) then
      call RegPackBounds(Buf, 1, lbound(InData%HubMB), ubound(InData%HubMB))
      call RegPack(Buf, InData%HubMB)
   end if
   call RegPack(Buf, allocated(InData%NacFB))
   if (allocated(InData%NacFB)) then
      call RegPackBounds(Buf, 1, lbound(InData%NacFB), ubound(InData%NacFB))
      call RegPack(Buf, InData%NacFB)
   end if
   call RegPack(Buf, allocated(InData%NacMB))
   if (allocated(InData%NacMB)) then
      call RegPackBounds(Buf, 1, lbound(InData%NacMB), ubound(InData%NacMB))
      call RegPack(Buf, InData%NacMB)
   end if
   call RegPack(Buf, allocated(InData%BladeRootLoad))
   if (allocated(InData%BladeRootLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeRootLoad), ubound(InData%BladeRootLoad))
      LB(1:1) = lbound(InData%BladeRootLoad)
      UB(1:1) = ubound(InData%BladeRootLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeRootLoad(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%B_L_2_R_P))
   if (allocated(InData%B_L_2_R_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_L_2_R_P), ubound(InData%B_L_2_R_P))
      LB(1:1) = lbound(InData%B_L_2_R_P)
      UB(1:1) = ubound(InData%B_L_2_R_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_L_2_R_P(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%BladeBuoyLoadPoint))
   if (allocated(InData%BladeBuoyLoadPoint)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeBuoyLoadPoint), ubound(InData%BladeBuoyLoadPoint))
      LB(1:1) = lbound(InData%BladeBuoyLoadPoint)
      UB(1:1) = ubound(InData%BladeBuoyLoadPoint)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeBuoyLoadPoint(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%BladeBuoyLoad))
   if (allocated(InData%BladeBuoyLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeBuoyLoad), ubound(InData%BladeBuoyLoad))
      LB(1:1) = lbound(InData%BladeBuoyLoad)
      UB(1:1) = ubound(InData%BladeBuoyLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeBuoyLoad(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%B_P_2_B_L))
   if (allocated(InData%B_P_2_B_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_P_2_B_L), ubound(InData%B_P_2_B_L))
      LB(1:1) = lbound(InData%B_P_2_B_L)
      UB(1:1) = ubound(InData%B_P_2_B_L)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_P_2_B_L(i1)) 
      end do
   end if
   call MeshPack(Buf, InData%TwrBuoyLoadPoint) 
   call MeshPack(Buf, InData%TwrBuoyLoad) 
   call NWTC_Library_PackMeshMapType(Buf, InData%T_P_2_T_L) 
   call RegPack(Buf, InData%FirstWarn_TowerStrike)
   call RegPack(Buf, InData%AvgDiskVel)
   call RegPack(Buf, InData%AvgDiskVelDist)
   call RegPack(Buf, InData%TFinAlpha)
   call RegPack(Buf, InData%TFinRe)
   call RegPack(Buf, InData%TFinVrel)
   call RegPack(Buf, InData%TFinVund_i)
   call RegPack(Buf, InData%TFinVind_i)
   call RegPack(Buf, InData%TFinVrel_i)
   call RegPack(Buf, InData%TFinSTV_i)
   call RegPack(Buf, InData%TFinF_i)
   call RegPack(Buf, InData%TFinM_i)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotMiscVarType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotMiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotMiscVarType'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call BEMT_UnpackMisc(Buf, OutData%BEMT) ! BEMT 
   call BEMT_UnpackOutput(Buf, OutData%BEMT_y) ! BEMT_y 
   LB(1:1) = lbound(OutData%BEMT_u)
   UB(1:1) = ubound(OutData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_UnpackInput(Buf, OutData%BEMT_u(i1)) ! BEMT_u 
   end do
   call AA_UnpackMisc(Buf, OutData%AA) ! AA 
   call AA_UnpackOutput(Buf, OutData%AA_y) ! AA_y 
   call AA_UnpackInput(Buf, OutData%AA_u) ! AA_u 
   if (allocated(OutData%DisturbedInflow)) deallocate(OutData%DisturbedInflow)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DisturbedInflow(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DisturbedInflow.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DisturbedInflow)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%orientationAnnulus)) deallocate(OutData%orientationAnnulus)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%orientationAnnulus(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%orientationAnnulus.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%orientationAnnulus)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AllOuts)) deallocate(OutData%AllOuts)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOuts(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOuts.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOuts)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%W_Twr)) deallocate(OutData%W_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%X_Twr)) deallocate(OutData%X_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Y_Twr)) deallocate(OutData%Y_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Curve)) deallocate(OutData%Curve)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Curve(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Curve.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Curve)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrClrnc)) deallocate(OutData%TwrClrnc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrClrnc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrClrnc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrClrnc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%X)) deallocate(OutData%X)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Y)) deallocate(OutData%Y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Z)) deallocate(OutData%Z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%M)) deallocate(OutData%M)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Mx)) deallocate(OutData%Mx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Mx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%My)) deallocate(OutData%My)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%My(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%My.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%My)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Mz)) deallocate(OutData%Mz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Mz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%V_DiskAvg)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%tilt)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%hub_theta_x_root)) deallocate(OutData%hub_theta_x_root)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%hub_theta_x_root(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%hub_theta_x_root.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%hub_theta_x_root)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%V_dot_x)
   if (RegCheckErr(Buf, RoutineName)) return
   call MeshUnpack(Buf, OutData%HubLoad) ! HubLoad 
   if (allocated(OutData%B_L_2_H_P)) deallocate(OutData%B_L_2_H_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_L_2_H_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_H_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_L_2_H_P(i1)) ! B_L_2_H_P 
      end do
   end if
   if (allocated(OutData%SigmaCavitCrit)) deallocate(OutData%SigmaCavitCrit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SigmaCavitCrit(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavitCrit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SigmaCavitCrit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%SigmaCavit)) deallocate(OutData%SigmaCavit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SigmaCavit(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SigmaCavit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CavitWarnSet)) deallocate(OutData%CavitWarnSet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CavitWarnSet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CavitWarnSet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CavitWarnSet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlFB)) deallocate(OutData%BlFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlFB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlMB)) deallocate(OutData%BlMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlMB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrFB)) deallocate(OutData%TwrFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrFB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrMB)) deallocate(OutData%TwrMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrMB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%HubFB)) deallocate(OutData%HubFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HubFB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HubFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%HubMB)) deallocate(OutData%HubMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HubMB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HubMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%NacFB)) deallocate(OutData%NacFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NacFB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NacFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%NacMB)) deallocate(OutData%NacMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NacMB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NacMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BladeRootLoad)) deallocate(OutData%BladeRootLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeRootLoad(i1)) ! BladeRootLoad 
      end do
   end if
   if (allocated(OutData%B_L_2_R_P)) deallocate(OutData%B_L_2_R_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_L_2_R_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_R_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_L_2_R_P(i1)) ! B_L_2_R_P 
      end do
   end if
   if (allocated(OutData%BladeBuoyLoadPoint)) deallocate(OutData%BladeBuoyLoadPoint)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeBuoyLoadPoint(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoadPoint.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeBuoyLoadPoint(i1)) ! BladeBuoyLoadPoint 
      end do
   end if
   if (allocated(OutData%BladeBuoyLoad)) deallocate(OutData%BladeBuoyLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeBuoyLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeBuoyLoad(i1)) ! BladeBuoyLoad 
      end do
   end if
   if (allocated(OutData%B_P_2_B_L)) deallocate(OutData%B_P_2_B_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_P_2_B_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_P_2_B_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_P_2_B_L(i1)) ! B_P_2_B_L 
      end do
   end if
   call MeshUnpack(Buf, OutData%TwrBuoyLoadPoint) ! TwrBuoyLoadPoint 
   call MeshUnpack(Buf, OutData%TwrBuoyLoad) ! TwrBuoyLoad 
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%T_P_2_T_L) ! T_P_2_T_L 
   call RegUnpack(Buf, OutData%FirstWarn_TowerStrike)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AvgDiskVel)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AvgDiskVelDist)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinRe)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinVrel)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinVund_i)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinVind_i)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinVrel_i)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinSTV_i)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinF_i)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinM_i)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(AD_MiscVarType), intent(inout) :: SrcMiscData
   type(AD_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%rotors)) then
      LB(1:1) = lbound(SrcMiscData%rotors)
      UB(1:1) = ubound(SrcMiscData%rotors)
      if (.not. allocated(DstMiscData%rotors)) then
         allocate(DstMiscData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotMiscVarType(SrcMiscData%rotors(i1), DstMiscData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%FVW_u)) then
      LB(1:1) = lbound(SrcMiscData%FVW_u)
      UB(1:1) = ubound(SrcMiscData%FVW_u)
      if (.not. allocated(DstMiscData%FVW_u)) then
         allocate(DstMiscData%FVW_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FVW_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FVW_CopyInput(SrcMiscData%FVW_u(i1), DstMiscData%FVW_u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FVW_CopyOutput(SrcMiscData%FVW_y, DstMiscData%FVW_y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FVW_CopyMisc(SrcMiscData%FVW, DstMiscData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMiscData%WindPos)) then
      LB(1:2) = lbound(SrcMiscData%WindPos)
      UB(1:2) = ubound(SrcMiscData%WindPos)
      if (.not. allocated(DstMiscData%WindPos)) then
         allocate(DstMiscData%WindPos(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindPos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WindPos = SrcMiscData%WindPos
   end if
   if (allocated(SrcMiscData%WindVel)) then
      LB(1:2) = lbound(SrcMiscData%WindVel)
      UB(1:2) = ubound(SrcMiscData%WindVel)
      if (.not. allocated(DstMiscData%WindVel)) then
         allocate(DstMiscData%WindVel(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindVel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WindVel = SrcMiscData%WindVel
   end if
   if (allocated(SrcMiscData%WindAcc)) then
      LB(1:2) = lbound(SrcMiscData%WindAcc)
      UB(1:2) = ubound(SrcMiscData%WindAcc)
      if (.not. allocated(DstMiscData%WindAcc)) then
         allocate(DstMiscData%WindAcc(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindAcc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WindAcc = SrcMiscData%WindAcc
   end if
end subroutine

subroutine AD_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(AD_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%rotors)) then
      LB(1:1) = lbound(MiscData%rotors)
      UB(1:1) = ubound(MiscData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotMiscVarType(MiscData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%rotors)
   end if
   if (allocated(MiscData%FVW_u)) then
      LB(1:1) = lbound(MiscData%FVW_u)
      UB(1:1) = ubound(MiscData%FVW_u)
      do i1 = LB(1), UB(1)
         call FVW_DestroyInput(MiscData%FVW_u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%FVW_u)
   end if
   call FVW_DestroyOutput(MiscData%FVW_y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FVW_DestroyMisc(MiscData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%WindPos)) then
      deallocate(MiscData%WindPos)
   end if
   if (allocated(MiscData%WindVel)) then
      deallocate(MiscData%WindVel)
   end if
   if (allocated(MiscData%WindAcc)) then
      deallocate(MiscData%WindAcc)
   end if
end subroutine

subroutine AD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotMiscVarType(Buf, InData%rotors(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%FVW_u))
   if (allocated(InData%FVW_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%FVW_u), ubound(InData%FVW_u))
      LB(1:1) = lbound(InData%FVW_u)
      UB(1:1) = ubound(InData%FVW_u)
      do i1 = LB(1), UB(1)
         call FVW_PackInput(Buf, InData%FVW_u(i1)) 
      end do
   end if
   call FVW_PackOutput(Buf, InData%FVW_y) 
   call FVW_PackMisc(Buf, InData%FVW) 
   call RegPack(Buf, allocated(InData%WindPos))
   if (allocated(InData%WindPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindPos), ubound(InData%WindPos))
      call RegPack(Buf, InData%WindPos)
   end if
   call RegPack(Buf, allocated(InData%WindVel))
   if (allocated(InData%WindVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindVel), ubound(InData%WindVel))
      call RegPack(Buf, InData%WindVel)
   end if
   call RegPack(Buf, allocated(InData%WindAcc))
   if (allocated(InData%WindAcc)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindAcc), ubound(InData%WindAcc))
      call RegPack(Buf, InData%WindAcc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotMiscVarType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   if (allocated(OutData%FVW_u)) deallocate(OutData%FVW_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FVW_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FVW_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackInput(Buf, OutData%FVW_u(i1)) ! FVW_u 
      end do
   end if
   call FVW_UnpackOutput(Buf, OutData%FVW_y) ! FVW_y 
   call FVW_UnpackMisc(Buf, OutData%FVW) ! FVW 
   if (allocated(OutData%WindPos)) deallocate(OutData%WindPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WindVel)) deallocate(OutData%WindVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%WindAcc)) deallocate(OutData%WindAcc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindAcc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindAcc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindAcc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotParameterType(SrcRotParameterTypeData, DstRotParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotParameterType), intent(in) :: SrcRotParameterTypeData
   type(RotParameterType), intent(inout) :: DstRotParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRotParameterTypeData%NumBlades = SrcRotParameterTypeData%NumBlades
   DstRotParameterTypeData%NumBlNds = SrcRotParameterTypeData%NumBlNds
   DstRotParameterTypeData%NumTwrNds = SrcRotParameterTypeData%NumTwrNds
   if (allocated(SrcRotParameterTypeData%TwrDiam)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrDiam)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrDiam)
      if (.not. allocated(DstRotParameterTypeData%TwrDiam)) then
         allocate(DstRotParameterTypeData%TwrDiam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDiam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrDiam = SrcRotParameterTypeData%TwrDiam
   end if
   if (allocated(SrcRotParameterTypeData%TwrCd)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrCd)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrCd)
      if (.not. allocated(DstRotParameterTypeData%TwrCd)) then
         allocate(DstRotParameterTypeData%TwrCd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrCd = SrcRotParameterTypeData%TwrCd
   end if
   if (allocated(SrcRotParameterTypeData%TwrTI)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrTI)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrTI)
      if (.not. allocated(DstRotParameterTypeData%TwrTI)) then
         allocate(DstRotParameterTypeData%TwrTI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrTI = SrcRotParameterTypeData%TwrTI
   end if
   if (allocated(SrcRotParameterTypeData%BlTwist)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlTwist)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlTwist)
      if (.not. allocated(DstRotParameterTypeData%BlTwist)) then
         allocate(DstRotParameterTypeData%BlTwist(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTwist.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlTwist = SrcRotParameterTypeData%BlTwist
   end if
   if (allocated(SrcRotParameterTypeData%TwrCb)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrCb)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrCb)
      if (.not. allocated(DstRotParameterTypeData%TwrCb)) then
         allocate(DstRotParameterTypeData%TwrCb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrCb = SrcRotParameterTypeData%TwrCb
   end if
   if (allocated(SrcRotParameterTypeData%BlCenBn)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlCenBn)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlCenBn)
      if (.not. allocated(DstRotParameterTypeData%BlCenBn)) then
         allocate(DstRotParameterTypeData%BlCenBn(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlCenBn = SrcRotParameterTypeData%BlCenBn
   end if
   if (allocated(SrcRotParameterTypeData%BlCenBt)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlCenBt)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlCenBt)
      if (.not. allocated(DstRotParameterTypeData%BlCenBt)) then
         allocate(DstRotParameterTypeData%BlCenBt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlCenBt = SrcRotParameterTypeData%BlCenBt
   end if
   DstRotParameterTypeData%VolHub = SrcRotParameterTypeData%VolHub
   DstRotParameterTypeData%HubCenBx = SrcRotParameterTypeData%HubCenBx
   DstRotParameterTypeData%VolNac = SrcRotParameterTypeData%VolNac
   DstRotParameterTypeData%NacCenB = SrcRotParameterTypeData%NacCenB
   DstRotParameterTypeData%VolBl = SrcRotParameterTypeData%VolBl
   DstRotParameterTypeData%VolTwr = SrcRotParameterTypeData%VolTwr
   if (allocated(SrcRotParameterTypeData%BlRad)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlRad)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlRad)
      if (.not. allocated(DstRotParameterTypeData%BlRad)) then
         allocate(DstRotParameterTypeData%BlRad(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlRad = SrcRotParameterTypeData%BlRad
   end if
   if (allocated(SrcRotParameterTypeData%BlDL)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlDL)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlDL)
      if (.not. allocated(DstRotParameterTypeData%BlDL)) then
         allocate(DstRotParameterTypeData%BlDL(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlDL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlDL = SrcRotParameterTypeData%BlDL
   end if
   if (allocated(SrcRotParameterTypeData%BlTaper)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlTaper)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlTaper)
      if (.not. allocated(DstRotParameterTypeData%BlTaper)) then
         allocate(DstRotParameterTypeData%BlTaper(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTaper.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlTaper = SrcRotParameterTypeData%BlTaper
   end if
   if (allocated(SrcRotParameterTypeData%BlAxCent)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%BlAxCent)
      UB(1:2) = ubound(SrcRotParameterTypeData%BlAxCent)
      if (.not. allocated(DstRotParameterTypeData%BlAxCent)) then
         allocate(DstRotParameterTypeData%BlAxCent(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAxCent.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BlAxCent = SrcRotParameterTypeData%BlAxCent
   end if
   if (allocated(SrcRotParameterTypeData%TwrRad)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrRad)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrRad)
      if (.not. allocated(DstRotParameterTypeData%TwrRad)) then
         allocate(DstRotParameterTypeData%TwrRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrRad = SrcRotParameterTypeData%TwrRad
   end if
   if (allocated(SrcRotParameterTypeData%TwrDL)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrDL)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrDL)
      if (.not. allocated(DstRotParameterTypeData%TwrDL)) then
         allocate(DstRotParameterTypeData%TwrDL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrDL = SrcRotParameterTypeData%TwrDL
   end if
   if (allocated(SrcRotParameterTypeData%TwrTaper)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrTaper)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrTaper)
      if (.not. allocated(DstRotParameterTypeData%TwrTaper)) then
         allocate(DstRotParameterTypeData%TwrTaper(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTaper.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrTaper = SrcRotParameterTypeData%TwrTaper
   end if
   if (allocated(SrcRotParameterTypeData%TwrAxCent)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%TwrAxCent)
      UB(1:1) = ubound(SrcRotParameterTypeData%TwrAxCent)
      if (.not. allocated(DstRotParameterTypeData%TwrAxCent)) then
         allocate(DstRotParameterTypeData%TwrAxCent(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrAxCent.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%TwrAxCent = SrcRotParameterTypeData%TwrAxCent
   end if
   call BEMT_CopyParam(SrcRotParameterTypeData%BEMT, DstRotParameterTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AA_CopyParam(SrcRotParameterTypeData%AA, DstRotParameterTypeData%AA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotParameterTypeData%Jac_u_indx)) then
      LB(1:2) = lbound(SrcRotParameterTypeData%Jac_u_indx)
      UB(1:2) = ubound(SrcRotParameterTypeData%Jac_u_indx)
      if (.not. allocated(DstRotParameterTypeData%Jac_u_indx)) then
         allocate(DstRotParameterTypeData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%Jac_u_indx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%Jac_u_indx = SrcRotParameterTypeData%Jac_u_indx
   end if
   if (allocated(SrcRotParameterTypeData%du)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%du)
      UB(1:1) = ubound(SrcRotParameterTypeData%du)
      if (.not. allocated(DstRotParameterTypeData%du)) then
         allocate(DstRotParameterTypeData%du(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%du.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%du = SrcRotParameterTypeData%du
   end if
   if (allocated(SrcRotParameterTypeData%dx)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%dx)
      UB(1:1) = ubound(SrcRotParameterTypeData%dx)
      if (.not. allocated(DstRotParameterTypeData%dx)) then
         allocate(DstRotParameterTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%dx = SrcRotParameterTypeData%dx
   end if
   DstRotParameterTypeData%Jac_ny = SrcRotParameterTypeData%Jac_ny
   DstRotParameterTypeData%NumBl_Lin = SrcRotParameterTypeData%NumBl_Lin
   DstRotParameterTypeData%TwrPotent = SrcRotParameterTypeData%TwrPotent
   DstRotParameterTypeData%TwrShadow = SrcRotParameterTypeData%TwrShadow
   DstRotParameterTypeData%TwrAero = SrcRotParameterTypeData%TwrAero
   DstRotParameterTypeData%FrozenWake = SrcRotParameterTypeData%FrozenWake
   DstRotParameterTypeData%CavitCheck = SrcRotParameterTypeData%CavitCheck
   DstRotParameterTypeData%Buoyancy = SrcRotParameterTypeData%Buoyancy
   DstRotParameterTypeData%MHK = SrcRotParameterTypeData%MHK
   DstRotParameterTypeData%CompAA = SrcRotParameterTypeData%CompAA
   DstRotParameterTypeData%AirDens = SrcRotParameterTypeData%AirDens
   DstRotParameterTypeData%KinVisc = SrcRotParameterTypeData%KinVisc
   DstRotParameterTypeData%SpdSound = SrcRotParameterTypeData%SpdSound
   DstRotParameterTypeData%Gravity = SrcRotParameterTypeData%Gravity
   DstRotParameterTypeData%Patm = SrcRotParameterTypeData%Patm
   DstRotParameterTypeData%Pvap = SrcRotParameterTypeData%Pvap
   DstRotParameterTypeData%WtrDpth = SrcRotParameterTypeData%WtrDpth
   DstRotParameterTypeData%MSL2SWL = SrcRotParameterTypeData%MSL2SWL
   DstRotParameterTypeData%AeroProjMod = SrcRotParameterTypeData%AeroProjMod
   DstRotParameterTypeData%AeroBEM_Mod = SrcRotParameterTypeData%AeroBEM_Mod
   DstRotParameterTypeData%NumOuts = SrcRotParameterTypeData%NumOuts
   DstRotParameterTypeData%RootName = SrcRotParameterTypeData%RootName
   if (allocated(SrcRotParameterTypeData%OutParam)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%OutParam)
      UB(1:1) = ubound(SrcRotParameterTypeData%OutParam)
      if (.not. allocated(DstRotParameterTypeData%OutParam)) then
         allocate(DstRotParameterTypeData%OutParam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%OutParam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyOutParmType(SrcRotParameterTypeData%OutParam(i1), DstRotParameterTypeData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstRotParameterTypeData%NBlOuts = SrcRotParameterTypeData%NBlOuts
   DstRotParameterTypeData%BlOutNd = SrcRotParameterTypeData%BlOutNd
   DstRotParameterTypeData%NTwOuts = SrcRotParameterTypeData%NTwOuts
   DstRotParameterTypeData%TwOutNd = SrcRotParameterTypeData%TwOutNd
   DstRotParameterTypeData%BldNd_NumOuts = SrcRotParameterTypeData%BldNd_NumOuts
   DstRotParameterTypeData%BldNd_TotNumOuts = SrcRotParameterTypeData%BldNd_TotNumOuts
   if (allocated(SrcRotParameterTypeData%BldNd_OutParam)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%BldNd_OutParam)
      UB(1:1) = ubound(SrcRotParameterTypeData%BldNd_OutParam)
      if (.not. allocated(DstRotParameterTypeData%BldNd_OutParam)) then
         allocate(DstRotParameterTypeData%BldNd_OutParam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_OutParam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyOutParmType(SrcRotParameterTypeData%BldNd_OutParam(i1), DstRotParameterTypeData%BldNd_OutParam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotParameterTypeData%BldNd_BlOutNd)) then
      LB(1:1) = lbound(SrcRotParameterTypeData%BldNd_BlOutNd)
      UB(1:1) = ubound(SrcRotParameterTypeData%BldNd_BlOutNd)
      if (.not. allocated(DstRotParameterTypeData%BldNd_BlOutNd)) then
         allocate(DstRotParameterTypeData%BldNd_BlOutNd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_BlOutNd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotParameterTypeData%BldNd_BlOutNd = SrcRotParameterTypeData%BldNd_BlOutNd
   end if
   DstRotParameterTypeData%BldNd_BladesOut = SrcRotParameterTypeData%BldNd_BladesOut
   DstRotParameterTypeData%TFinAero = SrcRotParameterTypeData%TFinAero
   call AD_CopyTFinParameterType(SrcRotParameterTypeData%TFin, DstRotParameterTypeData%TFin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine AD_DestroyRotParameterType(RotParameterTypeData, ErrStat, ErrMsg)
   type(RotParameterType), intent(inout) :: RotParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(RotParameterTypeData%TwrDiam)) then
      deallocate(RotParameterTypeData%TwrDiam)
   end if
   if (allocated(RotParameterTypeData%TwrCd)) then
      deallocate(RotParameterTypeData%TwrCd)
   end if
   if (allocated(RotParameterTypeData%TwrTI)) then
      deallocate(RotParameterTypeData%TwrTI)
   end if
   if (allocated(RotParameterTypeData%BlTwist)) then
      deallocate(RotParameterTypeData%BlTwist)
   end if
   if (allocated(RotParameterTypeData%TwrCb)) then
      deallocate(RotParameterTypeData%TwrCb)
   end if
   if (allocated(RotParameterTypeData%BlCenBn)) then
      deallocate(RotParameterTypeData%BlCenBn)
   end if
   if (allocated(RotParameterTypeData%BlCenBt)) then
      deallocate(RotParameterTypeData%BlCenBt)
   end if
   if (allocated(RotParameterTypeData%BlRad)) then
      deallocate(RotParameterTypeData%BlRad)
   end if
   if (allocated(RotParameterTypeData%BlDL)) then
      deallocate(RotParameterTypeData%BlDL)
   end if
   if (allocated(RotParameterTypeData%BlTaper)) then
      deallocate(RotParameterTypeData%BlTaper)
   end if
   if (allocated(RotParameterTypeData%BlAxCent)) then
      deallocate(RotParameterTypeData%BlAxCent)
   end if
   if (allocated(RotParameterTypeData%TwrRad)) then
      deallocate(RotParameterTypeData%TwrRad)
   end if
   if (allocated(RotParameterTypeData%TwrDL)) then
      deallocate(RotParameterTypeData%TwrDL)
   end if
   if (allocated(RotParameterTypeData%TwrTaper)) then
      deallocate(RotParameterTypeData%TwrTaper)
   end if
   if (allocated(RotParameterTypeData%TwrAxCent)) then
      deallocate(RotParameterTypeData%TwrAxCent)
   end if
   call BEMT_DestroyParam(RotParameterTypeData%BEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AA_DestroyParam(RotParameterTypeData%AA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotParameterTypeData%Jac_u_indx)) then
      deallocate(RotParameterTypeData%Jac_u_indx)
   end if
   if (allocated(RotParameterTypeData%du)) then
      deallocate(RotParameterTypeData%du)
   end if
   if (allocated(RotParameterTypeData%dx)) then
      deallocate(RotParameterTypeData%dx)
   end if
   if (allocated(RotParameterTypeData%OutParam)) then
      LB(1:1) = lbound(RotParameterTypeData%OutParam)
      UB(1:1) = ubound(RotParameterTypeData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyOutParmType(RotParameterTypeData%OutParam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotParameterTypeData%OutParam)
   end if
   if (allocated(RotParameterTypeData%BldNd_OutParam)) then
      LB(1:1) = lbound(RotParameterTypeData%BldNd_OutParam)
      UB(1:1) = ubound(RotParameterTypeData%BldNd_OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyOutParmType(RotParameterTypeData%BldNd_OutParam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotParameterTypeData%BldNd_OutParam)
   end if
   if (allocated(RotParameterTypeData%BldNd_BlOutNd)) then
      deallocate(RotParameterTypeData%BldNd_BlOutNd)
   end if
   call AD_DestroyTFinParameterType(RotParameterTypeData%TFin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine AD_PackRotParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotParameterType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%NumBlades)
   call RegPack(Buf, InData%NumBlNds)
   call RegPack(Buf, InData%NumTwrNds)
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   call RegPack(Buf, allocated(InData%TwrCd))
   if (allocated(InData%TwrCd)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCd), ubound(InData%TwrCd))
      call RegPack(Buf, InData%TwrCd)
   end if
   call RegPack(Buf, allocated(InData%TwrTI))
   if (allocated(InData%TwrTI)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTI), ubound(InData%TwrTI))
      call RegPack(Buf, InData%TwrTI)
   end if
   call RegPack(Buf, allocated(InData%BlTwist))
   if (allocated(InData%BlTwist)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlTwist), ubound(InData%BlTwist))
      call RegPack(Buf, InData%BlTwist)
   end if
   call RegPack(Buf, allocated(InData%TwrCb))
   if (allocated(InData%TwrCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCb), ubound(InData%TwrCb))
      call RegPack(Buf, InData%TwrCb)
   end if
   call RegPack(Buf, allocated(InData%BlCenBn))
   if (allocated(InData%BlCenBn)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlCenBn), ubound(InData%BlCenBn))
      call RegPack(Buf, InData%BlCenBn)
   end if
   call RegPack(Buf, allocated(InData%BlCenBt))
   if (allocated(InData%BlCenBt)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlCenBt), ubound(InData%BlCenBt))
      call RegPack(Buf, InData%BlCenBt)
   end if
   call RegPack(Buf, InData%VolHub)
   call RegPack(Buf, InData%HubCenBx)
   call RegPack(Buf, InData%VolNac)
   call RegPack(Buf, InData%NacCenB)
   call RegPack(Buf, InData%VolBl)
   call RegPack(Buf, InData%VolTwr)
   call RegPack(Buf, allocated(InData%BlRad))
   if (allocated(InData%BlRad)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlRad), ubound(InData%BlRad))
      call RegPack(Buf, InData%BlRad)
   end if
   call RegPack(Buf, allocated(InData%BlDL))
   if (allocated(InData%BlDL)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlDL), ubound(InData%BlDL))
      call RegPack(Buf, InData%BlDL)
   end if
   call RegPack(Buf, allocated(InData%BlTaper))
   if (allocated(InData%BlTaper)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlTaper), ubound(InData%BlTaper))
      call RegPack(Buf, InData%BlTaper)
   end if
   call RegPack(Buf, allocated(InData%BlAxCent))
   if (allocated(InData%BlAxCent)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlAxCent), ubound(InData%BlAxCent))
      call RegPack(Buf, InData%BlAxCent)
   end if
   call RegPack(Buf, allocated(InData%TwrRad))
   if (allocated(InData%TwrRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrRad), ubound(InData%TwrRad))
      call RegPack(Buf, InData%TwrRad)
   end if
   call RegPack(Buf, allocated(InData%TwrDL))
   if (allocated(InData%TwrDL)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDL), ubound(InData%TwrDL))
      call RegPack(Buf, InData%TwrDL)
   end if
   call RegPack(Buf, allocated(InData%TwrTaper))
   if (allocated(InData%TwrTaper)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTaper), ubound(InData%TwrTaper))
      call RegPack(Buf, InData%TwrTaper)
   end if
   call RegPack(Buf, allocated(InData%TwrAxCent))
   if (allocated(InData%TwrAxCent)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrAxCent), ubound(InData%TwrAxCent))
      call RegPack(Buf, InData%TwrAxCent)
   end if
   call BEMT_PackParam(Buf, InData%BEMT) 
   call AA_PackParam(Buf, InData%AA) 
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   call RegPack(Buf, allocated(InData%dx))
   if (allocated(InData%dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dx), ubound(InData%dx))
      call RegPack(Buf, InData%dx)
   end if
   call RegPack(Buf, InData%Jac_ny)
   call RegPack(Buf, InData%NumBl_Lin)
   call RegPack(Buf, InData%TwrPotent)
   call RegPack(Buf, InData%TwrShadow)
   call RegPack(Buf, InData%TwrAero)
   call RegPack(Buf, InData%FrozenWake)
   call RegPack(Buf, InData%CavitCheck)
   call RegPack(Buf, InData%Buoyancy)
   call RegPack(Buf, InData%MHK)
   call RegPack(Buf, InData%CompAA)
   call RegPack(Buf, InData%AirDens)
   call RegPack(Buf, InData%KinVisc)
   call RegPack(Buf, InData%SpdSound)
   call RegPack(Buf, InData%Gravity)
   call RegPack(Buf, InData%Patm)
   call RegPack(Buf, InData%Pvap)
   call RegPack(Buf, InData%WtrDpth)
   call RegPack(Buf, InData%MSL2SWL)
   call RegPack(Buf, InData%AeroProjMod)
   call RegPack(Buf, InData%AeroBEM_Mod)
   call RegPack(Buf, InData%NumOuts)
   call RegPack(Buf, InData%RootName)
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   call RegPack(Buf, InData%NBlOuts)
   call RegPack(Buf, InData%BlOutNd)
   call RegPack(Buf, InData%NTwOuts)
   call RegPack(Buf, InData%TwOutNd)
   call RegPack(Buf, InData%BldNd_NumOuts)
   call RegPack(Buf, InData%BldNd_TotNumOuts)
   call RegPack(Buf, allocated(InData%BldNd_OutParam))
   if (allocated(InData%BldNd_OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_OutParam), ubound(InData%BldNd_OutParam))
      LB(1:1) = lbound(InData%BldNd_OutParam)
      UB(1:1) = ubound(InData%BldNd_OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%BldNd_OutParam(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%BldNd_BlOutNd))
   if (allocated(InData%BldNd_BlOutNd)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_BlOutNd), ubound(InData%BldNd_BlOutNd))
      call RegPack(Buf, InData%BldNd_BlOutNd)
   end if
   call RegPack(Buf, InData%BldNd_BladesOut)
   call RegPack(Buf, InData%TFinAero)
   call AD_PackTFinParameterType(Buf, InData%TFin) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotParameterType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrCd)) deallocate(OutData%TwrCd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrTI)) deallocate(OutData%TwrTI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlTwist)) deallocate(OutData%BlTwist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTwist(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTwist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrCb)) deallocate(OutData%TwrCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCenBn)) deallocate(OutData%BlCenBn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBn(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlCenBt)) deallocate(OutData%BlCenBt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VolBl)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%VolTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%BlRad)) deallocate(OutData%BlRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlRad(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlDL)) deallocate(OutData%BlDL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlDL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlDL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlDL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlTaper)) deallocate(OutData%BlTaper)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTaper(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTaper.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTaper)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%BlAxCent)) deallocate(OutData%BlAxCent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlAxCent(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAxCent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlAxCent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrRad)) deallocate(OutData%TwrRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrDL)) deallocate(OutData%TwrDL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrTaper)) deallocate(OutData%TwrTaper)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTaper(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTaper.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTaper)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TwrAxCent)) deallocate(OutData%TwrAxCent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrAxCent(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrAxCent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrAxCent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call BEMT_UnpackParam(Buf, OutData%BEMT) ! BEMT 
   call AA_UnpackParam(Buf, OutData%AA) ! AA 
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%dx)) deallocate(OutData%dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumBl_Lin)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   call RegUnpack(Buf, OutData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BldNd_TotNumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%BldNd_OutParam)) deallocate(OutData%BldNd_OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%BldNd_OutParam(i1)) ! BldNd_OutParam 
      end do
   end if
   if (allocated(OutData%BldNd_BlOutNd)) deallocate(OutData%BldNd_BlOutNd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_BlOutNd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_BlOutNd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BldNd_BlOutNd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   call AD_UnpackTFinParameterType(Buf, OutData%TFin) ! TFin 
end subroutine

subroutine AD_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(AD_ParameterType), intent(in) :: SrcParamData
   type(AD_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcParamData%rotors)) then
      LB(1:1) = lbound(SrcParamData%rotors)
      UB(1:1) = ubound(SrcParamData%rotors)
      if (.not. allocated(DstParamData%rotors)) then
         allocate(DstParamData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotParameterType(SrcParamData%rotors(i1), DstParamData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%DT = SrcParamData%DT
   DstParamData%RootName = SrcParamData%RootName
   if (allocated(SrcParamData%AFI)) then
      LB(1:1) = lbound(SrcParamData%AFI)
      UB(1:1) = ubound(SrcParamData%AFI)
      if (.not. allocated(DstParamData%AFI)) then
         allocate(DstParamData%AFI(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFI.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AFI_CopyParam(SrcParamData%AFI(i1), DstParamData%AFI(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%SkewMod = SrcParamData%SkewMod
   DstParamData%WakeMod = SrcParamData%WakeMod
   call FVW_CopyParam(SrcParamData%FVW, DstParamData%FVW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%CompAeroMaps = SrcParamData%CompAeroMaps
   DstParamData%UA_Flag = SrcParamData%UA_Flag
   DstParamData%FlowField => SrcParamData%FlowField
   DstParamData%WaveField => SrcParamData%WaveField
end subroutine

subroutine AD_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(AD_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%rotors)) then
      LB(1:1) = lbound(ParamData%rotors)
      UB(1:1) = ubound(ParamData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotParameterType(ParamData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%rotors)
   end if
   if (allocated(ParamData%AFI)) then
      LB(1:1) = lbound(ParamData%AFI)
      UB(1:1) = ubound(ParamData%AFI)
      do i1 = LB(1), UB(1)
         call AFI_DestroyParam(ParamData%AFI(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%AFI)
   end if
   call FVW_DestroyParam(ParamData%FVW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   nullify(ParamData%FlowField)
   nullify(ParamData%WaveField)
end subroutine

subroutine AD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackParam'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotParameterType(Buf, InData%rotors(i1)) 
      end do
   end if
   call RegPack(Buf, InData%DT)
   call RegPack(Buf, InData%RootName)
   call RegPack(Buf, allocated(InData%AFI))
   if (allocated(InData%AFI)) then
      call RegPackBounds(Buf, 1, lbound(InData%AFI), ubound(InData%AFI))
      LB(1:1) = lbound(InData%AFI)
      UB(1:1) = ubound(InData%AFI)
      do i1 = LB(1), UB(1)
         call AFI_PackParam(Buf, InData%AFI(i1)) 
      end do
   end if
   call RegPack(Buf, InData%SkewMod)
   call RegPack(Buf, InData%WakeMod)
   call FVW_PackParam(Buf, InData%FVW) 
   call RegPack(Buf, InData%CompAeroMaps)
   call RegPack(Buf, InData%UA_Flag)
   call RegPack(Buf, associated(InData%FlowField))
   if (associated(InData%FlowField)) then
      call RegPackPointer(Buf, c_loc(InData%FlowField), PtrInIndex)
      if (.not. PtrInIndex) then
         call IfW_FlowField_PackFlowFieldType(Buf, InData%FlowField) 
      end if
   end if
   call RegPack(Buf, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(Buf, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(Buf, InData%WaveField) 
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackParam'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotParameterType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%AFI)) deallocate(OutData%AFI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AFI_UnpackParam(Buf, OutData%AFI(i1)) ! AFI 
      end do
   end if
   call RegUnpack(Buf, OutData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call FVW_UnpackParam(Buf, OutData%FVW) ! FVW 
   call RegUnpack(Buf, OutData%CompAeroMaps)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   if (associated(OutData%FlowField)) deallocate(OutData%FlowField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%FlowField)
      else
         allocate(OutData%FlowField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FlowField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%FlowField)
         call IfW_FlowField_UnpackFlowFieldType(Buf, OutData%FlowField) ! FlowField 
      end if
   else
      OutData%FlowField => null()
   end if
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(Buf, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
end subroutine

subroutine AD_CopyBldInputType(SrcBldInputTypeData, DstBldInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(BldInputType), intent(in) :: SrcBldInputTypeData
   type(BldInputType), intent(inout) :: DstBldInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'AD_CopyBldInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBldInputTypeData%InflowOnBlade)) then
      LB(1:2) = lbound(SrcBldInputTypeData%InflowOnBlade)
      UB(1:2) = ubound(SrcBldInputTypeData%InflowOnBlade)
      if (.not. allocated(DstBldInputTypeData%InflowOnBlade)) then
         allocate(DstBldInputTypeData%InflowOnBlade(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBldInputTypeData%InflowOnBlade.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBldInputTypeData%InflowOnBlade = SrcBldInputTypeData%InflowOnBlade
   end if
   if (allocated(SrcBldInputTypeData%AccelOnBlade)) then
      LB(1:2) = lbound(SrcBldInputTypeData%AccelOnBlade)
      UB(1:2) = ubound(SrcBldInputTypeData%AccelOnBlade)
      if (.not. allocated(DstBldInputTypeData%AccelOnBlade)) then
         allocate(DstBldInputTypeData%AccelOnBlade(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBldInputTypeData%AccelOnBlade.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBldInputTypeData%AccelOnBlade = SrcBldInputTypeData%AccelOnBlade
   end if
end subroutine

subroutine AD_DestroyBldInputType(BldInputTypeData, ErrStat, ErrMsg)
   type(BldInputType), intent(inout) :: BldInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'AD_DestroyBldInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BldInputTypeData%InflowOnBlade)) then
      deallocate(BldInputTypeData%InflowOnBlade)
   end if
   if (allocated(BldInputTypeData%AccelOnBlade)) then
      deallocate(BldInputTypeData%AccelOnBlade)
   end if
end subroutine

subroutine AD_PackBldInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BldInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackBldInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%InflowOnBlade))
   if (allocated(InData%InflowOnBlade)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowOnBlade), ubound(InData%InflowOnBlade))
      call RegPack(Buf, InData%InflowOnBlade)
   end if
   call RegPack(Buf, allocated(InData%AccelOnBlade))
   if (allocated(InData%AccelOnBlade)) then
      call RegPackBounds(Buf, 2, lbound(InData%AccelOnBlade), ubound(InData%AccelOnBlade))
      call RegPack(Buf, InData%AccelOnBlade)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackBldInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BldInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackBldInputType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%InflowOnBlade)) deallocate(OutData%InflowOnBlade)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowOnBlade(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnBlade.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowOnBlade)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AccelOnBlade)) deallocate(OutData%AccelOnBlade)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccelOnBlade(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccelOnBlade.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccelOnBlade)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotInputType(SrcRotInputTypeData, DstRotInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotInputType), intent(inout) :: SrcRotInputTypeData
   type(RotInputType), intent(inout) :: DstRotInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcRotInputTypeData%NacelleMotion, DstRotInputTypeData%NacelleMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcRotInputTypeData%TowerMotion, DstRotInputTypeData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcRotInputTypeData%HubMotion, DstRotInputTypeData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotInputTypeData%BladeRootMotion)) then
      LB(1:1) = lbound(SrcRotInputTypeData%BladeRootMotion)
      UB(1:1) = ubound(SrcRotInputTypeData%BladeRootMotion)
      if (.not. allocated(DstRotInputTypeData%BladeRootMotion)) then
         allocate(DstRotInputTypeData%BladeRootMotion(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeRootMotion.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotInputTypeData%BladeRootMotion(i1), DstRotInputTypeData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotInputTypeData%BladeMotion)) then
      LB(1:1) = lbound(SrcRotInputTypeData%BladeMotion)
      UB(1:1) = ubound(SrcRotInputTypeData%BladeMotion)
      if (.not. allocated(DstRotInputTypeData%BladeMotion)) then
         allocate(DstRotInputTypeData%BladeMotion(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeMotion.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotInputTypeData%BladeMotion(i1), DstRotInputTypeData%BladeMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcRotInputTypeData%TFinMotion, DstRotInputTypeData%TFinMotion, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotInputTypeData%Bld)) then
      LB(1:1) = lbound(SrcRotInputTypeData%Bld)
      UB(1:1) = ubound(SrcRotInputTypeData%Bld)
      if (.not. allocated(DstRotInputTypeData%Bld)) then
         allocate(DstRotInputTypeData%Bld(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%Bld.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyBldInputType(SrcRotInputTypeData%Bld(i1), DstRotInputTypeData%Bld(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcRotInputTypeData%InflowOnTower)) then
      LB(1:2) = lbound(SrcRotInputTypeData%InflowOnTower)
      UB(1:2) = ubound(SrcRotInputTypeData%InflowOnTower)
      if (.not. allocated(DstRotInputTypeData%InflowOnTower)) then
         allocate(DstRotInputTypeData%InflowOnTower(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%InflowOnTower.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputTypeData%InflowOnTower = SrcRotInputTypeData%InflowOnTower
   end if
   if (allocated(SrcRotInputTypeData%AccelOnTower)) then
      LB(1:2) = lbound(SrcRotInputTypeData%AccelOnTower)
      UB(1:2) = ubound(SrcRotInputTypeData%AccelOnTower)
      if (.not. allocated(DstRotInputTypeData%AccelOnTower)) then
         allocate(DstRotInputTypeData%AccelOnTower(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%AccelOnTower.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputTypeData%AccelOnTower = SrcRotInputTypeData%AccelOnTower
   end if
   DstRotInputTypeData%InflowOnHub = SrcRotInputTypeData%InflowOnHub
   DstRotInputTypeData%InflowOnNacelle = SrcRotInputTypeData%InflowOnNacelle
   DstRotInputTypeData%InflowOnTailFin = SrcRotInputTypeData%InflowOnTailFin
   if (allocated(SrcRotInputTypeData%UserProp)) then
      LB(1:2) = lbound(SrcRotInputTypeData%UserProp)
      UB(1:2) = ubound(SrcRotInputTypeData%UserProp)
      if (.not. allocated(DstRotInputTypeData%UserProp)) then
         allocate(DstRotInputTypeData%UserProp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%UserProp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotInputTypeData%UserProp = SrcRotInputTypeData%UserProp
   end if
end subroutine

subroutine AD_DestroyRotInputType(RotInputTypeData, ErrStat, ErrMsg)
   type(RotInputType), intent(inout) :: RotInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( RotInputTypeData%NacelleMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( RotInputTypeData%TowerMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( RotInputTypeData%HubMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotInputTypeData%BladeRootMotion)) then
      LB(1:1) = lbound(RotInputTypeData%BladeRootMotion)
      UB(1:1) = ubound(RotInputTypeData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotInputTypeData%BladeRootMotion(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInputTypeData%BladeRootMotion)
   end if
   if (allocated(RotInputTypeData%BladeMotion)) then
      LB(1:1) = lbound(RotInputTypeData%BladeMotion)
      UB(1:1) = ubound(RotInputTypeData%BladeMotion)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotInputTypeData%BladeMotion(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInputTypeData%BladeMotion)
   end if
   call MeshDestroy( RotInputTypeData%TFinMotion, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotInputTypeData%Bld)) then
      LB(1:1) = lbound(RotInputTypeData%Bld)
      UB(1:1) = ubound(RotInputTypeData%Bld)
      do i1 = LB(1), UB(1)
         call AD_DestroyBldInputType(RotInputTypeData%Bld(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotInputTypeData%Bld)
   end if
   if (allocated(RotInputTypeData%InflowOnTower)) then
      deallocate(RotInputTypeData%InflowOnTower)
   end if
   if (allocated(RotInputTypeData%AccelOnTower)) then
      deallocate(RotInputTypeData%AccelOnTower)
   end if
   if (allocated(RotInputTypeData%UserProp)) then
      deallocate(RotInputTypeData%UserProp)
   end if
end subroutine

subroutine AD_PackRotInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInputType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call MeshPack(Buf, InData%NacelleMotion) 
   call MeshPack(Buf, InData%TowerMotion) 
   call MeshPack(Buf, InData%HubMotion) 
   call RegPack(Buf, allocated(InData%BladeRootMotion))
   if (allocated(InData%BladeRootMotion)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeRootMotion), ubound(InData%BladeRootMotion))
      LB(1:1) = lbound(InData%BladeRootMotion)
      UB(1:1) = ubound(InData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeRootMotion(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%BladeMotion))
   if (allocated(InData%BladeMotion)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeMotion), ubound(InData%BladeMotion))
      LB(1:1) = lbound(InData%BladeMotion)
      UB(1:1) = ubound(InData%BladeMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeMotion(i1)) 
      end do
   end if
   call MeshPack(Buf, InData%TFinMotion) 
   call RegPack(Buf, allocated(InData%Bld))
   if (allocated(InData%Bld)) then
      call RegPackBounds(Buf, 1, lbound(InData%Bld), ubound(InData%Bld))
      LB(1:1) = lbound(InData%Bld)
      UB(1:1) = ubound(InData%Bld)
      do i1 = LB(1), UB(1)
         call AD_PackBldInputType(Buf, InData%Bld(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%InflowOnTower))
   if (allocated(InData%InflowOnTower)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowOnTower), ubound(InData%InflowOnTower))
      call RegPack(Buf, InData%InflowOnTower)
   end if
   call RegPack(Buf, allocated(InData%AccelOnTower))
   if (allocated(InData%AccelOnTower)) then
      call RegPackBounds(Buf, 2, lbound(InData%AccelOnTower), ubound(InData%AccelOnTower))
      call RegPack(Buf, InData%AccelOnTower)
   end if
   call RegPack(Buf, InData%InflowOnHub)
   call RegPack(Buf, InData%InflowOnNacelle)
   call RegPack(Buf, InData%InflowOnTailFin)
   call RegPack(Buf, allocated(InData%UserProp))
   if (allocated(InData%UserProp)) then
      call RegPackBounds(Buf, 2, lbound(InData%UserProp), ubound(InData%UserProp))
      call RegPack(Buf, InData%UserProp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInputType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call MeshUnpack(Buf, OutData%NacelleMotion) ! NacelleMotion 
   call MeshUnpack(Buf, OutData%TowerMotion) ! TowerMotion 
   call MeshUnpack(Buf, OutData%HubMotion) ! HubMotion 
   if (allocated(OutData%BladeRootMotion)) deallocate(OutData%BladeRootMotion)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeRootMotion(i1)) ! BladeRootMotion 
      end do
   end if
   if (allocated(OutData%BladeMotion)) deallocate(OutData%BladeMotion)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeMotion.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeMotion(i1)) ! BladeMotion 
      end do
   end if
   call MeshUnpack(Buf, OutData%TFinMotion) ! TFinMotion 
   if (allocated(OutData%Bld)) deallocate(OutData%Bld)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Bld(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bld.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBldInputType(Buf, OutData%Bld(i1)) ! Bld 
      end do
   end if
   if (allocated(OutData%InflowOnTower)) deallocate(OutData%InflowOnTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowOnTower(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowOnTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AccelOnTower)) deallocate(OutData%AccelOnTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccelOnTower(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccelOnTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccelOnTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%InflowOnHub)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InflowOnNacelle)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%InflowOnTailFin)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%UserProp)) deallocate(OutData%UserProp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UserProp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UserProp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UserProp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(AD_InputType), intent(inout) :: SrcInputData
   type(AD_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInputData%rotors)) then
      LB(1:1) = lbound(SrcInputData%rotors)
      UB(1:1) = ubound(SrcInputData%rotors)
      if (.not. allocated(DstInputData%rotors)) then
         allocate(DstInputData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotInputType(SrcInputData%rotors(i1), DstInputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInputData%InflowWakeVel)) then
      LB(1:2) = lbound(SrcInputData%InflowWakeVel)
      UB(1:2) = ubound(SrcInputData%InflowWakeVel)
      if (.not. allocated(DstInputData%InflowWakeVel)) then
         allocate(DstInputData%InflowWakeVel(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowWakeVel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%InflowWakeVel = SrcInputData%InflowWakeVel
   end if
end subroutine

subroutine AD_DestroyInput(InputData, ErrStat, ErrMsg)
   type(AD_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%rotors)) then
      LB(1:1) = lbound(InputData%rotors)
      UB(1:1) = ubound(InputData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotInputType(InputData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InputData%rotors)
   end if
   if (allocated(InputData%InflowWakeVel)) then
      deallocate(InputData%InflowWakeVel)
   end if
end subroutine

subroutine AD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInputType(Buf, InData%rotors(i1)) 
      end do
   end if
   call RegPack(Buf, allocated(InData%InflowWakeVel))
   if (allocated(InData%InflowWakeVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowWakeVel), ubound(InData%InflowWakeVel))
      call RegPack(Buf, InData%InflowWakeVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   if (allocated(OutData%InflowWakeVel)) deallocate(OutData%InflowWakeVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowWakeVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowWakeVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowWakeVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyRotOutputType(SrcRotOutputTypeData, DstRotOutputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(RotOutputType), intent(inout) :: SrcRotOutputTypeData
   type(RotOutputType), intent(inout) :: DstRotOutputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyRotOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcRotOutputTypeData%NacelleLoad, DstRotOutputTypeData%NacelleLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcRotOutputTypeData%HubLoad, DstRotOutputTypeData%HubLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcRotOutputTypeData%TowerLoad, DstRotOutputTypeData%TowerLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotOutputTypeData%BladeLoad)) then
      LB(1:1) = lbound(SrcRotOutputTypeData%BladeLoad)
      UB(1:1) = ubound(SrcRotOutputTypeData%BladeLoad)
      if (.not. allocated(DstRotOutputTypeData%BladeLoad)) then
         allocate(DstRotOutputTypeData%BladeLoad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotOutputTypeData%BladeLoad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcRotOutputTypeData%BladeLoad(i1), DstRotOutputTypeData%BladeLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MeshCopy(SrcRotOutputTypeData%TFinLoad, DstRotOutputTypeData%TFinLoad, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcRotOutputTypeData%WriteOutput)) then
      LB(1:1) = lbound(SrcRotOutputTypeData%WriteOutput)
      UB(1:1) = ubound(SrcRotOutputTypeData%WriteOutput)
      if (.not. allocated(DstRotOutputTypeData%WriteOutput)) then
         allocate(DstRotOutputTypeData%WriteOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRotOutputTypeData%WriteOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRotOutputTypeData%WriteOutput = SrcRotOutputTypeData%WriteOutput
   end if
end subroutine

subroutine AD_DestroyRotOutputType(RotOutputTypeData, ErrStat, ErrMsg)
   type(RotOutputType), intent(inout) :: RotOutputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyRotOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( RotOutputTypeData%NacelleLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( RotOutputTypeData%HubLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( RotOutputTypeData%TowerLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotOutputTypeData%BladeLoad)) then
      LB(1:1) = lbound(RotOutputTypeData%BladeLoad)
      UB(1:1) = ubound(RotOutputTypeData%BladeLoad)
      do i1 = LB(1), UB(1)
         call MeshDestroy( RotOutputTypeData%BladeLoad(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(RotOutputTypeData%BladeLoad)
   end if
   call MeshDestroy( RotOutputTypeData%TFinLoad, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(RotOutputTypeData%WriteOutput)) then
      deallocate(RotOutputTypeData%WriteOutput)
   end if
end subroutine

subroutine AD_PackRotOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call MeshPack(Buf, InData%NacelleLoad) 
   call MeshPack(Buf, InData%HubLoad) 
   call MeshPack(Buf, InData%TowerLoad) 
   call RegPack(Buf, allocated(InData%BladeLoad))
   if (allocated(InData%BladeLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeLoad), ubound(InData%BladeLoad))
      LB(1:1) = lbound(InData%BladeLoad)
      UB(1:1) = ubound(InData%BladeLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeLoad(i1)) 
      end do
   end if
   call MeshPack(Buf, InData%TFinLoad) 
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call MeshUnpack(Buf, OutData%NacelleLoad) ! NacelleLoad 
   call MeshUnpack(Buf, OutData%HubLoad) ! HubLoad 
   call MeshUnpack(Buf, OutData%TowerLoad) ! TowerLoad 
   if (allocated(OutData%BladeLoad)) deallocate(OutData%BladeLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeLoad(i1)) ! BladeLoad 
      end do
   end if
   call MeshUnpack(Buf, OutData%TFinLoad) ! TFinLoad 
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine AD_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(AD_OutputType), intent(inout) :: SrcOutputData
   type(AD_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%rotors)) then
      LB(1:1) = lbound(SrcOutputData%rotors)
      UB(1:1) = ubound(SrcOutputData%rotors)
      if (.not. allocated(DstOutputData%rotors)) then
         allocate(DstOutputData%rotors(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%rotors.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyRotOutputType(SrcOutputData%rotors(i1), DstOutputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine AD_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(AD_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'AD_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%rotors)) then
      LB(1:1) = lbound(OutputData%rotors)
      UB(1:1) = ubound(OutputData%rotors)
      do i1 = LB(1), UB(1)
         call AD_DestroyRotOutputType(OutputData%rotors(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%rotors)
   end if
end subroutine

subroutine AD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotOutputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotOutputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
end subroutine

subroutine AD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
   ! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(AD_InputType), intent(inout)  :: u(:) ! Input at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Inputs
   type(AD_InputType), intent(inout)  :: u_out ! Input at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'AD_Input_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(u)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(u)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(u) - 1
   select case (order)
   case (0)
      call AD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call AD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call AD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(u) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE AD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

   TYPE(AD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
   TYPE(AD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
   TYPE(AD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'AD_Input_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i11      ! dim1 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i02      ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i12      ! dim2 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   INTEGER                                    :: i2       ! dim2 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp1(u1%rotors(i01)%NacelleMotion, u2%rotors(i01)%NacelleMotion, tin, u_out%rotors(i01)%NacelleMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
<<<<<<< HEAD
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%InflowOnTower,2),UBOUND(u_out%rotors(i01)%InflowOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTower,1),UBOUND(u_out%rotors(i01)%InflowOnTower,1)
      b = -(u1%rotors(i01)%InflowOnTower(i1,i2) - u2%rotors(i01)%InflowOnTower(i1,i2))
      u_out%rotors(i01)%InflowOnTower(i1,i2) = u1%rotors(i01)%InflowOnTower(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnHub,1),UBOUND(u_out%rotors(i01)%InflowOnHub,1)
    b = -(u1%rotors(i01)%InflowOnHub(i1) - u2%rotors(i01)%InflowOnHub(i1))
    u_out%rotors(i01)%InflowOnHub(i1) = u1%rotors(i01)%InflowOnHub(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnNacelle,1),UBOUND(u_out%rotors(i01)%InflowOnNacelle,1)
    b = -(u1%rotors(i01)%InflowOnNacelle(i1) - u2%rotors(i01)%InflowOnNacelle(i1))
    u_out%rotors(i01)%InflowOnNacelle(i1) = u1%rotors(i01)%InflowOnNacelle(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTailFin,1),UBOUND(u_out%rotors(i01)%InflowOnTailFin,1)
    b = -(u1%rotors(i01)%InflowOnTailFin(i1) - u2%rotors(i01)%InflowOnTailFin(i1))
    u_out%rotors(i01)%InflowOnTailFin(i1) = u1%rotors(i01)%InflowOnTailFin(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%AccelOnBlade) .AND. ALLOCATED(u1%rotors(i01)%AccelOnBlade)) THEN
  DO i3 = LBOUND(u_out%rotors(i01)%AccelOnBlade,3),UBOUND(u_out%rotors(i01)%AccelOnBlade,3)
    DO i2 = LBOUND(u_out%rotors(i01)%AccelOnBlade,2),UBOUND(u_out%rotors(i01)%AccelOnBlade,2)
      DO i1 = LBOUND(u_out%rotors(i01)%AccelOnBlade,1),UBOUND(u_out%rotors(i01)%AccelOnBlade,1)
        b = -(u1%rotors(i01)%AccelOnBlade(i1,i2,i3) - u2%rotors(i01)%AccelOnBlade(i1,i2,i3))
        u_out%rotors(i01)%AccelOnBlade(i1,i2,i3) = u1%rotors(i01)%AccelOnBlade(i1,i2,i3) + b * ScaleFactor
      END DO
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%AccelOnTower) .AND. ALLOCATED(u1%rotors(i01)%AccelOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%AccelOnTower,2),UBOUND(u_out%rotors(i01)%AccelOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%AccelOnTower,1),UBOUND(u_out%rotors(i01)%AccelOnTower,1)
      b = -(u1%rotors(i01)%AccelOnTower(i1,i2) - u2%rotors(i01)%AccelOnTower(i1,i2))
      u_out%rotors(i01)%AccelOnTower(i1,i2) = u1%rotors(i01)%AccelOnTower(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%UserProp,2),UBOUND(u_out%rotors(i01)%UserProp,2)
    DO i1 = LBOUND(u_out%rotors(i01)%UserProp,1),UBOUND(u_out%rotors(i01)%UserProp,1)
      b = -(u1%rotors(i01)%UserProp(i1,i2) - u2%rotors(i01)%UserProp(i1,i2))
      u_out%rotors(i01)%UserProp(i1,i2) = u1%rotors(i01)%UserProp(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
  DO i2 = LBOUND(u_out%InflowWakeVel,2),UBOUND(u_out%InflowWakeVel,2)
    DO i1 = LBOUND(u_out%InflowWakeVel,1),UBOUND(u_out%InflowWakeVel,1)
      b = -(u1%InflowWakeVel(i1,i2) - u2%InflowWakeVel(i1,i2))
      u_out%InflowWakeVel(i1,i2) = u1%InflowWakeVel(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE AD_Input_ExtrapInterp1
=======
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp1(u1%rotors(i01)%TowerMotion, u2%rotors(i01)%TowerMotion, tin, u_out%rotors(i01)%TowerMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp1(u1%rotors(i01)%HubMotion, u2%rotors(i01)%HubMotion, tin, u_out%rotors(i01)%HubMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%BladeRootMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeRootMotion)) THEN
            DO i1 = LBOUND(u_out%rotors(i01)%BladeRootMotion,1),UBOUND(u_out%rotors(i01)%BladeRootMotion,1)
               CALL MeshExtrapInterp1(u1%rotors(i01)%BladeRootMotion(i1), u2%rotors(i01)%BladeRootMotion(i1), tin, u_out%rotors(i01)%BladeRootMotion(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%BladeMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeMotion)) THEN
            DO i1 = LBOUND(u_out%rotors(i01)%BladeMotion,1),UBOUND(u_out%rotors(i01)%BladeMotion,1)
               CALL MeshExtrapInterp1(u1%rotors(i01)%BladeMotion(i1), u2%rotors(i01)%BladeMotion(i1), tin, u_out%rotors(i01)%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp1(u1%rotors(i01)%TFinMotion, u2%rotors(i01)%TFinMotion, tin, u_out%rotors(i01)%TFinMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%Bld) .AND. ALLOCATED(u1%rotors(i01)%Bld)) THEN
            DO i11 = LBOUND(u_out%rotors(i01)%Bld,1),UBOUND(u_out%rotors(i01)%Bld,1)
               IF (ALLOCATED(u_out%rotors(i01)%Bld(i11)%InflowOnBlade) .AND. ALLOCATED(u1%rotors(i01)%Bld(i11)%InflowOnBlade)) THEN
                  u_out%rotors(i01)%Bld(i11)%InflowOnBlade = a1*u1%rotors(i01)%Bld(i11)%InflowOnBlade + a2*u2%rotors(i01)%Bld(i11)%InflowOnBlade
               END IF ! check if allocated
            END DO
            DO i11 = LBOUND(u_out%rotors(i01)%Bld,1),UBOUND(u_out%rotors(i01)%Bld,1)
               IF (ALLOCATED(u_out%rotors(i01)%Bld(i11)%AccelOnBlade) .AND. ALLOCATED(u1%rotors(i01)%Bld(i11)%AccelOnBlade)) THEN
                  u_out%rotors(i01)%Bld(i11)%AccelOnBlade = a1*u1%rotors(i01)%Bld(i11)%AccelOnBlade + a2*u2%rotors(i01)%Bld(i11)%AccelOnBlade
               END IF ! check if allocated
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
            u_out%rotors(i01)%InflowOnTower = a1*u1%rotors(i01)%InflowOnTower + a2*u2%rotors(i01)%InflowOnTower
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%AccelOnTower) .AND. ALLOCATED(u1%rotors(i01)%AccelOnTower)) THEN
            u_out%rotors(i01)%AccelOnTower = a1*u1%rotors(i01)%AccelOnTower + a2*u2%rotors(i01)%AccelOnTower
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnHub = a1*u1%rotors(i01)%InflowOnHub + a2*u2%rotors(i01)%InflowOnHub
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnNacelle = a1*u1%rotors(i01)%InflowOnNacelle + a2*u2%rotors(i01)%InflowOnNacelle
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnTailFin = a1*u1%rotors(i01)%InflowOnTailFin + a2*u2%rotors(i01)%InflowOnTailFin
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
            u_out%rotors(i01)%UserProp = a1*u1%rotors(i01)%UserProp + a2*u2%rotors(i01)%UserProp
         END IF ! check if allocated
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
      u_out%InflowWakeVel = a1*u1%InflowWakeVel + a2*u2%InflowWakeVel
   END IF ! check if allocated
END SUBROUTINE
>>>>>>> luwang00/f/IfW_SeaSt_Coupling

SUBROUTINE AD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

   TYPE(AD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
   TYPE(AD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
   TYPE(AD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
   TYPE(AD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'AD_Input_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   INTEGER                                    :: i2    ! dim2 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp2(u1%rotors(i01)%NacelleMotion, u2%rotors(i01)%NacelleMotion, u3%rotors(i01)%NacelleMotion, tin, u_out%rotors(i01)%NacelleMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
<<<<<<< HEAD
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%InflowOnTower,2),UBOUND(u_out%rotors(i01)%InflowOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTower,1),UBOUND(u_out%rotors(i01)%InflowOnTower,1)
      b = (t(3)**2*(u1%rotors(i01)%InflowOnTower(i1,i2) - u2%rotors(i01)%InflowOnTower(i1,i2)) + t(2)**2*(-u1%rotors(i01)%InflowOnTower(i1,i2) + u3%rotors(i01)%InflowOnTower(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnTower(i1,i2) + t(3)*u2%rotors(i01)%InflowOnTower(i1,i2) - t(2)*u3%rotors(i01)%InflowOnTower(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%InflowOnTower(i1,i2) = u1%rotors(i01)%InflowOnTower(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnHub,1),UBOUND(u_out%rotors(i01)%InflowOnHub,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnHub(i1) - u2%rotors(i01)%InflowOnHub(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnHub(i1) + u3%rotors(i01)%InflowOnHub(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnHub(i1) + t(3)*u2%rotors(i01)%InflowOnHub(i1) - t(2)*u3%rotors(i01)%InflowOnHub(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnHub(i1) = u1%rotors(i01)%InflowOnHub(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnNacelle,1),UBOUND(u_out%rotors(i01)%InflowOnNacelle,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnNacelle(i1) - u2%rotors(i01)%InflowOnNacelle(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnNacelle(i1) + u3%rotors(i01)%InflowOnNacelle(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnNacelle(i1) + t(3)*u2%rotors(i01)%InflowOnNacelle(i1) - t(2)*u3%rotors(i01)%InflowOnNacelle(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnNacelle(i1) = u1%rotors(i01)%InflowOnNacelle(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTailFin,1),UBOUND(u_out%rotors(i01)%InflowOnTailFin,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnTailFin(i1) - u2%rotors(i01)%InflowOnTailFin(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnTailFin(i1) + u3%rotors(i01)%InflowOnTailFin(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnTailFin(i1) + t(3)*u2%rotors(i01)%InflowOnTailFin(i1) - t(2)*u3%rotors(i01)%InflowOnTailFin(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnTailFin(i1) = u1%rotors(i01)%InflowOnTailFin(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%AccelOnBlade) .AND. ALLOCATED(u1%rotors(i01)%AccelOnBlade)) THEN
  DO i3 = LBOUND(u_out%rotors(i01)%AccelOnBlade,3),UBOUND(u_out%rotors(i01)%AccelOnBlade,3)
    DO i2 = LBOUND(u_out%rotors(i01)%AccelOnBlade,2),UBOUND(u_out%rotors(i01)%AccelOnBlade,2)
      DO i1 = LBOUND(u_out%rotors(i01)%AccelOnBlade,1),UBOUND(u_out%rotors(i01)%AccelOnBlade,1)
        b = (t(3)**2*(u1%rotors(i01)%AccelOnBlade(i1,i2,i3) - u2%rotors(i01)%AccelOnBlade(i1,i2,i3)) + t(2)**2*(-u1%rotors(i01)%AccelOnBlade(i1,i2,i3) + u3%rotors(i01)%AccelOnBlade(i1,i2,i3)))* scaleFactor
        c = ( (t(2)-t(3))*u1%rotors(i01)%AccelOnBlade(i1,i2,i3) + t(3)*u2%rotors(i01)%AccelOnBlade(i1,i2,i3) - t(2)*u3%rotors(i01)%AccelOnBlade(i1,i2,i3) ) * scaleFactor
        u_out%rotors(i01)%AccelOnBlade(i1,i2,i3) = u1%rotors(i01)%AccelOnBlade(i1,i2,i3) + b  + c * t_out
      END DO
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%AccelOnTower) .AND. ALLOCATED(u1%rotors(i01)%AccelOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%AccelOnTower,2),UBOUND(u_out%rotors(i01)%AccelOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%AccelOnTower,1),UBOUND(u_out%rotors(i01)%AccelOnTower,1)
      b = (t(3)**2*(u1%rotors(i01)%AccelOnTower(i1,i2) - u2%rotors(i01)%AccelOnTower(i1,i2)) + t(2)**2*(-u1%rotors(i01)%AccelOnTower(i1,i2) + u3%rotors(i01)%AccelOnTower(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%AccelOnTower(i1,i2) + t(3)*u2%rotors(i01)%AccelOnTower(i1,i2) - t(2)*u3%rotors(i01)%AccelOnTower(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%AccelOnTower(i1,i2) = u1%rotors(i01)%AccelOnTower(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%UserProp,2),UBOUND(u_out%rotors(i01)%UserProp,2)
    DO i1 = LBOUND(u_out%rotors(i01)%UserProp,1),UBOUND(u_out%rotors(i01)%UserProp,1)
      b = (t(3)**2*(u1%rotors(i01)%UserProp(i1,i2) - u2%rotors(i01)%UserProp(i1,i2)) + t(2)**2*(-u1%rotors(i01)%UserProp(i1,i2) + u3%rotors(i01)%UserProp(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%UserProp(i1,i2) + t(3)*u2%rotors(i01)%UserProp(i1,i2) - t(2)*u3%rotors(i01)%UserProp(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%UserProp(i1,i2) = u1%rotors(i01)%UserProp(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
  DO i2 = LBOUND(u_out%InflowWakeVel,2),UBOUND(u_out%InflowWakeVel,2)
    DO i1 = LBOUND(u_out%InflowWakeVel,1),UBOUND(u_out%InflowWakeVel,1)
      b = (t(3)**2*(u1%InflowWakeVel(i1,i2) - u2%InflowWakeVel(i1,i2)) + t(2)**2*(-u1%InflowWakeVel(i1,i2) + u3%InflowWakeVel(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%InflowWakeVel(i1,i2) + t(3)*u2%InflowWakeVel(i1,i2) - t(2)*u3%InflowWakeVel(i1,i2) ) * scaleFactor
      u_out%InflowWakeVel(i1,i2) = u1%InflowWakeVel(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE AD_Input_ExtrapInterp2
=======
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp2(u1%rotors(i01)%TowerMotion, u2%rotors(i01)%TowerMotion, u3%rotors(i01)%TowerMotion, tin, u_out%rotors(i01)%TowerMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp2(u1%rotors(i01)%HubMotion, u2%rotors(i01)%HubMotion, u3%rotors(i01)%HubMotion, tin, u_out%rotors(i01)%HubMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%BladeRootMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeRootMotion)) THEN
            DO i1 = LBOUND(u_out%rotors(i01)%BladeRootMotion,1),UBOUND(u_out%rotors(i01)%BladeRootMotion,1)
               CALL MeshExtrapInterp2(u1%rotors(i01)%BladeRootMotion(i1), u2%rotors(i01)%BladeRootMotion(i1), u3%rotors(i01)%BladeRootMotion(i1), tin, u_out%rotors(i01)%BladeRootMotion(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%BladeMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeMotion)) THEN
            DO i1 = LBOUND(u_out%rotors(i01)%BladeMotion,1),UBOUND(u_out%rotors(i01)%BladeMotion,1)
               CALL MeshExtrapInterp2(u1%rotors(i01)%BladeMotion(i1), u2%rotors(i01)%BladeMotion(i1), u3%rotors(i01)%BladeMotion(i1), tin, u_out%rotors(i01)%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         CALL MeshExtrapInterp2(u1%rotors(i01)%TFinMotion, u2%rotors(i01)%TFinMotion, u3%rotors(i01)%TFinMotion, tin, u_out%rotors(i01)%TFinMotion, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%Bld) .AND. ALLOCATED(u1%rotors(i01)%Bld)) THEN
            DO i11 = LBOUND(u_out%rotors(i01)%Bld,1),UBOUND(u_out%rotors(i01)%Bld,1)
               IF (ALLOCATED(u_out%rotors(i01)%Bld(i11)%InflowOnBlade) .AND. ALLOCATED(u1%rotors(i01)%Bld(i11)%InflowOnBlade)) THEN
                  u_out%rotors(i01)%Bld(i11)%InflowOnBlade = a1*u1%rotors(i01)%Bld(i11)%InflowOnBlade + a2*u2%rotors(i01)%Bld(i11)%InflowOnBlade + a3*u3%rotors(i01)%Bld(i11)%InflowOnBlade
               END IF ! check if allocated
            END DO
            DO i11 = LBOUND(u_out%rotors(i01)%Bld,1),UBOUND(u_out%rotors(i01)%Bld,1)
               IF (ALLOCATED(u_out%rotors(i01)%Bld(i11)%AccelOnBlade) .AND. ALLOCATED(u1%rotors(i01)%Bld(i11)%AccelOnBlade)) THEN
                  u_out%rotors(i01)%Bld(i11)%AccelOnBlade = a1*u1%rotors(i01)%Bld(i11)%AccelOnBlade + a2*u2%rotors(i01)%Bld(i11)%AccelOnBlade + a3*u3%rotors(i01)%Bld(i11)%AccelOnBlade
               END IF ! check if allocated
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
            u_out%rotors(i01)%InflowOnTower = a1*u1%rotors(i01)%InflowOnTower + a2*u2%rotors(i01)%InflowOnTower + a3*u3%rotors(i01)%InflowOnTower
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%AccelOnTower) .AND. ALLOCATED(u1%rotors(i01)%AccelOnTower)) THEN
            u_out%rotors(i01)%AccelOnTower = a1*u1%rotors(i01)%AccelOnTower + a2*u2%rotors(i01)%AccelOnTower + a3*u3%rotors(i01)%AccelOnTower
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnHub = a1*u1%rotors(i01)%InflowOnHub + a2*u2%rotors(i01)%InflowOnHub + a3*u3%rotors(i01)%InflowOnHub
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnNacelle = a1*u1%rotors(i01)%InflowOnNacelle + a2*u2%rotors(i01)%InflowOnNacelle + a3*u3%rotors(i01)%InflowOnNacelle
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         u_out%rotors(i01)%InflowOnTailFin = a1*u1%rotors(i01)%InflowOnTailFin + a2*u2%rotors(i01)%InflowOnTailFin + a3*u3%rotors(i01)%InflowOnTailFin
      END DO
      DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
         IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
            u_out%rotors(i01)%UserProp = a1*u1%rotors(i01)%UserProp + a2*u2%rotors(i01)%UserProp + a3*u3%rotors(i01)%UserProp
         END IF ! check if allocated
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
      u_out%InflowWakeVel = a1*u1%InflowWakeVel + a2*u2%InflowWakeVel + a3*u3%InflowWakeVel
   END IF ! check if allocated
END SUBROUTINE
>>>>>>> luwang00/f/IfW_SeaSt_Coupling

subroutine AD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
   ! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(AD_OutputType), intent(inout)  :: y(:) ! Output at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Outputs
   type(AD_OutputType), intent(inout)  :: y_out ! Output at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'AD_Output_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(y)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(y)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(y) - 1
   select case (order)
   case (0)
      call AD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call AD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call AD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(y) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE AD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

   TYPE(AD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
   TYPE(AD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
   TYPE(AD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'AD_Output_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(y_out%rotors) .AND. ALLOCATED(y1%rotors)) THEN
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp1(y1%rotors(i01)%NacelleLoad, y2%rotors(i01)%NacelleLoad, tin, y_out%rotors(i01)%NacelleLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp1(y1%rotors(i01)%HubLoad, y2%rotors(i01)%HubLoad, tin, y_out%rotors(i01)%HubLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp1(y1%rotors(i01)%TowerLoad, y2%rotors(i01)%TowerLoad, tin, y_out%rotors(i01)%TowerLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         IF (ALLOCATED(y_out%rotors(i01)%BladeLoad) .AND. ALLOCATED(y1%rotors(i01)%BladeLoad)) THEN
            DO i1 = LBOUND(y_out%rotors(i01)%BladeLoad,1),UBOUND(y_out%rotors(i01)%BladeLoad,1)
               CALL MeshExtrapInterp1(y1%rotors(i01)%BladeLoad(i1), y2%rotors(i01)%BladeLoad(i1), tin, y_out%rotors(i01)%BladeLoad(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp1(y1%rotors(i01)%TFinLoad, y2%rotors(i01)%TFinLoad, tin, y_out%rotors(i01)%TFinLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         IF (ALLOCATED(y_out%rotors(i01)%WriteOutput) .AND. ALLOCATED(y1%rotors(i01)%WriteOutput)) THEN
            y_out%rotors(i01)%WriteOutput = a1*y1%rotors(i01)%WriteOutput + a2*y2%rotors(i01)%WriteOutput
         END IF ! check if allocated
      END DO
   END IF ! check if allocated
END SUBROUTINE

SUBROUTINE AD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

   TYPE(AD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
   TYPE(AD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
   TYPE(AD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
   TYPE(AD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'AD_Output_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(y_out%rotors) .AND. ALLOCATED(y1%rotors)) THEN
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp2(y1%rotors(i01)%NacelleLoad, y2%rotors(i01)%NacelleLoad, y3%rotors(i01)%NacelleLoad, tin, y_out%rotors(i01)%NacelleLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp2(y1%rotors(i01)%HubLoad, y2%rotors(i01)%HubLoad, y3%rotors(i01)%HubLoad, tin, y_out%rotors(i01)%HubLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp2(y1%rotors(i01)%TowerLoad, y2%rotors(i01)%TowerLoad, y3%rotors(i01)%TowerLoad, tin, y_out%rotors(i01)%TowerLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         IF (ALLOCATED(y_out%rotors(i01)%BladeLoad) .AND. ALLOCATED(y1%rotors(i01)%BladeLoad)) THEN
            DO i1 = LBOUND(y_out%rotors(i01)%BladeLoad,1),UBOUND(y_out%rotors(i01)%BladeLoad,1)
               CALL MeshExtrapInterp2(y1%rotors(i01)%BladeLoad(i1), y2%rotors(i01)%BladeLoad(i1), y3%rotors(i01)%BladeLoad(i1), tin, y_out%rotors(i01)%BladeLoad(i1), tin_out, ErrStat2, ErrMsg2)
                  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
            END DO
         END IF ! check if allocated
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         CALL MeshExtrapInterp2(y1%rotors(i01)%TFinLoad, y2%rotors(i01)%TFinLoad, y3%rotors(i01)%TFinLoad, tin, y_out%rotors(i01)%TFinLoad, tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
      DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
         IF (ALLOCATED(y_out%rotors(i01)%WriteOutput) .AND. ALLOCATED(y1%rotors(i01)%WriteOutput)) THEN
            y_out%rotors(i01)%WriteOutput = a1*y1%rotors(i01)%WriteOutput + a2*y2%rotors(i01)%WriteOutput + a3*y3%rotors(i01)%WriteOutput
         END IF ! check if allocated
      END DO
   END IF ! check if allocated
END SUBROUTINE
END MODULE AeroDyn_Types
!ENDOFREGISTRYGENERATEDFILE
