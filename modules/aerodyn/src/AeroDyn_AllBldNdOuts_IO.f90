! This module is an add on to AeroDyn 15 to allow output of Aerodynamic data at each blade node.
!
!  Copyright 2016   Envision Energy
!
MODULE AeroDyn_AllBldNdOuts_IO

   USE NWTC_Library
   USE NWTC_LAPACK
   USE AeroDyn_Types

   IMPLICIT NONE

   PRIVATE

   PUBLIC   :: AllBldNdOuts_InitOut
   PUBLIC   :: Calc_WriteAllBldNdOutput
   PUBLIC   :: AllBldNdOuts_SetParameters


      ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 6    ! The NREL allowed channel name length is usually 20.  We are making these of the form B#N##namesuffix


! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary.
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 12-Dec-2017 22:02:25.


     ! NOTES:
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"


     ! Blade:

   INTEGER(IntKi), PARAMETER      :: BldNd_VUndx    =  1
   INTEGER(IntKi), PARAMETER      :: BldNd_VUndy    =  2
   INTEGER(IntKi), PARAMETER      :: BldNd_VUndz    =  3
   INTEGER(IntKi), PARAMETER      :: BldNd_VDisx    =  4
   INTEGER(IntKi), PARAMETER      :: BldNd_VDisy    =  5
   INTEGER(IntKi), PARAMETER      :: BldNd_VDisz    =  6
   INTEGER(IntKi), PARAMETER      :: BldNd_STVx     =  7
   INTEGER(IntKi), PARAMETER      :: BldNd_STVy     =  8
   INTEGER(IntKi), PARAMETER      :: BldNd_STVz     =  9
   INTEGER(IntKi), PARAMETER      :: BldNd_VRel     = 10
   INTEGER(IntKi), PARAMETER      :: BldNd_DynP     = 11
   INTEGER(IntKi), PARAMETER      :: BldNd_Re       = 12
   INTEGER(IntKi), PARAMETER      :: BldNd_M        = 13
   INTEGER(IntKi), PARAMETER      :: BldNd_Vindx    = 14
   INTEGER(IntKi), PARAMETER      :: BldNd_Vindy    = 15
   INTEGER(IntKi), PARAMETER      :: BldNd_AxInd    = 16
   INTEGER(IntKi), PARAMETER      :: BldNd_TnInd    = 17
   INTEGER(IntKi), PARAMETER      :: BldNd_Alpha    = 18
   INTEGER(IntKi), PARAMETER      :: BldNd_Theta    = 19
   INTEGER(IntKi), PARAMETER      :: BldNd_Phi      = 20
   INTEGER(IntKi), PARAMETER      :: BldNd_Curve    = 21
   INTEGER(IntKi), PARAMETER      :: BldNd_Cl       = 22
   INTEGER(IntKi), PARAMETER      :: BldNd_Cd       = 23
   INTEGER(IntKi), PARAMETER      :: BldNd_Cm       = 24
   INTEGER(IntKi), PARAMETER      :: BldNd_Cx       = 25
   INTEGER(IntKi), PARAMETER      :: BldNd_Cy       = 26
   INTEGER(IntKi), PARAMETER      :: BldNd_Cn       = 27
   INTEGER(IntKi), PARAMETER      :: BldNd_Ct       = 28
   INTEGER(IntKi), PARAMETER      :: BldNd_Fl       = 29
   INTEGER(IntKi), PARAMETER      :: BldNd_Fd       = 30
   INTEGER(IntKi), PARAMETER      :: BldNd_Mm       = 31
   INTEGER(IntKi), PARAMETER      :: BldNd_Fx       = 32
   INTEGER(IntKi), PARAMETER      :: BldNd_Fy       = 33
   INTEGER(IntKi), PARAMETER      :: BldNd_Fn       = 34
   INTEGER(IntKi), PARAMETER      :: BldNd_Ft       = 35
   INTEGER(IntKi), PARAMETER      :: BldNd_Clrnc    = 36
   INTEGER(IntKi), PARAMETER      :: BldNd_Vx       = 37
   INTEGER(IntKi), PARAMETER      :: BldNd_Vy       = 38
   INTEGER(IntKi), PARAMETER      :: BldNd_GeomPhi  = 39
   INTEGER(IntKi), PARAMETER      :: BldNd_Chi      = 40
   INTEGER(IntKi), PARAMETER      :: BldNd_UA_Flag  = 41

     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER, PUBLIC  :: BldNd_MaxOutPts      = 41

!End of code generated by Matlab script
! ===================================================================================================

CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------

!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine populates the headers with the blade node outputs.  The iteration cycle is blade:node:channel (channel iterated
!! fastest).  If this iteration order is changed, it should be changed in the Calc_WriteAllBldNdOutput routine as well.
SUBROUTINE AllBldNdOuts_InitOut( InitOut, p, InputFileData, ErrStat, ErrMsg )

   TYPE(AD_InitOutputType),      INTENT(INOUT)  :: InitOut                          ! output data
   TYPE(AD_ParameterType),       INTENT(IN   )  :: p                                ! The module parameters
   TYPE(AD_InputFile),           INTENT(IN   )  :: InputFileData                    ! All the data in the AeroDyn input file (want Blade Span for channel name)
   INTEGER(IntKi),               INTENT(  OUT)  :: ErrStat                          ! The error status code
   CHARACTER(*),                 INTENT(  OUT)  :: ErrMsg                           ! The error message, if an error occurred

   INTEGER(IntKi)                               :: INDX                             ! Index count within WriteOutput
   INTEGER(IntKi)                               :: IdxBlade                         ! Counter to which blade we are on
   INTEGER(IntKi)                               :: IdxNode                          ! Counter to the blade node we ae on
   INTEGER(IntKi)                               :: IdxChan                          ! Counter to the channel we are outputting.
   CHARACTER(16)                                :: ChanPrefix                       ! Name prefix (AB#N###)
   CHARACTER(6)                                 :: TmpChar                          ! Temporary char array to hold the node digits (3 places only!!!!)
   CHARACTER(*), PARAMETER                      :: RoutineName = ('AllBldNdOuts_InitOut')


         ! Initialize some things
      ErrMsg = ''
      ErrStat = ErrID_None


         ! Warn if we will run into issues with more than 99 nodes.
      IF (p%NumBlNds > 999 ) CALL SetErrStat(ErrID_Severe,'More than 999 blade nodes in use.  Output channel headers will not '// &
            'correctly reflect blade stations beyond 999. Modifications to the variable ChanLen in FAST are required.',ErrStat,ErrMsg,RoutineName)


         ! Populate the header an unit lines for all blades and nodes
         ! First set a counter so we know where in the output array we are in
      INDX = p%NumOuts + 1       ! p%NumOuts is the number of outputs from the normal AeroDyn output.  The WriteOutput array is sized to p%NumOuts + num(AllBldNdOuts)

      DO IdxChan=1,p%BldNd_NumOuts

         DO IdxBlade=1,p%BldNd_BladesOut
            DO IdxNode=1,p%NumBlNds

                  ! Create the name prefix:
               WRITE (TmpChar,'(I3.3)')  IdxNode         ! 3 digit number
               ChanPrefix = 'AB' // TRIM(Num2LStr(IdxBlade)) // 'N' // TRIM(TmpChar) ! // '_' ! note that I added an "AB" to indicate "Aero B1" in case of confusion with structural nodal outputs with the same name
                  ! Now write to the header
               InitOut%WriteOutputHdr(INDX) = trim(ChanPrefix) // p%BldNd_OutParam(IdxChan)%Name
               InitOut%WriteOutputUnt(INDX) = p%BldNd_OutParam(IdxChan)%Units

                  ! Increment the index to the Header arrays
               INDX = INDX + 1

            ENDDO
         ENDDO

      ENDDO

END SUBROUTINE AllBldNdOuts_InitOut

!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine populates the headers with the blade node outputs.  The iteration cycle is channel:blade:node (node iterated
!! fastest).  If this iteration order is changed, it should be changed in the Calc_WriteAllBldNdOutput routine as well.
!!
!! NOTE: the equations here came from the output section of AeroDyn_IO.f90.  If anything changes in there, it needs to be reflected
!!       here.

SUBROUTINE Calc_WriteAllBldNdOutput( p, u, m, y, OtherState, Indx, ErrStat, ErrMsg )
   TYPE(AD_ParameterType),    INTENT(IN   )  :: p                                 ! The module parameters
   TYPE(AD_InputType),        INTENT(IN   )  :: u                                 ! inputs
   TYPE(AD_MiscVarType),      INTENT(IN   )  :: m                                 ! misc variables
   TYPE(AD_OutputType),       INTENT(INOUT)  :: y                                 ! outputs (updates y%WriteOutput)
   TYPE(AD_OtherStateType),   INTENT(IN   )  :: OtherState                        ! other states
   INTEGER,                   INTENT(IN   )  :: Indx                              ! index into m%BEMT_u(Indx) array; 1=t and 2=t+dt (but not checked here)
   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg                            ! The error message, if an error occurred

      ! local variables
 
   INTEGER(IntKi)                               :: OutIdx                             ! Index count within WriteOutput
   INTEGER(IntKi)                               :: IdxBlade                         ! Counter to which blade we are on
   INTEGER(IntKi)                               :: IdxNode                          ! Counter to the blade node we ae on
   INTEGER(IntKi)                               :: IdxChan                          ! Counter to the channel we are outputting.
   INTEGER(IntKi)                               :: compIndx                         ! index for array component (x,y,z)
   CHARACTER(*), PARAMETER                      :: RoutineName = 'Calc_WriteAllBldNdOutput'
   REAL(ReKi)                                   :: ct, st ! cosine, sine of theta
   REAL(ReKi)                                   :: cp, sp ! cosine, sine of phi
   REAL(ReKi)                                   :: Tmp33a(3,3)
   REAL(ReKi)                                   :: Tmp33b(3,3)
   REAL(R8Ki)                                   :: Tmp33aR8Ki(3,3)
   REAL(R8Ki)                                   :: Tmp33bR8Ki(3,3)
   REAL(ReKi)                                   :: ThetaYXZ(3)
   REAL(ReKi)                                   :: ThetaYXZ_RD(3)
   REAL(ReKi)                                   :: BladeLocalOrient(3,3)

         ! Error handling
   INTEGER(IntKi)          :: ErrStat2                     ! Temporary Error status
   CHARACTER(ErrMsgLen)    :: ErrMsg2                      ! Temporary Error message 


         ! Initialize some things
      ErrMsg = ''
      ErrStat = ErrID_None


         ! Populate the header an unit lines for all blades and nodes
         ! First set a counter so we know where in the output array we are in
      OutIdx = p%NumOuts + 1       ! p%NumOuts is the number of outputs from the normal AeroDyn output.  The WriteOutput array is sized to p%NumOuts + num(AllBldNdOuts)

      
         ! Case to assign output to this channel and populate based on Indx value (this indicates what the channel is)
         ! Logic and mathematics used here come from Calc_WriteOutput
      DO IdxChan=1,p%BldNd_NumOuts

         SELECT CASE( p%BldNd_OutParam(IdxChan)%Indx )      ! Indx contains the information on what channel should be output
         CASE (0) ! Invalid channel
            CYCLE
               ! ***** Undisturbed wind velocity in local blade coord system *****
         CASE ( BldNd_VUndx )
                  
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(1)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(1,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO
                  
                  
         CASE ( BldNd_VUndy )
                  
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(2)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(2,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO
                  
         CASE ( BldNd_VUndz )
                  
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(3)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(3,:,IdxNode,IdxBlade), u%InflowOnBlade(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO
      
      

                  ! ***** Disturbed wind velocity in the local blade coordinate system *****
         CASE ( BldNd_VDisx )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(1)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(1,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO

         CASE ( BldNd_VDisy )
         
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(2)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(2,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_VDisz )
         
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                  !y%WriteOutput( OutIdx )  = Tmp3(3)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(3,:,IdxNode,IdxBlade), m%DisturbedInflow(:,IdxNode,IdxBlade) )
                                          
                  OutIdx = OutIdx + 1
               END DO
            END DO

         
               ! ***** Structural translational velocity in the local blade coordinate system ***** 
         CASE ( BldNd_STVx )
         
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  !y%WriteOutput( OutIdx )  = Tmp3(1)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(1,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_STVy )
         
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  !y%WriteOutput( OutIdx )  = Tmp3(2)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(2,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_STVz )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  !Tmp3     = matmul( m%WithoutSweepPitchTwist(:,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  !y%WriteOutput( OutIdx )  = Tmp3(3)
                  y%WriteOutput( OutIdx )  = dot_product( m%WithoutSweepPitchTwist(3,:,IdxNode,IdxBlade), u%BladeMotion(IdxBlade)%TranslationVel(:,IdxNode) )
                  OutIdx = OutIdx + 1
               END DO
            END DO

         
            ! Relative wind speed
         CASE ( BldNd_VRel )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Vrel(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
            ! Dynamic pressure
         CASE ( BldNd_DynP )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = 0.5 * p%airDens * m%BEMT_y%Vrel(IdxNode,IdxBlade)**2
                  OutIdx = OutIdx + 1
               END DO
            END DO

            ! Reynolds number (in millions)
         CASE ( BldNd_Re )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = p%BEMT%chord(IdxNode,IdxBlade) * m%BEMT_y%Vrel(IdxNode,IdxBlade) / p%KinVisc / 1.0E6
                  OutIdx = OutIdx + 1
               END DO
            END DO

            ! Mach number
         CASE ( BldNd_M )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Vrel(IdxNode,IdxBlade) / p%SpdSound
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         
            ! Axial and tangential induced wind velocity
         CASE ( BldNd_Vindx )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds 
                  y%WriteOutput( OutIdx )  = - m%BEMT_u(Indx)%Vx(IdxNode,IdxBlade) * m%BEMT_y%axInduction( IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO
                     
         CASE ( BldNd_Vindy )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds 
                  y%WriteOutput( OutIdx )  = m%BEMT_u(Indx)%Vy(IdxNode,IdxBlade) * m%BEMT_y%tanInduction(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO
         

            ! Axial and tangential induction factors
         CASE ( BldNd_AxInd )         
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_y%axInduction(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO

         CASE ( BldNd_TnInd )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%tanInduction(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
                  
            ! AoA, pitch+twist angle, inflow angle, and curvature angle
         CASE ( BldNd_Alpha )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = Rad2M180to180Deg( m%BEMT_y%phi(IdxNode,IdxBlade) - m%BEMT_u(Indx)%theta(IdxNode,IdxBlade) )
                  OutIdx = OutIdx + 1
               END DO
            END DO

         CASE ( BldNd_Theta )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_u(Indx)%theta(IdxNode,IdxBlade)*R2D
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_Phi )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%phi(IdxNode,IdxBlade)*R2D                                            
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_Curve )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%Curve(IdxNode,IdxBlade)*R2D                                            
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         
                        ! Lift force, drag force, pitching moment coefficients
         CASE ( BldNd_Cl )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cl(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO
         
         CASE ( BldNd_Cd )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cd(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO

         CASE ( BldNd_Cm )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cm(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

            ! Normal force (to plane), tangential force (to plane) coefficients
         CASE ( BldNd_Cx )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cx(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Cy )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds                   
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cy(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

            ! Normal force (to chord), and tangential force (to chord) coefficients
         CASE ( BldNd_Cn )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  ct=cos(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  st=sin(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))               
                  y%WriteOutput( OutIdx )  = m%BEMT_y%Cx(IdxNode,IdxBlade)*ct + m%BEMT_y%Cy(IdxNode,IdxBlade)*st
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Ct )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  ct=cos(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  st=sin(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))               
                  y%WriteOutput( OutIdx )  = -m%BEMT_y%Cx(IdxNode,IdxBlade)*st + m%BEMT_y%Cy(IdxNode,IdxBlade)*ct
                  OutIdx = OutIdx + 1
               END DO
            END DO 


               ! Lift force, drag force, pitching moment
         CASE ( BldNd_Fl )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  cp=cos(m%BEMT_y%phi(IdxNode,IdxBlade))
                  sp=sin(m%BEMT_y%phi(IdxNode,IdxBlade))
                  y%WriteOutput( OutIdx )  = m%X(IdxNode,IdxBlade)*cp - m%Y(IdxNode,IdxBlade)*sp
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Fd )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  cp=cos(m%BEMT_y%phi(IdxNode,IdxBlade))
                  sp=sin(m%BEMT_y%phi(IdxNode,IdxBlade))
                  y%WriteOutput( OutIdx )  = m%X(IdxNode,IdxBlade)*sp + m%Y(IdxNode,IdxBlade)*cp
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Mm )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  y%WriteOutput( OutIdx )  = m%M(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

            ! Normal force (to plane), tangential force (to plane)
         CASE ( BldNd_Fx )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  y%WriteOutput( OutIdx )  = m%X(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Fy )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  y%WriteOutput( OutIdx )  = -m%Y(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

            ! Normal force (to chord), and tangential force (to chord) per unit length
         CASE ( BldNd_Fn )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  ct=cos(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  st=sin(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  y%WriteOutput( OutIdx )  = m%X(IdxNode,IdxBlade)*ct - m%Y(IdxNode,IdxBlade)*st
                  OutIdx = OutIdx + 1
               END DO
            END DO 
         
         CASE ( BldNd_Ft )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds   
                  ct=cos(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  st=sin(m%BEMT_u(Indx)%theta(IdxNode,IdxBlade))
                  y%WriteOutput( OutIdx )  = -m%X(IdxNode,IdxBlade)*st - m%Y(IdxNode,IdxBlade)*ct
                  OutIdx = OutIdx + 1
               END DO
            END DO 

                        ! Tower clearance (requires tower influence calculation):
         CASE ( BldNd_Clrnc )
            if (.not. allocated(m%TwrClrnc)) then
               DO IdxBlade=1,p%BldNd_BladesOut
                  DO IdxNode=1,p%NumBlNds   
                     y%WriteOutput( OutIdx )  = 0.0_ReKi
                     OutIdx = OutIdx + 1
                  END DO
               END DO 
            else
               DO IdxBlade=1,p%BldNd_BladesOut
                  DO IdxNode=1,p%NumBlNds
                     y%WriteOutput( OutIdx )  = m%TwrClrnc(IdxNode,IdxBlade)
                     OutIdx = OutIdx + 1
                  END DO
               END DO 
            end if
         
         
         CASE ( BldNd_Vx )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_u(Indx)%Vx(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_Vy )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_u(Indx)%Vy(IdxNode,IdxBlade)
                  OutIdx = OutIdx + 1
               END DO
            END DO 
                     
         CASE ( BldNd_GeomPhi )
            if (allocated(OtherState%BEMT%ValidPhi)) then
               DO IdxBlade=1,p%BldNd_BladesOut
                  DO IdxNode=1,p%NumBlNds 
                     if (OtherState%BEMT%ValidPhi(IdxNode,IdxBlade)) then
                        y%WriteOutput( OutIdx ) = 0.0_ReKi
                     else
                        y%WriteOutput( OutIdx ) = 1.0_ReKi
                     end if
                     OutIdx = OutIdx + 1
                  END DO
               END DO 
            else
               DO IdxBlade=1,p%BldNd_BladesOut
                  DO IdxNode=1,p%NumBlNds   
                     y%WriteOutput( OutIdx )  = 1.0_ReKi
                     OutIdx = OutIdx + 1
                  END DO
               END DO 
            end if

         CASE ( BldNd_chi )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,p%NumBlNds
                  y%WriteOutput( OutIdx )  = m%BEMT_y%chi(IdxNode,IdxBlade)*R2D
                  OutIdx = OutIdx + 1
               END DO
            END DO 

         CASE ( BldNd_UA_Flag )
            DO IdxBlade=1,p%BldNd_BladesOut
               DO IdxNode=1,u%BladeMotion(IdxBlade)%NNodes    ! Note p%node_total is total number of nodes including all elements
                  IF ( OtherState%BEMT%UA_Flag(IdxNode, IdxBlade) ) THEN
                     y%WriteOutput( OutIdx ) = 1.0_ReKi
                  ELSE
                     y%WriteOutput( OutIdx ) = 0.0_ReKi
                  ENDIF
                  OutIdx = OutIdx + 1
               ENDDO
            ENDDO
      

         END SELECT
         
      END DO ! each channel
      
                    
END SUBROUTINE Calc_WriteAllBldNdOutput


!----------------------------------------------------------------------------------------------------------------------------------
!> This routine validates and sets the parameters for the nodal outputs.
SUBROUTINE AllBldNdOuts_SetParameters( InitInp, InputFileData, p, ErrStat, ErrMsg )
!..................................................................................................................................


      ! Passed variables:

   TYPE(AD_InitInputType),       intent(IN   )  :: InitInp          !< Input data for initialization routine, out is needed because of copy below
   TYPE(AD_InputFile),           INTENT(IN   )  :: InputFileData    !< Data stored in the module's input file
   TYPE(AD_ParameterType),       INTENT(INOUT)  :: p                !< Parameters
   INTEGER(IntKi),               INTENT(  OUT)  :: ErrStat          !< Error status of the operation
   CHARACTER(*),                 INTENT(  OUT)  :: ErrMsg           !< Error message if ErrStat /= ErrID_None

   
      ! local variables
   character(*), parameter                  :: RoutineName = 'AllBldNdOuts_SetParameters'
   
   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Check if the requested blades exist
   IF ( (InputFileData%BldNd_BladesOut < 0_IntKi) .OR. (InputFileData%BldNd_BladesOut > p%NumBlades) ) THEN
      CALL SetErrStat( ErrID_Warn, " Number of blades to output data at all blade nodes (BldNd_BladesOut) must be between 0 and "//TRIM(Num2LStr(p%NumBlades))//".", ErrStat, ErrMsg, RoutineName)
      p%BldNd_BladesOut = 0_IntKi
   ELSE
      p%BldNd_BladesOut = InputFileData%BldNd_BladesOut
   ENDIF


      ! Check if the requested blade nodes are valid
   ! InputFileData%BldNd_BlOutNd


      ! Set the parameter to store number of requested Blade Node output sets
   p%BldNd_NumOuts = InputFileData%BldNd_NumOuts

      ! Set the total number of outputs ( requested channel groups * number requested nodes * number requested blades )
   p%BldNd_TotNumOuts = p%BldNd_NumOuts*p%NumBlNds*p%BldNd_BladesOut    ! p%BldNd_NumOuts * size(p%BldNd_BlOutNd) * size(p%BldNd_BladesOut)
   
!      ! Check if the blade node array to output is valid: p%BldNd_BlOutNd 
!      ! TODO: this value is not read in by the input file reading yet, so setting to all blade nodes
!      !        -- check if list handed in is of nodes that exist (not sure this is ever checked)
!      !        -- copy values over
!
!      ! Temporary workaround here:
!   ALLOCATE ( p%BldNd_BlOutNd(1:p%NumBlNds) , STAT=ErrStat2 )
!   IF ( ErrStat2 /= 0_IntKi )  THEN
!      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the AeroDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
!      RETURN
!   ENDIF
!   DO I=1,p%NumBlNds          ! put all nodes in the list
!      p%BldNd_BlOutNd(i) = i
!   ENDDO
   

!      ! Check if the requested blades are actually in use: 
!      ! TODO: this value is not read in by the input file reading yet, so setting to all blades
!      !        -- check if list handed in is of blades that exist (not sure this is ever checked)
!      !        -- copy values over
!   ALLOCATE ( p%BldNd_BladesOut(1:p%NumBlades), STAT=ErrStat2 )
!   IF ( ErrStat2 /= 0_IntKi )  THEN
!      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the AeroDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
!      RETURN
!   ENDIF
!   DO I=1,p%NumBlades        ! put all blades in the list
!      p%BldNd_BladesOut(i) = i
!   ENDDO
   
   if (p%BldNd_TotNumOuts > 0) then
      call BldNdOuts_SetOutParam(InputFileData%BldNd_OutList, p, ErrStat, ErrMsg ) ! requires: p%NumOuts, p%numBlades, p%NumBlNds, p%NumTwrNds; sets: p%BldNdOutParam.
         if (ErrStat >= AbortErrLev) return
   end if



END SUBROUTINE AllBldNdOuts_SetParameters  
 

!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
!! warning if any of the channels are not available outputs from the module.
!!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!!  the sign is set to 0 if the channel is invalid.
!! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!! 
!! This routine was generated by Write_ChckOutLst.m using the parameters listed in OutListParameters.xlsx at 12-Dec-2017 22:08:06.
SUBROUTINE BldNdOuts_SetOutParam(BldNd_OutList, p, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: BldNd_OutList(:)                  !< The list out user-requested outputs
   TYPE(AD_ParameterType),    INTENT(INOUT)  :: p                                 !< The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           !< The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            !< The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: InvalidOutput(1:BldNd_MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "BldNdOuts_SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(41) =  (/  &   ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "ALPHA   ","AXIND   ","CD      ","CHI     ", &
                               "CL      ","CLRNC   ","CM      ","CN      ","CT      ","CURVE   ","CX      ","CY      ","DYNP    ", &
                               "FD      ","FL      ","FN      ","FT      ","FX      ","FY      ","GEOMPHI ","M       ","MM      ", &
                               "PHI     ","RE      ","STVX    ", &
                               "STVY    ","STVZ    ","THETA   ","TNIND   ","UA_FLAG ", &
                               "VDISX   ","VDISY   ","VDISZ   ","VINDX   ","VINDY   ","VREL    ","VUNDX   ","VUNDY   ","VUNDZ   ", &
                               "VX      ","VY      "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(41) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                    BldNd_Alpha ,    BldNd_AxInd ,     BldNd_Cd ,      BldNd_Chi , &
                                      BldNd_Cl ,    BldNd_Clrnc ,       BldNd_Cm ,       BldNd_Cn ,       BldNd_Ct ,    BldNd_Curve ,       BldNd_Cx ,       BldNd_Cy ,     BldNd_DynP , &
                                      BldNd_Fd ,       BldNd_Fl ,       BldNd_Fn ,       BldNd_Ft ,       BldNd_Fx ,       BldNd_Fy ,  BldNd_GeomPhi ,        BldNd_M ,       BldNd_Mm , &
                                     BldNd_Phi ,   BldNd_Re ,    BldNd_STVx , &
                                    BldNd_STVy ,     BldNd_STVz ,    BldNd_Theta ,    BldNd_TnInd ,      BldNd_UA_Flag , &
                                   BldNd_VDisx ,    BldNd_VDisy ,    BldNd_VDisz ,    BldNd_Vindx ,    BldNd_Vindy ,     BldNd_VRel ,    BldNd_VUndx ,    BldNd_VUndy ,    BldNd_VUndz , &
                                      BldNd_Vx ,       BldNd_Vy /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(41) =  (/  &  ! This lists the units corresponding to the allowed parameters
                               "(deg)  ","(-)    ","(-)    ","(deg)  ", &
                               "(-)    ","(m)    ","(-)    ","(-)    ","(-)    ","(deg)  ","(-)    ","(-)    ","(Pa)   ", &
                               "(N/m)  ","(N/m)  ","(N/m)  ","(N/m)  ","(N/m)  ","(N/m)  ","(1/0)  ","(-)    ","(N-m/m)", &
                               "(deg)  ","(-)    ","(m/s)  ", &
                               "(m/s)  ","(m/s)  ","(deg)  ","(-)    ","(-)    ", &
                               "(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ","(m/s)  ", &
                               "(m/s)  ","(m/s)  "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....

!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%BldNd_OutParam(1:p%BldNd_NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the AeroDyn BldNd_OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%BldNd_NumOuts

      p%BldNd_OutParam(I)%Name  = BldNd_OutList(I)
      OutListTmp          = BldNd_OutList(I)
      p%BldNd_OutParam(I)%SignM = 1   ! this won't be used

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )

      IF ( Indx > 0 ) THEN ! we found the channel name
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%BldNd_OutParam(I)%Indx  = 0                 ! pick any valid channel (I just picked "Time=0" here because it's universal)
            p%BldNd_OutParam(I)%Units = "INVALID"
            p%BldNd_OutParam(I)%SignM = 0
         ELSE
            p%BldNd_OutParam(I)%Indx  = ParamIndxAry(Indx)
            p%BldNd_OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%BldNd_OutParam(I)%Indx  = 0                    ! pick any valid channel (I just picked "Time=0" here because it's universal)
         p%BldNd_OutParam(I)%Units = "INVALID"
         p%BldNd_OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%BldNd_OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE BldNdOuts_SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************

END MODULE AeroDyn_AllBldNdOuts_IO
