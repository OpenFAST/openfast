!STARTOFREGISTRYGENERATEDFILE 'FVW_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FVW_Types
!.................................................................................................................................
! This file is part of FVW.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FVW. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FVW_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE UnsteadyAero_Types
USE NWTC_Library
IMPLICIT NONE
! =========  FVW_ParameterType  =======
  TYPE, PUBLIC :: FVW_ParameterType
    INTEGER(IntKi)  :: nWings      !< Number of Wings [-]
    INTEGER(IntKi)  :: nSpan      !< TODO, should be defined per wing. Number of spanwise element [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index to the airfoils from AD15 [idx1= BladeNode, idx2=Blade number] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Chord      !< Chord of each blade element from input file [idx1=BladeNode, idx2=Blade number] [-]
    INTEGER(IntKi)  :: nNWMax      !< Maximum number of nw panels, per wing [-]
    INTEGER(IntKi)  :: nFWMax      !< Maximum number of fw panels, per wing [-]
    INTEGER(IntKi)  :: nFWFree      !< Number of fw panels that are free, per wing [-]
    LOGICAL  :: FWShedVorticity      !< Include shed vorticity in the far wake [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCirculationStart      !< Time when the circulation is full [s]
    INTEGER(IntKi)  :: CirculationMethod      !< Method to determine the circulation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PrescribedCirculation      !< Prescribed circulation on all lifting lines [m/s]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: CircSolvPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: DiffusionMethod      !< Diffusion method (None, CoreSpreading, PSE) [-]
    REAL(ReKi)  :: CoreSpreadEddyVisc      !< Eddy viscosity used in the core spreading method [-]
    INTEGER(IntKi)  :: RegDeterMethod      !< Regularization determinatino method (manual, automatic) [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegParam      !< Initial value of the regularization parameter [-]
    REAL(ReKi)  :: WingRegParam      !< Regularization parameter of the wing [-]
    INTEGER(IntKi)  :: ShearModel      !< Option for shear modelling [-]
    LOGICAL  :: TwrShadowOnWake      !< Include tower shadow effects on wake [-]
    INTEGER(IntKi)  :: VelocityMethod      !< Velocity calculation method [-]
    REAL(ReKi)  :: TreeBranchFactor      !< Factor used to determine if a point is far enough [-]
    INTEGER(IntKi)  :: PartPerSegment      !< Number of particles per segment, e.g. for tree method [-]
    REAL(DbKi)  :: DTaero      !< Time interval for calls calculations [s]
    REAL(DbKi)  :: DTfvw      !< Time interval for calculating wake induced velocities [s]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: WrVTK      !< Outputs VTK at each calcoutput call, even if main fst doesnt do it [-]
    INTEGER(IntKi)  :: VTKBlades      !< Outputs VTk for each blade 0=no blade, 1=Bld 1 [-]
    REAL(DbKi)  :: DTvtk      !< DT between vtk writes [s]
    INTEGER(IntKi)  :: VTKCoord      !< Switch for VTK outputs coordinate  system [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    CHARACTER(1024)  :: VTK_OutFileRoot      !< Rootdirectory for writing VTK files [-]
    CHARACTER(1024)  :: VTK_OutFileBase      !< Basename for writing VTK files [-]
  END TYPE FVW_ParameterType
! =======================
! =========  FVW_MiscVarType  =======
  TYPE, PUBLIC :: FVW_MiscVarType
    LOGICAL  :: FirstCall      !< True if this is the first call to update state (used in CalcOutput) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: LE      !< Leading edge points [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: TE      !< Trailing edge points [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_LL      !< Position    of the Lifting line panels [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: s_LL      !< Spanwise coordinate of LL elements [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord_LL      !< chord on LL nodes  [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: s_CP_LL      !< Spanwise coordinate of LL CP [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord_CP_LL      !< chord on LL cp  [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CP_LL      !< Coordinates of LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Tang      !< Unit Tangential vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Norm      !< Unit Normal vector on LL CP     [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Orth      !< Unit Orthogonal vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: dl      !< Vector of elementary length along the LL [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Area      !< Area of each LL panel [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: diag_LL      !< Diagonal length of each LL panel [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_LL      !< Circulation on the wing lifting line (COPY of Constraint State) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind_LL      !< Induced velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vtot_LL      !< Total velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr_LL      !< Structural velocity on LL CP [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vwnd_LL      !< Wind on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vwnd_NW      !< Wind on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vwnd_FW      !< Wind on far  wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vind_NW      !< Induced velocity on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vind_FW      !< Induced velocity on far  wake panels [m/s]
    INTEGER(IntKi)  :: nNW      !< Number of active near wake panels [-]
    INTEGER(IntKi)  :: nFW      !< Number of active far  wake panels [-]
    INTEGER(IntKi)  :: iStep      !< Current step number used for update state [-]
    INTEGER(IntKi)  :: VTKstep      !< Current vtk output step number [-]
    REAL(DbKi)  :: VTKlastTime      !< Time the last VTK file set was written out [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r_wind      !< List of points where wind is requested for next time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PitchAndTwist      !< Twist angle (includes all sources of twist)  [Array of size (NumBlNds,numBlades)] [rad]
    LOGICAL  :: ComputeWakeInduced      !< Compute induced velocities on this timestep [-]
    REAL(DbKi)  :: OldWakeTime      !< Time the wake induction velocities were last calculated [s]
    REAL(ReKi)  :: tSpent      !< Time spent in expensive Biot-Savart computation [s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: dxdt_NW      !< State time derivatie, stored for subcylcing [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: dxdt_FW      !< State time derivatie, stored for subcylcing [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_LL      !< Angle of attack at lifting line CP, only computed with CircPolarData method [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vreln_LL      !< Norm of Vrel on the lifting line [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: SegConnct      !< Connectivity of segments [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SegPoints      !< Points delimiting the segments [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SegGamma      !< Segment circulations [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SegEpsilon      !< Segment regularization parameter [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CPs      !< Control points used for wake rollup computation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Uind      !< Induced velocities obtained at control points [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_AxInd      !< Axial induction [size: (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_TanInd      !< Tangential induction [size: (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Vrel      !< Relative velocity [size: (NumBlNds,numBlades)] [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_alpha      !< Angle of attack [size: (NumBlNds,numBlades)] [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_phi      !< angle between the plane of rotation and the direction of the local wind [size: (NumBlNds,numBlades)] [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Re      !< Reynolds number [size: (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BN_URelWind_s      !< Relative wind velocity in section coordinates [size: (3,NumBlNds,numBlades)] [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cl_Static      !< Coefficient lift,   excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cd_Static      !< Coefficient drag.   excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cm_Static      !< Coefficient moment, excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cl      !< Coefficient lift,   including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cd      !< Coefficient drag,   including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cm      !< Coefficient moment, including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cx      !< normal force coefficient (normal to the plane, not chord) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_Cy      !< tangential force coefficient (tangential to the plane, not chord) of the jth node in the kth blade [-]
    TYPE(UA_MiscVarType)  :: m_UA      !< misc vars for UnsteadyAero [-]
    TYPE(UA_OutputType)  :: y_UA      !< outputs from UnsteadyAero [-]
    TYPE(UA_ParameterType)  :: p_UA      !< parameters for UnsteadyAero [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vwnd_ND      !< InflowOnBlade (at nodes) values modified by tower influence. ONLY for UA [m/s]
  END TYPE FVW_MiscVarType
! =======================
! =========  FVW_InputType  =======
  TYPE, PUBLIC :: FVW_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< Input Mesh defining position and orientation of wings [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: V_wind      !< Wind at requested points (r_wind) [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: HubOrientation      !< Orientation of hub coordinate system (for output only) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: HubPosition      !< Origin of hub (for output only) [-]
  END TYPE FVW_InputType
! =======================
! =========  FVW_OutputType  =======
  TYPE, PUBLIC :: FVW_OutputType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind      !< TODO mesh  - Induced velocity vector.  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cl_KJ      !< Lift coefficient from circulation (Kutta-Joukowski) [-]
  END TYPE FVW_OutputType
! =======================
! =========  FVW_ContinuousStateType  =======
  TYPE, PUBLIC :: FVW_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Gamma_NW      !< Circulation of the near wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Gamma_FW      !< Circulation of the far  wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_NW      !< Position    of the near wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_FW      !< Position    of the far  wake panels [-]
    TYPE(UA_ContinuousStateType)  :: UA      !< states for UnsteadyAero [-]
  END TYPE FVW_ContinuousStateType
! =======================
! =========  FVW_DiscreteStateType  =======
  TYPE, PUBLIC :: FVW_DiscreteStateType
    REAL(ReKi)  :: NULL      !< Empty to satisfy framework [-]
    TYPE(UA_DiscreteStateType)  :: UA      !< states for UnsteadyAero [-]
  END TYPE FVW_DiscreteStateType
! =======================
! =========  FVW_ConstraintStateType  =======
  TYPE, PUBLIC :: FVW_ConstraintStateType
    REAL(ReKi)  :: residual 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_LL      !< Circulation on the wing lifting line [-]
  END TYPE FVW_ConstraintStateType
! =======================
! =========  FVW_OtherStateType  =======
  TYPE, PUBLIC :: FVW_OtherStateType
    INTEGER(IntKi)  :: NULL      !< Number of active near wake panels [-]
    TYPE(UA_OtherStateType)  :: UA      !< other states for UnsteadyAero [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
  END TYPE FVW_OtherStateType
! =======================
! =========  FVW_InitInputType  =======
  TYPE, PUBLIC :: FVW_InitInputType
    CHARACTER(1024)  :: FVWFileName      !< Main FVW input file name [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< Input Mesh defining position and orientation of wings (nSpan+1)  [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index to the airfoils from AD15 [idx1=BladeNode, idx2=Blade number] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Chord      !< Chord of each blade element from input file [idx1=BladeNode, idx2=Blade number] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RElm      !< radius of center of each element [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zHub      !< Distance to hub for each blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: zLocal      !< Distance to blade node, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zTip      !< Distance to blade tip, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      !< Radial distance to blade node from the center of rotation, measured in the rotor plane, needed for DBEMT [m]
    INTEGER(IntKi)  :: NumBlades      !< Number of blades [-]
    INTEGER(IntKi)  :: NumBladeNodes      !< Number of nodes on each blade [-]
    REAL(DbKi)  :: DTaero      !< Time interval for calls (from AD15) [s]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: UAMod      !< Model for the dynamic stall equations [1 = Leishman/Beddoes, 2 = Gonzalez, 3 = Minnema] [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    LOGICAL  :: Flookup      !< Use table lookup for f' and f''  [-]
    REAL(ReKi)  :: a_s      !< speed of sound [m/s]
  END TYPE FVW_InitInputType
! =======================
! =========  FVW_InputFile  =======
  TYPE, PUBLIC :: FVW_InputFile
    INTEGER(IntKi)  :: CirculationMethod      !< Method to determine the circulation [-]
    CHARACTER(1024)  :: CirculationFile      !< Prescribed circulation file [-]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1, 7=Corrector/Predictor) [-]
    LOGICAL  :: FreeWake      !< Disable roll up, wake convects with wind only (flag) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCirculationStart      !< Time when the circulation is full [s]
    REAL(DbKi)  :: DTfvw      !< Time interval for calculating wake induced velocities [s]
    INTEGER(IntKi)  :: CircSolvPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: nNWPanels      !< Number of nw panels [-]
    INTEGER(IntKi)  :: nFWPanels      !< Number of fw panels [-]
    INTEGER(IntKi)  :: nFWPanelsFree      !< Number of fw panels that are free [-]
    LOGICAL  :: FWShedVorticity      !< Include shed vorticity in the far wake [-]
    INTEGER(IntKi)  :: DiffusionMethod      !< Diffusion method (None, CoreSpreading, PSE) [-]
    REAL(ReKi)  :: CoreSpreadEddyVisc      !< Eddy viscosity used in the core spreading method [-]
    INTEGER(IntKi)  :: RegDeterMethod      !< Regularization determinatino method (manual, automatic) [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegParam      !< Factor used in the regularization  [-]
    REAL(ReKi)  :: WingRegParam      !< Factor used in the regularization  [-]
    INTEGER(IntKi)  :: ShearModel      !< Option for shear modelling [-]
    LOGICAL  :: TwrShadowOnWake      !< Include tower shadow effects on wake [-]
    INTEGER(IntKi)  :: VelocityMethod      !< Velocity calculation method [-]
    REAL(ReKi)  :: TreeBranchFactor      !< Factor used to determine if a point is far enough [-]
    INTEGER(IntKi)  :: PartPerSegment      !< Number of particles per segment, e.g. for tree method [-]
    INTEGER(IntKi)  :: WrVTK      !< Outputs VTK at each calcoutput call, even if main fst doesnt do it [-]
    INTEGER(IntKi)  :: VTKBlades      !< Outputs VTk for each blade 0=no blade, 1=Bld 1 [-]
    REAL(DbKi)  :: DTvtk      !< Requested timestep between VTK outputs (calculated from the VTK_fps read in) [s]
    INTEGER(IntKi)  :: VTKCoord      !< Switch for VTK outputs coordinate  system [-]
  END TYPE FVW_InputFile
! =======================
! =========  FVW_InitOutputType  =======
  TYPE, PUBLIC :: FVW_InitOutputType
    INTEGER(IntKi)  :: Null      !< Empty parameter to satisfy framework [-]
  END TYPE FVW_InitOutputType
! =======================
CONTAINS
 SUBROUTINE FVW_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FVW_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%nWings = SrcParamData%nWings
    DstParamData%nSpan = SrcParamData%nSpan
IF (ALLOCATED(SrcParamData%AFindx)) THEN
  i1_l = LBOUND(SrcParamData%AFindx,1)
  i1_u = UBOUND(SrcParamData%AFindx,1)
  i2_l = LBOUND(SrcParamData%AFindx,2)
  i2_u = UBOUND(SrcParamData%AFindx,2)
  IF (.NOT. ALLOCATED(DstParamData%AFindx)) THEN 
    ALLOCATE(DstParamData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFindx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AFindx = SrcParamData%AFindx
ENDIF
IF (ALLOCATED(SrcParamData%Chord)) THEN
  i1_l = LBOUND(SrcParamData%Chord,1)
  i1_u = UBOUND(SrcParamData%Chord,1)
  i2_l = LBOUND(SrcParamData%Chord,2)
  i2_u = UBOUND(SrcParamData%Chord,2)
  IF (.NOT. ALLOCATED(DstParamData%Chord)) THEN 
    ALLOCATE(DstParamData%Chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Chord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Chord = SrcParamData%Chord
ENDIF
    DstParamData%nNWMax = SrcParamData%nNWMax
    DstParamData%nFWMax = SrcParamData%nFWMax
    DstParamData%nFWFree = SrcParamData%nFWFree
    DstParamData%FWShedVorticity = SrcParamData%FWShedVorticity
    DstParamData%IntMethod = SrcParamData%IntMethod
    DstParamData%FreeWakeStart = SrcParamData%FreeWakeStart
    DstParamData%FullCirculationStart = SrcParamData%FullCirculationStart
    DstParamData%CirculationMethod = SrcParamData%CirculationMethod
IF (ALLOCATED(SrcParamData%PrescribedCirculation)) THEN
  i1_l = LBOUND(SrcParamData%PrescribedCirculation,1)
  i1_u = UBOUND(SrcParamData%PrescribedCirculation,1)
  IF (.NOT. ALLOCATED(DstParamData%PrescribedCirculation)) THEN 
    ALLOCATE(DstParamData%PrescribedCirculation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PrescribedCirculation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PrescribedCirculation = SrcParamData%PrescribedCirculation
ENDIF
    DstParamData%CircSolvMaxIter = SrcParamData%CircSolvMaxIter
    DstParamData%CircSolvConvCrit = SrcParamData%CircSolvConvCrit
    DstParamData%CircSolvRelaxation = SrcParamData%CircSolvRelaxation
    DstParamData%CircSolvPolar = SrcParamData%CircSolvPolar
    DstParamData%DiffusionMethod = SrcParamData%DiffusionMethod
    DstParamData%CoreSpreadEddyVisc = SrcParamData%CoreSpreadEddyVisc
    DstParamData%RegDeterMethod = SrcParamData%RegDeterMethod
    DstParamData%RegFunction = SrcParamData%RegFunction
    DstParamData%WakeRegMethod = SrcParamData%WakeRegMethod
    DstParamData%WakeRegParam = SrcParamData%WakeRegParam
    DstParamData%WingRegParam = SrcParamData%WingRegParam
    DstParamData%ShearModel = SrcParamData%ShearModel
    DstParamData%TwrShadowOnWake = SrcParamData%TwrShadowOnWake
    DstParamData%VelocityMethod = SrcParamData%VelocityMethod
    DstParamData%TreeBranchFactor = SrcParamData%TreeBranchFactor
    DstParamData%PartPerSegment = SrcParamData%PartPerSegment
    DstParamData%DTaero = SrcParamData%DTaero
    DstParamData%DTfvw = SrcParamData%DTfvw
    DstParamData%KinVisc = SrcParamData%KinVisc
    DstParamData%WrVTK = SrcParamData%WrVTK
    DstParamData%VTKBlades = SrcParamData%VTKBlades
    DstParamData%DTvtk = SrcParamData%DTvtk
    DstParamData%VTKCoord = SrcParamData%VTKCoord
    DstParamData%RootName = SrcParamData%RootName
    DstParamData%VTK_OutFileRoot = SrcParamData%VTK_OutFileRoot
    DstParamData%VTK_OutFileBase = SrcParamData%VTK_OutFileBase
 END SUBROUTINE FVW_CopyParam

 SUBROUTINE FVW_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FVW_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%AFindx)) THEN
  DEALLOCATE(ParamData%AFindx)
ENDIF
IF (ALLOCATED(ParamData%Chord)) THEN
  DEALLOCATE(ParamData%Chord)
ENDIF
IF (ALLOCATED(ParamData%PrescribedCirculation)) THEN
  DEALLOCATE(ParamData%PrescribedCirculation)
ENDIF
 END SUBROUTINE FVW_DestroyParam

 SUBROUTINE FVW_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! nWings
      Int_BufSz  = Int_BufSz  + 1  ! nSpan
  Int_BufSz   = Int_BufSz   + 1     ! AFindx allocated yes/no
  IF ( ALLOCATED(InData%AFindx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AFindx upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%AFindx)  ! AFindx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Chord allocated yes/no
  IF ( ALLOCATED(InData%Chord) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Chord upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Chord)  ! Chord
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! nNWMax
      Int_BufSz  = Int_BufSz  + 1  ! nFWMax
      Int_BufSz  = Int_BufSz  + 1  ! nFWFree
      Int_BufSz  = Int_BufSz  + 1  ! FWShedVorticity
      Int_BufSz  = Int_BufSz  + 1  ! IntMethod
      Re_BufSz   = Re_BufSz   + 1  ! FreeWakeStart
      Re_BufSz   = Re_BufSz   + 1  ! FullCirculationStart
      Int_BufSz  = Int_BufSz  + 1  ! CirculationMethod
  Int_BufSz   = Int_BufSz   + 1     ! PrescribedCirculation allocated yes/no
  IF ( ALLOCATED(InData%PrescribedCirculation) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PrescribedCirculation upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%PrescribedCirculation)  ! PrescribedCirculation
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvMaxIter
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvConvCrit
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvRelaxation
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvPolar
      Int_BufSz  = Int_BufSz  + 1  ! DiffusionMethod
      Re_BufSz   = Re_BufSz   + 1  ! CoreSpreadEddyVisc
      Int_BufSz  = Int_BufSz  + 1  ! RegDeterMethod
      Int_BufSz  = Int_BufSz  + 1  ! RegFunction
      Int_BufSz  = Int_BufSz  + 1  ! WakeRegMethod
      Re_BufSz   = Re_BufSz   + 1  ! WakeRegParam
      Re_BufSz   = Re_BufSz   + 1  ! WingRegParam
      Int_BufSz  = Int_BufSz  + 1  ! ShearModel
      Int_BufSz  = Int_BufSz  + 1  ! TwrShadowOnWake
      Int_BufSz  = Int_BufSz  + 1  ! VelocityMethod
      Re_BufSz   = Re_BufSz   + 1  ! TreeBranchFactor
      Int_BufSz  = Int_BufSz  + 1  ! PartPerSegment
      Db_BufSz   = Db_BufSz   + 1  ! DTaero
      Db_BufSz   = Db_BufSz   + 1  ! DTfvw
      Re_BufSz   = Re_BufSz   + 1  ! KinVisc
      Int_BufSz  = Int_BufSz  + 1  ! WrVTK
      Int_BufSz  = Int_BufSz  + 1  ! VTKBlades
      Db_BufSz   = Db_BufSz   + 1  ! DTvtk
      Int_BufSz  = Int_BufSz  + 1  ! VTKCoord
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%RootName)  ! RootName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%VTK_OutFileRoot)  ! VTK_OutFileRoot
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%VTK_OutFileBase)  ! VTK_OutFileBase
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%nWings
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nSpan
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%AFindx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFindx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFindx,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFindx,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFindx,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%AFindx,2), UBOUND(InData%AFindx,2)
        DO i1 = LBOUND(InData%AFindx,1), UBOUND(InData%AFindx,1)
          IntKiBuf(Int_Xferred) = InData%AFindx(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Chord) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Chord,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Chord,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Chord,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Chord,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Chord,2), UBOUND(InData%Chord,2)
        DO i1 = LBOUND(InData%Chord,1), UBOUND(InData%Chord,1)
          ReKiBuf(Re_Xferred) = InData%Chord(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%nNWMax
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nFWMax
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nFWFree
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FWShedVorticity, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%IntMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FreeWakeStart
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FullCirculationStart
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%CirculationMethod
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%PrescribedCirculation) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PrescribedCirculation,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PrescribedCirculation,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PrescribedCirculation,1), UBOUND(InData%PrescribedCirculation,1)
        ReKiBuf(Re_Xferred) = InData%PrescribedCirculation(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%CircSolvMaxIter
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CircSolvConvCrit
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CircSolvRelaxation
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%CircSolvPolar
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%DiffusionMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CoreSpreadEddyVisc
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%RegDeterMethod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%RegFunction
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WakeRegMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WakeRegParam
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WingRegParam
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%ShearModel
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TwrShadowOnWake, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VelocityMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TreeBranchFactor
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%PartPerSegment
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTaero
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTfvw
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%KinVisc
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WrVTK
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VTKBlades
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTvtk
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VTKCoord
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%RootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%RootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%VTK_OutFileRoot)
      IntKiBuf(Int_Xferred) = ICHAR(InData%VTK_OutFileRoot(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%VTK_OutFileBase)
      IntKiBuf(Int_Xferred) = ICHAR(InData%VTK_OutFileBase(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
 END SUBROUTINE FVW_PackParam

 SUBROUTINE FVW_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%nWings = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nSpan = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AFindx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AFindx)) DEALLOCATE(OutData%AFindx)
    ALLOCATE(OutData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%AFindx,2), UBOUND(OutData%AFindx,2)
        DO i1 = LBOUND(OutData%AFindx,1), UBOUND(OutData%AFindx,1)
          OutData%AFindx(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Chord not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Chord)) DEALLOCATE(OutData%Chord)
    ALLOCATE(OutData%Chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Chord.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Chord,2), UBOUND(OutData%Chord,2)
        DO i1 = LBOUND(OutData%Chord,1), UBOUND(OutData%Chord,1)
          OutData%Chord(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%nNWMax = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nFWMax = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nFWFree = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FWShedVorticity = TRANSFER(IntKiBuf(Int_Xferred), OutData%FWShedVorticity)
    Int_Xferred = Int_Xferred + 1
    OutData%IntMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FreeWakeStart = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FullCirculationStart = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CirculationMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PrescribedCirculation not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PrescribedCirculation)) DEALLOCATE(OutData%PrescribedCirculation)
    ALLOCATE(OutData%PrescribedCirculation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrescribedCirculation.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PrescribedCirculation,1), UBOUND(OutData%PrescribedCirculation,1)
        OutData%PrescribedCirculation(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%CircSolvMaxIter = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CircSolvConvCrit = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CircSolvRelaxation = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CircSolvPolar = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%DiffusionMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CoreSpreadEddyVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RegDeterMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%RegFunction = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WakeRegMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WakeRegParam = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WingRegParam = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%ShearModel = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrShadowOnWake = TRANSFER(IntKiBuf(Int_Xferred), OutData%TwrShadowOnWake)
    Int_Xferred = Int_Xferred + 1
    OutData%VelocityMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TreeBranchFactor = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PartPerSegment = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%DTaero = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%DTfvw = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%KinVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WrVTK = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%VTKBlades = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%DTvtk = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%VTKCoord = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%RootName)
      OutData%RootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%VTK_OutFileRoot)
      OutData%VTK_OutFileRoot(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%VTK_OutFileBase)
      OutData%VTK_OutFileBase(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
 END SUBROUTINE FVW_UnPackParam

 SUBROUTINE FVW_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(FVW_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%FirstCall = SrcMiscData%FirstCall
IF (ALLOCATED(SrcMiscData%LE)) THEN
  i1_l = LBOUND(SrcMiscData%LE,1)
  i1_u = UBOUND(SrcMiscData%LE,1)
  i2_l = LBOUND(SrcMiscData%LE,2)
  i2_u = UBOUND(SrcMiscData%LE,2)
  i3_l = LBOUND(SrcMiscData%LE,3)
  i3_u = UBOUND(SrcMiscData%LE,3)
  IF (.NOT. ALLOCATED(DstMiscData%LE)) THEN 
    ALLOCATE(DstMiscData%LE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LE = SrcMiscData%LE
ENDIF
IF (ALLOCATED(SrcMiscData%TE)) THEN
  i1_l = LBOUND(SrcMiscData%TE,1)
  i1_u = UBOUND(SrcMiscData%TE,1)
  i2_l = LBOUND(SrcMiscData%TE,2)
  i2_u = UBOUND(SrcMiscData%TE,2)
  i3_l = LBOUND(SrcMiscData%TE,3)
  i3_u = UBOUND(SrcMiscData%TE,3)
  IF (.NOT. ALLOCATED(DstMiscData%TE)) THEN 
    ALLOCATE(DstMiscData%TE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%TE = SrcMiscData%TE
ENDIF
IF (ALLOCATED(SrcMiscData%r_LL)) THEN
  i1_l = LBOUND(SrcMiscData%r_LL,1)
  i1_u = UBOUND(SrcMiscData%r_LL,1)
  i2_l = LBOUND(SrcMiscData%r_LL,2)
  i2_u = UBOUND(SrcMiscData%r_LL,2)
  i3_l = LBOUND(SrcMiscData%r_LL,3)
  i3_u = UBOUND(SrcMiscData%r_LL,3)
  i4_l = LBOUND(SrcMiscData%r_LL,4)
  i4_u = UBOUND(SrcMiscData%r_LL,4)
  IF (.NOT. ALLOCATED(DstMiscData%r_LL)) THEN 
    ALLOCATE(DstMiscData%r_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_LL = SrcMiscData%r_LL
ENDIF
IF (ALLOCATED(SrcMiscData%s_LL)) THEN
  i1_l = LBOUND(SrcMiscData%s_LL,1)
  i1_u = UBOUND(SrcMiscData%s_LL,1)
  i2_l = LBOUND(SrcMiscData%s_LL,2)
  i2_u = UBOUND(SrcMiscData%s_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%s_LL)) THEN 
    ALLOCATE(DstMiscData%s_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%s_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%s_LL = SrcMiscData%s_LL
ENDIF
IF (ALLOCATED(SrcMiscData%chord_LL)) THEN
  i1_l = LBOUND(SrcMiscData%chord_LL,1)
  i1_u = UBOUND(SrcMiscData%chord_LL,1)
  i2_l = LBOUND(SrcMiscData%chord_LL,2)
  i2_u = UBOUND(SrcMiscData%chord_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%chord_LL)) THEN 
    ALLOCATE(DstMiscData%chord_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%chord_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%chord_LL = SrcMiscData%chord_LL
ENDIF
IF (ALLOCATED(SrcMiscData%s_CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%s_CP_LL,1)
  i1_u = UBOUND(SrcMiscData%s_CP_LL,1)
  i2_l = LBOUND(SrcMiscData%s_CP_LL,2)
  i2_u = UBOUND(SrcMiscData%s_CP_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%s_CP_LL)) THEN 
    ALLOCATE(DstMiscData%s_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%s_CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%s_CP_LL = SrcMiscData%s_CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%chord_CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%chord_CP_LL,1)
  i1_u = UBOUND(SrcMiscData%chord_CP_LL,1)
  i2_l = LBOUND(SrcMiscData%chord_CP_LL,2)
  i2_u = UBOUND(SrcMiscData%chord_CP_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%chord_CP_LL)) THEN 
    ALLOCATE(DstMiscData%chord_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%chord_CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%chord_CP_LL = SrcMiscData%chord_CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%CP_LL,1)
  i1_u = UBOUND(SrcMiscData%CP_LL,1)
  i2_l = LBOUND(SrcMiscData%CP_LL,2)
  i2_u = UBOUND(SrcMiscData%CP_LL,2)
  i3_l = LBOUND(SrcMiscData%CP_LL,3)
  i3_u = UBOUND(SrcMiscData%CP_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%CP_LL)) THEN 
    ALLOCATE(DstMiscData%CP_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CP_LL = SrcMiscData%CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Tang)) THEN
  i1_l = LBOUND(SrcMiscData%Tang,1)
  i1_u = UBOUND(SrcMiscData%Tang,1)
  i2_l = LBOUND(SrcMiscData%Tang,2)
  i2_u = UBOUND(SrcMiscData%Tang,2)
  i3_l = LBOUND(SrcMiscData%Tang,3)
  i3_u = UBOUND(SrcMiscData%Tang,3)
  IF (.NOT. ALLOCATED(DstMiscData%Tang)) THEN 
    ALLOCATE(DstMiscData%Tang(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Tang.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Tang = SrcMiscData%Tang
ENDIF
IF (ALLOCATED(SrcMiscData%Norm)) THEN
  i1_l = LBOUND(SrcMiscData%Norm,1)
  i1_u = UBOUND(SrcMiscData%Norm,1)
  i2_l = LBOUND(SrcMiscData%Norm,2)
  i2_u = UBOUND(SrcMiscData%Norm,2)
  i3_l = LBOUND(SrcMiscData%Norm,3)
  i3_u = UBOUND(SrcMiscData%Norm,3)
  IF (.NOT. ALLOCATED(DstMiscData%Norm)) THEN 
    ALLOCATE(DstMiscData%Norm(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Norm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Norm = SrcMiscData%Norm
ENDIF
IF (ALLOCATED(SrcMiscData%Orth)) THEN
  i1_l = LBOUND(SrcMiscData%Orth,1)
  i1_u = UBOUND(SrcMiscData%Orth,1)
  i2_l = LBOUND(SrcMiscData%Orth,2)
  i2_u = UBOUND(SrcMiscData%Orth,2)
  i3_l = LBOUND(SrcMiscData%Orth,3)
  i3_u = UBOUND(SrcMiscData%Orth,3)
  IF (.NOT. ALLOCATED(DstMiscData%Orth)) THEN 
    ALLOCATE(DstMiscData%Orth(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Orth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Orth = SrcMiscData%Orth
ENDIF
IF (ALLOCATED(SrcMiscData%dl)) THEN
  i1_l = LBOUND(SrcMiscData%dl,1)
  i1_u = UBOUND(SrcMiscData%dl,1)
  i2_l = LBOUND(SrcMiscData%dl,2)
  i2_u = UBOUND(SrcMiscData%dl,2)
  i3_l = LBOUND(SrcMiscData%dl,3)
  i3_u = UBOUND(SrcMiscData%dl,3)
  IF (.NOT. ALLOCATED(DstMiscData%dl)) THEN 
    ALLOCATE(DstMiscData%dl(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dl = SrcMiscData%dl
ENDIF
IF (ALLOCATED(SrcMiscData%Area)) THEN
  i1_l = LBOUND(SrcMiscData%Area,1)
  i1_u = UBOUND(SrcMiscData%Area,1)
  i2_l = LBOUND(SrcMiscData%Area,2)
  i2_u = UBOUND(SrcMiscData%Area,2)
  IF (.NOT. ALLOCATED(DstMiscData%Area)) THEN 
    ALLOCATE(DstMiscData%Area(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Area.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Area = SrcMiscData%Area
ENDIF
IF (ALLOCATED(SrcMiscData%diag_LL)) THEN
  i1_l = LBOUND(SrcMiscData%diag_LL,1)
  i1_u = UBOUND(SrcMiscData%diag_LL,1)
  i2_l = LBOUND(SrcMiscData%diag_LL,2)
  i2_u = UBOUND(SrcMiscData%diag_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%diag_LL)) THEN 
    ALLOCATE(DstMiscData%diag_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%diag_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%diag_LL = SrcMiscData%diag_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Gamma_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Gamma_LL,1)
  i1_u = UBOUND(SrcMiscData%Gamma_LL,1)
  i2_l = LBOUND(SrcMiscData%Gamma_LL,2)
  i2_u = UBOUND(SrcMiscData%Gamma_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%Gamma_LL)) THEN 
    ALLOCATE(DstMiscData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Gamma_LL = SrcMiscData%Gamma_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_LL,1)
  i1_u = UBOUND(SrcMiscData%Vind_LL,1)
  i2_l = LBOUND(SrcMiscData%Vind_LL,2)
  i2_u = UBOUND(SrcMiscData%Vind_LL,2)
  i3_l = LBOUND(SrcMiscData%Vind_LL,3)
  i3_u = UBOUND(SrcMiscData%Vind_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_LL)) THEN 
    ALLOCATE(DstMiscData%Vind_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_LL = SrcMiscData%Vind_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vtot_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vtot_LL,1)
  i1_u = UBOUND(SrcMiscData%Vtot_LL,1)
  i2_l = LBOUND(SrcMiscData%Vtot_LL,2)
  i2_u = UBOUND(SrcMiscData%Vtot_LL,2)
  i3_l = LBOUND(SrcMiscData%Vtot_LL,3)
  i3_u = UBOUND(SrcMiscData%Vtot_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vtot_LL)) THEN 
    ALLOCATE(DstMiscData%Vtot_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vtot_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vtot_LL = SrcMiscData%Vtot_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vstr_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vstr_LL,1)
  i1_u = UBOUND(SrcMiscData%Vstr_LL,1)
  i2_l = LBOUND(SrcMiscData%Vstr_LL,2)
  i2_u = UBOUND(SrcMiscData%Vstr_LL,2)
  i3_l = LBOUND(SrcMiscData%Vstr_LL,3)
  i3_u = UBOUND(SrcMiscData%Vstr_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vstr_LL)) THEN 
    ALLOCATE(DstMiscData%Vstr_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vstr_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vstr_LL = SrcMiscData%Vstr_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_LL,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_LL,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_LL,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_LL,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_LL,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_LL)) THEN 
    ALLOCATE(DstMiscData%Vwnd_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_LL = SrcMiscData%Vwnd_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_NW)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_NW,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_NW,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_NW,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_NW,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_NW,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_NW,3)
  i4_l = LBOUND(SrcMiscData%Vwnd_NW,4)
  i4_u = UBOUND(SrcMiscData%Vwnd_NW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_NW)) THEN 
    ALLOCATE(DstMiscData%Vwnd_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_NW = SrcMiscData%Vwnd_NW
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_FW)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_FW,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_FW,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_FW,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_FW,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_FW,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_FW,3)
  i4_l = LBOUND(SrcMiscData%Vwnd_FW,4)
  i4_u = UBOUND(SrcMiscData%Vwnd_FW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_FW)) THEN 
    ALLOCATE(DstMiscData%Vwnd_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_FW = SrcMiscData%Vwnd_FW
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_NW)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_NW,1)
  i1_u = UBOUND(SrcMiscData%Vind_NW,1)
  i2_l = LBOUND(SrcMiscData%Vind_NW,2)
  i2_u = UBOUND(SrcMiscData%Vind_NW,2)
  i3_l = LBOUND(SrcMiscData%Vind_NW,3)
  i3_u = UBOUND(SrcMiscData%Vind_NW,3)
  i4_l = LBOUND(SrcMiscData%Vind_NW,4)
  i4_u = UBOUND(SrcMiscData%Vind_NW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_NW)) THEN 
    ALLOCATE(DstMiscData%Vind_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_NW = SrcMiscData%Vind_NW
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_FW)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_FW,1)
  i1_u = UBOUND(SrcMiscData%Vind_FW,1)
  i2_l = LBOUND(SrcMiscData%Vind_FW,2)
  i2_u = UBOUND(SrcMiscData%Vind_FW,2)
  i3_l = LBOUND(SrcMiscData%Vind_FW,3)
  i3_u = UBOUND(SrcMiscData%Vind_FW,3)
  i4_l = LBOUND(SrcMiscData%Vind_FW,4)
  i4_u = UBOUND(SrcMiscData%Vind_FW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_FW)) THEN 
    ALLOCATE(DstMiscData%Vind_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_FW = SrcMiscData%Vind_FW
ENDIF
    DstMiscData%nNW = SrcMiscData%nNW
    DstMiscData%nFW = SrcMiscData%nFW
    DstMiscData%iStep = SrcMiscData%iStep
    DstMiscData%VTKstep = SrcMiscData%VTKstep
    DstMiscData%VTKlastTime = SrcMiscData%VTKlastTime
IF (ALLOCATED(SrcMiscData%r_wind)) THEN
  i1_l = LBOUND(SrcMiscData%r_wind,1)
  i1_u = UBOUND(SrcMiscData%r_wind,1)
  i2_l = LBOUND(SrcMiscData%r_wind,2)
  i2_u = UBOUND(SrcMiscData%r_wind,2)
  IF (.NOT. ALLOCATED(DstMiscData%r_wind)) THEN 
    ALLOCATE(DstMiscData%r_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_wind = SrcMiscData%r_wind
ENDIF
IF (ALLOCATED(SrcMiscData%PitchAndTwist)) THEN
  i1_l = LBOUND(SrcMiscData%PitchAndTwist,1)
  i1_u = UBOUND(SrcMiscData%PitchAndTwist,1)
  i2_l = LBOUND(SrcMiscData%PitchAndTwist,2)
  i2_u = UBOUND(SrcMiscData%PitchAndTwist,2)
  IF (.NOT. ALLOCATED(DstMiscData%PitchAndTwist)) THEN 
    ALLOCATE(DstMiscData%PitchAndTwist(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PitchAndTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%PitchAndTwist = SrcMiscData%PitchAndTwist
ENDIF
    DstMiscData%ComputeWakeInduced = SrcMiscData%ComputeWakeInduced
    DstMiscData%OldWakeTime = SrcMiscData%OldWakeTime
    DstMiscData%tSpent = SrcMiscData%tSpent
IF (ALLOCATED(SrcMiscData%dxdt_NW)) THEN
  i1_l = LBOUND(SrcMiscData%dxdt_NW,1)
  i1_u = UBOUND(SrcMiscData%dxdt_NW,1)
  i2_l = LBOUND(SrcMiscData%dxdt_NW,2)
  i2_u = UBOUND(SrcMiscData%dxdt_NW,2)
  i3_l = LBOUND(SrcMiscData%dxdt_NW,3)
  i3_u = UBOUND(SrcMiscData%dxdt_NW,3)
  i4_l = LBOUND(SrcMiscData%dxdt_NW,4)
  i4_u = UBOUND(SrcMiscData%dxdt_NW,4)
  IF (.NOT. ALLOCATED(DstMiscData%dxdt_NW)) THEN 
    ALLOCATE(DstMiscData%dxdt_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dxdt_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dxdt_NW = SrcMiscData%dxdt_NW
ENDIF
IF (ALLOCATED(SrcMiscData%dxdt_FW)) THEN
  i1_l = LBOUND(SrcMiscData%dxdt_FW,1)
  i1_u = UBOUND(SrcMiscData%dxdt_FW,1)
  i2_l = LBOUND(SrcMiscData%dxdt_FW,2)
  i2_u = UBOUND(SrcMiscData%dxdt_FW,2)
  i3_l = LBOUND(SrcMiscData%dxdt_FW,3)
  i3_u = UBOUND(SrcMiscData%dxdt_FW,3)
  i4_l = LBOUND(SrcMiscData%dxdt_FW,4)
  i4_u = UBOUND(SrcMiscData%dxdt_FW,4)
  IF (.NOT. ALLOCATED(DstMiscData%dxdt_FW)) THEN 
    ALLOCATE(DstMiscData%dxdt_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dxdt_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dxdt_FW = SrcMiscData%dxdt_FW
ENDIF
IF (ALLOCATED(SrcMiscData%alpha_LL)) THEN
  i1_l = LBOUND(SrcMiscData%alpha_LL,1)
  i1_u = UBOUND(SrcMiscData%alpha_LL,1)
  i2_l = LBOUND(SrcMiscData%alpha_LL,2)
  i2_u = UBOUND(SrcMiscData%alpha_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%alpha_LL)) THEN 
    ALLOCATE(DstMiscData%alpha_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%alpha_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%alpha_LL = SrcMiscData%alpha_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vreln_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vreln_LL,1)
  i1_u = UBOUND(SrcMiscData%Vreln_LL,1)
  i2_l = LBOUND(SrcMiscData%Vreln_LL,2)
  i2_u = UBOUND(SrcMiscData%Vreln_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%Vreln_LL)) THEN 
    ALLOCATE(DstMiscData%Vreln_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vreln_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vreln_LL = SrcMiscData%Vreln_LL
ENDIF
IF (ALLOCATED(SrcMiscData%SegConnct)) THEN
  i1_l = LBOUND(SrcMiscData%SegConnct,1)
  i1_u = UBOUND(SrcMiscData%SegConnct,1)
  i2_l = LBOUND(SrcMiscData%SegConnct,2)
  i2_u = UBOUND(SrcMiscData%SegConnct,2)
  IF (.NOT. ALLOCATED(DstMiscData%SegConnct)) THEN 
    ALLOCATE(DstMiscData%SegConnct(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SegConnct.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%SegConnct = SrcMiscData%SegConnct
ENDIF
IF (ALLOCATED(SrcMiscData%SegPoints)) THEN
  i1_l = LBOUND(SrcMiscData%SegPoints,1)
  i1_u = UBOUND(SrcMiscData%SegPoints,1)
  i2_l = LBOUND(SrcMiscData%SegPoints,2)
  i2_u = UBOUND(SrcMiscData%SegPoints,2)
  IF (.NOT. ALLOCATED(DstMiscData%SegPoints)) THEN 
    ALLOCATE(DstMiscData%SegPoints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SegPoints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%SegPoints = SrcMiscData%SegPoints
ENDIF
IF (ALLOCATED(SrcMiscData%SegGamma)) THEN
  i1_l = LBOUND(SrcMiscData%SegGamma,1)
  i1_u = UBOUND(SrcMiscData%SegGamma,1)
  IF (.NOT. ALLOCATED(DstMiscData%SegGamma)) THEN 
    ALLOCATE(DstMiscData%SegGamma(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SegGamma.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%SegGamma = SrcMiscData%SegGamma
ENDIF
IF (ALLOCATED(SrcMiscData%SegEpsilon)) THEN
  i1_l = LBOUND(SrcMiscData%SegEpsilon,1)
  i1_u = UBOUND(SrcMiscData%SegEpsilon,1)
  IF (.NOT. ALLOCATED(DstMiscData%SegEpsilon)) THEN 
    ALLOCATE(DstMiscData%SegEpsilon(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SegEpsilon.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%SegEpsilon = SrcMiscData%SegEpsilon
ENDIF
IF (ALLOCATED(SrcMiscData%CPs)) THEN
  i1_l = LBOUND(SrcMiscData%CPs,1)
  i1_u = UBOUND(SrcMiscData%CPs,1)
  i2_l = LBOUND(SrcMiscData%CPs,2)
  i2_u = UBOUND(SrcMiscData%CPs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CPs)) THEN 
    ALLOCATE(DstMiscData%CPs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CPs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CPs = SrcMiscData%CPs
ENDIF
IF (ALLOCATED(SrcMiscData%Uind)) THEN
  i1_l = LBOUND(SrcMiscData%Uind,1)
  i1_u = UBOUND(SrcMiscData%Uind,1)
  i2_l = LBOUND(SrcMiscData%Uind,2)
  i2_u = UBOUND(SrcMiscData%Uind,2)
  IF (.NOT. ALLOCATED(DstMiscData%Uind)) THEN 
    ALLOCATE(DstMiscData%Uind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Uind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Uind = SrcMiscData%Uind
ENDIF
IF (ALLOCATED(SrcMiscData%BN_AxInd)) THEN
  i1_l = LBOUND(SrcMiscData%BN_AxInd,1)
  i1_u = UBOUND(SrcMiscData%BN_AxInd,1)
  i2_l = LBOUND(SrcMiscData%BN_AxInd,2)
  i2_u = UBOUND(SrcMiscData%BN_AxInd,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_AxInd)) THEN 
    ALLOCATE(DstMiscData%BN_AxInd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_AxInd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_AxInd = SrcMiscData%BN_AxInd
ENDIF
IF (ALLOCATED(SrcMiscData%BN_TanInd)) THEN
  i1_l = LBOUND(SrcMiscData%BN_TanInd,1)
  i1_u = UBOUND(SrcMiscData%BN_TanInd,1)
  i2_l = LBOUND(SrcMiscData%BN_TanInd,2)
  i2_u = UBOUND(SrcMiscData%BN_TanInd,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_TanInd)) THEN 
    ALLOCATE(DstMiscData%BN_TanInd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_TanInd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_TanInd = SrcMiscData%BN_TanInd
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Vrel)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Vrel,1)
  i1_u = UBOUND(SrcMiscData%BN_Vrel,1)
  i2_l = LBOUND(SrcMiscData%BN_Vrel,2)
  i2_u = UBOUND(SrcMiscData%BN_Vrel,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Vrel)) THEN 
    ALLOCATE(DstMiscData%BN_Vrel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Vrel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Vrel = SrcMiscData%BN_Vrel
ENDIF
IF (ALLOCATED(SrcMiscData%BN_alpha)) THEN
  i1_l = LBOUND(SrcMiscData%BN_alpha,1)
  i1_u = UBOUND(SrcMiscData%BN_alpha,1)
  i2_l = LBOUND(SrcMiscData%BN_alpha,2)
  i2_u = UBOUND(SrcMiscData%BN_alpha,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_alpha)) THEN 
    ALLOCATE(DstMiscData%BN_alpha(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_alpha.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_alpha = SrcMiscData%BN_alpha
ENDIF
IF (ALLOCATED(SrcMiscData%BN_phi)) THEN
  i1_l = LBOUND(SrcMiscData%BN_phi,1)
  i1_u = UBOUND(SrcMiscData%BN_phi,1)
  i2_l = LBOUND(SrcMiscData%BN_phi,2)
  i2_u = UBOUND(SrcMiscData%BN_phi,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_phi)) THEN 
    ALLOCATE(DstMiscData%BN_phi(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_phi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_phi = SrcMiscData%BN_phi
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Re)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Re,1)
  i1_u = UBOUND(SrcMiscData%BN_Re,1)
  i2_l = LBOUND(SrcMiscData%BN_Re,2)
  i2_u = UBOUND(SrcMiscData%BN_Re,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Re)) THEN 
    ALLOCATE(DstMiscData%BN_Re(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Re.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Re = SrcMiscData%BN_Re
ENDIF
IF (ALLOCATED(SrcMiscData%BN_URelWind_s)) THEN
  i1_l = LBOUND(SrcMiscData%BN_URelWind_s,1)
  i1_u = UBOUND(SrcMiscData%BN_URelWind_s,1)
  i2_l = LBOUND(SrcMiscData%BN_URelWind_s,2)
  i2_u = UBOUND(SrcMiscData%BN_URelWind_s,2)
  i3_l = LBOUND(SrcMiscData%BN_URelWind_s,3)
  i3_u = UBOUND(SrcMiscData%BN_URelWind_s,3)
  IF (.NOT. ALLOCATED(DstMiscData%BN_URelWind_s)) THEN 
    ALLOCATE(DstMiscData%BN_URelWind_s(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_URelWind_s.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_URelWind_s = SrcMiscData%BN_URelWind_s
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cl_Static)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cl_Static,1)
  i1_u = UBOUND(SrcMiscData%BN_Cl_Static,1)
  i2_l = LBOUND(SrcMiscData%BN_Cl_Static,2)
  i2_u = UBOUND(SrcMiscData%BN_Cl_Static,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cl_Static)) THEN 
    ALLOCATE(DstMiscData%BN_Cl_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cl_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cl_Static = SrcMiscData%BN_Cl_Static
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cd_Static)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cd_Static,1)
  i1_u = UBOUND(SrcMiscData%BN_Cd_Static,1)
  i2_l = LBOUND(SrcMiscData%BN_Cd_Static,2)
  i2_u = UBOUND(SrcMiscData%BN_Cd_Static,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cd_Static)) THEN 
    ALLOCATE(DstMiscData%BN_Cd_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cd_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cd_Static = SrcMiscData%BN_Cd_Static
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cm_Static)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cm_Static,1)
  i1_u = UBOUND(SrcMiscData%BN_Cm_Static,1)
  i2_l = LBOUND(SrcMiscData%BN_Cm_Static,2)
  i2_u = UBOUND(SrcMiscData%BN_Cm_Static,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cm_Static)) THEN 
    ALLOCATE(DstMiscData%BN_Cm_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cm_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cm_Static = SrcMiscData%BN_Cm_Static
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cl)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cl,1)
  i1_u = UBOUND(SrcMiscData%BN_Cl,1)
  i2_l = LBOUND(SrcMiscData%BN_Cl,2)
  i2_u = UBOUND(SrcMiscData%BN_Cl,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cl)) THEN 
    ALLOCATE(DstMiscData%BN_Cl(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cl = SrcMiscData%BN_Cl
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cd)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cd,1)
  i1_u = UBOUND(SrcMiscData%BN_Cd,1)
  i2_l = LBOUND(SrcMiscData%BN_Cd,2)
  i2_u = UBOUND(SrcMiscData%BN_Cd,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cd)) THEN 
    ALLOCATE(DstMiscData%BN_Cd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cd = SrcMiscData%BN_Cd
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cm)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cm,1)
  i1_u = UBOUND(SrcMiscData%BN_Cm,1)
  i2_l = LBOUND(SrcMiscData%BN_Cm,2)
  i2_u = UBOUND(SrcMiscData%BN_Cm,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cm)) THEN 
    ALLOCATE(DstMiscData%BN_Cm(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cm = SrcMiscData%BN_Cm
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cx)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cx,1)
  i1_u = UBOUND(SrcMiscData%BN_Cx,1)
  i2_l = LBOUND(SrcMiscData%BN_Cx,2)
  i2_u = UBOUND(SrcMiscData%BN_Cx,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cx)) THEN 
    ALLOCATE(DstMiscData%BN_Cx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cx = SrcMiscData%BN_Cx
ENDIF
IF (ALLOCATED(SrcMiscData%BN_Cy)) THEN
  i1_l = LBOUND(SrcMiscData%BN_Cy,1)
  i1_u = UBOUND(SrcMiscData%BN_Cy,1)
  i2_l = LBOUND(SrcMiscData%BN_Cy,2)
  i2_u = UBOUND(SrcMiscData%BN_Cy,2)
  IF (.NOT. ALLOCATED(DstMiscData%BN_Cy)) THEN 
    ALLOCATE(DstMiscData%BN_Cy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BN_Cy.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BN_Cy = SrcMiscData%BN_Cy
ENDIF
      CALL UA_CopyMisc( SrcMiscData%m_UA, DstMiscData%m_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL UA_CopyOutput( SrcMiscData%y_UA, DstMiscData%y_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL UA_CopyParam( SrcMiscData%p_UA, DstMiscData%p_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%UA_Flag = SrcMiscData%UA_Flag
IF (ALLOCATED(SrcMiscData%Vwnd_ND)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_ND,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_ND,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_ND,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_ND,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_ND,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_ND,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_ND)) THEN 
    ALLOCATE(DstMiscData%Vwnd_ND(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_ND.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_ND = SrcMiscData%Vwnd_ND
ENDIF
 END SUBROUTINE FVW_CopyMisc

 SUBROUTINE FVW_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(FVW_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MiscData%LE)) THEN
  DEALLOCATE(MiscData%LE)
ENDIF
IF (ALLOCATED(MiscData%TE)) THEN
  DEALLOCATE(MiscData%TE)
ENDIF
IF (ALLOCATED(MiscData%r_LL)) THEN
  DEALLOCATE(MiscData%r_LL)
ENDIF
IF (ALLOCATED(MiscData%s_LL)) THEN
  DEALLOCATE(MiscData%s_LL)
ENDIF
IF (ALLOCATED(MiscData%chord_LL)) THEN
  DEALLOCATE(MiscData%chord_LL)
ENDIF
IF (ALLOCATED(MiscData%s_CP_LL)) THEN
  DEALLOCATE(MiscData%s_CP_LL)
ENDIF
IF (ALLOCATED(MiscData%chord_CP_LL)) THEN
  DEALLOCATE(MiscData%chord_CP_LL)
ENDIF
IF (ALLOCATED(MiscData%CP_LL)) THEN
  DEALLOCATE(MiscData%CP_LL)
ENDIF
IF (ALLOCATED(MiscData%Tang)) THEN
  DEALLOCATE(MiscData%Tang)
ENDIF
IF (ALLOCATED(MiscData%Norm)) THEN
  DEALLOCATE(MiscData%Norm)
ENDIF
IF (ALLOCATED(MiscData%Orth)) THEN
  DEALLOCATE(MiscData%Orth)
ENDIF
IF (ALLOCATED(MiscData%dl)) THEN
  DEALLOCATE(MiscData%dl)
ENDIF
IF (ALLOCATED(MiscData%Area)) THEN
  DEALLOCATE(MiscData%Area)
ENDIF
IF (ALLOCATED(MiscData%diag_LL)) THEN
  DEALLOCATE(MiscData%diag_LL)
ENDIF
IF (ALLOCATED(MiscData%Gamma_LL)) THEN
  DEALLOCATE(MiscData%Gamma_LL)
ENDIF
IF (ALLOCATED(MiscData%Vind_LL)) THEN
  DEALLOCATE(MiscData%Vind_LL)
ENDIF
IF (ALLOCATED(MiscData%Vtot_LL)) THEN
  DEALLOCATE(MiscData%Vtot_LL)
ENDIF
IF (ALLOCATED(MiscData%Vstr_LL)) THEN
  DEALLOCATE(MiscData%Vstr_LL)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_LL)) THEN
  DEALLOCATE(MiscData%Vwnd_LL)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_NW)) THEN
  DEALLOCATE(MiscData%Vwnd_NW)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_FW)) THEN
  DEALLOCATE(MiscData%Vwnd_FW)
ENDIF
IF (ALLOCATED(MiscData%Vind_NW)) THEN
  DEALLOCATE(MiscData%Vind_NW)
ENDIF
IF (ALLOCATED(MiscData%Vind_FW)) THEN
  DEALLOCATE(MiscData%Vind_FW)
ENDIF
IF (ALLOCATED(MiscData%r_wind)) THEN
  DEALLOCATE(MiscData%r_wind)
ENDIF
IF (ALLOCATED(MiscData%PitchAndTwist)) THEN
  DEALLOCATE(MiscData%PitchAndTwist)
ENDIF
IF (ALLOCATED(MiscData%dxdt_NW)) THEN
  DEALLOCATE(MiscData%dxdt_NW)
ENDIF
IF (ALLOCATED(MiscData%dxdt_FW)) THEN
  DEALLOCATE(MiscData%dxdt_FW)
ENDIF
IF (ALLOCATED(MiscData%alpha_LL)) THEN
  DEALLOCATE(MiscData%alpha_LL)
ENDIF
IF (ALLOCATED(MiscData%Vreln_LL)) THEN
  DEALLOCATE(MiscData%Vreln_LL)
ENDIF
IF (ALLOCATED(MiscData%SegConnct)) THEN
  DEALLOCATE(MiscData%SegConnct)
ENDIF
IF (ALLOCATED(MiscData%SegPoints)) THEN
  DEALLOCATE(MiscData%SegPoints)
ENDIF
IF (ALLOCATED(MiscData%SegGamma)) THEN
  DEALLOCATE(MiscData%SegGamma)
ENDIF
IF (ALLOCATED(MiscData%SegEpsilon)) THEN
  DEALLOCATE(MiscData%SegEpsilon)
ENDIF
IF (ALLOCATED(MiscData%CPs)) THEN
  DEALLOCATE(MiscData%CPs)
ENDIF
IF (ALLOCATED(MiscData%Uind)) THEN
  DEALLOCATE(MiscData%Uind)
ENDIF
IF (ALLOCATED(MiscData%BN_AxInd)) THEN
  DEALLOCATE(MiscData%BN_AxInd)
ENDIF
IF (ALLOCATED(MiscData%BN_TanInd)) THEN
  DEALLOCATE(MiscData%BN_TanInd)
ENDIF
IF (ALLOCATED(MiscData%BN_Vrel)) THEN
  DEALLOCATE(MiscData%BN_Vrel)
ENDIF
IF (ALLOCATED(MiscData%BN_alpha)) THEN
  DEALLOCATE(MiscData%BN_alpha)
ENDIF
IF (ALLOCATED(MiscData%BN_phi)) THEN
  DEALLOCATE(MiscData%BN_phi)
ENDIF
IF (ALLOCATED(MiscData%BN_Re)) THEN
  DEALLOCATE(MiscData%BN_Re)
ENDIF
IF (ALLOCATED(MiscData%BN_URelWind_s)) THEN
  DEALLOCATE(MiscData%BN_URelWind_s)
ENDIF
IF (ALLOCATED(MiscData%BN_Cl_Static)) THEN
  DEALLOCATE(MiscData%BN_Cl_Static)
ENDIF
IF (ALLOCATED(MiscData%BN_Cd_Static)) THEN
  DEALLOCATE(MiscData%BN_Cd_Static)
ENDIF
IF (ALLOCATED(MiscData%BN_Cm_Static)) THEN
  DEALLOCATE(MiscData%BN_Cm_Static)
ENDIF
IF (ALLOCATED(MiscData%BN_Cl)) THEN
  DEALLOCATE(MiscData%BN_Cl)
ENDIF
IF (ALLOCATED(MiscData%BN_Cd)) THEN
  DEALLOCATE(MiscData%BN_Cd)
ENDIF
IF (ALLOCATED(MiscData%BN_Cm)) THEN
  DEALLOCATE(MiscData%BN_Cm)
ENDIF
IF (ALLOCATED(MiscData%BN_Cx)) THEN
  DEALLOCATE(MiscData%BN_Cx)
ENDIF
IF (ALLOCATED(MiscData%BN_Cy)) THEN
  DEALLOCATE(MiscData%BN_Cy)
ENDIF
  CALL UA_DestroyMisc( MiscData%m_UA, ErrStat, ErrMsg )
  CALL UA_DestroyOutput( MiscData%y_UA, ErrStat, ErrMsg )
  CALL UA_DestroyParam( MiscData%p_UA, ErrStat, ErrMsg )
IF (ALLOCATED(MiscData%Vwnd_ND)) THEN
  DEALLOCATE(MiscData%Vwnd_ND)
ENDIF
 END SUBROUTINE FVW_DestroyMisc

 SUBROUTINE FVW_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! FirstCall
  Int_BufSz   = Int_BufSz   + 1     ! LE allocated yes/no
  IF ( ALLOCATED(InData%LE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! LE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%LE)  ! LE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TE allocated yes/no
  IF ( ALLOCATED(InData%TE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! TE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TE)  ! TE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_LL allocated yes/no
  IF ( ALLOCATED(InData%r_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_LL)  ! r_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! s_LL allocated yes/no
  IF ( ALLOCATED(InData%s_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! s_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%s_LL)  ! s_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! chord_LL allocated yes/no
  IF ( ALLOCATED(InData%chord_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! chord_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%chord_LL)  ! chord_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! s_CP_LL allocated yes/no
  IF ( ALLOCATED(InData%s_CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! s_CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%s_CP_LL)  ! s_CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! chord_CP_LL allocated yes/no
  IF ( ALLOCATED(InData%chord_CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! chord_CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%chord_CP_LL)  ! chord_CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CP_LL allocated yes/no
  IF ( ALLOCATED(InData%CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CP_LL)  ! CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Tang allocated yes/no
  IF ( ALLOCATED(InData%Tang) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Tang upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Tang)  ! Tang
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Norm allocated yes/no
  IF ( ALLOCATED(InData%Norm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Norm upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Norm)  ! Norm
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Orth allocated yes/no
  IF ( ALLOCATED(InData%Orth) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Orth upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Orth)  ! Orth
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! dl allocated yes/no
  IF ( ALLOCATED(InData%dl) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! dl upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%dl)  ! dl
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Area allocated yes/no
  IF ( ALLOCATED(InData%Area) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Area upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Area)  ! Area
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! diag_LL allocated yes/no
  IF ( ALLOCATED(InData%diag_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! diag_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%diag_LL)  ! diag_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_LL allocated yes/no
  IF ( ALLOCATED(InData%Gamma_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Gamma_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_LL)  ! Gamma_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_LL allocated yes/no
  IF ( ALLOCATED(InData%Vind_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vind_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_LL)  ! Vind_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vtot_LL allocated yes/no
  IF ( ALLOCATED(InData%Vtot_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vtot_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vtot_LL)  ! Vtot_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vstr_LL allocated yes/no
  IF ( ALLOCATED(InData%Vstr_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vstr_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vstr_LL)  ! Vstr_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_LL allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vwnd_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_LL)  ! Vwnd_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_NW allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vwnd_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_NW)  ! Vwnd_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_FW allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vwnd_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_FW)  ! Vwnd_FW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_NW allocated yes/no
  IF ( ALLOCATED(InData%Vind_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vind_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_NW)  ! Vind_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_FW allocated yes/no
  IF ( ALLOCATED(InData%Vind_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vind_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_FW)  ! Vind_FW
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! nNW
      Int_BufSz  = Int_BufSz  + 1  ! nFW
      Int_BufSz  = Int_BufSz  + 1  ! iStep
      Int_BufSz  = Int_BufSz  + 1  ! VTKstep
      Db_BufSz   = Db_BufSz   + 1  ! VTKlastTime
  Int_BufSz   = Int_BufSz   + 1     ! r_wind allocated yes/no
  IF ( ALLOCATED(InData%r_wind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! r_wind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_wind)  ! r_wind
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PitchAndTwist allocated yes/no
  IF ( ALLOCATED(InData%PitchAndTwist) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! PitchAndTwist upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%PitchAndTwist)  ! PitchAndTwist
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! ComputeWakeInduced
      Db_BufSz   = Db_BufSz   + 1  ! OldWakeTime
      Re_BufSz   = Re_BufSz   + 1  ! tSpent
  Int_BufSz   = Int_BufSz   + 1     ! dxdt_NW allocated yes/no
  IF ( ALLOCATED(InData%dxdt_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! dxdt_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%dxdt_NW)  ! dxdt_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! dxdt_FW allocated yes/no
  IF ( ALLOCATED(InData%dxdt_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! dxdt_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%dxdt_FW)  ! dxdt_FW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! alpha_LL allocated yes/no
  IF ( ALLOCATED(InData%alpha_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! alpha_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%alpha_LL)  ! alpha_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vreln_LL allocated yes/no
  IF ( ALLOCATED(InData%Vreln_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Vreln_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vreln_LL)  ! Vreln_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SegConnct allocated yes/no
  IF ( ALLOCATED(InData%SegConnct) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SegConnct upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%SegConnct)  ! SegConnct
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SegPoints allocated yes/no
  IF ( ALLOCATED(InData%SegPoints) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! SegPoints upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SegPoints)  ! SegPoints
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SegGamma allocated yes/no
  IF ( ALLOCATED(InData%SegGamma) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! SegGamma upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SegGamma)  ! SegGamma
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SegEpsilon allocated yes/no
  IF ( ALLOCATED(InData%SegEpsilon) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! SegEpsilon upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SegEpsilon)  ! SegEpsilon
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CPs allocated yes/no
  IF ( ALLOCATED(InData%CPs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CPs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CPs)  ! CPs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Uind allocated yes/no
  IF ( ALLOCATED(InData%Uind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Uind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Uind)  ! Uind
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_AxInd allocated yes/no
  IF ( ALLOCATED(InData%BN_AxInd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_AxInd upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_AxInd)  ! BN_AxInd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_TanInd allocated yes/no
  IF ( ALLOCATED(InData%BN_TanInd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_TanInd upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_TanInd)  ! BN_TanInd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Vrel allocated yes/no
  IF ( ALLOCATED(InData%BN_Vrel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Vrel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Vrel)  ! BN_Vrel
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_alpha allocated yes/no
  IF ( ALLOCATED(InData%BN_alpha) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_alpha upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_alpha)  ! BN_alpha
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_phi allocated yes/no
  IF ( ALLOCATED(InData%BN_phi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_phi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_phi)  ! BN_phi
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Re allocated yes/no
  IF ( ALLOCATED(InData%BN_Re) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Re upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Re)  ! BN_Re
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_URelWind_s allocated yes/no
  IF ( ALLOCATED(InData%BN_URelWind_s) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! BN_URelWind_s upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_URelWind_s)  ! BN_URelWind_s
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cl_Static allocated yes/no
  IF ( ALLOCATED(InData%BN_Cl_Static) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cl_Static upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cl_Static)  ! BN_Cl_Static
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cd_Static allocated yes/no
  IF ( ALLOCATED(InData%BN_Cd_Static) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cd_Static upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cd_Static)  ! BN_Cd_Static
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cm_Static allocated yes/no
  IF ( ALLOCATED(InData%BN_Cm_Static) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cm_Static upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cm_Static)  ! BN_Cm_Static
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cl allocated yes/no
  IF ( ALLOCATED(InData%BN_Cl) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cl upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cl)  ! BN_Cl
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cd allocated yes/no
  IF ( ALLOCATED(InData%BN_Cd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cd upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cd)  ! BN_Cd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cm allocated yes/no
  IF ( ALLOCATED(InData%BN_Cm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cm upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cm)  ! BN_Cm
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cx allocated yes/no
  IF ( ALLOCATED(InData%BN_Cx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cx upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cx)  ! BN_Cx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BN_Cy allocated yes/no
  IF ( ALLOCATED(InData%BN_Cy) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BN_Cy upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BN_Cy)  ! BN_Cy
  END IF
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! m_UA: size of buffers for each call to pack subtype
      CALL UA_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%m_UA, ErrStat2, ErrMsg2, .TRUE. ) ! m_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! m_UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! m_UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! m_UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! y_UA: size of buffers for each call to pack subtype
      CALL UA_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%y_UA, ErrStat2, ErrMsg2, .TRUE. ) ! y_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! y_UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! y_UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! y_UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! p_UA: size of buffers for each call to pack subtype
      CALL UA_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%p_UA, ErrStat2, ErrMsg2, .TRUE. ) ! p_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! p_UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! p_UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! p_UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! UA_Flag
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_ND allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_ND) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vwnd_ND upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_ND)  ! Vwnd_ND
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = TRANSFER(InData%FirstCall, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%LE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%LE,3), UBOUND(InData%LE,3)
        DO i2 = LBOUND(InData%LE,2), UBOUND(InData%LE,2)
          DO i1 = LBOUND(InData%LE,1), UBOUND(InData%LE,1)
            ReKiBuf(Re_Xferred) = InData%LE(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%TE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%TE,3), UBOUND(InData%TE,3)
        DO i2 = LBOUND(InData%TE,2), UBOUND(InData%TE,2)
          DO i1 = LBOUND(InData%TE,1), UBOUND(InData%TE,1)
            ReKiBuf(Re_Xferred) = InData%TE(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%r_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%r_LL,4), UBOUND(InData%r_LL,4)
        DO i3 = LBOUND(InData%r_LL,3), UBOUND(InData%r_LL,3)
          DO i2 = LBOUND(InData%r_LL,2), UBOUND(InData%r_LL,2)
            DO i1 = LBOUND(InData%r_LL,1), UBOUND(InData%r_LL,1)
              ReKiBuf(Re_Xferred) = InData%r_LL(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%s_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%s_LL,2), UBOUND(InData%s_LL,2)
        DO i1 = LBOUND(InData%s_LL,1), UBOUND(InData%s_LL,1)
          ReKiBuf(Re_Xferred) = InData%s_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%chord_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%chord_LL,2), UBOUND(InData%chord_LL,2)
        DO i1 = LBOUND(InData%chord_LL,1), UBOUND(InData%chord_LL,1)
          ReKiBuf(Re_Xferred) = InData%chord_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%s_CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_CP_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%s_CP_LL,2), UBOUND(InData%s_CP_LL,2)
        DO i1 = LBOUND(InData%s_CP_LL,1), UBOUND(InData%s_CP_LL,1)
          ReKiBuf(Re_Xferred) = InData%s_CP_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%chord_CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_CP_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%chord_CP_LL,2), UBOUND(InData%chord_CP_LL,2)
        DO i1 = LBOUND(InData%chord_CP_LL,1), UBOUND(InData%chord_CP_LL,1)
          ReKiBuf(Re_Xferred) = InData%chord_CP_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%CP_LL,3), UBOUND(InData%CP_LL,3)
        DO i2 = LBOUND(InData%CP_LL,2), UBOUND(InData%CP_LL,2)
          DO i1 = LBOUND(InData%CP_LL,1), UBOUND(InData%CP_LL,1)
            ReKiBuf(Re_Xferred) = InData%CP_LL(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Tang) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Tang,3), UBOUND(InData%Tang,3)
        DO i2 = LBOUND(InData%Tang,2), UBOUND(InData%Tang,2)
          DO i1 = LBOUND(InData%Tang,1), UBOUND(InData%Tang,1)
            ReKiBuf(Re_Xferred) = InData%Tang(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Norm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Norm,3), UBOUND(InData%Norm,3)
        DO i2 = LBOUND(InData%Norm,2), UBOUND(InData%Norm,2)
          DO i1 = LBOUND(InData%Norm,1), UBOUND(InData%Norm,1)
            ReKiBuf(Re_Xferred) = InData%Norm(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Orth) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Orth,3), UBOUND(InData%Orth,3)
        DO i2 = LBOUND(InData%Orth,2), UBOUND(InData%Orth,2)
          DO i1 = LBOUND(InData%Orth,1), UBOUND(InData%Orth,1)
            ReKiBuf(Re_Xferred) = InData%Orth(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%dl) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%dl,3), UBOUND(InData%dl,3)
        DO i2 = LBOUND(InData%dl,2), UBOUND(InData%dl,2)
          DO i1 = LBOUND(InData%dl,1), UBOUND(InData%dl,1)
            ReKiBuf(Re_Xferred) = InData%dl(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Area) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Area,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Area,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Area,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Area,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Area,2), UBOUND(InData%Area,2)
        DO i1 = LBOUND(InData%Area,1), UBOUND(InData%Area,1)
          ReKiBuf(Re_Xferred) = InData%Area(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%diag_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%diag_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%diag_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%diag_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%diag_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%diag_LL,2), UBOUND(InData%diag_LL,2)
        DO i1 = LBOUND(InData%diag_LL,1), UBOUND(InData%diag_LL,1)
          ReKiBuf(Re_Xferred) = InData%diag_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Gamma_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Gamma_LL,2), UBOUND(InData%Gamma_LL,2)
        DO i1 = LBOUND(InData%Gamma_LL,1), UBOUND(InData%Gamma_LL,1)
          ReKiBuf(Re_Xferred) = InData%Gamma_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vind_LL,3), UBOUND(InData%Vind_LL,3)
        DO i2 = LBOUND(InData%Vind_LL,2), UBOUND(InData%Vind_LL,2)
          DO i1 = LBOUND(InData%Vind_LL,1), UBOUND(InData%Vind_LL,1)
            ReKiBuf(Re_Xferred) = InData%Vind_LL(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vtot_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vtot_LL,3), UBOUND(InData%Vtot_LL,3)
        DO i2 = LBOUND(InData%Vtot_LL,2), UBOUND(InData%Vtot_LL,2)
          DO i1 = LBOUND(InData%Vtot_LL,1), UBOUND(InData%Vtot_LL,1)
            ReKiBuf(Re_Xferred) = InData%Vtot_LL(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vstr_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vstr_LL,3), UBOUND(InData%Vstr_LL,3)
        DO i2 = LBOUND(InData%Vstr_LL,2), UBOUND(InData%Vstr_LL,2)
          DO i1 = LBOUND(InData%Vstr_LL,1), UBOUND(InData%Vstr_LL,1)
            ReKiBuf(Re_Xferred) = InData%Vstr_LL(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vwnd_LL,3), UBOUND(InData%Vwnd_LL,3)
        DO i2 = LBOUND(InData%Vwnd_LL,2), UBOUND(InData%Vwnd_LL,2)
          DO i1 = LBOUND(InData%Vwnd_LL,1), UBOUND(InData%Vwnd_LL,1)
            ReKiBuf(Re_Xferred) = InData%Vwnd_LL(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Vwnd_NW,4), UBOUND(InData%Vwnd_NW,4)
        DO i3 = LBOUND(InData%Vwnd_NW,3), UBOUND(InData%Vwnd_NW,3)
          DO i2 = LBOUND(InData%Vwnd_NW,2), UBOUND(InData%Vwnd_NW,2)
            DO i1 = LBOUND(InData%Vwnd_NW,1), UBOUND(InData%Vwnd_NW,1)
              ReKiBuf(Re_Xferred) = InData%Vwnd_NW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Vwnd_FW,4), UBOUND(InData%Vwnd_FW,4)
        DO i3 = LBOUND(InData%Vwnd_FW,3), UBOUND(InData%Vwnd_FW,3)
          DO i2 = LBOUND(InData%Vwnd_FW,2), UBOUND(InData%Vwnd_FW,2)
            DO i1 = LBOUND(InData%Vwnd_FW,1), UBOUND(InData%Vwnd_FW,1)
              ReKiBuf(Re_Xferred) = InData%Vwnd_FW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Vind_NW,4), UBOUND(InData%Vind_NW,4)
        DO i3 = LBOUND(InData%Vind_NW,3), UBOUND(InData%Vind_NW,3)
          DO i2 = LBOUND(InData%Vind_NW,2), UBOUND(InData%Vind_NW,2)
            DO i1 = LBOUND(InData%Vind_NW,1), UBOUND(InData%Vind_NW,1)
              ReKiBuf(Re_Xferred) = InData%Vind_NW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Vind_FW,4), UBOUND(InData%Vind_FW,4)
        DO i3 = LBOUND(InData%Vind_FW,3), UBOUND(InData%Vind_FW,3)
          DO i2 = LBOUND(InData%Vind_FW,2), UBOUND(InData%Vind_FW,2)
            DO i1 = LBOUND(InData%Vind_FW,1), UBOUND(InData%Vind_FW,1)
              ReKiBuf(Re_Xferred) = InData%Vind_FW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%nNW
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nFW
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%iStep
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VTKstep
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%VTKlastTime
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%r_wind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_wind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_wind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_wind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_wind,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%r_wind,2), UBOUND(InData%r_wind,2)
        DO i1 = LBOUND(InData%r_wind,1), UBOUND(InData%r_wind,1)
          ReKiBuf(Re_Xferred) = InData%r_wind(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PitchAndTwist) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PitchAndTwist,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PitchAndTwist,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PitchAndTwist,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PitchAndTwist,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%PitchAndTwist,2), UBOUND(InData%PitchAndTwist,2)
        DO i1 = LBOUND(InData%PitchAndTwist,1), UBOUND(InData%PitchAndTwist,1)
          ReKiBuf(Re_Xferred) = InData%PitchAndTwist(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    IntKiBuf(Int_Xferred) = TRANSFER(InData%ComputeWakeInduced, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%OldWakeTime
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%tSpent
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%dxdt_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_NW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%dxdt_NW,4), UBOUND(InData%dxdt_NW,4)
        DO i3 = LBOUND(InData%dxdt_NW,3), UBOUND(InData%dxdt_NW,3)
          DO i2 = LBOUND(InData%dxdt_NW,2), UBOUND(InData%dxdt_NW,2)
            DO i1 = LBOUND(InData%dxdt_NW,1), UBOUND(InData%dxdt_NW,1)
              ReKiBuf(Re_Xferred) = InData%dxdt_NW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%dxdt_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dxdt_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dxdt_FW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%dxdt_FW,4), UBOUND(InData%dxdt_FW,4)
        DO i3 = LBOUND(InData%dxdt_FW,3), UBOUND(InData%dxdt_FW,3)
          DO i2 = LBOUND(InData%dxdt_FW,2), UBOUND(InData%dxdt_FW,2)
            DO i1 = LBOUND(InData%dxdt_FW,1), UBOUND(InData%dxdt_FW,1)
              ReKiBuf(Re_Xferred) = InData%dxdt_FW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%alpha_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%alpha_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%alpha_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%alpha_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%alpha_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%alpha_LL,2), UBOUND(InData%alpha_LL,2)
        DO i1 = LBOUND(InData%alpha_LL,1), UBOUND(InData%alpha_LL,1)
          ReKiBuf(Re_Xferred) = InData%alpha_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vreln_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vreln_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vreln_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vreln_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vreln_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Vreln_LL,2), UBOUND(InData%Vreln_LL,2)
        DO i1 = LBOUND(InData%Vreln_LL,1), UBOUND(InData%Vreln_LL,1)
          ReKiBuf(Re_Xferred) = InData%Vreln_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SegConnct) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegConnct,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegConnct,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegConnct,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegConnct,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%SegConnct,2), UBOUND(InData%SegConnct,2)
        DO i1 = LBOUND(InData%SegConnct,1), UBOUND(InData%SegConnct,1)
          IntKiBuf(Int_Xferred) = InData%SegConnct(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SegPoints) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegPoints,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegPoints,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegPoints,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegPoints,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%SegPoints,2), UBOUND(InData%SegPoints,2)
        DO i1 = LBOUND(InData%SegPoints,1), UBOUND(InData%SegPoints,1)
          ReKiBuf(Re_Xferred) = InData%SegPoints(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SegGamma) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegGamma,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegGamma,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%SegGamma,1), UBOUND(InData%SegGamma,1)
        ReKiBuf(Re_Xferred) = InData%SegGamma(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SegEpsilon) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SegEpsilon,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SegEpsilon,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%SegEpsilon,1), UBOUND(InData%SegEpsilon,1)
        ReKiBuf(Re_Xferred) = InData%SegEpsilon(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CPs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CPs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CPs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CPs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CPs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%CPs,2), UBOUND(InData%CPs,2)
        DO i1 = LBOUND(InData%CPs,1), UBOUND(InData%CPs,1)
          ReKiBuf(Re_Xferred) = InData%CPs(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Uind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Uind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Uind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Uind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Uind,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Uind,2), UBOUND(InData%Uind,2)
        DO i1 = LBOUND(InData%Uind,1), UBOUND(InData%Uind,1)
          ReKiBuf(Re_Xferred) = InData%Uind(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_AxInd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_AxInd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_AxInd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_AxInd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_AxInd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_AxInd,2), UBOUND(InData%BN_AxInd,2)
        DO i1 = LBOUND(InData%BN_AxInd,1), UBOUND(InData%BN_AxInd,1)
          ReKiBuf(Re_Xferred) = InData%BN_AxInd(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_TanInd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_TanInd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_TanInd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_TanInd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_TanInd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_TanInd,2), UBOUND(InData%BN_TanInd,2)
        DO i1 = LBOUND(InData%BN_TanInd,1), UBOUND(InData%BN_TanInd,1)
          ReKiBuf(Re_Xferred) = InData%BN_TanInd(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Vrel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Vrel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Vrel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Vrel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Vrel,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Vrel,2), UBOUND(InData%BN_Vrel,2)
        DO i1 = LBOUND(InData%BN_Vrel,1), UBOUND(InData%BN_Vrel,1)
          ReKiBuf(Re_Xferred) = InData%BN_Vrel(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_alpha) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_alpha,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_alpha,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_alpha,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_alpha,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_alpha,2), UBOUND(InData%BN_alpha,2)
        DO i1 = LBOUND(InData%BN_alpha,1), UBOUND(InData%BN_alpha,1)
          ReKiBuf(Re_Xferred) = InData%BN_alpha(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_phi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_phi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_phi,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_phi,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_phi,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_phi,2), UBOUND(InData%BN_phi,2)
        DO i1 = LBOUND(InData%BN_phi,1), UBOUND(InData%BN_phi,1)
          ReKiBuf(Re_Xferred) = InData%BN_phi(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Re) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Re,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Re,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Re,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Re,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Re,2), UBOUND(InData%BN_Re,2)
        DO i1 = LBOUND(InData%BN_Re,1), UBOUND(InData%BN_Re,1)
          ReKiBuf(Re_Xferred) = InData%BN_Re(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_URelWind_s) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_URelWind_s,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_URelWind_s,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_URelWind_s,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_URelWind_s,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_URelWind_s,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_URelWind_s,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%BN_URelWind_s,3), UBOUND(InData%BN_URelWind_s,3)
        DO i2 = LBOUND(InData%BN_URelWind_s,2), UBOUND(InData%BN_URelWind_s,2)
          DO i1 = LBOUND(InData%BN_URelWind_s,1), UBOUND(InData%BN_URelWind_s,1)
            ReKiBuf(Re_Xferred) = InData%BN_URelWind_s(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cl_Static) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cl_Static,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cl_Static,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cl_Static,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cl_Static,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cl_Static,2), UBOUND(InData%BN_Cl_Static,2)
        DO i1 = LBOUND(InData%BN_Cl_Static,1), UBOUND(InData%BN_Cl_Static,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cl_Static(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cd_Static) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cd_Static,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cd_Static,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cd_Static,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cd_Static,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cd_Static,2), UBOUND(InData%BN_Cd_Static,2)
        DO i1 = LBOUND(InData%BN_Cd_Static,1), UBOUND(InData%BN_Cd_Static,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cd_Static(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cm_Static) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cm_Static,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cm_Static,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cm_Static,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cm_Static,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cm_Static,2), UBOUND(InData%BN_Cm_Static,2)
        DO i1 = LBOUND(InData%BN_Cm_Static,1), UBOUND(InData%BN_Cm_Static,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cm_Static(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cl) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cl,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cl,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cl,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cl,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cl,2), UBOUND(InData%BN_Cl,2)
        DO i1 = LBOUND(InData%BN_Cl,1), UBOUND(InData%BN_Cl,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cl(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cd,2), UBOUND(InData%BN_Cd,2)
        DO i1 = LBOUND(InData%BN_Cd,1), UBOUND(InData%BN_Cd,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cd(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cm,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cm,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cm,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cm,2), UBOUND(InData%BN_Cm,2)
        DO i1 = LBOUND(InData%BN_Cm,1), UBOUND(InData%BN_Cm,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cm(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cx,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cx,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cx,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cx,2), UBOUND(InData%BN_Cx,2)
        DO i1 = LBOUND(InData%BN_Cx,1), UBOUND(InData%BN_Cx,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cx(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BN_Cy) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cy,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cy,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BN_Cy,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BN_Cy,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BN_Cy,2), UBOUND(InData%BN_Cy,2)
        DO i1 = LBOUND(InData%BN_Cy,1), UBOUND(InData%BN_Cy,1)
          ReKiBuf(Re_Xferred) = InData%BN_Cy(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
      CALL UA_PackMisc( Re_Buf, Db_Buf, Int_Buf, InData%m_UA, ErrStat2, ErrMsg2, OnlySize ) ! m_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL UA_PackOutput( Re_Buf, Db_Buf, Int_Buf, InData%y_UA, ErrStat2, ErrMsg2, OnlySize ) ! y_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL UA_PackParam( Re_Buf, Db_Buf, Int_Buf, InData%p_UA, ErrStat2, ErrMsg2, OnlySize ) ! p_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    IntKiBuf(Int_Xferred) = TRANSFER(InData%UA_Flag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Vwnd_ND) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_ND,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_ND,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_ND,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_ND,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_ND,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_ND,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vwnd_ND,3), UBOUND(InData%Vwnd_ND,3)
        DO i2 = LBOUND(InData%Vwnd_ND,2), UBOUND(InData%Vwnd_ND,2)
          DO i1 = LBOUND(InData%Vwnd_ND,1), UBOUND(InData%Vwnd_ND,1)
            ReKiBuf(Re_Xferred) = InData%Vwnd_ND(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_PackMisc

 SUBROUTINE FVW_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%FirstCall = TRANSFER(IntKiBuf(Int_Xferred), OutData%FirstCall)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LE)) DEALLOCATE(OutData%LE)
    ALLOCATE(OutData%LE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%LE,3), UBOUND(OutData%LE,3)
        DO i2 = LBOUND(OutData%LE,2), UBOUND(OutData%LE,2)
          DO i1 = LBOUND(OutData%LE,1), UBOUND(OutData%LE,1)
            OutData%LE(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TE)) DEALLOCATE(OutData%TE)
    ALLOCATE(OutData%TE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%TE,3), UBOUND(OutData%TE,3)
        DO i2 = LBOUND(OutData%TE,2), UBOUND(OutData%TE,2)
          DO i1 = LBOUND(OutData%TE,1), UBOUND(OutData%TE,1)
            OutData%TE(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_LL)) DEALLOCATE(OutData%r_LL)
    ALLOCATE(OutData%r_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%r_LL,4), UBOUND(OutData%r_LL,4)
        DO i3 = LBOUND(OutData%r_LL,3), UBOUND(OutData%r_LL,3)
          DO i2 = LBOUND(OutData%r_LL,2), UBOUND(OutData%r_LL,2)
            DO i1 = LBOUND(OutData%r_LL,1), UBOUND(OutData%r_LL,1)
              OutData%r_LL(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! s_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%s_LL)) DEALLOCATE(OutData%s_LL)
    ALLOCATE(OutData%s_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%s_LL,2), UBOUND(OutData%s_LL,2)
        DO i1 = LBOUND(OutData%s_LL,1), UBOUND(OutData%s_LL,1)
          OutData%s_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! chord_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%chord_LL)) DEALLOCATE(OutData%chord_LL)
    ALLOCATE(OutData%chord_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%chord_LL,2), UBOUND(OutData%chord_LL,2)
        DO i1 = LBOUND(OutData%chord_LL,1), UBOUND(OutData%chord_LL,1)
          OutData%chord_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! s_CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%s_CP_LL)) DEALLOCATE(OutData%s_CP_LL)
    ALLOCATE(OutData%s_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%s_CP_LL,2), UBOUND(OutData%s_CP_LL,2)
        DO i1 = LBOUND(OutData%s_CP_LL,1), UBOUND(OutData%s_CP_LL,1)
          OutData%s_CP_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! chord_CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%chord_CP_LL)) DEALLOCATE(OutData%chord_CP_LL)
    ALLOCATE(OutData%chord_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%chord_CP_LL,2), UBOUND(OutData%chord_CP_LL,2)
        DO i1 = LBOUND(OutData%chord_CP_LL,1), UBOUND(OutData%chord_CP_LL,1)
          OutData%chord_CP_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CP_LL)) DEALLOCATE(OutData%CP_LL)
    ALLOCATE(OutData%CP_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%CP_LL,3), UBOUND(OutData%CP_LL,3)
        DO i2 = LBOUND(OutData%CP_LL,2), UBOUND(OutData%CP_LL,2)
          DO i1 = LBOUND(OutData%CP_LL,1), UBOUND(OutData%CP_LL,1)
            OutData%CP_LL(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Tang not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Tang)) DEALLOCATE(OutData%Tang)
    ALLOCATE(OutData%Tang(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Tang.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Tang,3), UBOUND(OutData%Tang,3)
        DO i2 = LBOUND(OutData%Tang,2), UBOUND(OutData%Tang,2)
          DO i1 = LBOUND(OutData%Tang,1), UBOUND(OutData%Tang,1)
            OutData%Tang(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Norm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Norm)) DEALLOCATE(OutData%Norm)
    ALLOCATE(OutData%Norm(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Norm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Norm,3), UBOUND(OutData%Norm,3)
        DO i2 = LBOUND(OutData%Norm,2), UBOUND(OutData%Norm,2)
          DO i1 = LBOUND(OutData%Norm,1), UBOUND(OutData%Norm,1)
            OutData%Norm(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Orth not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Orth)) DEALLOCATE(OutData%Orth)
    ALLOCATE(OutData%Orth(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Orth.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Orth,3), UBOUND(OutData%Orth,3)
        DO i2 = LBOUND(OutData%Orth,2), UBOUND(OutData%Orth,2)
          DO i1 = LBOUND(OutData%Orth,1), UBOUND(OutData%Orth,1)
            OutData%Orth(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dl not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dl)) DEALLOCATE(OutData%dl)
    ALLOCATE(OutData%dl(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dl.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%dl,3), UBOUND(OutData%dl,3)
        DO i2 = LBOUND(OutData%dl,2), UBOUND(OutData%dl,2)
          DO i1 = LBOUND(OutData%dl,1), UBOUND(OutData%dl,1)
            OutData%dl(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Area not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Area)) DEALLOCATE(OutData%Area)
    ALLOCATE(OutData%Area(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Area.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Area,2), UBOUND(OutData%Area,2)
        DO i1 = LBOUND(OutData%Area,1), UBOUND(OutData%Area,1)
          OutData%Area(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! diag_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%diag_LL)) DEALLOCATE(OutData%diag_LL)
    ALLOCATE(OutData%diag_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%diag_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%diag_LL,2), UBOUND(OutData%diag_LL,2)
        DO i1 = LBOUND(OutData%diag_LL,1), UBOUND(OutData%diag_LL,1)
          OutData%diag_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_LL)) DEALLOCATE(OutData%Gamma_LL)
    ALLOCATE(OutData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Gamma_LL,2), UBOUND(OutData%Gamma_LL,2)
        DO i1 = LBOUND(OutData%Gamma_LL,1), UBOUND(OutData%Gamma_LL,1)
          OutData%Gamma_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_LL)) DEALLOCATE(OutData%Vind_LL)
    ALLOCATE(OutData%Vind_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vind_LL,3), UBOUND(OutData%Vind_LL,3)
        DO i2 = LBOUND(OutData%Vind_LL,2), UBOUND(OutData%Vind_LL,2)
          DO i1 = LBOUND(OutData%Vind_LL,1), UBOUND(OutData%Vind_LL,1)
            OutData%Vind_LL(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vtot_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vtot_LL)) DEALLOCATE(OutData%Vtot_LL)
    ALLOCATE(OutData%Vtot_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vtot_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vtot_LL,3), UBOUND(OutData%Vtot_LL,3)
        DO i2 = LBOUND(OutData%Vtot_LL,2), UBOUND(OutData%Vtot_LL,2)
          DO i1 = LBOUND(OutData%Vtot_LL,1), UBOUND(OutData%Vtot_LL,1)
            OutData%Vtot_LL(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vstr_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vstr_LL)) DEALLOCATE(OutData%Vstr_LL)
    ALLOCATE(OutData%Vstr_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vstr_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vstr_LL,3), UBOUND(OutData%Vstr_LL,3)
        DO i2 = LBOUND(OutData%Vstr_LL,2), UBOUND(OutData%Vstr_LL,2)
          DO i1 = LBOUND(OutData%Vstr_LL,1), UBOUND(OutData%Vstr_LL,1)
            OutData%Vstr_LL(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_LL)) DEALLOCATE(OutData%Vwnd_LL)
    ALLOCATE(OutData%Vwnd_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vwnd_LL,3), UBOUND(OutData%Vwnd_LL,3)
        DO i2 = LBOUND(OutData%Vwnd_LL,2), UBOUND(OutData%Vwnd_LL,2)
          DO i1 = LBOUND(OutData%Vwnd_LL,1), UBOUND(OutData%Vwnd_LL,1)
            OutData%Vwnd_LL(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_NW)) DEALLOCATE(OutData%Vwnd_NW)
    ALLOCATE(OutData%Vwnd_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Vwnd_NW,4), UBOUND(OutData%Vwnd_NW,4)
        DO i3 = LBOUND(OutData%Vwnd_NW,3), UBOUND(OutData%Vwnd_NW,3)
          DO i2 = LBOUND(OutData%Vwnd_NW,2), UBOUND(OutData%Vwnd_NW,2)
            DO i1 = LBOUND(OutData%Vwnd_NW,1), UBOUND(OutData%Vwnd_NW,1)
              OutData%Vwnd_NW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_FW)) DEALLOCATE(OutData%Vwnd_FW)
    ALLOCATE(OutData%Vwnd_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Vwnd_FW,4), UBOUND(OutData%Vwnd_FW,4)
        DO i3 = LBOUND(OutData%Vwnd_FW,3), UBOUND(OutData%Vwnd_FW,3)
          DO i2 = LBOUND(OutData%Vwnd_FW,2), UBOUND(OutData%Vwnd_FW,2)
            DO i1 = LBOUND(OutData%Vwnd_FW,1), UBOUND(OutData%Vwnd_FW,1)
              OutData%Vwnd_FW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_NW)) DEALLOCATE(OutData%Vind_NW)
    ALLOCATE(OutData%Vind_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Vind_NW,4), UBOUND(OutData%Vind_NW,4)
        DO i3 = LBOUND(OutData%Vind_NW,3), UBOUND(OutData%Vind_NW,3)
          DO i2 = LBOUND(OutData%Vind_NW,2), UBOUND(OutData%Vind_NW,2)
            DO i1 = LBOUND(OutData%Vind_NW,1), UBOUND(OutData%Vind_NW,1)
              OutData%Vind_NW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_FW)) DEALLOCATE(OutData%Vind_FW)
    ALLOCATE(OutData%Vind_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Vind_FW,4), UBOUND(OutData%Vind_FW,4)
        DO i3 = LBOUND(OutData%Vind_FW,3), UBOUND(OutData%Vind_FW,3)
          DO i2 = LBOUND(OutData%Vind_FW,2), UBOUND(OutData%Vind_FW,2)
            DO i1 = LBOUND(OutData%Vind_FW,1), UBOUND(OutData%Vind_FW,1)
              OutData%Vind_FW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
    OutData%nNW = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nFW = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%iStep = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%VTKstep = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%VTKlastTime = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_wind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_wind)) DEALLOCATE(OutData%r_wind)
    ALLOCATE(OutData%r_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_wind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%r_wind,2), UBOUND(OutData%r_wind,2)
        DO i1 = LBOUND(OutData%r_wind,1), UBOUND(OutData%r_wind,1)
          OutData%r_wind(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PitchAndTwist not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PitchAndTwist)) DEALLOCATE(OutData%PitchAndTwist)
    ALLOCATE(OutData%PitchAndTwist(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PitchAndTwist.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%PitchAndTwist,2), UBOUND(OutData%PitchAndTwist,2)
        DO i1 = LBOUND(OutData%PitchAndTwist,1), UBOUND(OutData%PitchAndTwist,1)
          OutData%PitchAndTwist(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%ComputeWakeInduced = TRANSFER(IntKiBuf(Int_Xferred), OutData%ComputeWakeInduced)
    Int_Xferred = Int_Xferred + 1
    OutData%OldWakeTime = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%tSpent = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dxdt_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dxdt_NW)) DEALLOCATE(OutData%dxdt_NW)
    ALLOCATE(OutData%dxdt_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dxdt_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%dxdt_NW,4), UBOUND(OutData%dxdt_NW,4)
        DO i3 = LBOUND(OutData%dxdt_NW,3), UBOUND(OutData%dxdt_NW,3)
          DO i2 = LBOUND(OutData%dxdt_NW,2), UBOUND(OutData%dxdt_NW,2)
            DO i1 = LBOUND(OutData%dxdt_NW,1), UBOUND(OutData%dxdt_NW,1)
              OutData%dxdt_NW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dxdt_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dxdt_FW)) DEALLOCATE(OutData%dxdt_FW)
    ALLOCATE(OutData%dxdt_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dxdt_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%dxdt_FW,4), UBOUND(OutData%dxdt_FW,4)
        DO i3 = LBOUND(OutData%dxdt_FW,3), UBOUND(OutData%dxdt_FW,3)
          DO i2 = LBOUND(OutData%dxdt_FW,2), UBOUND(OutData%dxdt_FW,2)
            DO i1 = LBOUND(OutData%dxdt_FW,1), UBOUND(OutData%dxdt_FW,1)
              OutData%dxdt_FW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! alpha_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%alpha_LL)) DEALLOCATE(OutData%alpha_LL)
    ALLOCATE(OutData%alpha_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%alpha_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%alpha_LL,2), UBOUND(OutData%alpha_LL,2)
        DO i1 = LBOUND(OutData%alpha_LL,1), UBOUND(OutData%alpha_LL,1)
          OutData%alpha_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vreln_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vreln_LL)) DEALLOCATE(OutData%Vreln_LL)
    ALLOCATE(OutData%Vreln_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vreln_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Vreln_LL,2), UBOUND(OutData%Vreln_LL,2)
        DO i1 = LBOUND(OutData%Vreln_LL,1), UBOUND(OutData%Vreln_LL,1)
          OutData%Vreln_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SegConnct not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SegConnct)) DEALLOCATE(OutData%SegConnct)
    ALLOCATE(OutData%SegConnct(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SegConnct.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%SegConnct,2), UBOUND(OutData%SegConnct,2)
        DO i1 = LBOUND(OutData%SegConnct,1), UBOUND(OutData%SegConnct,1)
          OutData%SegConnct(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SegPoints not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SegPoints)) DEALLOCATE(OutData%SegPoints)
    ALLOCATE(OutData%SegPoints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SegPoints.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%SegPoints,2), UBOUND(OutData%SegPoints,2)
        DO i1 = LBOUND(OutData%SegPoints,1), UBOUND(OutData%SegPoints,1)
          OutData%SegPoints(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SegGamma not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SegGamma)) DEALLOCATE(OutData%SegGamma)
    ALLOCATE(OutData%SegGamma(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SegGamma.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%SegGamma,1), UBOUND(OutData%SegGamma,1)
        OutData%SegGamma(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SegEpsilon not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SegEpsilon)) DEALLOCATE(OutData%SegEpsilon)
    ALLOCATE(OutData%SegEpsilon(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SegEpsilon.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%SegEpsilon,1), UBOUND(OutData%SegEpsilon,1)
        OutData%SegEpsilon(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CPs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CPs)) DEALLOCATE(OutData%CPs)
    ALLOCATE(OutData%CPs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CPs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%CPs,2), UBOUND(OutData%CPs,2)
        DO i1 = LBOUND(OutData%CPs,1), UBOUND(OutData%CPs,1)
          OutData%CPs(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Uind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Uind)) DEALLOCATE(OutData%Uind)
    ALLOCATE(OutData%Uind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Uind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Uind,2), UBOUND(OutData%Uind,2)
        DO i1 = LBOUND(OutData%Uind,1), UBOUND(OutData%Uind,1)
          OutData%Uind(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_AxInd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_AxInd)) DEALLOCATE(OutData%BN_AxInd)
    ALLOCATE(OutData%BN_AxInd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_AxInd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_AxInd,2), UBOUND(OutData%BN_AxInd,2)
        DO i1 = LBOUND(OutData%BN_AxInd,1), UBOUND(OutData%BN_AxInd,1)
          OutData%BN_AxInd(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_TanInd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_TanInd)) DEALLOCATE(OutData%BN_TanInd)
    ALLOCATE(OutData%BN_TanInd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_TanInd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_TanInd,2), UBOUND(OutData%BN_TanInd,2)
        DO i1 = LBOUND(OutData%BN_TanInd,1), UBOUND(OutData%BN_TanInd,1)
          OutData%BN_TanInd(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Vrel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Vrel)) DEALLOCATE(OutData%BN_Vrel)
    ALLOCATE(OutData%BN_Vrel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Vrel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Vrel,2), UBOUND(OutData%BN_Vrel,2)
        DO i1 = LBOUND(OutData%BN_Vrel,1), UBOUND(OutData%BN_Vrel,1)
          OutData%BN_Vrel(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_alpha not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_alpha)) DEALLOCATE(OutData%BN_alpha)
    ALLOCATE(OutData%BN_alpha(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_alpha.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_alpha,2), UBOUND(OutData%BN_alpha,2)
        DO i1 = LBOUND(OutData%BN_alpha,1), UBOUND(OutData%BN_alpha,1)
          OutData%BN_alpha(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_phi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_phi)) DEALLOCATE(OutData%BN_phi)
    ALLOCATE(OutData%BN_phi(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_phi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_phi,2), UBOUND(OutData%BN_phi,2)
        DO i1 = LBOUND(OutData%BN_phi,1), UBOUND(OutData%BN_phi,1)
          OutData%BN_phi(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Re not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Re)) DEALLOCATE(OutData%BN_Re)
    ALLOCATE(OutData%BN_Re(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Re.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Re,2), UBOUND(OutData%BN_Re,2)
        DO i1 = LBOUND(OutData%BN_Re,1), UBOUND(OutData%BN_Re,1)
          OutData%BN_Re(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_URelWind_s not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_URelWind_s)) DEALLOCATE(OutData%BN_URelWind_s)
    ALLOCATE(OutData%BN_URelWind_s(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_URelWind_s.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%BN_URelWind_s,3), UBOUND(OutData%BN_URelWind_s,3)
        DO i2 = LBOUND(OutData%BN_URelWind_s,2), UBOUND(OutData%BN_URelWind_s,2)
          DO i1 = LBOUND(OutData%BN_URelWind_s,1), UBOUND(OutData%BN_URelWind_s,1)
            OutData%BN_URelWind_s(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cl_Static not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cl_Static)) DEALLOCATE(OutData%BN_Cl_Static)
    ALLOCATE(OutData%BN_Cl_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cl_Static.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cl_Static,2), UBOUND(OutData%BN_Cl_Static,2)
        DO i1 = LBOUND(OutData%BN_Cl_Static,1), UBOUND(OutData%BN_Cl_Static,1)
          OutData%BN_Cl_Static(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cd_Static not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cd_Static)) DEALLOCATE(OutData%BN_Cd_Static)
    ALLOCATE(OutData%BN_Cd_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cd_Static.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cd_Static,2), UBOUND(OutData%BN_Cd_Static,2)
        DO i1 = LBOUND(OutData%BN_Cd_Static,1), UBOUND(OutData%BN_Cd_Static,1)
          OutData%BN_Cd_Static(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cm_Static not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cm_Static)) DEALLOCATE(OutData%BN_Cm_Static)
    ALLOCATE(OutData%BN_Cm_Static(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cm_Static.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cm_Static,2), UBOUND(OutData%BN_Cm_Static,2)
        DO i1 = LBOUND(OutData%BN_Cm_Static,1), UBOUND(OutData%BN_Cm_Static,1)
          OutData%BN_Cm_Static(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cl not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cl)) DEALLOCATE(OutData%BN_Cl)
    ALLOCATE(OutData%BN_Cl(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cl.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cl,2), UBOUND(OutData%BN_Cl,2)
        DO i1 = LBOUND(OutData%BN_Cl,1), UBOUND(OutData%BN_Cl,1)
          OutData%BN_Cl(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cd)) DEALLOCATE(OutData%BN_Cd)
    ALLOCATE(OutData%BN_Cd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cd,2), UBOUND(OutData%BN_Cd,2)
        DO i1 = LBOUND(OutData%BN_Cd,1), UBOUND(OutData%BN_Cd,1)
          OutData%BN_Cd(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cm)) DEALLOCATE(OutData%BN_Cm)
    ALLOCATE(OutData%BN_Cm(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cm,2), UBOUND(OutData%BN_Cm,2)
        DO i1 = LBOUND(OutData%BN_Cm,1), UBOUND(OutData%BN_Cm,1)
          OutData%BN_Cm(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cx)) DEALLOCATE(OutData%BN_Cx)
    ALLOCATE(OutData%BN_Cx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cx,2), UBOUND(OutData%BN_Cx,2)
        DO i1 = LBOUND(OutData%BN_Cx,1), UBOUND(OutData%BN_Cx,1)
          OutData%BN_Cx(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BN_Cy not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BN_Cy)) DEALLOCATE(OutData%BN_Cy)
    ALLOCATE(OutData%BN_Cy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cy.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BN_Cy,2), UBOUND(OutData%BN_Cy,2)
        DO i1 = LBOUND(OutData%BN_Cy,1), UBOUND(OutData%BN_Cy,1)
          OutData%BN_Cy(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackMisc( Re_Buf, Db_Buf, Int_Buf, OutData%m_UA, ErrStat2, ErrMsg2 ) ! m_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackOutput( Re_Buf, Db_Buf, Int_Buf, OutData%y_UA, ErrStat2, ErrMsg2 ) ! y_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackParam( Re_Buf, Db_Buf, Int_Buf, OutData%p_UA, ErrStat2, ErrMsg2 ) ! p_UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    OutData%UA_Flag = TRANSFER(IntKiBuf(Int_Xferred), OutData%UA_Flag)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_ND not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_ND)) DEALLOCATE(OutData%Vwnd_ND)
    ALLOCATE(OutData%Vwnd_ND(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_ND.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vwnd_ND,3), UBOUND(OutData%Vwnd_ND,3)
        DO i2 = LBOUND(OutData%Vwnd_ND,2), UBOUND(OutData%Vwnd_ND,2)
          DO i1 = LBOUND(OutData%Vwnd_ND,1), UBOUND(OutData%Vwnd_ND,1)
            OutData%Vwnd_ND(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_UnPackMisc

 SUBROUTINE FVW_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(FVW_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%WingsMesh)) THEN 
    ALLOCATE(DstInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%WingsMesh,1), UBOUND(SrcInputData%WingsMesh,1)
      CALL MeshCopy( SrcInputData%WingsMesh(i1), DstInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%V_wind)) THEN
  i1_l = LBOUND(SrcInputData%V_wind,1)
  i1_u = UBOUND(SrcInputData%V_wind,1)
  i2_l = LBOUND(SrcInputData%V_wind,2)
  i2_u = UBOUND(SrcInputData%V_wind,2)
  IF (.NOT. ALLOCATED(DstInputData%V_wind)) THEN 
    ALLOCATE(DstInputData%V_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%V_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%V_wind = SrcInputData%V_wind
ENDIF
    DstInputData%HubOrientation = SrcInputData%HubOrientation
    DstInputData%HubPosition = SrcInputData%HubPosition
 END SUBROUTINE FVW_CopyInput

 SUBROUTINE FVW_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FVW_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%WingsMesh)) THEN
DO i1 = LBOUND(InputData%WingsMesh,1), UBOUND(InputData%WingsMesh,1)
  CALL MeshDestroy( InputData%WingsMesh(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InputData%WingsMesh)
ENDIF
IF (ALLOCATED(InputData%V_wind)) THEN
  DEALLOCATE(InputData%V_wind)
ENDIF
 END SUBROUTINE FVW_DestroyInput

 SUBROUTINE FVW_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WingsMesh allocated yes/no
  IF ( ALLOCATED(InData%WingsMesh) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WingsMesh upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      Int_BufSz   = Int_BufSz + 3  ! WingsMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! WingsMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! WingsMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! WingsMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! V_wind allocated yes/no
  IF ( ALLOCATED(InData%V_wind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! V_wind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%V_wind)  ! V_wind
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%HubOrientation)  ! HubOrientation
      Re_BufSz   = Re_BufSz   + SIZE(InData%HubPosition)  ! HubPosition
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WingsMesh) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WingsMesh,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WingsMesh,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%V_wind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V_wind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V_wind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V_wind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V_wind,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%V_wind,2), UBOUND(InData%V_wind,2)
        DO i1 = LBOUND(InData%V_wind,1), UBOUND(InData%V_wind,1)
          ReKiBuf(Re_Xferred) = InData%V_wind(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    DO i2 = LBOUND(InData%HubOrientation,2), UBOUND(InData%HubOrientation,2)
      DO i1 = LBOUND(InData%HubOrientation,1), UBOUND(InData%HubOrientation,1)
        ReKiBuf(Re_Xferred) = InData%HubOrientation(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    DO i1 = LBOUND(InData%HubPosition,1), UBOUND(InData%HubPosition,1)
      ReKiBuf(Re_Xferred) = InData%HubPosition(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
 END SUBROUTINE FVW_PackInput

 SUBROUTINE FVW_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WingsMesh not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WingsMesh)) DEALLOCATE(OutData%WingsMesh)
    ALLOCATE(OutData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%WingsMesh,1), UBOUND(OutData%WingsMesh,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! V_wind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%V_wind)) DEALLOCATE(OutData%V_wind)
    ALLOCATE(OutData%V_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_wind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%V_wind,2), UBOUND(OutData%V_wind,2)
        DO i1 = LBOUND(OutData%V_wind,1), UBOUND(OutData%V_wind,1)
          OutData%V_wind(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%HubOrientation,1)
    i1_u = UBOUND(OutData%HubOrientation,1)
    i2_l = LBOUND(OutData%HubOrientation,2)
    i2_u = UBOUND(OutData%HubOrientation,2)
    DO i2 = LBOUND(OutData%HubOrientation,2), UBOUND(OutData%HubOrientation,2)
      DO i1 = LBOUND(OutData%HubOrientation,1), UBOUND(OutData%HubOrientation,1)
        OutData%HubOrientation(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%HubPosition,1)
    i1_u = UBOUND(OutData%HubPosition,1)
    DO i1 = LBOUND(OutData%HubPosition,1), UBOUND(OutData%HubPosition,1)
      OutData%HubPosition(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
 END SUBROUTINE FVW_UnPackInput

 SUBROUTINE FVW_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(FVW_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Vind)) THEN
  i1_l = LBOUND(SrcOutputData%Vind,1)
  i1_u = UBOUND(SrcOutputData%Vind,1)
  i2_l = LBOUND(SrcOutputData%Vind,2)
  i2_u = UBOUND(SrcOutputData%Vind,2)
  i3_l = LBOUND(SrcOutputData%Vind,3)
  i3_u = UBOUND(SrcOutputData%Vind,3)
  IF (.NOT. ALLOCATED(DstOutputData%Vind)) THEN 
    ALLOCATE(DstOutputData%Vind(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vind = SrcOutputData%Vind
ENDIF
IF (ALLOCATED(SrcOutputData%Cl_KJ)) THEN
  i1_l = LBOUND(SrcOutputData%Cl_KJ,1)
  i1_u = UBOUND(SrcOutputData%Cl_KJ,1)
  i2_l = LBOUND(SrcOutputData%Cl_KJ,2)
  i2_u = UBOUND(SrcOutputData%Cl_KJ,2)
  IF (.NOT. ALLOCATED(DstOutputData%Cl_KJ)) THEN 
    ALLOCATE(DstOutputData%Cl_KJ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cl_KJ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Cl_KJ = SrcOutputData%Cl_KJ
ENDIF
 END SUBROUTINE FVW_CopyOutput

 SUBROUTINE FVW_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FVW_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%Vind)) THEN
  DEALLOCATE(OutputData%Vind)
ENDIF
IF (ALLOCATED(OutputData%Cl_KJ)) THEN
  DEALLOCATE(OutputData%Cl_KJ)
ENDIF
 END SUBROUTINE FVW_DestroyOutput

 SUBROUTINE FVW_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Vind allocated yes/no
  IF ( ALLOCATED(InData%Vind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind)  ! Vind
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Cl_KJ allocated yes/no
  IF ( ALLOCATED(InData%Cl_KJ) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Cl_KJ upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Cl_KJ)  ! Cl_KJ
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Vind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Vind,3), UBOUND(InData%Vind,3)
        DO i2 = LBOUND(InData%Vind,2), UBOUND(InData%Vind,2)
          DO i1 = LBOUND(InData%Vind,1), UBOUND(InData%Vind,1)
            ReKiBuf(Re_Xferred) = InData%Vind(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Cl_KJ) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Cl_KJ,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Cl_KJ,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Cl_KJ,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Cl_KJ,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Cl_KJ,2), UBOUND(InData%Cl_KJ,2)
        DO i1 = LBOUND(InData%Cl_KJ,1), UBOUND(InData%Cl_KJ,1)
          ReKiBuf(Re_Xferred) = InData%Cl_KJ(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_PackOutput

 SUBROUTINE FVW_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind)) DEALLOCATE(OutData%Vind)
    ALLOCATE(OutData%Vind(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Vind,3), UBOUND(OutData%Vind,3)
        DO i2 = LBOUND(OutData%Vind,2), UBOUND(OutData%Vind,2)
          DO i1 = LBOUND(OutData%Vind,1), UBOUND(OutData%Vind,1)
            OutData%Vind(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Cl_KJ not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Cl_KJ)) DEALLOCATE(OutData%Cl_KJ)
    ALLOCATE(OutData%Cl_KJ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cl_KJ.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Cl_KJ,2), UBOUND(OutData%Cl_KJ,2)
        DO i1 = LBOUND(OutData%Cl_KJ,1), UBOUND(OutData%Cl_KJ,1)
          OutData%Cl_KJ(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_UnPackOutput

 SUBROUTINE FVW_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%Gamma_NW)) THEN
  i1_l = LBOUND(SrcContStateData%Gamma_NW,1)
  i1_u = UBOUND(SrcContStateData%Gamma_NW,1)
  i2_l = LBOUND(SrcContStateData%Gamma_NW,2)
  i2_u = UBOUND(SrcContStateData%Gamma_NW,2)
  i3_l = LBOUND(SrcContStateData%Gamma_NW,3)
  i3_u = UBOUND(SrcContStateData%Gamma_NW,3)
  IF (.NOT. ALLOCATED(DstContStateData%Gamma_NW)) THEN 
    ALLOCATE(DstContStateData%Gamma_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%Gamma_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%Gamma_NW = SrcContStateData%Gamma_NW
ENDIF
IF (ALLOCATED(SrcContStateData%Gamma_FW)) THEN
  i1_l = LBOUND(SrcContStateData%Gamma_FW,1)
  i1_u = UBOUND(SrcContStateData%Gamma_FW,1)
  i2_l = LBOUND(SrcContStateData%Gamma_FW,2)
  i2_u = UBOUND(SrcContStateData%Gamma_FW,2)
  i3_l = LBOUND(SrcContStateData%Gamma_FW,3)
  i3_u = UBOUND(SrcContStateData%Gamma_FW,3)
  IF (.NOT. ALLOCATED(DstContStateData%Gamma_FW)) THEN 
    ALLOCATE(DstContStateData%Gamma_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%Gamma_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%Gamma_FW = SrcContStateData%Gamma_FW
ENDIF
IF (ALLOCATED(SrcContStateData%r_NW)) THEN
  i1_l = LBOUND(SrcContStateData%r_NW,1)
  i1_u = UBOUND(SrcContStateData%r_NW,1)
  i2_l = LBOUND(SrcContStateData%r_NW,2)
  i2_u = UBOUND(SrcContStateData%r_NW,2)
  i3_l = LBOUND(SrcContStateData%r_NW,3)
  i3_u = UBOUND(SrcContStateData%r_NW,3)
  i4_l = LBOUND(SrcContStateData%r_NW,4)
  i4_u = UBOUND(SrcContStateData%r_NW,4)
  IF (.NOT. ALLOCATED(DstContStateData%r_NW)) THEN 
    ALLOCATE(DstContStateData%r_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%r_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%r_NW = SrcContStateData%r_NW
ENDIF
IF (ALLOCATED(SrcContStateData%r_FW)) THEN
  i1_l = LBOUND(SrcContStateData%r_FW,1)
  i1_u = UBOUND(SrcContStateData%r_FW,1)
  i2_l = LBOUND(SrcContStateData%r_FW,2)
  i2_u = UBOUND(SrcContStateData%r_FW,2)
  i3_l = LBOUND(SrcContStateData%r_FW,3)
  i3_u = UBOUND(SrcContStateData%r_FW,3)
  i4_l = LBOUND(SrcContStateData%r_FW,4)
  i4_u = UBOUND(SrcContStateData%r_FW,4)
  IF (.NOT. ALLOCATED(DstContStateData%r_FW)) THEN 
    ALLOCATE(DstContStateData%r_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%r_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%r_FW = SrcContStateData%r_FW
ENDIF
      CALL UA_CopyContState( SrcContStateData%UA, DstContStateData%UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FVW_CopyContState

 SUBROUTINE FVW_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%Gamma_NW)) THEN
  DEALLOCATE(ContStateData%Gamma_NW)
ENDIF
IF (ALLOCATED(ContStateData%Gamma_FW)) THEN
  DEALLOCATE(ContStateData%Gamma_FW)
ENDIF
IF (ALLOCATED(ContStateData%r_NW)) THEN
  DEALLOCATE(ContStateData%r_NW)
ENDIF
IF (ALLOCATED(ContStateData%r_FW)) THEN
  DEALLOCATE(ContStateData%r_FW)
ENDIF
  CALL UA_DestroyContState( ContStateData%UA, ErrStat, ErrMsg )
 END SUBROUTINE FVW_DestroyContState

 SUBROUTINE FVW_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_NW allocated yes/no
  IF ( ALLOCATED(InData%Gamma_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Gamma_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_NW)  ! Gamma_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_FW allocated yes/no
  IF ( ALLOCATED(InData%Gamma_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Gamma_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_FW)  ! Gamma_FW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_NW allocated yes/no
  IF ( ALLOCATED(InData%r_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_NW)  ! r_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_FW allocated yes/no
  IF ( ALLOCATED(InData%r_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_FW)  ! r_FW
  END IF
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! UA: size of buffers for each call to pack subtype
      CALL UA_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, .TRUE. ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Gamma_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Gamma_NW,3), UBOUND(InData%Gamma_NW,3)
        DO i2 = LBOUND(InData%Gamma_NW,2), UBOUND(InData%Gamma_NW,2)
          DO i1 = LBOUND(InData%Gamma_NW,1), UBOUND(InData%Gamma_NW,1)
            ReKiBuf(Re_Xferred) = InData%Gamma_NW(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Gamma_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%Gamma_FW,3), UBOUND(InData%Gamma_FW,3)
        DO i2 = LBOUND(InData%Gamma_FW,2), UBOUND(InData%Gamma_FW,2)
          DO i1 = LBOUND(InData%Gamma_FW,1), UBOUND(InData%Gamma_FW,1)
            ReKiBuf(Re_Xferred) = InData%Gamma_FW(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%r_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%r_NW,4), UBOUND(InData%r_NW,4)
        DO i3 = LBOUND(InData%r_NW,3), UBOUND(InData%r_NW,3)
          DO i2 = LBOUND(InData%r_NW,2), UBOUND(InData%r_NW,2)
            DO i1 = LBOUND(InData%r_NW,1), UBOUND(InData%r_NW,1)
              ReKiBuf(Re_Xferred) = InData%r_NW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%r_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%r_FW,4), UBOUND(InData%r_FW,4)
        DO i3 = LBOUND(InData%r_FW,3), UBOUND(InData%r_FW,3)
          DO i2 = LBOUND(InData%r_FW,2), UBOUND(InData%r_FW,2)
            DO i1 = LBOUND(InData%r_FW,1), UBOUND(InData%r_FW,1)
              ReKiBuf(Re_Xferred) = InData%r_FW(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
      CALL UA_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, OnlySize ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE FVW_PackContState

 SUBROUTINE FVW_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_NW)) DEALLOCATE(OutData%Gamma_NW)
    ALLOCATE(OutData%Gamma_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Gamma_NW,3), UBOUND(OutData%Gamma_NW,3)
        DO i2 = LBOUND(OutData%Gamma_NW,2), UBOUND(OutData%Gamma_NW,2)
          DO i1 = LBOUND(OutData%Gamma_NW,1), UBOUND(OutData%Gamma_NW,1)
            OutData%Gamma_NW(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_FW)) DEALLOCATE(OutData%Gamma_FW)
    ALLOCATE(OutData%Gamma_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%Gamma_FW,3), UBOUND(OutData%Gamma_FW,3)
        DO i2 = LBOUND(OutData%Gamma_FW,2), UBOUND(OutData%Gamma_FW,2)
          DO i1 = LBOUND(OutData%Gamma_FW,1), UBOUND(OutData%Gamma_FW,1)
            OutData%Gamma_FW(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_NW)) DEALLOCATE(OutData%r_NW)
    ALLOCATE(OutData%r_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%r_NW,4), UBOUND(OutData%r_NW,4)
        DO i3 = LBOUND(OutData%r_NW,3), UBOUND(OutData%r_NW,3)
          DO i2 = LBOUND(OutData%r_NW,2), UBOUND(OutData%r_NW,2)
            DO i1 = LBOUND(OutData%r_NW,1), UBOUND(OutData%r_NW,1)
              OutData%r_NW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_FW)) DEALLOCATE(OutData%r_FW)
    ALLOCATE(OutData%r_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%r_FW,4), UBOUND(OutData%r_FW,4)
        DO i3 = LBOUND(OutData%r_FW,3), UBOUND(OutData%r_FW,3)
          DO i2 = LBOUND(OutData%r_FW,2), UBOUND(OutData%r_FW,2)
            DO i1 = LBOUND(OutData%r_FW,1), UBOUND(OutData%r_FW,1)
              OutData%r_FW(i1,i2,i3,i4) = ReKiBuf(Re_Xferred)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackContState( Re_Buf, Db_Buf, Int_Buf, OutData%UA, ErrStat2, ErrMsg2 ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE FVW_UnPackContState

 SUBROUTINE FVW_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%NULL = SrcDiscStateData%NULL
      CALL UA_CopyDiscState( SrcDiscStateData%UA, DstDiscStateData%UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FVW_CopyDiscState

 SUBROUTINE FVW_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL UA_DestroyDiscState( DiscStateData%UA, ErrStat, ErrMsg )
 END SUBROUTINE FVW_DestroyDiscState

 SUBROUTINE FVW_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! NULL
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! UA: size of buffers for each call to pack subtype
      CALL UA_PackDiscState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, .TRUE. ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%NULL
    Re_Xferred = Re_Xferred + 1
      CALL UA_PackDiscState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, OnlySize ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE FVW_PackDiscState

 SUBROUTINE FVW_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%NULL = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackDiscState( Re_Buf, Db_Buf, Int_Buf, OutData%UA, ErrStat2, ErrMsg2 ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE FVW_UnPackDiscState

 SUBROUTINE FVW_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%residual = SrcConstrStateData%residual
IF (ALLOCATED(SrcConstrStateData%Gamma_LL)) THEN
  i1_l = LBOUND(SrcConstrStateData%Gamma_LL,1)
  i1_u = UBOUND(SrcConstrStateData%Gamma_LL,1)
  i2_l = LBOUND(SrcConstrStateData%Gamma_LL,2)
  i2_u = UBOUND(SrcConstrStateData%Gamma_LL,2)
  IF (.NOT. ALLOCATED(DstConstrStateData%Gamma_LL)) THEN 
    ALLOCATE(DstConstrStateData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstConstrStateData%Gamma_LL = SrcConstrStateData%Gamma_LL
ENDIF
 END SUBROUTINE FVW_CopyConstrState

 SUBROUTINE FVW_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConstrStateData%Gamma_LL)) THEN
  DEALLOCATE(ConstrStateData%Gamma_LL)
ENDIF
 END SUBROUTINE FVW_DestroyConstrState

 SUBROUTINE FVW_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! residual
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_LL allocated yes/no
  IF ( ALLOCATED(InData%Gamma_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Gamma_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_LL)  ! Gamma_LL
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%residual
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Gamma_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Gamma_LL,2), UBOUND(InData%Gamma_LL,2)
        DO i1 = LBOUND(InData%Gamma_LL,1), UBOUND(InData%Gamma_LL,1)
          ReKiBuf(Re_Xferred) = InData%Gamma_LL(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_PackConstrState

 SUBROUTINE FVW_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%residual = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_LL)) DEALLOCATE(OutData%Gamma_LL)
    ALLOCATE(OutData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Gamma_LL,2), UBOUND(OutData%Gamma_LL,2)
        DO i1 = LBOUND(OutData%Gamma_LL,1), UBOUND(OutData%Gamma_LL,1)
          OutData%Gamma_LL(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_UnPackConstrState

 SUBROUTINE FVW_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(FVW_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%NULL = SrcOtherStateData%NULL
      CALL UA_CopyOtherState( SrcOtherStateData%UA, DstOtherStateData%UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOtherStateData%UA_Flag)) THEN
  i1_l = LBOUND(SrcOtherStateData%UA_Flag,1)
  i1_u = UBOUND(SrcOtherStateData%UA_Flag,1)
  i2_l = LBOUND(SrcOtherStateData%UA_Flag,2)
  i2_u = UBOUND(SrcOtherStateData%UA_Flag,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%UA_Flag)) THEN 
    ALLOCATE(DstOtherStateData%UA_Flag(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UA_Flag.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%UA_Flag = SrcOtherStateData%UA_Flag
ENDIF
 END SUBROUTINE FVW_CopyOtherState

 SUBROUTINE FVW_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FVW_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL UA_DestroyOtherState( OtherStateData%UA, ErrStat, ErrMsg )
IF (ALLOCATED(OtherStateData%UA_Flag)) THEN
  DEALLOCATE(OtherStateData%UA_Flag)
ENDIF
 END SUBROUTINE FVW_DestroyOtherState

 SUBROUTINE FVW_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NULL
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! UA: size of buffers for each call to pack subtype
      CALL UA_PackOtherState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, .TRUE. ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! UA
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! UA
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! UA
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! UA_Flag allocated yes/no
  IF ( ALLOCATED(InData%UA_Flag) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! UA_Flag upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%UA_Flag)  ! UA_Flag
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%NULL
    Int_Xferred = Int_Xferred + 1
      CALL UA_PackOtherState( Re_Buf, Db_Buf, Int_Buf, InData%UA, ErrStat2, ErrMsg2, OnlySize ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%UA_Flag) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%UA_Flag,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%UA_Flag,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%UA_Flag,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%UA_Flag,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%UA_Flag,2), UBOUND(InData%UA_Flag,2)
        DO i1 = LBOUND(InData%UA_Flag,1), UBOUND(InData%UA_Flag,1)
          IntKiBuf(Int_Xferred) = TRANSFER(InData%UA_Flag(i1,i2), IntKiBuf(1))
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_PackOtherState

 SUBROUTINE FVW_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%NULL = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL UA_UnpackOtherState( Re_Buf, Db_Buf, Int_Buf, OutData%UA, ErrStat2, ErrMsg2 ) ! UA 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! UA_Flag not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%UA_Flag)) DEALLOCATE(OutData%UA_Flag)
    ALLOCATE(OutData%UA_Flag(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%UA_Flag.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%UA_Flag,2), UBOUND(OutData%UA_Flag,2)
        DO i1 = LBOUND(OutData%UA_Flag,1), UBOUND(OutData%UA_Flag,1)
          OutData%UA_Flag(i1,i2) = TRANSFER(IntKiBuf(Int_Xferred), OutData%UA_Flag(i1,i2))
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FVW_UnPackOtherState

 SUBROUTINE FVW_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitInputType), INTENT(INOUT) :: SrcInitInputData
   TYPE(FVW_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%FVWFileName = SrcInitInputData%FVWFileName
    DstInitInputData%RootName = SrcInitInputData%RootName
IF (ALLOCATED(SrcInitInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInitInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInitInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WingsMesh)) THEN 
    ALLOCATE(DstInitInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%WingsMesh,1), UBOUND(SrcInitInputData%WingsMesh,1)
      CALL MeshCopy( SrcInitInputData%WingsMesh(i1), DstInitInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInitInputData%AFindx)) THEN
  i1_l = LBOUND(SrcInitInputData%AFindx,1)
  i1_u = UBOUND(SrcInitInputData%AFindx,1)
  i2_l = LBOUND(SrcInitInputData%AFindx,2)
  i2_u = UBOUND(SrcInitInputData%AFindx,2)
  IF (.NOT. ALLOCATED(DstInitInputData%AFindx)) THEN 
    ALLOCATE(DstInitInputData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFindx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%AFindx = SrcInitInputData%AFindx
ENDIF
IF (ALLOCATED(SrcInitInputData%Chord)) THEN
  i1_l = LBOUND(SrcInitInputData%Chord,1)
  i1_u = UBOUND(SrcInitInputData%Chord,1)
  i2_l = LBOUND(SrcInitInputData%Chord,2)
  i2_u = UBOUND(SrcInitInputData%Chord,2)
  IF (.NOT. ALLOCATED(DstInitInputData%Chord)) THEN 
    ALLOCATE(DstInitInputData%Chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Chord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%Chord = SrcInitInputData%Chord
ENDIF
IF (ALLOCATED(SrcInitInputData%RElm)) THEN
  i1_l = LBOUND(SrcInitInputData%RElm,1)
  i1_u = UBOUND(SrcInitInputData%RElm,1)
  IF (.NOT. ALLOCATED(DstInitInputData%RElm)) THEN 
    ALLOCATE(DstInitInputData%RElm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%RElm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%RElm = SrcInitInputData%RElm
ENDIF
IF (ALLOCATED(SrcInitInputData%zHub)) THEN
  i1_l = LBOUND(SrcInitInputData%zHub,1)
  i1_u = UBOUND(SrcInitInputData%zHub,1)
  IF (.NOT. ALLOCATED(DstInitInputData%zHub)) THEN 
    ALLOCATE(DstInitInputData%zHub(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zHub.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%zHub = SrcInitInputData%zHub
ENDIF
IF (ALLOCATED(SrcInitInputData%zLocal)) THEN
  i1_l = LBOUND(SrcInitInputData%zLocal,1)
  i1_u = UBOUND(SrcInitInputData%zLocal,1)
  i2_l = LBOUND(SrcInitInputData%zLocal,2)
  i2_u = UBOUND(SrcInitInputData%zLocal,2)
  IF (.NOT. ALLOCATED(DstInitInputData%zLocal)) THEN 
    ALLOCATE(DstInitInputData%zLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zLocal.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%zLocal = SrcInitInputData%zLocal
ENDIF
IF (ALLOCATED(SrcInitInputData%zTip)) THEN
  i1_l = LBOUND(SrcInitInputData%zTip,1)
  i1_u = UBOUND(SrcInitInputData%zTip,1)
  IF (.NOT. ALLOCATED(DstInitInputData%zTip)) THEN 
    ALLOCATE(DstInitInputData%zTip(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zTip.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%zTip = SrcInitInputData%zTip
ENDIF
IF (ALLOCATED(SrcInitInputData%rLocal)) THEN
  i1_l = LBOUND(SrcInitInputData%rLocal,1)
  i1_u = UBOUND(SrcInitInputData%rLocal,1)
  i2_l = LBOUND(SrcInitInputData%rLocal,2)
  i2_u = UBOUND(SrcInitInputData%rLocal,2)
  IF (.NOT. ALLOCATED(DstInitInputData%rLocal)) THEN 
    ALLOCATE(DstInitInputData%rLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rLocal.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%rLocal = SrcInitInputData%rLocal
ENDIF
    DstInitInputData%NumBlades = SrcInitInputData%NumBlades
    DstInitInputData%NumBladeNodes = SrcInitInputData%NumBladeNodes
    DstInitInputData%DTaero = SrcInitInputData%DTaero
    DstInitInputData%KinVisc = SrcInitInputData%KinVisc
    DstInitInputData%UAMod = SrcInitInputData%UAMod
    DstInitInputData%UA_Flag = SrcInitInputData%UA_Flag
    DstInitInputData%Flookup = SrcInitInputData%Flookup
    DstInitInputData%a_s = SrcInitInputData%a_s
 END SUBROUTINE FVW_CopyInitInput

 SUBROUTINE FVW_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FVW_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%WingsMesh)) THEN
DO i1 = LBOUND(InitInputData%WingsMesh,1), UBOUND(InitInputData%WingsMesh,1)
  CALL MeshDestroy( InitInputData%WingsMesh(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%WingsMesh)
ENDIF
IF (ALLOCATED(InitInputData%AFindx)) THEN
  DEALLOCATE(InitInputData%AFindx)
ENDIF
IF (ALLOCATED(InitInputData%Chord)) THEN
  DEALLOCATE(InitInputData%Chord)
ENDIF
IF (ALLOCATED(InitInputData%RElm)) THEN
  DEALLOCATE(InitInputData%RElm)
ENDIF
IF (ALLOCATED(InitInputData%zHub)) THEN
  DEALLOCATE(InitInputData%zHub)
ENDIF
IF (ALLOCATED(InitInputData%zLocal)) THEN
  DEALLOCATE(InitInputData%zLocal)
ENDIF
IF (ALLOCATED(InitInputData%zTip)) THEN
  DEALLOCATE(InitInputData%zTip)
ENDIF
IF (ALLOCATED(InitInputData%rLocal)) THEN
  DEALLOCATE(InitInputData%rLocal)
ENDIF
 END SUBROUTINE FVW_DestroyInitInput

 SUBROUTINE FVW_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FVWFileName)  ! FVWFileName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%RootName)  ! RootName
  Int_BufSz   = Int_BufSz   + 1     ! WingsMesh allocated yes/no
  IF ( ALLOCATED(InData%WingsMesh) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WingsMesh upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      Int_BufSz   = Int_BufSz + 3  ! WingsMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! WingsMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! WingsMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! WingsMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AFindx allocated yes/no
  IF ( ALLOCATED(InData%AFindx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AFindx upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%AFindx)  ! AFindx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Chord allocated yes/no
  IF ( ALLOCATED(InData%Chord) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Chord upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Chord)  ! Chord
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RElm allocated yes/no
  IF ( ALLOCATED(InData%RElm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RElm upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RElm)  ! RElm
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zHub allocated yes/no
  IF ( ALLOCATED(InData%zHub) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zHub upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%zHub)  ! zHub
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zLocal allocated yes/no
  IF ( ALLOCATED(InData%zLocal) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! zLocal upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%zLocal)  ! zLocal
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zTip allocated yes/no
  IF ( ALLOCATED(InData%zTip) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zTip upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%zTip)  ! zTip
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! rLocal allocated yes/no
  IF ( ALLOCATED(InData%rLocal) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! rLocal upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%rLocal)  ! rLocal
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumBlades
      Int_BufSz  = Int_BufSz  + 1  ! NumBladeNodes
      Db_BufSz   = Db_BufSz   + 1  ! DTaero
      Re_BufSz   = Re_BufSz   + 1  ! KinVisc
      Int_BufSz  = Int_BufSz  + 1  ! UAMod
      Int_BufSz  = Int_BufSz  + 1  ! UA_Flag
      Int_BufSz  = Int_BufSz  + 1  ! Flookup
      Re_BufSz   = Re_BufSz   + 1  ! a_s
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DO I = 1, LEN(InData%FVWFileName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%FVWFileName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%RootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%RootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( .NOT. ALLOCATED(InData%WingsMesh) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WingsMesh,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WingsMesh,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AFindx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFindx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFindx,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AFindx,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AFindx,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%AFindx,2), UBOUND(InData%AFindx,2)
        DO i1 = LBOUND(InData%AFindx,1), UBOUND(InData%AFindx,1)
          IntKiBuf(Int_Xferred) = InData%AFindx(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Chord) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Chord,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Chord,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Chord,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Chord,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Chord,2), UBOUND(InData%Chord,2)
        DO i1 = LBOUND(InData%Chord,1), UBOUND(InData%Chord,1)
          ReKiBuf(Re_Xferred) = InData%Chord(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RElm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RElm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RElm,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RElm,1), UBOUND(InData%RElm,1)
        ReKiBuf(Re_Xferred) = InData%RElm(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%zHub) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zHub,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zHub,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%zHub,1), UBOUND(InData%zHub,1)
        ReKiBuf(Re_Xferred) = InData%zHub(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%zLocal) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zLocal,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zLocal,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zLocal,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zLocal,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%zLocal,2), UBOUND(InData%zLocal,2)
        DO i1 = LBOUND(InData%zLocal,1), UBOUND(InData%zLocal,1)
          ReKiBuf(Re_Xferred) = InData%zLocal(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%zTip) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zTip,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zTip,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%zTip,1), UBOUND(InData%zTip,1)
        ReKiBuf(Re_Xferred) = InData%zTip(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%rLocal) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rLocal,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rLocal,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rLocal,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rLocal,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%rLocal,2), UBOUND(InData%rLocal,2)
        DO i1 = LBOUND(InData%rLocal,1), UBOUND(InData%rLocal,1)
          ReKiBuf(Re_Xferred) = InData%rLocal(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumBlades
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumBladeNodes
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTaero
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%KinVisc
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%UAMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%UA_Flag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%Flookup, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%a_s
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FVW_PackInitInput

 SUBROUTINE FVW_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    DO I = 1, LEN(OutData%FVWFileName)
      OutData%FVWFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%RootName)
      OutData%RootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WingsMesh not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WingsMesh)) DEALLOCATE(OutData%WingsMesh)
    ALLOCATE(OutData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%WingsMesh,1), UBOUND(OutData%WingsMesh,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AFindx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AFindx)) DEALLOCATE(OutData%AFindx)
    ALLOCATE(OutData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%AFindx,2), UBOUND(OutData%AFindx,2)
        DO i1 = LBOUND(OutData%AFindx,1), UBOUND(OutData%AFindx,1)
          OutData%AFindx(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Chord not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Chord)) DEALLOCATE(OutData%Chord)
    ALLOCATE(OutData%Chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Chord.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Chord,2), UBOUND(OutData%Chord,2)
        DO i1 = LBOUND(OutData%Chord,1), UBOUND(OutData%Chord,1)
          OutData%Chord(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RElm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RElm)) DEALLOCATE(OutData%RElm)
    ALLOCATE(OutData%RElm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RElm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RElm,1), UBOUND(OutData%RElm,1)
        OutData%RElm(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zHub not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zHub)) DEALLOCATE(OutData%zHub)
    ALLOCATE(OutData%zHub(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zHub.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%zHub,1), UBOUND(OutData%zHub,1)
        OutData%zHub(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zLocal not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zLocal)) DEALLOCATE(OutData%zLocal)
    ALLOCATE(OutData%zLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zLocal.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%zLocal,2), UBOUND(OutData%zLocal,2)
        DO i1 = LBOUND(OutData%zLocal,1), UBOUND(OutData%zLocal,1)
          OutData%zLocal(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zTip not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zTip)) DEALLOCATE(OutData%zTip)
    ALLOCATE(OutData%zTip(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zTip.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%zTip,1), UBOUND(OutData%zTip,1)
        OutData%zTip(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! rLocal not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%rLocal)) DEALLOCATE(OutData%rLocal)
    ALLOCATE(OutData%rLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%rLocal.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%rLocal,2), UBOUND(OutData%rLocal,2)
        DO i1 = LBOUND(OutData%rLocal,1), UBOUND(OutData%rLocal,1)
          OutData%rLocal(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%NumBlades = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumBladeNodes = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%DTaero = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%KinVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%UAMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UA_Flag = TRANSFER(IntKiBuf(Int_Xferred), OutData%UA_Flag)
    Int_Xferred = Int_Xferred + 1
    OutData%Flookup = TRANSFER(IntKiBuf(Int_Xferred), OutData%Flookup)
    Int_Xferred = Int_Xferred + 1
    OutData%a_s = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FVW_UnPackInitInput

 SUBROUTINE FVW_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(FVW_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%CirculationMethod = SrcInputFileData%CirculationMethod
    DstInputFileData%CirculationFile = SrcInputFileData%CirculationFile
    DstInputFileData%CircSolvMaxIter = SrcInputFileData%CircSolvMaxIter
    DstInputFileData%CircSolvConvCrit = SrcInputFileData%CircSolvConvCrit
    DstInputFileData%CircSolvRelaxation = SrcInputFileData%CircSolvRelaxation
    DstInputFileData%IntMethod = SrcInputFileData%IntMethod
    DstInputFileData%FreeWake = SrcInputFileData%FreeWake
    DstInputFileData%FreeWakeStart = SrcInputFileData%FreeWakeStart
    DstInputFileData%FullCirculationStart = SrcInputFileData%FullCirculationStart
    DstInputFileData%DTfvw = SrcInputFileData%DTfvw
    DstInputFileData%CircSolvPolar = SrcInputFileData%CircSolvPolar
    DstInputFileData%nNWPanels = SrcInputFileData%nNWPanels
    DstInputFileData%nFWPanels = SrcInputFileData%nFWPanels
    DstInputFileData%nFWPanelsFree = SrcInputFileData%nFWPanelsFree
    DstInputFileData%FWShedVorticity = SrcInputFileData%FWShedVorticity
    DstInputFileData%DiffusionMethod = SrcInputFileData%DiffusionMethod
    DstInputFileData%CoreSpreadEddyVisc = SrcInputFileData%CoreSpreadEddyVisc
    DstInputFileData%RegDeterMethod = SrcInputFileData%RegDeterMethod
    DstInputFileData%RegFunction = SrcInputFileData%RegFunction
    DstInputFileData%WakeRegMethod = SrcInputFileData%WakeRegMethod
    DstInputFileData%WakeRegParam = SrcInputFileData%WakeRegParam
    DstInputFileData%WingRegParam = SrcInputFileData%WingRegParam
    DstInputFileData%ShearModel = SrcInputFileData%ShearModel
    DstInputFileData%TwrShadowOnWake = SrcInputFileData%TwrShadowOnWake
    DstInputFileData%VelocityMethod = SrcInputFileData%VelocityMethod
    DstInputFileData%TreeBranchFactor = SrcInputFileData%TreeBranchFactor
    DstInputFileData%PartPerSegment = SrcInputFileData%PartPerSegment
    DstInputFileData%WrVTK = SrcInputFileData%WrVTK
    DstInputFileData%VTKBlades = SrcInputFileData%VTKBlades
    DstInputFileData%DTvtk = SrcInputFileData%DTvtk
    DstInputFileData%VTKCoord = SrcInputFileData%VTKCoord
 END SUBROUTINE FVW_CopyInputFile

 SUBROUTINE FVW_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(FVW_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInputFile'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyInputFile

 SUBROUTINE FVW_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InputFile),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInputFile'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! CirculationMethod
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%CirculationFile)  ! CirculationFile
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvMaxIter
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvConvCrit
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvRelaxation
      Int_BufSz  = Int_BufSz  + 1  ! IntMethod
      Int_BufSz  = Int_BufSz  + 1  ! FreeWake
      Re_BufSz   = Re_BufSz   + 1  ! FreeWakeStart
      Re_BufSz   = Re_BufSz   + 1  ! FullCirculationStart
      Db_BufSz   = Db_BufSz   + 1  ! DTfvw
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvPolar
      Int_BufSz  = Int_BufSz  + 1  ! nNWPanels
      Int_BufSz  = Int_BufSz  + 1  ! nFWPanels
      Int_BufSz  = Int_BufSz  + 1  ! nFWPanelsFree
      Int_BufSz  = Int_BufSz  + 1  ! FWShedVorticity
      Int_BufSz  = Int_BufSz  + 1  ! DiffusionMethod
      Re_BufSz   = Re_BufSz   + 1  ! CoreSpreadEddyVisc
      Int_BufSz  = Int_BufSz  + 1  ! RegDeterMethod
      Int_BufSz  = Int_BufSz  + 1  ! RegFunction
      Int_BufSz  = Int_BufSz  + 1  ! WakeRegMethod
      Re_BufSz   = Re_BufSz   + 1  ! WakeRegParam
      Re_BufSz   = Re_BufSz   + 1  ! WingRegParam
      Int_BufSz  = Int_BufSz  + 1  ! ShearModel
      Int_BufSz  = Int_BufSz  + 1  ! TwrShadowOnWake
      Int_BufSz  = Int_BufSz  + 1  ! VelocityMethod
      Re_BufSz   = Re_BufSz   + 1  ! TreeBranchFactor
      Int_BufSz  = Int_BufSz  + 1  ! PartPerSegment
      Int_BufSz  = Int_BufSz  + 1  ! WrVTK
      Int_BufSz  = Int_BufSz  + 1  ! VTKBlades
      Db_BufSz   = Db_BufSz   + 1  ! DTvtk
      Int_BufSz  = Int_BufSz  + 1  ! VTKCoord
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%CirculationMethod
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%CirculationFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%CirculationFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = InData%CircSolvMaxIter
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CircSolvConvCrit
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CircSolvRelaxation
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%IntMethod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FreeWake, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FreeWakeStart
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FullCirculationStart
    Re_Xferred = Re_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTfvw
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%CircSolvPolar
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nNWPanels
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nFWPanels
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nFWPanelsFree
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FWShedVorticity, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%DiffusionMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CoreSpreadEddyVisc
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%RegDeterMethod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%RegFunction
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WakeRegMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WakeRegParam
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WingRegParam
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%ShearModel
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TwrShadowOnWake, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VelocityMethod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TreeBranchFactor
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%PartPerSegment
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WrVTK
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VTKBlades
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTvtk
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%VTKCoord
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE FVW_PackInputFile

 SUBROUTINE FVW_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInputFile'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%CirculationMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%CirculationFile)
      OutData%CirculationFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%CircSolvMaxIter = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CircSolvConvCrit = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CircSolvRelaxation = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%IntMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FreeWake = TRANSFER(IntKiBuf(Int_Xferred), OutData%FreeWake)
    Int_Xferred = Int_Xferred + 1
    OutData%FreeWakeStart = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FullCirculationStart = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DTfvw = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CircSolvPolar = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nNWPanels = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nFWPanels = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nFWPanelsFree = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FWShedVorticity = TRANSFER(IntKiBuf(Int_Xferred), OutData%FWShedVorticity)
    Int_Xferred = Int_Xferred + 1
    OutData%DiffusionMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CoreSpreadEddyVisc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RegDeterMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%RegFunction = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WakeRegMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WakeRegParam = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WingRegParam = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%ShearModel = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TwrShadowOnWake = TRANSFER(IntKiBuf(Int_Xferred), OutData%TwrShadowOnWake)
    Int_Xferred = Int_Xferred + 1
    OutData%VelocityMethod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TreeBranchFactor = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PartPerSegment = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WrVTK = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%VTKBlades = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%DTvtk = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%VTKCoord = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackInputFile

 SUBROUTINE FVW_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(FVW_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%Null = SrcInitOutputData%Null
 END SUBROUTINE FVW_CopyInitOutput

 SUBROUTINE FVW_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FVW_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyInitOutput

 SUBROUTINE FVW_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Null
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%Null
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE FVW_PackInitOutput

 SUBROUTINE FVW_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Null = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackInitOutput


 SUBROUTINE FVW_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Input_ExtrapInterp


 SUBROUTINE FVW_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i1 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp1(u1%WingsMesh(i1), u2%WingsMesh(i1), tin, u_out%WingsMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  DO i2 = LBOUND(u_out%V_wind,2),UBOUND(u_out%V_wind,2)
    DO i1 = LBOUND(u_out%V_wind,1),UBOUND(u_out%V_wind,1)
      b = -(u1%V_wind(i1,i2) - u2%V_wind(i1,i2))
      u_out%V_wind(i1,i2) = u1%V_wind(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  DO i2 = LBOUND(u_out%HubOrientation,2),UBOUND(u_out%HubOrientation,2)
    DO i1 = LBOUND(u_out%HubOrientation,1),UBOUND(u_out%HubOrientation,1)
      b = -(u1%HubOrientation(i1,i2) - u2%HubOrientation(i1,i2))
      u_out%HubOrientation(i1,i2) = u1%HubOrientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%HubPosition,1),UBOUND(u_out%HubPosition,1)
    b = -(u1%HubPosition(i1) - u2%HubPosition(i1))
    u_out%HubPosition(i1) = u1%HubPosition(i1) + b * ScaleFactor
  END DO
 END SUBROUTINE FVW_Input_ExtrapInterp1


 SUBROUTINE FVW_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i1 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp2(u1%WingsMesh(i1), u2%WingsMesh(i1), u3%WingsMesh(i1), tin, u_out%WingsMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  DO i2 = LBOUND(u_out%V_wind,2),UBOUND(u_out%V_wind,2)
    DO i1 = LBOUND(u_out%V_wind,1),UBOUND(u_out%V_wind,1)
      b = (t(3)**2*(u1%V_wind(i1,i2) - u2%V_wind(i1,i2)) + t(2)**2*(-u1%V_wind(i1,i2) + u3%V_wind(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%V_wind(i1,i2) + t(3)*u2%V_wind(i1,i2) - t(2)*u3%V_wind(i1,i2) ) * scaleFactor
      u_out%V_wind(i1,i2) = u1%V_wind(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  DO i2 = LBOUND(u_out%HubOrientation,2),UBOUND(u_out%HubOrientation,2)
    DO i1 = LBOUND(u_out%HubOrientation,1),UBOUND(u_out%HubOrientation,1)
      b = (t(3)**2*(u1%HubOrientation(i1,i2) - u2%HubOrientation(i1,i2)) + t(2)**2*(-u1%HubOrientation(i1,i2) + u3%HubOrientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%HubOrientation(i1,i2) + t(3)*u2%HubOrientation(i1,i2) - t(2)*u3%HubOrientation(i1,i2) ) * scaleFactor
      u_out%HubOrientation(i1,i2) = u1%HubOrientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%HubPosition,1),UBOUND(u_out%HubPosition,1)
    b = (t(3)**2*(u1%HubPosition(i1) - u2%HubPosition(i1)) + t(2)**2*(-u1%HubPosition(i1) + u3%HubPosition(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%HubPosition(i1) + t(3)*u2%HubPosition(i1) - t(2)*u3%HubPosition(i1) ) * scaleFactor
    u_out%HubPosition(i1) = u1%HubPosition(i1) + b  + c * t_out
  END DO
 END SUBROUTINE FVW_Input_ExtrapInterp2


 SUBROUTINE FVW_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Output_ExtrapInterp


 SUBROUTINE FVW_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(FVW_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
 INTEGER                                    :: i3    ! dim3 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%Vind) .AND. ALLOCATED(y1%Vind)) THEN
  DO i3 = LBOUND(y_out%Vind,3),UBOUND(y_out%Vind,3)
    DO i2 = LBOUND(y_out%Vind,2),UBOUND(y_out%Vind,2)
      DO i1 = LBOUND(y_out%Vind,1),UBOUND(y_out%Vind,1)
        b = -(y1%Vind(i1,i2,i3) - y2%Vind(i1,i2,i3))
        y_out%Vind(i1,i2,i3) = y1%Vind(i1,i2,i3) + b * ScaleFactor
      END DO
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl_KJ) .AND. ALLOCATED(y1%Cl_KJ)) THEN
  DO i2 = LBOUND(y_out%Cl_KJ,2),UBOUND(y_out%Cl_KJ,2)
    DO i1 = LBOUND(y_out%Cl_KJ,1),UBOUND(y_out%Cl_KJ,1)
      b = -(y1%Cl_KJ(i1,i2) - y2%Cl_KJ(i1,i2))
      y_out%Cl_KJ(i1,i2) = y1%Cl_KJ(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp1


 SUBROUTINE FVW_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(FVW_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(FVW_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
 INTEGER                                    :: i3    ! dim3 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%Vind) .AND. ALLOCATED(y1%Vind)) THEN
  DO i3 = LBOUND(y_out%Vind,3),UBOUND(y_out%Vind,3)
    DO i2 = LBOUND(y_out%Vind,2),UBOUND(y_out%Vind,2)
      DO i1 = LBOUND(y_out%Vind,1),UBOUND(y_out%Vind,1)
        b = (t(3)**2*(y1%Vind(i1,i2,i3) - y2%Vind(i1,i2,i3)) + t(2)**2*(-y1%Vind(i1,i2,i3) + y3%Vind(i1,i2,i3)))* scaleFactor
        c = ( (t(2)-t(3))*y1%Vind(i1,i2,i3) + t(3)*y2%Vind(i1,i2,i3) - t(2)*y3%Vind(i1,i2,i3) ) * scaleFactor
        y_out%Vind(i1,i2,i3) = y1%Vind(i1,i2,i3) + b  + c * t_out
      END DO
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl_KJ) .AND. ALLOCATED(y1%Cl_KJ)) THEN
  DO i2 = LBOUND(y_out%Cl_KJ,2),UBOUND(y_out%Cl_KJ,2)
    DO i1 = LBOUND(y_out%Cl_KJ,1),UBOUND(y_out%Cl_KJ,1)
      b = (t(3)**2*(y1%Cl_KJ(i1,i2) - y2%Cl_KJ(i1,i2)) + t(2)**2*(-y1%Cl_KJ(i1,i2) + y3%Cl_KJ(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cl_KJ(i1,i2) + t(3)*y2%Cl_KJ(i1,i2) - t(2)*y3%Cl_KJ(i1,i2) ) * scaleFactor
      y_out%Cl_KJ(i1,i2) = y1%Cl_KJ(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp2

END MODULE FVW_Types
!ENDOFREGISTRYGENERATEDFILE
