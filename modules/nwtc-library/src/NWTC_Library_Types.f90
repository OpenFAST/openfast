!STARTOFREGISTRYGENERATEDFILE 'NWTC_Library_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! NWTC_Library_Types
!.................................................................................................................................
! This file is part of NWTC_Library.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in NWTC_Library. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE NWTC_Library_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SysSubs
USE ModReg
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VarNameLen                       = 64      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldForce                       = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldMoment                      = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldOrientation                 = 3      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransDisp                   = 4      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularDisp                 = 5      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransVel                    = 6      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularVel                  = 7      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransAcc                    = 8      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularAcc                  = 9      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldScalar                      = 10      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_None                          = 0      ! Variable with no flags [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Mesh                          = 1      ! Variable contained in mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Line                          = 2      ! Variable is for a line mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_RotFrame                      = 4      ! Variable in rotating frame [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Linearize                     = 8      ! Variable for linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_ExtLin                        = 16      ! Variable for extended linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_SmallAngle                    = 32      ! Use small angles to calculate difference in linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_2PI                           = 64      ! Variable is an angle with range [0,2pi] [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_WriteOut                      = 128      ! Variable for write output [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Solve                         = 256      ! Variable for solver [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AeroMap                       = 512      ! Variable for aeromap [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder1                   = 1024      ! Variable is derivative order 1 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder2                   = 2048      ! Variable is derivative order 2 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_None                          = 0      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Tight                         = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option1                       = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option2                       = 3      !  [-]
! =========  ProgDesc  =======
  TYPE, PUBLIC :: ProgDesc
    CHARACTER(99)  :: Name      !< Name of the program or module [-]
    CHARACTER(99)  :: Ver      !< Version number of the program or module [-]
    CHARACTER(24)  :: Date      !< String containing date module was last updated [-]
  END TYPE ProgDesc
! =======================
! =========  FASTdataType  =======
  TYPE, PUBLIC :: FASTdataType
    CHARACTER(1024)  :: File      !< Name of the FAST-style binary file [-]
    CHARACTER(1024)  :: Descr      !< String describing file [-]
    INTEGER(IntKi)  :: NumChans = 0_IntKi      !< Number of output channels in this binary file (not including the time channel) [-]
    INTEGER(IntKi)  :: NumRecs = 0_IntKi      !< Number of records (rows) of data in the file [-]
    REAL(DbKi)  :: TimeStep = 0.0_R8Ki      !< Time step for evenly-spaced data in the output file (when NumRecs is not allo [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanNames      !< Strings describing the names of the channels from the binary file (including the time channel) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanUnits      !< Strings describing the units of the channels from the binary file (including the time channel) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Data      !< numeric data (rows and columns) from the binary file, including the time channel [-]
  END TYPE FASTdataType
! =======================
! =========  OutParmType  =======
  TYPE, PUBLIC :: OutParmType
    INTEGER(IntKi)  :: Indx = 0_IntKi      !< An index into AllOuts array where this channel is computed/stored [-]
    CHARACTER(ChanLen)  :: Name      !< Name of the output channel [-]
    CHARACTER(ChanLen)  :: Units      !< Units this channel is specified in [-]
    INTEGER(IntKi)  :: SignM = 0_IntKi      !< Multiplier for output channel; usually -1 (minus) or 0 (invalid channel) [-]
  END TYPE OutParmType
! =======================
! =========  FileInfoType  =======
  TYPE, PUBLIC :: FileInfoType
    INTEGER(IntKi)  :: NumLines = 0_IntKi 
    INTEGER(IntKi)  :: NumFiles = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileLine 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileIndx 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: FileList 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: Lines 
  END TYPE FileInfoType
! =======================
! =========  Quaternion  =======
  TYPE, PUBLIC :: Quaternion
    REAL(ReKi)  :: q0 = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:3)  :: v = 0.0_ReKi 
  END TYPE Quaternion
! =======================
! =========  NWTC_RandomNumber_ParameterType  =======
  TYPE, PUBLIC :: NWTC_RandomNumber_ParameterType
    INTEGER(IntKi)  :: pRNG = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:3)  :: RandSeed = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RandSeedAry 
    CHARACTER(6)  :: RNG_type 
  END TYPE NWTC_RandomNumber_ParameterType
! =======================
! =========  DatLoc  =======
  TYPE, PUBLIC :: DatLoc
    INTEGER(IntKi)  :: Num = 0      !< Mesh number in module [-]
    INTEGER(IntKi)  :: i1 = 0      !< Index 1 [-]
    INTEGER(IntKi)  :: i2 = 0      !< Index 2 [-]
    INTEGER(IntKi)  :: i3 = 0      !< Index 3 [-]
  END TYPE DatLoc
! =======================
! =========  ModVarType  =======
  TYPE, PUBLIC :: ModVarType
    character(VarNameLen)  :: Name      !<  [-]
    INTEGER(IntKi)  :: iMod = 0      !< Module index [-]
    INTEGER(IntKi)  :: iVar = 0      !< Variable index [-]
    TYPE(DatLoc)  :: DL      !< data location [-]
    INTEGER(IntKi)  :: Field = 0      !<  [-]
    INTEGER(IntKi)  :: Nodes = 1      !<  [-]
    INTEGER(IntKi)  :: Num = 1      !<  [-]
    INTEGER(IntKi)  :: Flags = 0      !<  [-]
    INTEGER(IntKi)  :: DerivOrder = 0      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iLoc = 0      !< indices in local arrays [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iAry = 0      !< first user defined index for variable [-]
    INTEGER(IntKi)  :: jAry = 0      !< second user defined index for variable [-]
    INTEGER(IntKi)  :: kAry = 0      !< third user defined index for variable [-]
    INTEGER(IntKi)  :: mAry = 0      !< third user defined index for variable [-]
    INTEGER(IntKi)  :: MeshID = 0      !< Mesh identification number [-]
    REAL(R8Ki)  :: Perturb = 0      !< perturbation amount for linearization [-]
    character(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames      !<  [-]
  END TYPE ModVarType
! =======================
! =========  ModVarsType  =======
  TYPE, PUBLIC :: ModVarsType
    INTEGER(IntKi)  :: Nx = 0      !< Number of x values [-]
    INTEGER(IntKi)  :: Nz = 0      !< Number of z values [-]
    INTEGER(IntKi)  :: Nu = 0      !< Number of u values [-]
    INTEGER(IntKi)  :: Ny = 0      !< Number of y values [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: x      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: z      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: u      !< Module input variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: y      !< Module output variable array [-]
  END TYPE ModVarsType
! =======================
! =========  ModJacType  =======
  TYPE, PUBLIC :: ModJacType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
  END TYPE ModJacType
! =======================
! =========  VarXfrType  =======
  TYPE, PUBLIC :: VarXfrType
    INTEGER(IntKi)  :: iVar = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NumVals = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iSrc = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iDst = 0_IntKi      !<  [-]
  END TYPE VarXfrType
! =======================
! =========  ModXfrType  =======
  TYPE, PUBLIC :: ModXfrType
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
  END TYPE ModXfrType
! =======================

contains

subroutine NWTC_Library_CopyProgDesc(SrcProgDescData, DstProgDescData, CtrlCode, ErrStat, ErrMsg)
   type(ProgDesc), intent(in) :: SrcProgDescData
   type(ProgDesc), intent(inout) :: DstProgDescData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstProgDescData%Name = SrcProgDescData%Name
   DstProgDescData%Ver = SrcProgDescData%Ver
   DstProgDescData%Date = SrcProgDescData%Date
end subroutine

subroutine NWTC_Library_DestroyProgDesc(ProgDescData, ErrStat, ErrMsg)
   type(ProgDesc), intent(inout) :: ProgDescData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackProgDesc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ProgDesc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackProgDesc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Ver)
   call RegPack(RF, InData%Date)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackProgDesc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ProgDesc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackProgDesc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ver); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Date); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFASTdataType(SrcFASTdataTypeData, DstFASTdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FASTdataType), intent(in) :: SrcFASTdataTypeData
   type(FASTdataType), intent(inout) :: DstFASTdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFASTdataTypeData%File = SrcFASTdataTypeData%File
   DstFASTdataTypeData%Descr = SrcFASTdataTypeData%Descr
   DstFASTdataTypeData%NumChans = SrcFASTdataTypeData%NumChans
   DstFASTdataTypeData%NumRecs = SrcFASTdataTypeData%NumRecs
   DstFASTdataTypeData%TimeStep = SrcFASTdataTypeData%TimeStep
   if (allocated(SrcFASTdataTypeData%ChanNames)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanNames)) then
         allocate(DstFASTdataTypeData%ChanNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanNames = SrcFASTdataTypeData%ChanNames
   end if
   if (allocated(SrcFASTdataTypeData%ChanUnits)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanUnits)) then
         allocate(DstFASTdataTypeData%ChanUnits(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanUnits.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanUnits = SrcFASTdataTypeData%ChanUnits
   end if
   if (allocated(SrcFASTdataTypeData%Data)) then
      LB(1:2) = lbound(SrcFASTdataTypeData%Data, kind=B8Ki)
      UB(1:2) = ubound(SrcFASTdataTypeData%Data, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%Data)) then
         allocate(DstFASTdataTypeData%Data(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%Data.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%Data = SrcFASTdataTypeData%Data
   end if
end subroutine

subroutine NWTC_Library_DestroyFASTdataType(FASTdataTypeData, ErrStat, ErrMsg)
   type(FASTdataType), intent(inout) :: FASTdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FASTdataTypeData%ChanNames)) then
      deallocate(FASTdataTypeData%ChanNames)
   end if
   if (allocated(FASTdataTypeData%ChanUnits)) then
      deallocate(FASTdataTypeData%ChanUnits)
   end if
   if (allocated(FASTdataTypeData%Data)) then
      deallocate(FASTdataTypeData%Data)
   end if
end subroutine

subroutine NWTC_Library_PackFASTdataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FASTdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFASTdataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%File)
   call RegPack(RF, InData%Descr)
   call RegPack(RF, InData%NumChans)
   call RegPack(RF, InData%NumRecs)
   call RegPack(RF, InData%TimeStep)
   call RegPackAlloc(RF, InData%ChanNames)
   call RegPackAlloc(RF, InData%ChanUnits)
   call RegPackAlloc(RF, InData%Data)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFASTdataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FASTdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFASTdataType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%File); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Descr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumRecs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TimeStep); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanNames); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanUnits); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Data); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyOutParmType(SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutParmType), intent(in) :: SrcOutParmTypeData
   type(OutParmType), intent(inout) :: DstOutParmTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutParmTypeData%Indx = SrcOutParmTypeData%Indx
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%SignM = SrcOutParmTypeData%SignM
end subroutine

subroutine NWTC_Library_DestroyOutParmType(OutParmTypeData, ErrStat, ErrMsg)
   type(OutParmType), intent(inout) :: OutParmTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackOutParmType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackOutParmType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Indx)
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Units)
   call RegPack(RF, InData%SignM)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackOutParmType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackOutParmType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Units); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SignM); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFileInfoType(SrcFileInfoTypeData, DstFileInfoTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FileInfoType), intent(in) :: SrcFileInfoTypeData
   type(FileInfoType), intent(inout) :: DstFileInfoTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFileInfoTypeData%NumLines = SrcFileInfoTypeData%NumLines
   DstFileInfoTypeData%NumFiles = SrcFileInfoTypeData%NumFiles
   if (allocated(SrcFileInfoTypeData%FileLine)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileLine)) then
         allocate(DstFileInfoTypeData%FileLine(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileLine.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileLine = SrcFileInfoTypeData%FileLine
   end if
   if (allocated(SrcFileInfoTypeData%FileIndx)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileIndx)) then
         allocate(DstFileInfoTypeData%FileIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileIndx = SrcFileInfoTypeData%FileIndx
   end if
   if (allocated(SrcFileInfoTypeData%FileList)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileList)) then
         allocate(DstFileInfoTypeData%FileList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileList = SrcFileInfoTypeData%FileList
   end if
   if (allocated(SrcFileInfoTypeData%Lines)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%Lines)) then
         allocate(DstFileInfoTypeData%Lines(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%Lines.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%Lines = SrcFileInfoTypeData%Lines
   end if
end subroutine

subroutine NWTC_Library_DestroyFileInfoType(FileInfoTypeData, ErrStat, ErrMsg)
   type(FileInfoType), intent(inout) :: FileInfoTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FileInfoTypeData%FileLine)) then
      deallocate(FileInfoTypeData%FileLine)
   end if
   if (allocated(FileInfoTypeData%FileIndx)) then
      deallocate(FileInfoTypeData%FileIndx)
   end if
   if (allocated(FileInfoTypeData%FileList)) then
      deallocate(FileInfoTypeData%FileList)
   end if
   if (allocated(FileInfoTypeData%Lines)) then
      deallocate(FileInfoTypeData%Lines)
   end if
end subroutine

subroutine NWTC_Library_PackFileInfoType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FileInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFileInfoType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumLines)
   call RegPack(RF, InData%NumFiles)
   call RegPackAlloc(RF, InData%FileLine)
   call RegPackAlloc(RF, InData%FileIndx)
   call RegPackAlloc(RF, InData%FileList)
   call RegPackAlloc(RF, InData%Lines)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFileInfoType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FileInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFileInfoType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumLines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumFiles); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileLine); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Lines); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyQuaternion(SrcQuaternionData, DstQuaternionData, CtrlCode, ErrStat, ErrMsg)
   type(Quaternion), intent(in) :: SrcQuaternionData
   type(Quaternion), intent(inout) :: DstQuaternionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstQuaternionData%q0 = SrcQuaternionData%q0
   DstQuaternionData%v = SrcQuaternionData%v
end subroutine

subroutine NWTC_Library_DestroyQuaternion(QuaternionData, ErrStat, ErrMsg)
   type(Quaternion), intent(inout) :: QuaternionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackQuaternion(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Quaternion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackQuaternion'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%q0)
   call RegPack(RF, InData%v)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackQuaternion(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Quaternion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackQuaternion'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%q0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%v); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyNWTC_RandomNumber_ParameterType(SrcNWTC_RandomNumber_ParameterTypeData, DstNWTC_RandomNumber_ParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(in) :: SrcNWTC_RandomNumber_ParameterTypeData
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: DstNWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstNWTC_RandomNumber_ParameterTypeData%pRNG = SrcNWTC_RandomNumber_ParameterTypeData%pRNG
   DstNWTC_RandomNumber_ParameterTypeData%RandSeed = SrcNWTC_RandomNumber_ParameterTypeData%RandSeed
   if (allocated(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      LB(1:1) = lbound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      UB(1:1) = ubound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      if (.not. allocated(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
         allocate(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry = SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry
   end if
   DstNWTC_RandomNumber_ParameterTypeData%RNG_type = SrcNWTC_RandomNumber_ParameterTypeData%RNG_type
end subroutine

subroutine NWTC_Library_DestroyNWTC_RandomNumber_ParameterType(NWTC_RandomNumber_ParameterTypeData, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: NWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      deallocate(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)
   end if
end subroutine

subroutine NWTC_Library_PackNWTC_RandomNumber_ParameterType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(NWTC_RandomNumber_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackNWTC_RandomNumber_ParameterType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%pRNG)
   call RegPack(RF, InData%RandSeed)
   call RegPackAlloc(RF, InData%RandSeedAry)
   call RegPack(RF, InData%RNG_type)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackNWTC_RandomNumber_ParameterType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackNWTC_RandomNumber_ParameterType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%pRNG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RandSeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RandSeedAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RNG_type); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyDatLoc(SrcDatLocData, DstDatLocData, CtrlCode, ErrStat, ErrMsg)
   type(DatLoc), intent(in) :: SrcDatLocData
   type(DatLoc), intent(inout) :: DstDatLocData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyDatLoc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDatLocData%Num = SrcDatLocData%Num
   DstDatLocData%i1 = SrcDatLocData%i1
   DstDatLocData%i2 = SrcDatLocData%i2
   DstDatLocData%i3 = SrcDatLocData%i3
end subroutine

subroutine NWTC_Library_DestroyDatLoc(DatLocData, ErrStat, ErrMsg)
   type(DatLoc), intent(inout) :: DatLocData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyDatLoc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackDatLoc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DatLoc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackDatLoc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%i1)
   call RegPack(RF, InData%i2)
   call RegPack(RF, InData%i3)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackDatLoc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DatLoc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackDatLoc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i3); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarType(SrcModVarTypeData, DstModVarTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarType), intent(in) :: SrcModVarTypeData
   type(ModVarType), intent(inout) :: DstModVarTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarTypeData%Name = SrcModVarTypeData%Name
   DstModVarTypeData%iMod = SrcModVarTypeData%iMod
   DstModVarTypeData%iVar = SrcModVarTypeData%iVar
   call NWTC_Library_CopyDatLoc(SrcModVarTypeData%DL, DstModVarTypeData%DL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstModVarTypeData%Field = SrcModVarTypeData%Field
   DstModVarTypeData%Nodes = SrcModVarTypeData%Nodes
   DstModVarTypeData%Num = SrcModVarTypeData%Num
   DstModVarTypeData%Flags = SrcModVarTypeData%Flags
   DstModVarTypeData%DerivOrder = SrcModVarTypeData%DerivOrder
   DstModVarTypeData%iLoc = SrcModVarTypeData%iLoc
   DstModVarTypeData%iAry = SrcModVarTypeData%iAry
   DstModVarTypeData%jAry = SrcModVarTypeData%jAry
   DstModVarTypeData%kAry = SrcModVarTypeData%kAry
   DstModVarTypeData%mAry = SrcModVarTypeData%mAry
   DstModVarTypeData%MeshID = SrcModVarTypeData%MeshID
   DstModVarTypeData%Perturb = SrcModVarTypeData%Perturb
   if (allocated(SrcModVarTypeData%LinNames)) then
      LB(1:1) = lbound(SrcModVarTypeData%LinNames, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarTypeData%LinNames, kind=B8Ki)
      if (.not. allocated(DstModVarTypeData%LinNames)) then
         allocate(DstModVarTypeData%LinNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarTypeData%LinNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModVarTypeData%LinNames = SrcModVarTypeData%LinNames
   end if
end subroutine

subroutine NWTC_Library_DestroyModVarType(ModVarTypeData, ErrStat, ErrMsg)
   type(ModVarType), intent(inout) :: ModVarTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyDatLoc(ModVarTypeData%DL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModVarTypeData%LinNames)) then
      deallocate(ModVarTypeData%LinNames)
   end if
end subroutine

subroutine NWTC_Library_PackModVarType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%iMod)
   call RegPack(RF, InData%iVar)
   call NWTC_Library_PackDatLoc(RF, InData%DL) 
   call RegPack(RF, InData%Field)
   call RegPack(RF, InData%Nodes)
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%Flags)
   call RegPack(RF, InData%DerivOrder)
   call RegPack(RF, InData%iLoc)
   call RegPack(RF, InData%iAry)
   call RegPack(RF, InData%jAry)
   call RegPack(RF, InData%kAry)
   call RegPack(RF, InData%mAry)
   call RegPack(RF, InData%MeshID)
   call RegPack(RF, InData%Perturb)
   call RegPackAlloc(RF, InData%LinNames)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVar); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackDatLoc(RF, OutData%DL) ! DL 
   call RegUnpack(RF, OutData%Field); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Flags); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DerivOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%jAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarsType(SrcModVarsTypeData, DstModVarsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarsType), intent(in) :: SrcModVarsTypeData
   type(ModVarsType), intent(inout) :: DstModVarsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarsTypeData%Nx = SrcModVarsTypeData%Nx
   DstModVarsTypeData%Nz = SrcModVarsTypeData%Nz
   DstModVarsTypeData%Nu = SrcModVarsTypeData%Nu
   DstModVarsTypeData%Ny = SrcModVarsTypeData%Ny
   if (allocated(SrcModVarsTypeData%x)) then
      LB(1:1) = lbound(SrcModVarsTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%x)) then
         allocate(DstModVarsTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%x(i1), DstModVarsTypeData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%z)) then
      LB(1:1) = lbound(SrcModVarsTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%z)) then
         allocate(DstModVarsTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%z(i1), DstModVarsTypeData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%u)) then
      LB(1:1) = lbound(SrcModVarsTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%u)) then
         allocate(DstModVarsTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%u(i1), DstModVarsTypeData%u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%y)) then
      LB(1:1) = lbound(SrcModVarsTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%y)) then
         allocate(DstModVarsTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%y(i1), DstModVarsTypeData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine NWTC_Library_DestroyModVarsType(ModVarsTypeData, ErrStat, ErrMsg)
   type(ModVarsType), intent(inout) :: ModVarsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModVarsTypeData%x)) then
      LB(1:1) = lbound(ModVarsTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%x)
   end if
   if (allocated(ModVarsTypeData%z)) then
      LB(1:1) = lbound(ModVarsTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%z)
   end if
   if (allocated(ModVarsTypeData%u)) then
      LB(1:1) = lbound(ModVarsTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%u)
   end if
   if (allocated(ModVarsTypeData%y)) then
      LB(1:1) = lbound(ModVarsTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%y)
   end if
end subroutine

subroutine NWTC_Library_PackModVarsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarsType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nz)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x, kind=B8Ki), ubound(InData%x, kind=B8Ki))
      LB(1:1) = lbound(InData%x, kind=B8Ki)
      UB(1:1) = ubound(InData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z, kind=B8Ki), ubound(InData%z, kind=B8Ki))
      LB(1:1) = lbound(InData%z, kind=B8Ki)
      UB(1:1) = ubound(InData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(RF, 1, lbound(InData%u, kind=B8Ki), ubound(InData%u, kind=B8Ki))
      LB(1:1) = lbound(InData%u, kind=B8Ki)
      UB(1:1) = ubound(InData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%u(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y, kind=B8Ki), ubound(InData%y, kind=B8Ki))
      LB(1:1) = lbound(InData%y, kind=B8Ki)
      UB(1:1) = ubound(InData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarsType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%u(i1)) ! u 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%y(i1)) ! y 
      end do
   end if
end subroutine

subroutine NWTC_Library_CopyModJacType(SrcModJacTypeData, DstModJacTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModJacType), intent(in) :: SrcModJacTypeData
   type(ModJacType), intent(inout) :: DstModJacTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModJacTypeData%x)) then
      LB(1:1) = lbound(SrcModJacTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x)) then
         allocate(DstModJacTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x = SrcModJacTypeData%x
   end if
   if (allocated(SrcModJacTypeData%dx)) then
      LB(1:1) = lbound(SrcModJacTypeData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%dx, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%dx)) then
         allocate(DstModJacTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%dx = SrcModJacTypeData%dx
   end if
   if (allocated(SrcModJacTypeData%z)) then
      LB(1:1) = lbound(SrcModJacTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%z)) then
         allocate(DstModJacTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%z = SrcModJacTypeData%z
   end if
   if (allocated(SrcModJacTypeData%u)) then
      LB(1:1) = lbound(SrcModJacTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%u)) then
         allocate(DstModJacTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u = SrcModJacTypeData%u
   end if
   if (allocated(SrcModJacTypeData%y)) then
      LB(1:1) = lbound(SrcModJacTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y)) then
         allocate(DstModJacTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y = SrcModJacTypeData%y
   end if
   if (allocated(SrcModJacTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%u_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%u_perturb, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%u_perturb)) then
         allocate(DstModJacTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u_perturb = SrcModJacTypeData%u_perturb
   end if
   if (allocated(SrcModJacTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_perturb, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_perturb)) then
         allocate(DstModJacTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_perturb = SrcModJacTypeData%x_perturb
   end if
   if (allocated(SrcModJacTypeData%x_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_pos, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_pos)) then
         allocate(DstModJacTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_pos = SrcModJacTypeData%x_pos
   end if
   if (allocated(SrcModJacTypeData%x_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_neg, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_neg)) then
         allocate(DstModJacTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_neg = SrcModJacTypeData%x_neg
   end if
   if (allocated(SrcModJacTypeData%y_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y_pos, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y_pos)) then
         allocate(DstModJacTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_pos = SrcModJacTypeData%y_pos
   end if
   if (allocated(SrcModJacTypeData%y_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y_neg, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y_neg)) then
         allocate(DstModJacTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_neg = SrcModJacTypeData%y_neg
   end if
end subroutine

subroutine NWTC_Library_DestroyModJacType(ModJacTypeData, ErrStat, ErrMsg)
   type(ModJacType), intent(inout) :: ModJacTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModJacTypeData%x)) then
      deallocate(ModJacTypeData%x)
   end if
   if (allocated(ModJacTypeData%dx)) then
      deallocate(ModJacTypeData%dx)
   end if
   if (allocated(ModJacTypeData%z)) then
      deallocate(ModJacTypeData%z)
   end if
   if (allocated(ModJacTypeData%u)) then
      deallocate(ModJacTypeData%u)
   end if
   if (allocated(ModJacTypeData%y)) then
      deallocate(ModJacTypeData%y)
   end if
   if (allocated(ModJacTypeData%u_perturb)) then
      deallocate(ModJacTypeData%u_perturb)
   end if
   if (allocated(ModJacTypeData%x_perturb)) then
      deallocate(ModJacTypeData%x_perturb)
   end if
   if (allocated(ModJacTypeData%x_pos)) then
      deallocate(ModJacTypeData%x_pos)
   end if
   if (allocated(ModJacTypeData%x_neg)) then
      deallocate(ModJacTypeData%x_neg)
   end if
   if (allocated(ModJacTypeData%y_pos)) then
      deallocate(ModJacTypeData%y_pos)
   end if
   if (allocated(ModJacTypeData%y_neg)) then
      deallocate(ModJacTypeData%y_neg)
   end if
end subroutine

subroutine NWTC_Library_PackModJacType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModJacType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModJacType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModJacType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModJacType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModJacType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyVarXfrType(SrcVarXfrTypeData, DstVarXfrTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarXfrType), intent(in) :: SrcVarXfrTypeData
   type(VarXfrType), intent(inout) :: DstVarXfrTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyVarXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVarXfrTypeData%iVar = SrcVarXfrTypeData%iVar
   DstVarXfrTypeData%NumVals = SrcVarXfrTypeData%NumVals
   DstVarXfrTypeData%iSrc = SrcVarXfrTypeData%iSrc
   DstVarXfrTypeData%iDst = SrcVarXfrTypeData%iDst
end subroutine

subroutine NWTC_Library_DestroyVarXfrType(VarXfrTypeData, ErrStat, ErrMsg)
   type(VarXfrType), intent(inout) :: VarXfrTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyVarXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackVarXfrType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarXfrType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackVarXfrType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%iVar)
   call RegPack(RF, InData%NumVals)
   call RegPack(RF, InData%iSrc)
   call RegPack(RF, InData%iDst)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackVarXfrType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarXfrType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackVarXfrType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%iVar); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumVals); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iDst); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModXfrType(SrcModXfrTypeData, DstModXfrTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModXfrType), intent(in) :: SrcModXfrTypeData
   type(ModXfrType), intent(inout) :: DstModXfrTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModXfrTypeData%x)) then
      LB(1:1) = lbound(SrcModXfrTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%x)) then
         allocate(DstModXfrTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyVarXfrType(SrcModXfrTypeData%x(i1), DstModXfrTypeData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%z)) then
      LB(1:1) = lbound(SrcModXfrTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%z)) then
         allocate(DstModXfrTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyVarXfrType(SrcModXfrTypeData%z(i1), DstModXfrTypeData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%u)) then
      LB(1:1) = lbound(SrcModXfrTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%u)) then
         allocate(DstModXfrTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyVarXfrType(SrcModXfrTypeData%u(i1), DstModXfrTypeData%u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%y)) then
      LB(1:1) = lbound(SrcModXfrTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%y)) then
         allocate(DstModXfrTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyVarXfrType(SrcModXfrTypeData%y(i1), DstModXfrTypeData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine NWTC_Library_DestroyModXfrType(ModXfrTypeData, ErrStat, ErrMsg)
   type(ModXfrType), intent(inout) :: ModXfrTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModXfrTypeData%x)) then
      LB(1:1) = lbound(ModXfrTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyVarXfrType(ModXfrTypeData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%x)
   end if
   if (allocated(ModXfrTypeData%z)) then
      LB(1:1) = lbound(ModXfrTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyVarXfrType(ModXfrTypeData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%z)
   end if
   if (allocated(ModXfrTypeData%u)) then
      LB(1:1) = lbound(ModXfrTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyVarXfrType(ModXfrTypeData%u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%u)
   end if
   if (allocated(ModXfrTypeData%y)) then
      LB(1:1) = lbound(ModXfrTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyVarXfrType(ModXfrTypeData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%y)
   end if
end subroutine

subroutine NWTC_Library_PackModXfrType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModXfrType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModXfrType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x, kind=B8Ki), ubound(InData%x, kind=B8Ki))
      LB(1:1) = lbound(InData%x, kind=B8Ki)
      UB(1:1) = ubound(InData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackVarXfrType(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z, kind=B8Ki), ubound(InData%z, kind=B8Ki))
      LB(1:1) = lbound(InData%z, kind=B8Ki)
      UB(1:1) = ubound(InData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackVarXfrType(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(RF, 1, lbound(InData%u, kind=B8Ki), ubound(InData%u, kind=B8Ki))
      LB(1:1) = lbound(InData%u, kind=B8Ki)
      UB(1:1) = ubound(InData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackVarXfrType(RF, InData%u(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y, kind=B8Ki), ubound(InData%y, kind=B8Ki))
      LB(1:1) = lbound(InData%y, kind=B8Ki)
      UB(1:1) = ubound(InData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackVarXfrType(RF, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModXfrType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModXfrType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModXfrType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackVarXfrType(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackVarXfrType(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackVarXfrType(RF, OutData%u(i1)) ! u 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackVarXfrType(RF, OutData%y(i1)) ! y 
      end do
   end if
end subroutine
END MODULE NWTC_Library_Types
!ENDOFREGISTRYGENERATEDFILE
