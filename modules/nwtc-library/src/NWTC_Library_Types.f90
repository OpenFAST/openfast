!STARTOFREGISTRYGENERATEDFILE 'NWTC_Library_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! NWTC_Library_Types
!.................................................................................................................................
! This file is part of NWTC_Library.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in NWTC_Library. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE NWTC_Library_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SysSubs
USE ModReg
IMPLICIT NONE
! =========  ProgDesc  =======
  TYPE, PUBLIC :: ProgDesc
    CHARACTER(99)  :: Name      !< Name of the program or module [-]
    CHARACTER(99)  :: Ver      !< Version number of the program or module [-]
    CHARACTER(24)  :: Date      !< String containing date module was last updated [-]
  END TYPE ProgDesc
! =======================
! =========  FASTdataType  =======
  TYPE, PUBLIC :: FASTdataType
    CHARACTER(1024)  :: File      !< Name of the FAST-style binary file [-]
    CHARACTER(1024)  :: Descr      !< String describing file [-]
    INTEGER(IntKi)  :: NumChans = 0_IntKi      !< Number of output channels in this binary file (not including the time channel) [-]
    INTEGER(IntKi)  :: NumRecs = 0_IntKi      !< Number of records (rows) of data in the file [-]
    REAL(DbKi)  :: TimeStep = 0.0_R8Ki      !< Time step for evenly-spaced data in the output file (when NumRecs is not allo [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanNames      !< Strings describing the names of the channels from the binary file (including the time channel) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanUnits      !< Strings describing the units of the channels from the binary file (including the time channel) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Data      !< numeric data (rows and columns) from the binary file, including the time channel [-]
  END TYPE FASTdataType
! =======================
! =========  OutParmType  =======
  TYPE, PUBLIC :: OutParmType
    INTEGER(IntKi)  :: Indx = 0_IntKi      !< An index into AllOuts array where this channel is computed/stored [-]
    CHARACTER(ChanLen)  :: Name      !< Name of the output channel [-]
    CHARACTER(ChanLen)  :: Units      !< Units this channel is specified in [-]
    INTEGER(IntKi)  :: SignM = 0_IntKi      !< Multiplier for output channel; usually -1 (minus) or 0 (invalid channel) [-]
  END TYPE OutParmType
! =======================
! =========  FileInfoType  =======
  TYPE, PUBLIC :: FileInfoType
    INTEGER(IntKi)  :: NumLines = 0_IntKi 
    INTEGER(IntKi)  :: NumFiles = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileLine 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileIndx 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: FileList 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: Lines 
  END TYPE FileInfoType
! =======================
! =========  Quaternion  =======
  TYPE, PUBLIC :: Quaternion
    REAL(ReKi)  :: q0 = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:3)  :: v = 0.0_ReKi 
  END TYPE Quaternion
! =======================
! =========  NWTC_RandomNumber_ParameterType  =======
  TYPE, PUBLIC :: NWTC_RandomNumber_ParameterType
    INTEGER(IntKi)  :: pRNG = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:3)  :: RandSeed = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RandSeedAry 
    CHARACTER(6)  :: RNG_type 
  END TYPE NWTC_RandomNumber_ParameterType
! =======================
CONTAINS

subroutine NWTC_Library_CopyProgDesc(SrcProgDescData, DstProgDescData, CtrlCode, ErrStat, ErrMsg)
   type(ProgDesc), intent(in) :: SrcProgDescData
   type(ProgDesc), intent(inout) :: DstProgDescData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstProgDescData%Name = SrcProgDescData%Name
   DstProgDescData%Ver = SrcProgDescData%Ver
   DstProgDescData%Date = SrcProgDescData%Date
end subroutine

subroutine NWTC_Library_DestroyProgDesc(ProgDescData, ErrStat, ErrMsg)
   type(ProgDesc), intent(inout) :: ProgDescData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackProgDesc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ProgDesc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackProgDesc'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Name)
   call RegPack(Buf, InData%Ver)
   call RegPack(Buf, InData%Date)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackProgDesc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ProgDesc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackProgDesc'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Ver)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Date)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFASTdataType(SrcFASTdataTypeData, DstFASTdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FASTdataType), intent(in) :: SrcFASTdataTypeData
   type(FASTdataType), intent(inout) :: DstFASTdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFASTdataTypeData%File = SrcFASTdataTypeData%File
   DstFASTdataTypeData%Descr = SrcFASTdataTypeData%Descr
   DstFASTdataTypeData%NumChans = SrcFASTdataTypeData%NumChans
   DstFASTdataTypeData%NumRecs = SrcFASTdataTypeData%NumRecs
   DstFASTdataTypeData%TimeStep = SrcFASTdataTypeData%TimeStep
   if (allocated(SrcFASTdataTypeData%ChanNames)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanNames)) then
         allocate(DstFASTdataTypeData%ChanNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanNames = SrcFASTdataTypeData%ChanNames
   end if
   if (allocated(SrcFASTdataTypeData%ChanUnits)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanUnits)) then
         allocate(DstFASTdataTypeData%ChanUnits(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanUnits.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanUnits = SrcFASTdataTypeData%ChanUnits
   end if
   if (allocated(SrcFASTdataTypeData%Data)) then
      LB(1:2) = lbound(SrcFASTdataTypeData%Data, kind=B8Ki)
      UB(1:2) = ubound(SrcFASTdataTypeData%Data, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%Data)) then
         allocate(DstFASTdataTypeData%Data(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%Data.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%Data = SrcFASTdataTypeData%Data
   end if
end subroutine

subroutine NWTC_Library_DestroyFASTdataType(FASTdataTypeData, ErrStat, ErrMsg)
   type(FASTdataType), intent(inout) :: FASTdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FASTdataTypeData%ChanNames)) then
      deallocate(FASTdataTypeData%ChanNames)
   end if
   if (allocated(FASTdataTypeData%ChanUnits)) then
      deallocate(FASTdataTypeData%ChanUnits)
   end if
   if (allocated(FASTdataTypeData%Data)) then
      deallocate(FASTdataTypeData%Data)
   end if
end subroutine

subroutine NWTC_Library_PackFASTdataType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FASTdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFASTdataType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%File)
   call RegPack(Buf, InData%Descr)
   call RegPack(Buf, InData%NumChans)
   call RegPack(Buf, InData%NumRecs)
   call RegPack(Buf, InData%TimeStep)
   call RegPack(Buf, allocated(InData%ChanNames))
   if (allocated(InData%ChanNames)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChanNames, kind=B8Ki), ubound(InData%ChanNames, kind=B8Ki))
      call RegPack(Buf, InData%ChanNames)
   end if
   call RegPack(Buf, allocated(InData%ChanUnits))
   if (allocated(InData%ChanUnits)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChanUnits, kind=B8Ki), ubound(InData%ChanUnits, kind=B8Ki))
      call RegPack(Buf, InData%ChanUnits)
   end if
   call RegPack(Buf, allocated(InData%Data))
   if (allocated(InData%Data)) then
      call RegPackBounds(Buf, 2, lbound(InData%Data, kind=B8Ki), ubound(InData%Data, kind=B8Ki))
      call RegPack(Buf, InData%Data)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFASTdataType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FASTdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFASTdataType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%File)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Descr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumChans)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumRecs)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TimeStep)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%ChanNames)) deallocate(OutData%ChanNames)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChanNames(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChanNames.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChanNames)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ChanUnits)) deallocate(OutData%ChanUnits)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChanUnits(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChanUnits.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChanUnits)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Data)) deallocate(OutData%Data)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Data(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Data.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Data)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine NWTC_Library_CopyOutParmType(SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutParmType), intent(in) :: SrcOutParmTypeData
   type(OutParmType), intent(inout) :: DstOutParmTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutParmTypeData%Indx = SrcOutParmTypeData%Indx
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%SignM = SrcOutParmTypeData%SignM
end subroutine

subroutine NWTC_Library_DestroyOutParmType(OutParmTypeData, ErrStat, ErrMsg)
   type(OutParmType), intent(inout) :: OutParmTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackOutParmType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackOutParmType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%Indx)
   call RegPack(Buf, InData%Name)
   call RegPack(Buf, InData%Units)
   call RegPack(Buf, InData%SignM)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackOutParmType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackOutParmType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%Indx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Units)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SignM)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFileInfoType(SrcFileInfoTypeData, DstFileInfoTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FileInfoType), intent(in) :: SrcFileInfoTypeData
   type(FileInfoType), intent(inout) :: DstFileInfoTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFileInfoTypeData%NumLines = SrcFileInfoTypeData%NumLines
   DstFileInfoTypeData%NumFiles = SrcFileInfoTypeData%NumFiles
   if (allocated(SrcFileInfoTypeData%FileLine)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileLine)) then
         allocate(DstFileInfoTypeData%FileLine(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileLine.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileLine = SrcFileInfoTypeData%FileLine
   end if
   if (allocated(SrcFileInfoTypeData%FileIndx)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileIndx)) then
         allocate(DstFileInfoTypeData%FileIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileIndx = SrcFileInfoTypeData%FileIndx
   end if
   if (allocated(SrcFileInfoTypeData%FileList)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileList)) then
         allocate(DstFileInfoTypeData%FileList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileList = SrcFileInfoTypeData%FileList
   end if
   if (allocated(SrcFileInfoTypeData%Lines)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%Lines)) then
         allocate(DstFileInfoTypeData%Lines(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%Lines.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%Lines = SrcFileInfoTypeData%Lines
   end if
end subroutine

subroutine NWTC_Library_DestroyFileInfoType(FileInfoTypeData, ErrStat, ErrMsg)
   type(FileInfoType), intent(inout) :: FileInfoTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FileInfoTypeData%FileLine)) then
      deallocate(FileInfoTypeData%FileLine)
   end if
   if (allocated(FileInfoTypeData%FileIndx)) then
      deallocate(FileInfoTypeData%FileIndx)
   end if
   if (allocated(FileInfoTypeData%FileList)) then
      deallocate(FileInfoTypeData%FileList)
   end if
   if (allocated(FileInfoTypeData%Lines)) then
      deallocate(FileInfoTypeData%Lines)
   end if
end subroutine

subroutine NWTC_Library_PackFileInfoType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FileInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFileInfoType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%NumLines)
   call RegPack(Buf, InData%NumFiles)
   call RegPack(Buf, allocated(InData%FileLine))
   if (allocated(InData%FileLine)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileLine, kind=B8Ki), ubound(InData%FileLine, kind=B8Ki))
      call RegPack(Buf, InData%FileLine)
   end if
   call RegPack(Buf, allocated(InData%FileIndx))
   if (allocated(InData%FileIndx)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileIndx, kind=B8Ki), ubound(InData%FileIndx, kind=B8Ki))
      call RegPack(Buf, InData%FileIndx)
   end if
   call RegPack(Buf, allocated(InData%FileList))
   if (allocated(InData%FileList)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileList, kind=B8Ki), ubound(InData%FileList, kind=B8Ki))
      call RegPack(Buf, InData%FileList)
   end if
   call RegPack(Buf, allocated(InData%Lines))
   if (allocated(InData%Lines)) then
      call RegPackBounds(Buf, 1, lbound(InData%Lines, kind=B8Ki), ubound(InData%Lines, kind=B8Ki))
      call RegPack(Buf, InData%Lines)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFileInfoType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FileInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFileInfoType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%NumFiles)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%FileLine)) deallocate(OutData%FileLine)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileLine(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileLine.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileLine)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FileIndx)) deallocate(OutData%FileIndx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileIndx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileIndx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileIndx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%FileList)) deallocate(OutData%FileList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Lines)) deallocate(OutData%Lines)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Lines(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Lines.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Lines)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine NWTC_Library_CopyQuaternion(SrcQuaternionData, DstQuaternionData, CtrlCode, ErrStat, ErrMsg)
   type(Quaternion), intent(in) :: SrcQuaternionData
   type(Quaternion), intent(inout) :: DstQuaternionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstQuaternionData%q0 = SrcQuaternionData%q0
   DstQuaternionData%v = SrcQuaternionData%v
end subroutine

subroutine NWTC_Library_DestroyQuaternion(QuaternionData, ErrStat, ErrMsg)
   type(Quaternion), intent(inout) :: QuaternionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackQuaternion(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Quaternion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackQuaternion'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%q0)
   call RegPack(Buf, InData%v)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackQuaternion(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Quaternion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackQuaternion'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%q0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%v)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyNWTC_RandomNumber_ParameterType(SrcNWTC_RandomNumber_ParameterTypeData, DstNWTC_RandomNumber_ParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(in) :: SrcNWTC_RandomNumber_ParameterTypeData
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: DstNWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstNWTC_RandomNumber_ParameterTypeData%pRNG = SrcNWTC_RandomNumber_ParameterTypeData%pRNG
   DstNWTC_RandomNumber_ParameterTypeData%RandSeed = SrcNWTC_RandomNumber_ParameterTypeData%RandSeed
   if (allocated(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      LB(1:1) = lbound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      UB(1:1) = ubound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      if (.not. allocated(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
         allocate(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry = SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry
   end if
   DstNWTC_RandomNumber_ParameterTypeData%RNG_type = SrcNWTC_RandomNumber_ParameterTypeData%RNG_type
end subroutine

subroutine NWTC_Library_DestroyNWTC_RandomNumber_ParameterType(NWTC_RandomNumber_ParameterTypeData, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: NWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      deallocate(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)
   end if
end subroutine

subroutine NWTC_Library_PackNWTC_RandomNumber_ParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(NWTC_RandomNumber_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackNWTC_RandomNumber_ParameterType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%pRNG)
   call RegPack(Buf, InData%RandSeed)
   call RegPack(Buf, allocated(InData%RandSeedAry))
   if (allocated(InData%RandSeedAry)) then
      call RegPackBounds(Buf, 1, lbound(InData%RandSeedAry, kind=B8Ki), ubound(InData%RandSeedAry, kind=B8Ki))
      call RegPack(Buf, InData%RandSeedAry)
   end if
   call RegPack(Buf, InData%RNG_type)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackNWTC_RandomNumber_ParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackNWTC_RandomNumber_ParameterType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%pRNG)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%RandSeed)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%RandSeedAry)) deallocate(OutData%RandSeedAry)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RandSeedAry(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RandSeedAry.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RandSeedAry)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%RNG_type)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE NWTC_Library_Types
!ENDOFREGISTRYGENERATEDFILE
