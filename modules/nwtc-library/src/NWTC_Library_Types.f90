!STARTOFREGISTRYGENERATEDFILE 'NWTC_Library_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! NWTC_Library_Types
!.................................................................................................................................
! This file is part of NWTC_Library.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in NWTC_Library. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE NWTC_Library_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE Precision
USE SysSubs
USE ModReg
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VarNameLen                       = 64      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldForce                       = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldMoment                      = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldOrientation                 = 3      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransDisp                   = 4      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransVel                    = 5      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularVel                  = 6      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldTransAcc                    = 7      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularAcc                  = 8      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldScalar                      = 9      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldAngularDisp                 = 10      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: FieldCount                       = 10      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_None                          = 0      ! Variable with no flags [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Mesh                          = 1      ! Variable contained in mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Line                          = 2      ! Variable is for a line mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_RotFrame                      = 4      ! Variable in rotating frame [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Linearize                     = 8      ! Variable for linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_ExtLin                        = 16      ! Variable for extended linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_SmallAngle                    = 32      ! Use small angles to calculate difference in linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_2PI                           = 64      ! Variable is an angle with range [0,2pi] [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_WM_Rot                        = 128      ! Variable is a Wiener-Milenkovic rotation [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_WriteOut                      = 256      ! Variable for write output [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Solve                         = 512      ! Variable for tight coupling solver [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AeroMap                       = 1024      ! Variable for aeromap [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder1                   = 2048      ! Variable is derivative order 1 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder2                   = 4096      ! Variable is derivative order 2 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Mapping                       = 8192      ! Variable is used in a module-to-module transfer mapping [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_None                          = 0      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Tight                         = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option1                       = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option2                       = 3      !  [-]
! =========  ProgDesc  =======
  TYPE, PUBLIC :: ProgDesc
    CHARACTER(99)  :: Name      !< Name of the program or module [-]
    CHARACTER(99)  :: Ver      !< Version number of the program or module [-]
    CHARACTER(24)  :: Date      !< String containing date module was last updated [-]
  END TYPE ProgDesc
! =======================
! =========  FASTdataType  =======
  TYPE, PUBLIC :: FASTdataType
    CHARACTER(1024)  :: File      !< Name of the FAST-style binary file [-]
    CHARACTER(1024)  :: Descr      !< String describing file [-]
    INTEGER(IntKi)  :: NumChans = 0_IntKi      !< Number of output channels in this binary file (not including the time channel) [-]
    INTEGER(IntKi)  :: NumRecs = 0_IntKi      !< Number of records (rows) of data in the file [-]
    REAL(DbKi)  :: TimeStep = 0.0_R8Ki      !< Time step for evenly-spaced data in the output file (when NumRecs is not allo [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanNames      !< Strings describing the names of the channels from the binary file (including the time channel) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanUnits      !< Strings describing the units of the channels from the binary file (including the time channel) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Data      !< numeric data (rows and columns) from the binary file, including the time channel [-]
  END TYPE FASTdataType
! =======================
! =========  OutParmType  =======
  TYPE, PUBLIC :: OutParmType
    INTEGER(IntKi)  :: Indx = 0_IntKi      !< An index into AllOuts array where this channel is computed/stored [-]
    CHARACTER(ChanLen)  :: Name      !< Name of the output channel [-]
    CHARACTER(ChanLen)  :: Units      !< Units this channel is specified in [-]
    INTEGER(IntKi)  :: SignM = 0_IntKi      !< Multiplier for output channel; usually -1 (minus) or 0 (invalid channel) [-]
  END TYPE OutParmType
! =======================
! =========  FileInfoType  =======
  TYPE, PUBLIC :: FileInfoType
    INTEGER(IntKi)  :: NumLines = 0_IntKi 
    INTEGER(IntKi)  :: NumFiles = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileLine 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileIndx 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: FileList 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: Lines 
  END TYPE FileInfoType
! =======================
! =========  Quaternion  =======
  TYPE, PUBLIC :: Quaternion
    REAL(ReKi)  :: q0 = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:3)  :: v = 0.0_ReKi 
  END TYPE Quaternion
! =======================
! =========  NWTC_RandomNumber_ParameterType  =======
  TYPE, PUBLIC :: NWTC_RandomNumber_ParameterType
    INTEGER(IntKi)  :: pRNG = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:3)  :: RandSeed = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RandSeedAry 
    CHARACTER(6)  :: RNG_type 
  END TYPE NWTC_RandomNumber_ParameterType
! =======================
! =========  DatLoc  =======
  TYPE, PUBLIC :: DatLoc
    INTEGER(IntKi)  :: Num = 0      !< Mesh number in module [-]
    INTEGER(IntKi)  :: i1 = 0      !< Index 1 [-]
    INTEGER(IntKi)  :: i2 = 0      !< Index 2 [-]
    INTEGER(IntKi)  :: i3 = 0      !< Index 3 [-]
    INTEGER(IntKi)  :: i4 = 0      !< Index 4 [-]
    INTEGER(IntKi)  :: i5 = 0      !< Index 5 [-]
  END TYPE DatLoc
! =======================
! =========  ModVarType  =======
  TYPE, PUBLIC :: ModVarType
    INTEGER(IntKi)  :: Field = 0      !<  [-]
    INTEGER(IntKi)  :: Nodes = 1      !<  [-]
    INTEGER(IntKi)  :: Num = 1      !<  [-]
    INTEGER(IntKi)  :: Flags = 0      !<  [-]
    INTEGER(IntKi)  :: DerivOrder = 0      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iLoc = 0      !< indices in module arrays [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iGlu = 0      !< indices in module arrays [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iq = 0      !< solver state row indices [-]
    INTEGER(IntKi)  :: iLB = 0      !< first user defined index lower bound for variable [-]
    INTEGER(IntKi)  :: iUB = 0      !< first user defined index upper bound for variable [-]
    INTEGER(IntKi)  :: j = 0      !< second user defined index for variable [-]
    INTEGER(IntKi)  :: k = 0      !< third user defined index for variable [-]
    INTEGER(IntKi)  :: m = 0      !< fourth user defined index for variable [-]
    INTEGER(IntKi)  :: n = 0      !< fifth user defined index for variable [-]
    REAL(R8Ki)  :: Perturb = 0      !< perturbation amount for linearization [-]
    TYPE(DatLoc)  :: DL      !< data location [-]
    character(VarNameLen)  :: Name      !<  [-]
    character(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames      !<  [-]
  END TYPE ModVarType
! =======================
! =========  ModVarsType  =======
  TYPE, PUBLIC :: ModVarsType
    INTEGER(IntKi)  :: Nx = 0      !< Number of x values [-]
    INTEGER(IntKi)  :: Nu = 0      !< Number of u values [-]
    INTEGER(IntKi)  :: Ny = 0      !< Number of y values [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: x      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: u      !< Module input variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: y      !< Module output variable array [-]
  END TYPE ModVarsType
! =======================
! =========  ModJacType  =======
  TYPE, PUBLIC :: ModJacType
    INTEGER(IntKi)  :: Nx = 0      !< Number of x values [-]
    INTEGER(IntKi)  :: Nu = 0      !< Number of u values [-]
    INTEGER(IntKi)  :: Ny = 0      !< Number of y values [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !<  [-]
  END TYPE ModJacType
! =======================
! =========  ModLinType  =======
  TYPE, PUBLIC :: ModLinType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !<  [-]
  END TYPE ModLinType
! =======================
! =========  ModDataType  =======
  TYPE, PUBLIC :: ModDataType
    character(ChanLen)  :: Abbr      !< Module name abbreviation [-]
    INTEGER(IntKi)  :: iMod = 0      !< Module index in array of modules [-]
    INTEGER(IntKi)  :: ID = 0      !< Module identification number [-]
    INTEGER(IntKi)  :: Ins = 0      !< Module instance number [-]
    INTEGER(IntKi)  :: SubSteps = 0      !< Module number of substeps per solver time step [-]
    REAL(R8Ki)  :: DT = 0      !< Module time step [-]
    TYPE(ModVarsType)  :: Vars      !< Module variables type [-]
    TYPE(ModLinType)  :: Lin      !< Module linearization arrays and matrices [-]
  END TYPE ModDataType
! =======================

contains

subroutine NWTC_Library_CopyProgDesc(SrcProgDescData, DstProgDescData, CtrlCode, ErrStat, ErrMsg)
   type(ProgDesc), intent(in) :: SrcProgDescData
   type(ProgDesc), intent(inout) :: DstProgDescData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstProgDescData%Name = SrcProgDescData%Name
   DstProgDescData%Ver = SrcProgDescData%Ver
   DstProgDescData%Date = SrcProgDescData%Date
end subroutine

subroutine NWTC_Library_DestroyProgDesc(ProgDescData, ErrStat, ErrMsg)
   type(ProgDesc), intent(inout) :: ProgDescData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackProgDesc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ProgDesc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackProgDesc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Ver)
   call RegPack(RF, InData%Date)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackProgDesc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ProgDesc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackProgDesc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ver); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Date); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFASTdataType(SrcFASTdataTypeData, DstFASTdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FASTdataType), intent(in) :: SrcFASTdataTypeData
   type(FASTdataType), intent(inout) :: DstFASTdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFASTdataTypeData%File = SrcFASTdataTypeData%File
   DstFASTdataTypeData%Descr = SrcFASTdataTypeData%Descr
   DstFASTdataTypeData%NumChans = SrcFASTdataTypeData%NumChans
   DstFASTdataTypeData%NumRecs = SrcFASTdataTypeData%NumRecs
   DstFASTdataTypeData%TimeStep = SrcFASTdataTypeData%TimeStep
   if (allocated(SrcFASTdataTypeData%ChanNames)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanNames)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanNames)
      if (.not. allocated(DstFASTdataTypeData%ChanNames)) then
         allocate(DstFASTdataTypeData%ChanNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanNames = SrcFASTdataTypeData%ChanNames
   end if
   if (allocated(SrcFASTdataTypeData%ChanUnits)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanUnits)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanUnits)
      if (.not. allocated(DstFASTdataTypeData%ChanUnits)) then
         allocate(DstFASTdataTypeData%ChanUnits(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanUnits.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanUnits = SrcFASTdataTypeData%ChanUnits
   end if
   if (allocated(SrcFASTdataTypeData%Data)) then
      LB(1:2) = lbound(SrcFASTdataTypeData%Data)
      UB(1:2) = ubound(SrcFASTdataTypeData%Data)
      if (.not. allocated(DstFASTdataTypeData%Data)) then
         allocate(DstFASTdataTypeData%Data(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%Data.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%Data = SrcFASTdataTypeData%Data
   end if
end subroutine

subroutine NWTC_Library_DestroyFASTdataType(FASTdataTypeData, ErrStat, ErrMsg)
   type(FASTdataType), intent(inout) :: FASTdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FASTdataTypeData%ChanNames)) then
      deallocate(FASTdataTypeData%ChanNames)
   end if
   if (allocated(FASTdataTypeData%ChanUnits)) then
      deallocate(FASTdataTypeData%ChanUnits)
   end if
   if (allocated(FASTdataTypeData%Data)) then
      deallocate(FASTdataTypeData%Data)
   end if
end subroutine

subroutine NWTC_Library_PackFASTdataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FASTdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFASTdataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%File)
   call RegPack(RF, InData%Descr)
   call RegPack(RF, InData%NumChans)
   call RegPack(RF, InData%NumRecs)
   call RegPack(RF, InData%TimeStep)
   call RegPackAlloc(RF, InData%ChanNames)
   call RegPackAlloc(RF, InData%ChanUnits)
   call RegPackAlloc(RF, InData%Data)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFASTdataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FASTdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFASTdataType'
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%File); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Descr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumRecs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TimeStep); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanNames); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanUnits); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Data); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyOutParmType(SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutParmType), intent(in) :: SrcOutParmTypeData
   type(OutParmType), intent(inout) :: DstOutParmTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutParmTypeData%Indx = SrcOutParmTypeData%Indx
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%SignM = SrcOutParmTypeData%SignM
end subroutine

subroutine NWTC_Library_DestroyOutParmType(OutParmTypeData, ErrStat, ErrMsg)
   type(OutParmType), intent(inout) :: OutParmTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackOutParmType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackOutParmType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Indx)
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Units)
   call RegPack(RF, InData%SignM)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackOutParmType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackOutParmType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Units); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SignM); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFileInfoType(SrcFileInfoTypeData, DstFileInfoTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FileInfoType), intent(in) :: SrcFileInfoTypeData
   type(FileInfoType), intent(inout) :: DstFileInfoTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFileInfoTypeData%NumLines = SrcFileInfoTypeData%NumLines
   DstFileInfoTypeData%NumFiles = SrcFileInfoTypeData%NumFiles
   if (allocated(SrcFileInfoTypeData%FileLine)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileLine)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileLine)
      if (.not. allocated(DstFileInfoTypeData%FileLine)) then
         allocate(DstFileInfoTypeData%FileLine(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileLine.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileLine = SrcFileInfoTypeData%FileLine
   end if
   if (allocated(SrcFileInfoTypeData%FileIndx)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileIndx)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileIndx)
      if (.not. allocated(DstFileInfoTypeData%FileIndx)) then
         allocate(DstFileInfoTypeData%FileIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileIndx = SrcFileInfoTypeData%FileIndx
   end if
   if (allocated(SrcFileInfoTypeData%FileList)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileList)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileList)
      if (.not. allocated(DstFileInfoTypeData%FileList)) then
         allocate(DstFileInfoTypeData%FileList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileList = SrcFileInfoTypeData%FileList
   end if
   if (allocated(SrcFileInfoTypeData%Lines)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%Lines)
      UB(1:1) = ubound(SrcFileInfoTypeData%Lines)
      if (.not. allocated(DstFileInfoTypeData%Lines)) then
         allocate(DstFileInfoTypeData%Lines(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%Lines.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%Lines = SrcFileInfoTypeData%Lines
   end if
end subroutine

subroutine NWTC_Library_DestroyFileInfoType(FileInfoTypeData, ErrStat, ErrMsg)
   type(FileInfoType), intent(inout) :: FileInfoTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FileInfoTypeData%FileLine)) then
      deallocate(FileInfoTypeData%FileLine)
   end if
   if (allocated(FileInfoTypeData%FileIndx)) then
      deallocate(FileInfoTypeData%FileIndx)
   end if
   if (allocated(FileInfoTypeData%FileList)) then
      deallocate(FileInfoTypeData%FileList)
   end if
   if (allocated(FileInfoTypeData%Lines)) then
      deallocate(FileInfoTypeData%Lines)
   end if
end subroutine

subroutine NWTC_Library_PackFileInfoType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FileInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFileInfoType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumLines)
   call RegPack(RF, InData%NumFiles)
   call RegPackAlloc(RF, InData%FileLine)
   call RegPackAlloc(RF, InData%FileIndx)
   call RegPackAlloc(RF, InData%FileList)
   call RegPackAlloc(RF, InData%Lines)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFileInfoType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FileInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFileInfoType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumLines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumFiles); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileLine); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Lines); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyQuaternion(SrcQuaternionData, DstQuaternionData, CtrlCode, ErrStat, ErrMsg)
   type(Quaternion), intent(in) :: SrcQuaternionData
   type(Quaternion), intent(inout) :: DstQuaternionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstQuaternionData%q0 = SrcQuaternionData%q0
   DstQuaternionData%v = SrcQuaternionData%v
end subroutine

subroutine NWTC_Library_DestroyQuaternion(QuaternionData, ErrStat, ErrMsg)
   type(Quaternion), intent(inout) :: QuaternionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackQuaternion(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Quaternion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackQuaternion'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%q0)
   call RegPack(RF, InData%v)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackQuaternion(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Quaternion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackQuaternion'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%q0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%v); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyNWTC_RandomNumber_ParameterType(SrcNWTC_RandomNumber_ParameterTypeData, DstNWTC_RandomNumber_ParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(in) :: SrcNWTC_RandomNumber_ParameterTypeData
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: DstNWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstNWTC_RandomNumber_ParameterTypeData%pRNG = SrcNWTC_RandomNumber_ParameterTypeData%pRNG
   DstNWTC_RandomNumber_ParameterTypeData%RandSeed = SrcNWTC_RandomNumber_ParameterTypeData%RandSeed
   if (allocated(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      LB(1:1) = lbound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)
      UB(1:1) = ubound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)
      if (.not. allocated(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
         allocate(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry = SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry
   end if
   DstNWTC_RandomNumber_ParameterTypeData%RNG_type = SrcNWTC_RandomNumber_ParameterTypeData%RNG_type
end subroutine

subroutine NWTC_Library_DestroyNWTC_RandomNumber_ParameterType(NWTC_RandomNumber_ParameterTypeData, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: NWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      deallocate(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)
   end if
end subroutine

subroutine NWTC_Library_PackNWTC_RandomNumber_ParameterType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(NWTC_RandomNumber_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackNWTC_RandomNumber_ParameterType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%pRNG)
   call RegPack(RF, InData%RandSeed)
   call RegPackAlloc(RF, InData%RandSeedAry)
   call RegPack(RF, InData%RNG_type)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackNWTC_RandomNumber_ParameterType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackNWTC_RandomNumber_ParameterType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%pRNG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RandSeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RandSeedAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RNG_type); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyDatLoc(SrcDatLocData, DstDatLocData, CtrlCode, ErrStat, ErrMsg)
   type(DatLoc), intent(in) :: SrcDatLocData
   type(DatLoc), intent(inout) :: DstDatLocData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyDatLoc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDatLocData%Num = SrcDatLocData%Num
   DstDatLocData%i1 = SrcDatLocData%i1
   DstDatLocData%i2 = SrcDatLocData%i2
   DstDatLocData%i3 = SrcDatLocData%i3
   DstDatLocData%i4 = SrcDatLocData%i4
   DstDatLocData%i5 = SrcDatLocData%i5
end subroutine

subroutine NWTC_Library_DestroyDatLoc(DatLocData, ErrStat, ErrMsg)
   type(DatLoc), intent(inout) :: DatLocData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyDatLoc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackDatLoc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DatLoc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackDatLoc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%i1)
   call RegPack(RF, InData%i2)
   call RegPack(RF, InData%i3)
   call RegPack(RF, InData%i4)
   call RegPack(RF, InData%i5)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackDatLoc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DatLoc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackDatLoc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i3); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i4); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i5); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarType(SrcModVarTypeData, DstModVarTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarType), intent(in) :: SrcModVarTypeData
   type(ModVarType), intent(inout) :: DstModVarTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarTypeData%Field = SrcModVarTypeData%Field
   DstModVarTypeData%Nodes = SrcModVarTypeData%Nodes
   DstModVarTypeData%Num = SrcModVarTypeData%Num
   DstModVarTypeData%Flags = SrcModVarTypeData%Flags
   DstModVarTypeData%DerivOrder = SrcModVarTypeData%DerivOrder
   DstModVarTypeData%iLoc = SrcModVarTypeData%iLoc
   DstModVarTypeData%iGlu = SrcModVarTypeData%iGlu
   DstModVarTypeData%iq = SrcModVarTypeData%iq
   DstModVarTypeData%iLB = SrcModVarTypeData%iLB
   DstModVarTypeData%iUB = SrcModVarTypeData%iUB
   DstModVarTypeData%j = SrcModVarTypeData%j
   DstModVarTypeData%k = SrcModVarTypeData%k
   DstModVarTypeData%m = SrcModVarTypeData%m
   DstModVarTypeData%n = SrcModVarTypeData%n
   DstModVarTypeData%Perturb = SrcModVarTypeData%Perturb
   call NWTC_Library_CopyDatLoc(SrcModVarTypeData%DL, DstModVarTypeData%DL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstModVarTypeData%Name = SrcModVarTypeData%Name
   if (allocated(SrcModVarTypeData%LinNames)) then
      LB(1:1) = lbound(SrcModVarTypeData%LinNames)
      UB(1:1) = ubound(SrcModVarTypeData%LinNames)
      if (.not. allocated(DstModVarTypeData%LinNames)) then
         allocate(DstModVarTypeData%LinNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarTypeData%LinNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModVarTypeData%LinNames = SrcModVarTypeData%LinNames
   end if
end subroutine

subroutine NWTC_Library_DestroyModVarType(ModVarTypeData, ErrStat, ErrMsg)
   type(ModVarType), intent(inout) :: ModVarTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyDatLoc(ModVarTypeData%DL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModVarTypeData%LinNames)) then
      deallocate(ModVarTypeData%LinNames)
   end if
end subroutine

subroutine NWTC_Library_PackModVarType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Field)
   call RegPack(RF, InData%Nodes)
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%Flags)
   call RegPack(RF, InData%DerivOrder)
   call RegPack(RF, InData%iLoc)
   call RegPack(RF, InData%iGlu)
   call RegPack(RF, InData%iq)
   call RegPack(RF, InData%iLB)
   call RegPack(RF, InData%iUB)
   call RegPack(RF, InData%j)
   call RegPack(RF, InData%k)
   call RegPack(RF, InData%m)
   call RegPack(RF, InData%n)
   call RegPack(RF, InData%Perturb)
   call NWTC_Library_PackDatLoc(RF, InData%DL) 
   call RegPack(RF, InData%Name)
   call RegPackAlloc(RF, InData%LinNames)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Field); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Flags); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DerivOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iGlu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iLB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%j); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%k); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%m); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Perturb); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackDatLoc(RF, OutData%DL) ! DL 
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarsType(SrcModVarsTypeData, DstModVarsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarsType), intent(in) :: SrcModVarsTypeData
   type(ModVarsType), intent(inout) :: DstModVarsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarsTypeData%Nx = SrcModVarsTypeData%Nx
   DstModVarsTypeData%Nu = SrcModVarsTypeData%Nu
   DstModVarsTypeData%Ny = SrcModVarsTypeData%Ny
   if (allocated(SrcModVarsTypeData%x)) then
      LB(1:1) = lbound(SrcModVarsTypeData%x)
      UB(1:1) = ubound(SrcModVarsTypeData%x)
      if (.not. allocated(DstModVarsTypeData%x)) then
         allocate(DstModVarsTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%x(i1), DstModVarsTypeData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%u)) then
      LB(1:1) = lbound(SrcModVarsTypeData%u)
      UB(1:1) = ubound(SrcModVarsTypeData%u)
      if (.not. allocated(DstModVarsTypeData%u)) then
         allocate(DstModVarsTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%u(i1), DstModVarsTypeData%u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%y)) then
      LB(1:1) = lbound(SrcModVarsTypeData%y)
      UB(1:1) = ubound(SrcModVarsTypeData%y)
      if (.not. allocated(DstModVarsTypeData%y)) then
         allocate(DstModVarsTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%y(i1), DstModVarsTypeData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine NWTC_Library_DestroyModVarsType(ModVarsTypeData, ErrStat, ErrMsg)
   type(ModVarsType), intent(inout) :: ModVarsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModVarsTypeData%x)) then
      LB(1:1) = lbound(ModVarsTypeData%x)
      UB(1:1) = ubound(ModVarsTypeData%x)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%x)
   end if
   if (allocated(ModVarsTypeData%u)) then
      LB(1:1) = lbound(ModVarsTypeData%u)
      UB(1:1) = ubound(ModVarsTypeData%u)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%u)
   end if
   if (allocated(ModVarsTypeData%y)) then
      LB(1:1) = lbound(ModVarsTypeData%y)
      UB(1:1) = ubound(ModVarsTypeData%y)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%y)
   end if
end subroutine

subroutine NWTC_Library_PackModVarsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarsType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(RF, 1, lbound(InData%u), ubound(InData%u))
      LB(1:1) = lbound(InData%u)
      UB(1:1) = ubound(InData%u)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%u(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarsType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%u(i1)) ! u 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%y(i1)) ! y 
      end do
   end if
end subroutine

subroutine NWTC_Library_CopyModJacType(SrcModJacTypeData, DstModJacTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModJacType), intent(in) :: SrcModJacTypeData
   type(ModJacType), intent(inout) :: DstModJacTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModJacTypeData%Nx = SrcModJacTypeData%Nx
   DstModJacTypeData%Nu = SrcModJacTypeData%Nu
   DstModJacTypeData%Ny = SrcModJacTypeData%Ny
   if (allocated(SrcModJacTypeData%x)) then
      LB(1:1) = lbound(SrcModJacTypeData%x)
      UB(1:1) = ubound(SrcModJacTypeData%x)
      if (.not. allocated(DstModJacTypeData%x)) then
         allocate(DstModJacTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x = SrcModJacTypeData%x
   end if
   if (allocated(SrcModJacTypeData%u)) then
      LB(1:1) = lbound(SrcModJacTypeData%u)
      UB(1:1) = ubound(SrcModJacTypeData%u)
      if (.not. allocated(DstModJacTypeData%u)) then
         allocate(DstModJacTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u = SrcModJacTypeData%u
   end if
   if (allocated(SrcModJacTypeData%y)) then
      LB(1:1) = lbound(SrcModJacTypeData%y)
      UB(1:1) = ubound(SrcModJacTypeData%y)
      if (.not. allocated(DstModJacTypeData%y)) then
         allocate(DstModJacTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y = SrcModJacTypeData%y
   end if
   if (allocated(SrcModJacTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_perturb)
      UB(1:1) = ubound(SrcModJacTypeData%x_perturb)
      if (.not. allocated(DstModJacTypeData%x_perturb)) then
         allocate(DstModJacTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_perturb = SrcModJacTypeData%x_perturb
   end if
   if (allocated(SrcModJacTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%u_perturb)
      UB(1:1) = ubound(SrcModJacTypeData%u_perturb)
      if (.not. allocated(DstModJacTypeData%u_perturb)) then
         allocate(DstModJacTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u_perturb = SrcModJacTypeData%u_perturb
   end if
   if (allocated(SrcModJacTypeData%x_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_pos)
      UB(1:1) = ubound(SrcModJacTypeData%x_pos)
      if (.not. allocated(DstModJacTypeData%x_pos)) then
         allocate(DstModJacTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_pos = SrcModJacTypeData%x_pos
   end if
   if (allocated(SrcModJacTypeData%x_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_neg)
      UB(1:1) = ubound(SrcModJacTypeData%x_neg)
      if (.not. allocated(DstModJacTypeData%x_neg)) then
         allocate(DstModJacTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_neg = SrcModJacTypeData%x_neg
   end if
   if (allocated(SrcModJacTypeData%y_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_pos)
      UB(1:1) = ubound(SrcModJacTypeData%y_pos)
      if (.not. allocated(DstModJacTypeData%y_pos)) then
         allocate(DstModJacTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_pos = SrcModJacTypeData%y_pos
   end if
   if (allocated(SrcModJacTypeData%y_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_neg)
      UB(1:1) = ubound(SrcModJacTypeData%y_neg)
      if (.not. allocated(DstModJacTypeData%y_neg)) then
         allocate(DstModJacTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_neg = SrcModJacTypeData%y_neg
   end if
   if (allocated(SrcModJacTypeData%StateRotation)) then
      LB(1:2) = lbound(SrcModJacTypeData%StateRotation)
      UB(1:2) = ubound(SrcModJacTypeData%StateRotation)
      if (.not. allocated(DstModJacTypeData%StateRotation)) then
         allocate(DstModJacTypeData%StateRotation(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%StateRotation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%StateRotation = SrcModJacTypeData%StateRotation
   end if
end subroutine

subroutine NWTC_Library_DestroyModJacType(ModJacTypeData, ErrStat, ErrMsg)
   type(ModJacType), intent(inout) :: ModJacTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModJacTypeData%x)) then
      deallocate(ModJacTypeData%x)
   end if
   if (allocated(ModJacTypeData%u)) then
      deallocate(ModJacTypeData%u)
   end if
   if (allocated(ModJacTypeData%y)) then
      deallocate(ModJacTypeData%y)
   end if
   if (allocated(ModJacTypeData%x_perturb)) then
      deallocate(ModJacTypeData%x_perturb)
   end if
   if (allocated(ModJacTypeData%u_perturb)) then
      deallocate(ModJacTypeData%u_perturb)
   end if
   if (allocated(ModJacTypeData%x_pos)) then
      deallocate(ModJacTypeData%x_pos)
   end if
   if (allocated(ModJacTypeData%x_neg)) then
      deallocate(ModJacTypeData%x_neg)
   end if
   if (allocated(ModJacTypeData%y_pos)) then
      deallocate(ModJacTypeData%y_pos)
   end if
   if (allocated(ModJacTypeData%y_neg)) then
      deallocate(ModJacTypeData%y_neg)
   end if
   if (allocated(ModJacTypeData%StateRotation)) then
      deallocate(ModJacTypeData%StateRotation)
   end if
end subroutine

subroutine NWTC_Library_PackModJacType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModJacType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModJacType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   call RegPackAlloc(RF, InData%StateRotation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModJacType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModJacType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModJacType'
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StateRotation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModLinType(SrcModLinTypeData, DstModLinTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModLinType), intent(in) :: SrcModLinTypeData
   type(ModLinType), intent(inout) :: DstModLinTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModLinTypeData%x)) then
      LB(1:1) = lbound(SrcModLinTypeData%x)
      UB(1:1) = ubound(SrcModLinTypeData%x)
      if (.not. allocated(DstModLinTypeData%x)) then
         allocate(DstModLinTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%x = SrcModLinTypeData%x
   end if
   if (allocated(SrcModLinTypeData%dx)) then
      LB(1:1) = lbound(SrcModLinTypeData%dx)
      UB(1:1) = ubound(SrcModLinTypeData%dx)
      if (.not. allocated(DstModLinTypeData%dx)) then
         allocate(DstModLinTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dx = SrcModLinTypeData%dx
   end if
   if (allocated(SrcModLinTypeData%u)) then
      LB(1:1) = lbound(SrcModLinTypeData%u)
      UB(1:1) = ubound(SrcModLinTypeData%u)
      if (.not. allocated(DstModLinTypeData%u)) then
         allocate(DstModLinTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%u = SrcModLinTypeData%u
   end if
   if (allocated(SrcModLinTypeData%y)) then
      LB(1:1) = lbound(SrcModLinTypeData%y)
      UB(1:1) = ubound(SrcModLinTypeData%y)
      if (.not. allocated(DstModLinTypeData%y)) then
         allocate(DstModLinTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%y = SrcModLinTypeData%y
   end if
   if (allocated(SrcModLinTypeData%J)) then
      LB(1:2) = lbound(SrcModLinTypeData%J)
      UB(1:2) = ubound(SrcModLinTypeData%J)
      if (.not. allocated(DstModLinTypeData%J)) then
         allocate(DstModLinTypeData%J(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%J.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%J = SrcModLinTypeData%J
   end if
   if (allocated(SrcModLinTypeData%dYdx)) then
      LB(1:2) = lbound(SrcModLinTypeData%dYdx)
      UB(1:2) = ubound(SrcModLinTypeData%dYdx)
      if (.not. allocated(DstModLinTypeData%dYdx)) then
         allocate(DstModLinTypeData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dYdx = SrcModLinTypeData%dYdx
   end if
   if (allocated(SrcModLinTypeData%dXdx)) then
      LB(1:2) = lbound(SrcModLinTypeData%dXdx)
      UB(1:2) = ubound(SrcModLinTypeData%dXdx)
      if (.not. allocated(DstModLinTypeData%dXdx)) then
         allocate(DstModLinTypeData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dXdx = SrcModLinTypeData%dXdx
   end if
   if (allocated(SrcModLinTypeData%dYdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dYdu)
      UB(1:2) = ubound(SrcModLinTypeData%dYdu)
      if (.not. allocated(DstModLinTypeData%dYdu)) then
         allocate(DstModLinTypeData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dYdu = SrcModLinTypeData%dYdu
   end if
   if (allocated(SrcModLinTypeData%dXdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dXdu)
      UB(1:2) = ubound(SrcModLinTypeData%dXdu)
      if (.not. allocated(DstModLinTypeData%dXdu)) then
         allocate(DstModLinTypeData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dXdu = SrcModLinTypeData%dXdu
   end if
   if (allocated(SrcModLinTypeData%dXdy)) then
      LB(1:2) = lbound(SrcModLinTypeData%dXdy)
      UB(1:2) = ubound(SrcModLinTypeData%dXdy)
      if (.not. allocated(DstModLinTypeData%dXdy)) then
         allocate(DstModLinTypeData%dXdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dXdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dXdy = SrcModLinTypeData%dXdy
   end if
   if (allocated(SrcModLinTypeData%dUdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dUdu)
      UB(1:2) = ubound(SrcModLinTypeData%dUdu)
      if (.not. allocated(DstModLinTypeData%dUdu)) then
         allocate(DstModLinTypeData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dUdu = SrcModLinTypeData%dUdu
   end if
   if (allocated(SrcModLinTypeData%dUdy)) then
      LB(1:2) = lbound(SrcModLinTypeData%dUdy)
      UB(1:2) = ubound(SrcModLinTypeData%dUdy)
      if (.not. allocated(DstModLinTypeData%dUdy)) then
         allocate(DstModLinTypeData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dUdy = SrcModLinTypeData%dUdy
   end if
   if (allocated(SrcModLinTypeData%StateRotation)) then
      LB(1:2) = lbound(SrcModLinTypeData%StateRotation)
      UB(1:2) = ubound(SrcModLinTypeData%StateRotation)
      if (.not. allocated(DstModLinTypeData%StateRotation)) then
         allocate(DstModLinTypeData%StateRotation(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%StateRotation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%StateRotation = SrcModLinTypeData%StateRotation
   end if
end subroutine

subroutine NWTC_Library_DestroyModLinType(ModLinTypeData, ErrStat, ErrMsg)
   type(ModLinType), intent(inout) :: ModLinTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModLinTypeData%x)) then
      deallocate(ModLinTypeData%x)
   end if
   if (allocated(ModLinTypeData%dx)) then
      deallocate(ModLinTypeData%dx)
   end if
   if (allocated(ModLinTypeData%u)) then
      deallocate(ModLinTypeData%u)
   end if
   if (allocated(ModLinTypeData%y)) then
      deallocate(ModLinTypeData%y)
   end if
   if (allocated(ModLinTypeData%J)) then
      deallocate(ModLinTypeData%J)
   end if
   if (allocated(ModLinTypeData%dYdx)) then
      deallocate(ModLinTypeData%dYdx)
   end if
   if (allocated(ModLinTypeData%dXdx)) then
      deallocate(ModLinTypeData%dXdx)
   end if
   if (allocated(ModLinTypeData%dYdu)) then
      deallocate(ModLinTypeData%dYdu)
   end if
   if (allocated(ModLinTypeData%dXdu)) then
      deallocate(ModLinTypeData%dXdu)
   end if
   if (allocated(ModLinTypeData%dXdy)) then
      deallocate(ModLinTypeData%dXdy)
   end if
   if (allocated(ModLinTypeData%dUdu)) then
      deallocate(ModLinTypeData%dUdu)
   end if
   if (allocated(ModLinTypeData%dUdy)) then
      deallocate(ModLinTypeData%dUdy)
   end if
   if (allocated(ModLinTypeData%StateRotation)) then
      deallocate(ModLinTypeData%StateRotation)
   end if
end subroutine

subroutine NWTC_Library_PackModLinType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModLinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModLinType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%J)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dXdy)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%StateRotation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModLinType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModLinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModLinType'
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StateRotation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModDataType(SrcModDataTypeData, DstModDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModDataType), intent(in) :: SrcModDataTypeData
   type(ModDataType), intent(inout) :: DstModDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModDataTypeData%Abbr = SrcModDataTypeData%Abbr
   DstModDataTypeData%iMod = SrcModDataTypeData%iMod
   DstModDataTypeData%ID = SrcModDataTypeData%ID
   DstModDataTypeData%Ins = SrcModDataTypeData%Ins
   DstModDataTypeData%SubSteps = SrcModDataTypeData%SubSteps
   DstModDataTypeData%DT = SrcModDataTypeData%DT
   call NWTC_Library_CopyModVarsType(SrcModDataTypeData%Vars, DstModDataTypeData%Vars, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyModLinType(SrcModDataTypeData%Lin, DstModDataTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine NWTC_Library_DestroyModDataType(ModDataTypeData, ErrStat, ErrMsg)
   type(ModDataType), intent(inout) :: ModDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyModVarsType(ModDataTypeData%Vars, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyModLinType(ModDataTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine NWTC_Library_PackModDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModDataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Abbr)
   call RegPack(RF, InData%iMod)
   call RegPack(RF, InData%ID)
   call RegPack(RF, InData%Ins)
   call RegPack(RF, InData%SubSteps)
   call RegPack(RF, InData%DT)
   call NWTC_Library_PackModVarsType(RF, InData%Vars) 
   call NWTC_Library_PackModLinType(RF, InData%Lin) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModDataType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Abbr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ins); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SubSteps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackModVarsType(RF, OutData%Vars) ! Vars 
   call NWTC_Library_UnpackModLinType(RF, OutData%Lin) ! Lin 
end subroutine

END MODULE NWTC_Library_Types

!ENDOFREGISTRYGENERATEDFILE
