!STARTOFREGISTRYGENERATEDFILE 'NWTC_Library_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! NWTC_Library_Types
!.................................................................................................................................
! This file is part of NWTC_Library.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in NWTC_Library. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE NWTC_Library_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SysSubs
USE ModReg
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VarNameLen                       = 64      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Force                         = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Moment                        = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Orientation                   = 3      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_TransDisp                     = 4      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AngularDisp                   = 5      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_TransVel                      = 6      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AngularVel                    = 7      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_TransAcc                      = 8      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AngularAcc                    = 9      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Scalar                        = 10      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_None                          = 0      ! Variable with no flags [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Mesh                          = 1      ! Variable contained in mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Line                          = 2      ! Variable is for a line mesh [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_RotFrame                      = 4      ! Variable in rotating frame [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Linearize                     = 8      ! Variable for linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_ExtLin                        = 16      ! Variable for extended linearization [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_WriteOut                      = 32      ! Variable for write output [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_Solve                         = 64      ! Variable for solver [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_AeroMap                       = 128      ! Variable for aeromap [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder1                   = 256      ! Variable is derivative order 1 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VF_DerivOrder2                   = 512      ! Variable is derivative order 2 in linearization file [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_None                          = 0      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Tight                         = 1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option1                       = 2      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: VC_Option2                       = 3      !  [-]
! =========  ProgDesc  =======
  TYPE, PUBLIC :: ProgDesc
    CHARACTER(99)  :: Name      !< Name of the program or module [-]
    CHARACTER(99)  :: Ver      !< Version number of the program or module [-]
    CHARACTER(24)  :: Date      !< String containing date module was last updated [-]
  END TYPE ProgDesc
! =======================
! =========  FASTdataType  =======
  TYPE, PUBLIC :: FASTdataType
    CHARACTER(1024)  :: File      !< Name of the FAST-style binary file [-]
    CHARACTER(1024)  :: Descr      !< String describing file [-]
    INTEGER(IntKi)  :: NumChans = 0_IntKi      !< Number of output channels in this binary file (not including the time channel) [-]
    INTEGER(IntKi)  :: NumRecs = 0_IntKi      !< Number of records (rows) of data in the file [-]
    REAL(DbKi)  :: TimeStep = 0.0_R8Ki      !< Time step for evenly-spaced data in the output file (when NumRecs is not allo [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanNames      !< Strings describing the names of the channels from the binary file (including the time channel) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanUnits      !< Strings describing the units of the channels from the binary file (including the time channel) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Data      !< numeric data (rows and columns) from the binary file, including the time channel [-]
  END TYPE FASTdataType
! =======================
! =========  OutParmType  =======
  TYPE, PUBLIC :: OutParmType
    INTEGER(IntKi)  :: Indx = 0_IntKi      !< An index into AllOuts array where this channel is computed/stored [-]
    CHARACTER(ChanLen)  :: Name      !< Name of the output channel [-]
    CHARACTER(ChanLen)  :: Units      !< Units this channel is specified in [-]
    INTEGER(IntKi)  :: SignM = 0_IntKi      !< Multiplier for output channel; usually -1 (minus) or 0 (invalid channel) [-]
  END TYPE OutParmType
! =======================
! =========  FileInfoType  =======
  TYPE, PUBLIC :: FileInfoType
    INTEGER(IntKi)  :: NumLines = 0_IntKi 
    INTEGER(IntKi)  :: NumFiles = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileLine 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileIndx 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: FileList 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: Lines 
  END TYPE FileInfoType
! =======================
! =========  Quaternion  =======
  TYPE, PUBLIC :: Quaternion
    REAL(ReKi)  :: q0 = 0.0_ReKi 
    REAL(ReKi) , DIMENSION(1:3)  :: v = 0.0_ReKi 
  END TYPE Quaternion
! =======================
! =========  NWTC_RandomNumber_ParameterType  =======
  TYPE, PUBLIC :: NWTC_RandomNumber_ParameterType
    INTEGER(IntKi)  :: pRNG = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(1:3)  :: RandSeed = 0_IntKi 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RandSeedAry 
    CHARACTER(6)  :: RNG_type 
  END TYPE NWTC_RandomNumber_ParameterType
! =======================
! =========  ModVarType  =======
  TYPE, PUBLIC :: ModVarType
    character(VarNameLen)  :: Name      !<  [-]
    INTEGER(IntKi)  :: Field = 0      !<  [-]
    INTEGER(IntKi)  :: Nodes = 1      !<  [-]
    INTEGER(IntKi)  :: Num = 1      !<  [-]
    INTEGER(IntKi)  :: Flags = 0      !<  [-]
    INTEGER(IntKi)  :: DerivOrder = 0      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iLoc = 0_IntKi      !< indices in local arrays [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iUsr = 0_IntKi      !< first user defined index for variable, can be used a lower/upper bounds [-]
    INTEGER(IntKi)  :: jUsr = 0      !< second user defined index for variable [-]
    INTEGER(IntKi)  :: MeshID = 0      !< Mesh identification number [-]
    REAL(R8Ki)  :: Perturb = 0      !< perturbation amount for linearization [-]
    character(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames      !<  [-]
  END TYPE ModVarType
! =======================
! =========  VarsIdxType  =======
  TYPE, PUBLIC :: VarsIdxType
    INTEGER(IntKi)  :: FlagFilter = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nx = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nxd = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nz = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nu = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Ny = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ix      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ixd      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iz      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: idx      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iu      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iy      !<  [-]
  END TYPE VarsIdxType
! =======================
! =========  ModVarsType  =======
  TYPE, PUBLIC :: ModVarsType
    INTEGER(IntKi)  :: Nx = 0      !< Number of x values [-]
    INTEGER(IntKi)  :: Nxd = 0      !< Number of xd values [-]
    INTEGER(IntKi)  :: Nz = 0      !< Number of z values [-]
    INTEGER(IntKi)  :: Nu = 0      !< Number of u values [-]
    INTEGER(IntKi)  :: Ny = 0      !< Number of y values [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: x      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: z      !< Module state variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: u      !< Module input variable array [-]
    TYPE(ModVarType) , DIMENSION(:), ALLOCATABLE  :: y      !< Module output variable array [-]
    TYPE(VarsIdxType)  :: IdxLin      !< Variable index array [-]
    TYPE(VarsIdxType)  :: IdxSolver      !< Variable index array [-]
    TYPE(VarsIdxType)  :: IdxAeroMap      !< Variable index array [-]
  END TYPE ModVarsType
! =======================
! =========  ModJacType  =======
  TYPE, PUBLIC :: ModJacType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xd      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
  END TYPE ModJacType
! =======================
! =========  ModLinType  =======
  TYPE, PUBLIC :: ModLinType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xd      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !<  [-]
  END TYPE ModLinType
! =======================
! =========  ModDataType  =======
  TYPE, PUBLIC :: ModDataType
    character(ChanLen)  :: Abbr      !< Module name abbreviation [-]
    INTEGER(IntKi)  :: ID = 0      !< Module identification number [-]
    INTEGER(IntKi)  :: Idx = 0      !< Module index in array of modules [-]
    INTEGER(IntKi)  :: Ins = 0      !< Module instance number [-]
    REAL(R8Ki)  :: DT = 0      !< Module time step [-]
    INTEGER(IntKi)  :: SubSteps = 0      !< Module number of substeps per solver time step [-]
    INTEGER(IntKi)  :: ixg = 0_IntKi      !< starting index for continuous state values in global arrays [-]
    INTEGER(IntKi)  :: ixdg = 0_IntKi      !< starting index for discrete state values in global arrays [-]
    INTEGER(IntKi)  :: izg = 0_IntKi      !< starting index for constraint state values in global arrays [-]
    INTEGER(IntKi)  :: iug = 0_IntKi      !< starting index for input values in global arrays [-]
    INTEGER(IntKi)  :: iyg = 0_IntKi      !< starting index for output values in global arrays [-]
    TYPE(ModVarsType) , POINTER :: Vars => NULL()      !< Pointer to module variables type [-]
    TYPE(ModLinType)  :: Lin      !< Module linearization data [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: SrcMaps      !< Indices of mappings where module is the source [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DstMaps      !< Indices of mappings where module is the destination [-]
  END TYPE ModDataType
! =======================
! =========  MeshLocType  =======
  TYPE, PUBLIC :: MeshLocType
    INTEGER(IntKi)  :: Num = 0      !< Mesh number in module [-]
    INTEGER(IntKi)  :: i1 = 0      !< Mesh index 1 [-]
    INTEGER(IntKi)  :: i2 = 0      !< Mesh index 2 [-]
    INTEGER(IntKi)  :: i3 = 0      !< Mesh index 3 [-]
  END TYPE MeshLocType
! =======================
CONTAINS

subroutine NWTC_Library_CopyProgDesc(SrcProgDescData, DstProgDescData, CtrlCode, ErrStat, ErrMsg)
   type(ProgDesc), intent(in) :: SrcProgDescData
   type(ProgDesc), intent(inout) :: DstProgDescData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstProgDescData%Name = SrcProgDescData%Name
   DstProgDescData%Ver = SrcProgDescData%Ver
   DstProgDescData%Date = SrcProgDescData%Date
end subroutine

subroutine NWTC_Library_DestroyProgDesc(ProgDescData, ErrStat, ErrMsg)
   type(ProgDesc), intent(inout) :: ProgDescData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyProgDesc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackProgDesc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ProgDesc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackProgDesc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Ver)
   call RegPack(RF, InData%Date)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackProgDesc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ProgDesc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackProgDesc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ver); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Date); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFASTdataType(SrcFASTdataTypeData, DstFASTdataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FASTdataType), intent(in) :: SrcFASTdataTypeData
   type(FASTdataType), intent(inout) :: DstFASTdataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFASTdataTypeData%File = SrcFASTdataTypeData%File
   DstFASTdataTypeData%Descr = SrcFASTdataTypeData%Descr
   DstFASTdataTypeData%NumChans = SrcFASTdataTypeData%NumChans
   DstFASTdataTypeData%NumRecs = SrcFASTdataTypeData%NumRecs
   DstFASTdataTypeData%TimeStep = SrcFASTdataTypeData%TimeStep
   if (allocated(SrcFASTdataTypeData%ChanNames)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanNames, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanNames)) then
         allocate(DstFASTdataTypeData%ChanNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanNames = SrcFASTdataTypeData%ChanNames
   end if
   if (allocated(SrcFASTdataTypeData%ChanUnits)) then
      LB(1:1) = lbound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      UB(1:1) = ubound(SrcFASTdataTypeData%ChanUnits, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%ChanUnits)) then
         allocate(DstFASTdataTypeData%ChanUnits(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanUnits.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%ChanUnits = SrcFASTdataTypeData%ChanUnits
   end if
   if (allocated(SrcFASTdataTypeData%Data)) then
      LB(1:2) = lbound(SrcFASTdataTypeData%Data, kind=B8Ki)
      UB(1:2) = ubound(SrcFASTdataTypeData%Data, kind=B8Ki)
      if (.not. allocated(DstFASTdataTypeData%Data)) then
         allocate(DstFASTdataTypeData%Data(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%Data.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFASTdataTypeData%Data = SrcFASTdataTypeData%Data
   end if
end subroutine

subroutine NWTC_Library_DestroyFASTdataType(FASTdataTypeData, ErrStat, ErrMsg)
   type(FASTdataType), intent(inout) :: FASTdataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFASTdataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FASTdataTypeData%ChanNames)) then
      deallocate(FASTdataTypeData%ChanNames)
   end if
   if (allocated(FASTdataTypeData%ChanUnits)) then
      deallocate(FASTdataTypeData%ChanUnits)
   end if
   if (allocated(FASTdataTypeData%Data)) then
      deallocate(FASTdataTypeData%Data)
   end if
end subroutine

subroutine NWTC_Library_PackFASTdataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FASTdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFASTdataType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%File)
   call RegPack(RF, InData%Descr)
   call RegPack(RF, InData%NumChans)
   call RegPack(RF, InData%NumRecs)
   call RegPack(RF, InData%TimeStep)
   call RegPackAlloc(RF, InData%ChanNames)
   call RegPackAlloc(RF, InData%ChanUnits)
   call RegPackAlloc(RF, InData%Data)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFASTdataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FASTdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFASTdataType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%File); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Descr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumChans); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumRecs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TimeStep); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanNames); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChanUnits); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Data); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyOutParmType(SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg)
   type(OutParmType), intent(in) :: SrcOutParmTypeData
   type(OutParmType), intent(inout) :: DstOutParmTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutParmTypeData%Indx = SrcOutParmTypeData%Indx
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%SignM = SrcOutParmTypeData%SignM
end subroutine

subroutine NWTC_Library_DestroyOutParmType(OutParmTypeData, ErrStat, ErrMsg)
   type(OutParmType), intent(inout) :: OutParmTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackOutParmType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackOutParmType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Indx)
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Units)
   call RegPack(RF, InData%SignM)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackOutParmType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackOutParmType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Units); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SignM); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyFileInfoType(SrcFileInfoTypeData, DstFileInfoTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FileInfoType), intent(in) :: SrcFileInfoTypeData
   type(FileInfoType), intent(inout) :: DstFileInfoTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFileInfoTypeData%NumLines = SrcFileInfoTypeData%NumLines
   DstFileInfoTypeData%NumFiles = SrcFileInfoTypeData%NumFiles
   if (allocated(SrcFileInfoTypeData%FileLine)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileLine, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileLine)) then
         allocate(DstFileInfoTypeData%FileLine(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileLine.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileLine = SrcFileInfoTypeData%FileLine
   end if
   if (allocated(SrcFileInfoTypeData%FileIndx)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileIndx, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileIndx)) then
         allocate(DstFileInfoTypeData%FileIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileIndx = SrcFileInfoTypeData%FileIndx
   end if
   if (allocated(SrcFileInfoTypeData%FileList)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%FileList, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%FileList)) then
         allocate(DstFileInfoTypeData%FileList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%FileList = SrcFileInfoTypeData%FileList
   end if
   if (allocated(SrcFileInfoTypeData%Lines)) then
      LB(1:1) = lbound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      UB(1:1) = ubound(SrcFileInfoTypeData%Lines, kind=B8Ki)
      if (.not. allocated(DstFileInfoTypeData%Lines)) then
         allocate(DstFileInfoTypeData%Lines(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%Lines.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFileInfoTypeData%Lines = SrcFileInfoTypeData%Lines
   end if
end subroutine

subroutine NWTC_Library_DestroyFileInfoType(FileInfoTypeData, ErrStat, ErrMsg)
   type(FileInfoType), intent(inout) :: FileInfoTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyFileInfoType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FileInfoTypeData%FileLine)) then
      deallocate(FileInfoTypeData%FileLine)
   end if
   if (allocated(FileInfoTypeData%FileIndx)) then
      deallocate(FileInfoTypeData%FileIndx)
   end if
   if (allocated(FileInfoTypeData%FileList)) then
      deallocate(FileInfoTypeData%FileList)
   end if
   if (allocated(FileInfoTypeData%Lines)) then
      deallocate(FileInfoTypeData%Lines)
   end if
end subroutine

subroutine NWTC_Library_PackFileInfoType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FileInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFileInfoType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumLines)
   call RegPack(RF, InData%NumFiles)
   call RegPackAlloc(RF, InData%FileLine)
   call RegPackAlloc(RF, InData%FileIndx)
   call RegPackAlloc(RF, InData%FileList)
   call RegPackAlloc(RF, InData%Lines)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFileInfoType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FileInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFileInfoType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumLines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumFiles); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileLine); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FileList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Lines); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyQuaternion(SrcQuaternionData, DstQuaternionData, CtrlCode, ErrStat, ErrMsg)
   type(Quaternion), intent(in) :: SrcQuaternionData
   type(Quaternion), intent(inout) :: DstQuaternionData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstQuaternionData%q0 = SrcQuaternionData%q0
   DstQuaternionData%v = SrcQuaternionData%v
end subroutine

subroutine NWTC_Library_DestroyQuaternion(QuaternionData, ErrStat, ErrMsg)
   type(Quaternion), intent(inout) :: QuaternionData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyQuaternion'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackQuaternion(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Quaternion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackQuaternion'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%q0)
   call RegPack(RF, InData%v)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackQuaternion(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Quaternion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackQuaternion'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%q0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%v); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyNWTC_RandomNumber_ParameterType(SrcNWTC_RandomNumber_ParameterTypeData, DstNWTC_RandomNumber_ParameterTypeData, CtrlCode, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(in) :: SrcNWTC_RandomNumber_ParameterTypeData
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: DstNWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstNWTC_RandomNumber_ParameterTypeData%pRNG = SrcNWTC_RandomNumber_ParameterTypeData%pRNG
   DstNWTC_RandomNumber_ParameterTypeData%RandSeed = SrcNWTC_RandomNumber_ParameterTypeData%RandSeed
   if (allocated(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      LB(1:1) = lbound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      UB(1:1) = ubound(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry, kind=B8Ki)
      if (.not. allocated(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
         allocate(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry = SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry
   end if
   DstNWTC_RandomNumber_ParameterTypeData%RNG_type = SrcNWTC_RandomNumber_ParameterTypeData%RNG_type
end subroutine

subroutine NWTC_Library_DestroyNWTC_RandomNumber_ParameterType(NWTC_RandomNumber_ParameterTypeData, ErrStat, ErrMsg)
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: NWTC_RandomNumber_ParameterTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyNWTC_RandomNumber_ParameterType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)) then
      deallocate(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)
   end if
end subroutine

subroutine NWTC_Library_PackNWTC_RandomNumber_ParameterType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(NWTC_RandomNumber_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackNWTC_RandomNumber_ParameterType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%pRNG)
   call RegPack(RF, InData%RandSeed)
   call RegPackAlloc(RF, InData%RandSeedAry)
   call RegPack(RF, InData%RNG_type)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackNWTC_RandomNumber_ParameterType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackNWTC_RandomNumber_ParameterType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%pRNG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RandSeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RandSeedAry); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RNG_type); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarType(SrcModVarTypeData, DstModVarTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarType), intent(in) :: SrcModVarTypeData
   type(ModVarType), intent(inout) :: DstModVarTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarTypeData%Name = SrcModVarTypeData%Name
   DstModVarTypeData%Field = SrcModVarTypeData%Field
   DstModVarTypeData%Nodes = SrcModVarTypeData%Nodes
   DstModVarTypeData%Num = SrcModVarTypeData%Num
   DstModVarTypeData%Flags = SrcModVarTypeData%Flags
   DstModVarTypeData%DerivOrder = SrcModVarTypeData%DerivOrder
   DstModVarTypeData%iLoc = SrcModVarTypeData%iLoc
   DstModVarTypeData%iUsr = SrcModVarTypeData%iUsr
   DstModVarTypeData%jUsr = SrcModVarTypeData%jUsr
   DstModVarTypeData%MeshID = SrcModVarTypeData%MeshID
   DstModVarTypeData%Perturb = SrcModVarTypeData%Perturb
   if (allocated(SrcModVarTypeData%LinNames)) then
      LB(1:1) = lbound(SrcModVarTypeData%LinNames, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarTypeData%LinNames, kind=B8Ki)
      if (.not. allocated(DstModVarTypeData%LinNames)) then
         allocate(DstModVarTypeData%LinNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarTypeData%LinNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModVarTypeData%LinNames = SrcModVarTypeData%LinNames
   end if
end subroutine

subroutine NWTC_Library_DestroyModVarType(ModVarTypeData, ErrStat, ErrMsg)
   type(ModVarType), intent(inout) :: ModVarTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModVarTypeData%LinNames)) then
      deallocate(ModVarTypeData%LinNames)
   end if
end subroutine

subroutine NWTC_Library_PackModVarType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Field)
   call RegPack(RF, InData%Nodes)
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%Flags)
   call RegPack(RF, InData%DerivOrder)
   call RegPack(RF, InData%iLoc)
   call RegPack(RF, InData%iUsr)
   call RegPack(RF, InData%jUsr)
   call RegPack(RF, InData%MeshID)
   call RegPack(RF, InData%Perturb)
   call RegPackAlloc(RF, InData%LinNames)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Field); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Flags); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DerivOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUsr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%jUsr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyVarsIdxType(SrcVarsIdxTypeData, DstVarsIdxTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarsIdxType), intent(in) :: SrcVarsIdxTypeData
   type(VarsIdxType), intent(inout) :: DstVarsIdxTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyVarsIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVarsIdxTypeData%FlagFilter = SrcVarsIdxTypeData%FlagFilter
   DstVarsIdxTypeData%Nx = SrcVarsIdxTypeData%Nx
   DstVarsIdxTypeData%Nxd = SrcVarsIdxTypeData%Nxd
   DstVarsIdxTypeData%Nz = SrcVarsIdxTypeData%Nz
   DstVarsIdxTypeData%Nu = SrcVarsIdxTypeData%Nu
   DstVarsIdxTypeData%Ny = SrcVarsIdxTypeData%Ny
   if (allocated(SrcVarsIdxTypeData%ix)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%ix, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%ix, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%ix)) then
         allocate(DstVarsIdxTypeData%ix(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%ix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%ix = SrcVarsIdxTypeData%ix
   end if
   if (allocated(SrcVarsIdxTypeData%ixd)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%ixd, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%ixd, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%ixd)) then
         allocate(DstVarsIdxTypeData%ixd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%ixd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%ixd = SrcVarsIdxTypeData%ixd
   end if
   if (allocated(SrcVarsIdxTypeData%iz)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%iz, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%iz, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%iz)) then
         allocate(DstVarsIdxTypeData%iz(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%iz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%iz = SrcVarsIdxTypeData%iz
   end if
   if (allocated(SrcVarsIdxTypeData%idx)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%idx, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%idx, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%idx)) then
         allocate(DstVarsIdxTypeData%idx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%idx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%idx = SrcVarsIdxTypeData%idx
   end if
   if (allocated(SrcVarsIdxTypeData%iu)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%iu, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%iu, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%iu)) then
         allocate(DstVarsIdxTypeData%iu(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%iu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%iu = SrcVarsIdxTypeData%iu
   end if
   if (allocated(SrcVarsIdxTypeData%iy)) then
      LB(1:1) = lbound(SrcVarsIdxTypeData%iy, kind=B8Ki)
      UB(1:1) = ubound(SrcVarsIdxTypeData%iy, kind=B8Ki)
      if (.not. allocated(DstVarsIdxTypeData%iy)) then
         allocate(DstVarsIdxTypeData%iy(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarsIdxTypeData%iy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarsIdxTypeData%iy = SrcVarsIdxTypeData%iy
   end if
end subroutine

subroutine NWTC_Library_DestroyVarsIdxType(VarsIdxTypeData, ErrStat, ErrMsg)
   type(VarsIdxType), intent(inout) :: VarsIdxTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyVarsIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VarsIdxTypeData%ix)) then
      deallocate(VarsIdxTypeData%ix)
   end if
   if (allocated(VarsIdxTypeData%ixd)) then
      deallocate(VarsIdxTypeData%ixd)
   end if
   if (allocated(VarsIdxTypeData%iz)) then
      deallocate(VarsIdxTypeData%iz)
   end if
   if (allocated(VarsIdxTypeData%idx)) then
      deallocate(VarsIdxTypeData%idx)
   end if
   if (allocated(VarsIdxTypeData%iu)) then
      deallocate(VarsIdxTypeData%iu)
   end if
   if (allocated(VarsIdxTypeData%iy)) then
      deallocate(VarsIdxTypeData%iy)
   end if
end subroutine

subroutine NWTC_Library_PackVarsIdxType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarsIdxType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackVarsIdxType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%FlagFilter)
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nxd)
   call RegPack(RF, InData%Nz)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call RegPackAlloc(RF, InData%ix)
   call RegPackAlloc(RF, InData%ixd)
   call RegPackAlloc(RF, InData%iz)
   call RegPackAlloc(RF, InData%idx)
   call RegPackAlloc(RF, InData%iu)
   call RegPackAlloc(RF, InData%iy)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackVarsIdxType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarsIdxType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackVarsIdxType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%FlagFilter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nxd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ix); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ixd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%idx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iy); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModVarsType(SrcModVarsTypeData, DstModVarsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModVarsType), intent(in) :: SrcModVarsTypeData
   type(ModVarsType), intent(inout) :: DstModVarsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModVarsTypeData%Nx = SrcModVarsTypeData%Nx
   DstModVarsTypeData%Nxd = SrcModVarsTypeData%Nxd
   DstModVarsTypeData%Nz = SrcModVarsTypeData%Nz
   DstModVarsTypeData%Nu = SrcModVarsTypeData%Nu
   DstModVarsTypeData%Ny = SrcModVarsTypeData%Ny
   if (allocated(SrcModVarsTypeData%x)) then
      LB(1:1) = lbound(SrcModVarsTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%x)) then
         allocate(DstModVarsTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%x(i1), DstModVarsTypeData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%xd)) then
      LB(1:1) = lbound(SrcModVarsTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%xd)) then
         allocate(DstModVarsTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%xd(i1), DstModVarsTypeData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%z)) then
      LB(1:1) = lbound(SrcModVarsTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%z)) then
         allocate(DstModVarsTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%z(i1), DstModVarsTypeData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%u)) then
      LB(1:1) = lbound(SrcModVarsTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%u)) then
         allocate(DstModVarsTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%u(i1), DstModVarsTypeData%u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModVarsTypeData%y)) then
      LB(1:1) = lbound(SrcModVarsTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModVarsTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModVarsTypeData%y)) then
         allocate(DstModVarsTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModVarsTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModVarType(SrcModVarsTypeData%y(i1), DstModVarsTypeData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call NWTC_Library_CopyVarsIdxType(SrcModVarsTypeData%IdxLin, DstModVarsTypeData%IdxLin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyVarsIdxType(SrcModVarsTypeData%IdxSolver, DstModVarsTypeData%IdxSolver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyVarsIdxType(SrcModVarsTypeData%IdxAeroMap, DstModVarsTypeData%IdxAeroMap, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine NWTC_Library_DestroyModVarsType(ModVarsTypeData, ErrStat, ErrMsg)
   type(ModVarsType), intent(inout) :: ModVarsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModVarsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModVarsTypeData%x)) then
      LB(1:1) = lbound(ModVarsTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%x)
   end if
   if (allocated(ModVarsTypeData%xd)) then
      LB(1:1) = lbound(ModVarsTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%xd, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%xd)
   end if
   if (allocated(ModVarsTypeData%z)) then
      LB(1:1) = lbound(ModVarsTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%z)
   end if
   if (allocated(ModVarsTypeData%u)) then
      LB(1:1) = lbound(ModVarsTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%u)
   end if
   if (allocated(ModVarsTypeData%y)) then
      LB(1:1) = lbound(ModVarsTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(ModVarsTypeData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModVarType(ModVarsTypeData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModVarsTypeData%y)
   end if
   call NWTC_Library_DestroyVarsIdxType(ModVarsTypeData%IdxLin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyVarsIdxType(ModVarsTypeData%IdxSolver, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyVarsIdxType(ModVarsTypeData%IdxAeroMap, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine NWTC_Library_PackModVarsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModVarsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModVarsType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nxd)
   call RegPack(RF, InData%Nz)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x, kind=B8Ki), ubound(InData%x, kind=B8Ki))
      LB(1:1) = lbound(InData%x, kind=B8Ki)
      UB(1:1) = ubound(InData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd, kind=B8Ki), ubound(InData%xd, kind=B8Ki))
      LB(1:1) = lbound(InData%xd, kind=B8Ki)
      UB(1:1) = ubound(InData%xd, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z, kind=B8Ki), ubound(InData%z, kind=B8Ki))
      LB(1:1) = lbound(InData%z, kind=B8Ki)
      UB(1:1) = ubound(InData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(RF, 1, lbound(InData%u, kind=B8Ki), ubound(InData%u, kind=B8Ki))
      LB(1:1) = lbound(InData%u, kind=B8Ki)
      UB(1:1) = ubound(InData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%u(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y, kind=B8Ki), ubound(InData%y, kind=B8Ki))
      LB(1:1) = lbound(InData%y, kind=B8Ki)
      UB(1:1) = ubound(InData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModVarType(RF, InData%y(i1)) 
      end do
   end if
   call NWTC_Library_PackVarsIdxType(RF, InData%IdxLin) 
   call NWTC_Library_PackVarsIdxType(RF, InData%IdxSolver) 
   call NWTC_Library_PackVarsIdxType(RF, InData%IdxAeroMap) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModVarsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModVarsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModVarsType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nxd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%u(i1)) ! u 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModVarType(RF, OutData%y(i1)) ! y 
      end do
   end if
   call NWTC_Library_UnpackVarsIdxType(RF, OutData%IdxLin) ! IdxLin 
   call NWTC_Library_UnpackVarsIdxType(RF, OutData%IdxSolver) ! IdxSolver 
   call NWTC_Library_UnpackVarsIdxType(RF, OutData%IdxAeroMap) ! IdxAeroMap 
end subroutine

subroutine NWTC_Library_CopyModJacType(SrcModJacTypeData, DstModJacTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModJacType), intent(in) :: SrcModJacTypeData
   type(ModJacType), intent(inout) :: DstModJacTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModJacTypeData%x)) then
      LB(1:1) = lbound(SrcModJacTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x)) then
         allocate(DstModJacTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x = SrcModJacTypeData%x
   end if
   if (allocated(SrcModJacTypeData%dx)) then
      LB(1:1) = lbound(SrcModJacTypeData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%dx, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%dx)) then
         allocate(DstModJacTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%dx = SrcModJacTypeData%dx
   end if
   if (allocated(SrcModJacTypeData%xd)) then
      LB(1:1) = lbound(SrcModJacTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%xd)) then
         allocate(DstModJacTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%xd = SrcModJacTypeData%xd
   end if
   if (allocated(SrcModJacTypeData%z)) then
      LB(1:1) = lbound(SrcModJacTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%z)) then
         allocate(DstModJacTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%z = SrcModJacTypeData%z
   end if
   if (allocated(SrcModJacTypeData%u)) then
      LB(1:1) = lbound(SrcModJacTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%u)) then
         allocate(DstModJacTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u = SrcModJacTypeData%u
   end if
   if (allocated(SrcModJacTypeData%y)) then
      LB(1:1) = lbound(SrcModJacTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y)) then
         allocate(DstModJacTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y = SrcModJacTypeData%y
   end if
   if (allocated(SrcModJacTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%u_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%u_perturb, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%u_perturb)) then
         allocate(DstModJacTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%u_perturb = SrcModJacTypeData%u_perturb
   end if
   if (allocated(SrcModJacTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_perturb, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_perturb)) then
         allocate(DstModJacTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_perturb = SrcModJacTypeData%x_perturb
   end if
   if (allocated(SrcModJacTypeData%x_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_pos, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_pos)) then
         allocate(DstModJacTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_pos = SrcModJacTypeData%x_pos
   end if
   if (allocated(SrcModJacTypeData%x_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%x_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%x_neg, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%x_neg)) then
         allocate(DstModJacTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%x_neg = SrcModJacTypeData%x_neg
   end if
   if (allocated(SrcModJacTypeData%y_pos)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y_pos, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y_pos)) then
         allocate(DstModJacTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_pos = SrcModJacTypeData%y_pos
   end if
   if (allocated(SrcModJacTypeData%y_neg)) then
      LB(1:1) = lbound(SrcModJacTypeData%y_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModJacTypeData%y_neg, kind=B8Ki)
      if (.not. allocated(DstModJacTypeData%y_neg)) then
         allocate(DstModJacTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModJacTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModJacTypeData%y_neg = SrcModJacTypeData%y_neg
   end if
end subroutine

subroutine NWTC_Library_DestroyModJacType(ModJacTypeData, ErrStat, ErrMsg)
   type(ModJacType), intent(inout) :: ModJacTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModJacType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModJacTypeData%x)) then
      deallocate(ModJacTypeData%x)
   end if
   if (allocated(ModJacTypeData%dx)) then
      deallocate(ModJacTypeData%dx)
   end if
   if (allocated(ModJacTypeData%xd)) then
      deallocate(ModJacTypeData%xd)
   end if
   if (allocated(ModJacTypeData%z)) then
      deallocate(ModJacTypeData%z)
   end if
   if (allocated(ModJacTypeData%u)) then
      deallocate(ModJacTypeData%u)
   end if
   if (allocated(ModJacTypeData%y)) then
      deallocate(ModJacTypeData%y)
   end if
   if (allocated(ModJacTypeData%u_perturb)) then
      deallocate(ModJacTypeData%u_perturb)
   end if
   if (allocated(ModJacTypeData%x_perturb)) then
      deallocate(ModJacTypeData%x_perturb)
   end if
   if (allocated(ModJacTypeData%x_pos)) then
      deallocate(ModJacTypeData%x_pos)
   end if
   if (allocated(ModJacTypeData%x_neg)) then
      deallocate(ModJacTypeData%x_neg)
   end if
   if (allocated(ModJacTypeData%y_pos)) then
      deallocate(ModJacTypeData%y_pos)
   end if
   if (allocated(ModJacTypeData%y_neg)) then
      deallocate(ModJacTypeData%y_neg)
   end if
end subroutine

subroutine NWTC_Library_PackModJacType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModJacType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModJacType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModJacType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModJacType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModJacType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModLinType(SrcModLinTypeData, DstModLinTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModLinType), intent(in) :: SrcModLinTypeData
   type(ModLinType), intent(inout) :: DstModLinTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModLinTypeData%x)) then
      LB(1:1) = lbound(SrcModLinTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%x)) then
         allocate(DstModLinTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%x = SrcModLinTypeData%x
   end if
   if (allocated(SrcModLinTypeData%dx)) then
      LB(1:1) = lbound(SrcModLinTypeData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%dx, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dx)) then
         allocate(DstModLinTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dx = SrcModLinTypeData%dx
   end if
   if (allocated(SrcModLinTypeData%xd)) then
      LB(1:1) = lbound(SrcModLinTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%xd)) then
         allocate(DstModLinTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%xd = SrcModLinTypeData%xd
   end if
   if (allocated(SrcModLinTypeData%z)) then
      LB(1:1) = lbound(SrcModLinTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%z)) then
         allocate(DstModLinTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%z = SrcModLinTypeData%z
   end if
   if (allocated(SrcModLinTypeData%u)) then
      LB(1:1) = lbound(SrcModLinTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%u)) then
         allocate(DstModLinTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%u = SrcModLinTypeData%u
   end if
   if (allocated(SrcModLinTypeData%y)) then
      LB(1:1) = lbound(SrcModLinTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%y)) then
         allocate(DstModLinTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%y = SrcModLinTypeData%y
   end if
   if (allocated(SrcModLinTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcModLinTypeData%u_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%u_perturb, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%u_perturb)) then
         allocate(DstModLinTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%u_perturb = SrcModLinTypeData%u_perturb
   end if
   if (allocated(SrcModLinTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcModLinTypeData%x_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%x_perturb, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%x_perturb)) then
         allocate(DstModLinTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%x_perturb = SrcModLinTypeData%x_perturb
   end if
   if (allocated(SrcModLinTypeData%x_pos)) then
      LB(1:1) = lbound(SrcModLinTypeData%x_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%x_pos, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%x_pos)) then
         allocate(DstModLinTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%x_pos = SrcModLinTypeData%x_pos
   end if
   if (allocated(SrcModLinTypeData%x_neg)) then
      LB(1:1) = lbound(SrcModLinTypeData%x_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%x_neg, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%x_neg)) then
         allocate(DstModLinTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%x_neg = SrcModLinTypeData%x_neg
   end if
   if (allocated(SrcModLinTypeData%y_pos)) then
      LB(1:1) = lbound(SrcModLinTypeData%y_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%y_pos, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%y_pos)) then
         allocate(DstModLinTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%y_pos = SrcModLinTypeData%y_pos
   end if
   if (allocated(SrcModLinTypeData%y_neg)) then
      LB(1:1) = lbound(SrcModLinTypeData%y_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcModLinTypeData%y_neg, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%y_neg)) then
         allocate(DstModLinTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%y_neg = SrcModLinTypeData%y_neg
   end if
   if (allocated(SrcModLinTypeData%dYdx)) then
      LB(1:2) = lbound(SrcModLinTypeData%dYdx, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dYdx, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dYdx)) then
         allocate(DstModLinTypeData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dYdx = SrcModLinTypeData%dYdx
   end if
   if (allocated(SrcModLinTypeData%dXdx)) then
      LB(1:2) = lbound(SrcModLinTypeData%dXdx, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dXdx, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dXdx)) then
         allocate(DstModLinTypeData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dXdx = SrcModLinTypeData%dXdx
   end if
   if (allocated(SrcModLinTypeData%dYdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dYdu, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dYdu, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dYdu)) then
         allocate(DstModLinTypeData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dYdu = SrcModLinTypeData%dYdu
   end if
   if (allocated(SrcModLinTypeData%dXdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dXdu, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dXdu, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dXdu)) then
         allocate(DstModLinTypeData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dXdu = SrcModLinTypeData%dXdu
   end if
   if (allocated(SrcModLinTypeData%dUdu)) then
      LB(1:2) = lbound(SrcModLinTypeData%dUdu, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dUdu, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dUdu)) then
         allocate(DstModLinTypeData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dUdu = SrcModLinTypeData%dUdu
   end if
   if (allocated(SrcModLinTypeData%dUdy)) then
      LB(1:2) = lbound(SrcModLinTypeData%dUdy, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%dUdy, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%dUdy)) then
         allocate(DstModLinTypeData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%dUdy = SrcModLinTypeData%dUdy
   end if
   if (allocated(SrcModLinTypeData%StateRotation)) then
      LB(1:2) = lbound(SrcModLinTypeData%StateRotation, kind=B8Ki)
      UB(1:2) = ubound(SrcModLinTypeData%StateRotation, kind=B8Ki)
      if (.not. allocated(DstModLinTypeData%StateRotation)) then
         allocate(DstModLinTypeData%StateRotation(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%StateRotation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModLinTypeData%StateRotation = SrcModLinTypeData%StateRotation
   end if
end subroutine

subroutine NWTC_Library_DestroyModLinType(ModLinTypeData, ErrStat, ErrMsg)
   type(ModLinType), intent(inout) :: ModLinTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModLinTypeData%x)) then
      deallocate(ModLinTypeData%x)
   end if
   if (allocated(ModLinTypeData%dx)) then
      deallocate(ModLinTypeData%dx)
   end if
   if (allocated(ModLinTypeData%xd)) then
      deallocate(ModLinTypeData%xd)
   end if
   if (allocated(ModLinTypeData%z)) then
      deallocate(ModLinTypeData%z)
   end if
   if (allocated(ModLinTypeData%u)) then
      deallocate(ModLinTypeData%u)
   end if
   if (allocated(ModLinTypeData%y)) then
      deallocate(ModLinTypeData%y)
   end if
   if (allocated(ModLinTypeData%u_perturb)) then
      deallocate(ModLinTypeData%u_perturb)
   end if
   if (allocated(ModLinTypeData%x_perturb)) then
      deallocate(ModLinTypeData%x_perturb)
   end if
   if (allocated(ModLinTypeData%x_pos)) then
      deallocate(ModLinTypeData%x_pos)
   end if
   if (allocated(ModLinTypeData%x_neg)) then
      deallocate(ModLinTypeData%x_neg)
   end if
   if (allocated(ModLinTypeData%y_pos)) then
      deallocate(ModLinTypeData%y_pos)
   end if
   if (allocated(ModLinTypeData%y_neg)) then
      deallocate(ModLinTypeData%y_neg)
   end if
   if (allocated(ModLinTypeData%dYdx)) then
      deallocate(ModLinTypeData%dYdx)
   end if
   if (allocated(ModLinTypeData%dXdx)) then
      deallocate(ModLinTypeData%dXdx)
   end if
   if (allocated(ModLinTypeData%dYdu)) then
      deallocate(ModLinTypeData%dYdu)
   end if
   if (allocated(ModLinTypeData%dXdu)) then
      deallocate(ModLinTypeData%dXdu)
   end if
   if (allocated(ModLinTypeData%dUdu)) then
      deallocate(ModLinTypeData%dUdu)
   end if
   if (allocated(ModLinTypeData%dUdy)) then
      deallocate(ModLinTypeData%dUdy)
   end if
   if (allocated(ModLinTypeData%StateRotation)) then
      deallocate(ModLinTypeData%StateRotation)
   end if
end subroutine

subroutine NWTC_Library_PackModLinType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModLinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModLinType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%StateRotation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModLinType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModLinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModLinType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StateRotation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyModDataType(SrcModDataTypeData, DstModDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModDataType), intent(in) :: SrcModDataTypeData
   type(ModDataType), intent(inout) :: DstModDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModDataTypeData%Abbr = SrcModDataTypeData%Abbr
   DstModDataTypeData%ID = SrcModDataTypeData%ID
   DstModDataTypeData%Idx = SrcModDataTypeData%Idx
   DstModDataTypeData%Ins = SrcModDataTypeData%Ins
   DstModDataTypeData%DT = SrcModDataTypeData%DT
   DstModDataTypeData%SubSteps = SrcModDataTypeData%SubSteps
   DstModDataTypeData%ixg = SrcModDataTypeData%ixg
   DstModDataTypeData%ixdg = SrcModDataTypeData%ixdg
   DstModDataTypeData%izg = SrcModDataTypeData%izg
   DstModDataTypeData%iug = SrcModDataTypeData%iug
   DstModDataTypeData%iyg = SrcModDataTypeData%iyg
   DstModDataTypeData%Vars => SrcModDataTypeData%Vars
   call NWTC_Library_CopyModLinType(SrcModDataTypeData%Lin, DstModDataTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcModDataTypeData%SrcMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%SrcMaps)) then
         allocate(DstModDataTypeData%SrcMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%SrcMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%SrcMaps = SrcModDataTypeData%SrcMaps
   end if
   if (allocated(SrcModDataTypeData%DstMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%DstMaps)) then
         allocate(DstModDataTypeData%DstMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%DstMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%DstMaps = SrcModDataTypeData%DstMaps
   end if
end subroutine

subroutine NWTC_Library_DestroyModDataType(ModDataTypeData, ErrStat, ErrMsg)
   type(ModDataType), intent(inout) :: ModDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   nullify(ModDataTypeData%Vars)
   call NWTC_Library_DestroyModLinType(ModDataTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModDataTypeData%SrcMaps)) then
      deallocate(ModDataTypeData%SrcMaps)
   end if
   if (allocated(ModDataTypeData%DstMaps)) then
      deallocate(ModDataTypeData%DstMaps)
   end if
end subroutine

subroutine NWTC_Library_PackModDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackModDataType'
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Abbr)
   call RegPack(RF, InData%ID)
   call RegPack(RF, InData%Idx)
   call RegPack(RF, InData%Ins)
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%SubSteps)
   call RegPack(RF, InData%ixg)
   call RegPack(RF, InData%ixdg)
   call RegPack(RF, InData%izg)
   call RegPack(RF, InData%iug)
   call RegPack(RF, InData%iyg)
   call RegPack(RF, associated(InData%Vars))
   if (associated(InData%Vars)) then
      call RegPackPointer(RF, c_loc(InData%Vars), PtrInIndex)
      if (.not. PtrInIndex) then
         call NWTC_Library_PackModVarsType(RF, InData%Vars) 
      end if
   end if
   call NWTC_Library_PackModLinType(RF, InData%Lin) 
   call RegPackAlloc(RF, InData%SrcMaps)
   call RegPackAlloc(RF, InData%DstMaps)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackModDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackModDataType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Abbr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Idx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ins); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SubSteps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ixg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ixdg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%izg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iug); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iyg); if (RegCheckErr(RF, RoutineName)) return
   if (associated(OutData%Vars)) deallocate(OutData%Vars)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(RF, Ptr, PtrIdx); if (RegCheckErr(RF, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vars)
      else
         allocate(OutData%Vars,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vars.', RF%ErrStat, RF%ErrMsg, RoutineName)
            return
         end if
         RF%Pointers(PtrIdx) = c_loc(OutData%Vars)
         call NWTC_Library_UnpackModVarsType(RF, OutData%Vars) ! Vars 
      end if
   else
      OutData%Vars => null()
   end if
   call NWTC_Library_UnpackModLinType(RF, OutData%Lin) ! Lin 
   call RegUnpackAlloc(RF, OutData%SrcMaps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DstMaps); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_CopyMeshLocType(SrcMeshLocTypeData, DstMeshLocTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MeshLocType), intent(in) :: SrcMeshLocTypeData
   type(MeshLocType), intent(inout) :: DstMeshLocTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_CopyMeshLocType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMeshLocTypeData%Num = SrcMeshLocTypeData%Num
   DstMeshLocTypeData%i1 = SrcMeshLocTypeData%i1
   DstMeshLocTypeData%i2 = SrcMeshLocTypeData%i2
   DstMeshLocTypeData%i3 = SrcMeshLocTypeData%i3
end subroutine

subroutine NWTC_Library_DestroyMeshLocType(MeshLocTypeData, ErrStat, ErrMsg)
   type(MeshLocType), intent(inout) :: MeshLocTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'NWTC_Library_DestroyMeshLocType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine NWTC_Library_PackMeshLocType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshLocType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackMeshLocType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Num)
   call RegPack(RF, InData%i1)
   call RegPack(RF, InData%i2)
   call RegPack(RF, InData%i3)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackMeshLocType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshLocType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackMeshLocType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Num); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i3); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE NWTC_Library_Types
!ENDOFREGISTRYGENERATEDFILE
