!STARTOFREGISTRYGENERATEDFILE 'Morison_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Morison_Types
!.................................................................................................................................
! This file is part of Morison.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Morison. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Morison_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SeaSt_WaveField_Types
USE NWTC_Library
IMPLICIT NONE
! =========  Morison_JointType  =======
  TYPE, PUBLIC :: Morison_JointType
    INTEGER(IntKi)  :: JointID = 0_IntKi      !< User-specified integer ID for the given joint [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Position = 0.0_ReKi      !< Undisplaced location of the joint in the platform coordinate system [m]
    INTEGER(IntKi)  :: JointAxID = 0_IntKi      !< Axial ID (found in the user-supplied Axial Coefficients Table) for this joint: used to determine axial coefs [-]
    INTEGER(IntKi)  :: JointAxIDIndx = 0_IntKi      !< The index into the Axial Coefs arrays corresponding to the above Axial ID [-]
    INTEGER(IntKi)  :: JointOvrlp = 0_IntKi      !< Joint overlap code [Unused [-]
    INTEGER(IntKi)  :: NConnections = 0_IntKi      !< Number of members connecting to this joint [-]
    INTEGER(IntKi) , DIMENSION(1:50)  :: ConnectionList = 0_IntKi      !< List of Members connected to this joint.  The member index is what is stored, not the Member ID [-]
  END TYPE Morison_JointType
! =======================
! =========  Morison_MemberPropType  =======
  TYPE, PUBLIC :: Morison_MemberPropType
    INTEGER(IntKi)  :: PropSetID = 0_IntKi      !< User-specified integer ID for this group of properties [-]
    REAL(ReKi)  :: PropD = 0.0_ReKi      !< Diameter [m]
    REAL(ReKi)  :: PropThck = 0.0_ReKi      !< Wall thickness [m]
  END TYPE Morison_MemberPropType
! =======================
! =========  Morison_FilledGroupType  =======
  TYPE, PUBLIC :: Morison_FilledGroupType
    INTEGER(IntKi)  :: FillNumM = 0_IntKi      !< Number of members in the Fill Group [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FillMList      !< List of Member IDs for the members in this fill group [-]
    REAL(ReKi)  :: FillFSLoc = 0.0_ReKi      !< The free-surface location (in Z) for this fill group [m]
    CHARACTER(80)  :: FillDensChr      !< String version of the Fill density [can be DEFAULT which sets the fill density to WtrDens] [kg/m^3]
    REAL(ReKi)  :: FillDens = 0.0_ReKi      !< Numerical fill density [kg/m^3]
  END TYPE Morison_FilledGroupType
! =======================
! =========  Morison_CoefDpths  =======
  TYPE, PUBLIC :: Morison_CoefDpths
    REAL(ReKi)  :: Dpth = 0.0_ReKi      !< Depth location for these depth-based hydrodynamic coefs [m]
    REAL(ReKi)  :: DpthCd = 0.0_ReKi      !< Depth-based drag coef [-]
    REAL(ReKi)  :: DpthCdMG = 0.0_ReKi      !< Depth-based drag coef for marine growth [-]
    REAL(ReKi)  :: DpthCa = 0.0_ReKi      !< Depth-based Ca [-]
    REAL(ReKi)  :: DpthCaMG = 0.0_ReKi      !< Depth-based Ca for marine growth [-]
    REAL(ReKi)  :: DpthCp = 0.0_ReKi      !< Depth-based Cp [-]
    REAL(ReKi)  :: DpthCpMG = 0.0_ReKi      !< Depth-based Cp for marine growth [-]
    REAL(ReKi)  :: DpthAxCd = 0.0_ReKi      !< Depth-based Axial Cd [-]
    REAL(ReKi)  :: DpthAxCdMG = 0.0_ReKi      !< Depth-based Axial Cd for marine growth [-]
    REAL(ReKi)  :: DpthAxCa = 0.0_ReKi      !< Depth-based Axial Ca [-]
    REAL(ReKi)  :: DpthAxCaMG = 0.0_ReKi      !< Depth-based Axial Ca for marine growth [-]
    REAL(ReKi)  :: DpthAxCp = 0.0_ReKi      !< Depth-based Axial Cp [-]
    REAL(ReKi)  :: DpthAxCpMG = 0.0_ReKi      !< Depth-based Axial Cp for marine growth [-]
    REAL(ReKi)  :: DpthCb = 0.0_ReKi      !< Simple model hydrostatic/buoyancy load coefficient [-]
    REAL(ReKi)  :: DpthCbMg = 0.0_ReKi      !< Simple model hydrostatic/buoyancy load coefficient for marine growth [-]
    LOGICAL  :: DpthMCF = .false.      !< Flag T/F for whether the member is modeled with the MacCamy-Fuchs diffraction model [-]
  END TYPE Morison_CoefDpths
! =======================
! =========  Morison_AxialCoefType  =======
  TYPE, PUBLIC :: Morison_AxialCoefType
    INTEGER(IntKi)  :: AxCoefID = 0_IntKi      !< User-supplied integer ID for this set of Axial coefs [-]
    REAL(ReKi)  :: AxCd = 0.0_ReKi      !< Axial Cd [-]
    REAL(ReKi)  :: AxCa = 0.0_ReKi      !< Axial Ca [-]
    REAL(ReKi)  :: AxCp = 0.0_ReKi      !< Axial Cp [-]
    REAL(ReKi)  :: AxVnCOff = 0.0_ReKi      !< High-pass cut-off frequency for normal velocity when computing axial drag force [-]
    REAL(ReKi)  :: AxFDLoFSc = 0.0_ReKi      !< Scaling factor for low frequency axial drag force [-]
    INTEGER(IntKi)  :: AxFDMod = 0_IntKi      !< Switch for the axial drag formulation {0: original formulation, 1: Away from member only} [-]
  END TYPE Morison_AxialCoefType
! =======================
! =========  Morison_MemberInputType  =======
  TYPE, PUBLIC :: Morison_MemberInputType
    INTEGER(IntKi)  :: MemberID = 0_IntKi      !< User-supplied integer ID for this member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIndx      !< Index of each of the member's nodes in the master node list [-]
    INTEGER(IntKi)  :: MJointID1 = 0_IntKi      !< Joint ID for start of member [-]
    INTEGER(IntKi)  :: MJointID2 = 0_IntKi      !< Joint ID for end of member [-]
    INTEGER(IntKi)  :: MJointID1Indx = 0_IntKi      !< Index into the joint table for the start of this member [-]
    INTEGER(IntKi)  :: MJointID2Indx = 0_IntKi      !< Index into the joint table for the end of this member [-]
    INTEGER(IntKi)  :: MPropSetID1 = 0_IntKi      !< Property set ID for the start of this member [-]
    INTEGER(IntKi)  :: MPropSetID2 = 0_IntKi      !< Property set ID for the end of this member [-]
    INTEGER(IntKi)  :: MPropSetID1Indx = 0_IntKi      !< Index into the Property table for the start of this member [-]
    INTEGER(IntKi)  :: MPropSetID2Indx = 0_IntKi      !< Index into the Property table for the end of this member [-]
    REAL(ReKi)  :: MDivSize = 0.0_ReKi      !< User-specified desired member discretization size for the final element [m]
    INTEGER(IntKi)  :: MCoefMod = 0_IntKi      !< Which coef. model is being used for this member [1=simple, 2=depth-based, 3=member-based] [-]
    INTEGER(IntKi)  :: MHstLMod = 0_IntKi      !< Which hydrostatic model is being used for this member [1=column-type, 2=ship-type] [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx = 0_IntKi      !< Index into the appropriate coefs table for this member's properties [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx = 0_IntKi      !< Index into the filled group table if this is a filled member [-]
    LOGICAL  :: PropPot = .false.      !< Flag T/F for whether the member is modeled with potential flow theory [-]
    LOGICAL  :: PropMCF = .false.      !< Flag T/F for whether the member is modeled with the MacCamy-Fuchs diffraction model [-]
    INTEGER(IntKi)  :: NElements = 0_IntKi      !< number of elements in this member [-]
    REAL(ReKi)  :: RefLength = 0.0_ReKi      !< the reference total length for this member [m]
    REAL(ReKi)  :: dl = 0.0_ReKi      !< the reference element length for this member (may be less than MDivSize to achieve uniform element lengths) [m]
  END TYPE Morison_MemberInputType
! =======================
! =========  Morison_NodeType  =======
  TYPE, PUBLIC :: Morison_NodeType
    INTEGER(IntKi)  :: JointIndx = 0_IntKi      !< Joint index from the user joint table that this node corresponds to.  If the software created this node, index is set to -1 [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Position = 0.0_ReKi      !< Position of the node in global coordinates [m]
    INTEGER(IntKi)  :: JointOvrlp = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: JointAxIDIndx = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NConnections = 0_IntKi      !< Number of elements connecting to this node [-]
    INTEGER(IntKi) , DIMENSION(1:50)  :: ConnectionList = 0_IntKi      !< Indices of all the members connected to this node (positive if end 1, negative if end 2) [-]
    REAL(ReKi)  :: JAxCd = 0.0_ReKi      !< Nodal lumped (joint) axial Cd [-]
    REAL(ReKi)  :: JAxCa = 0.0_ReKi      !< Nodal lumped (joint) axial Cp [-]
    REAL(ReKi)  :: JAxCp = 0.0_ReKi      !< Nodal lumped (joint) axial Ca [-]
    REAL(ReKi)  :: JAxVnCOff = 0.0_ReKi      !< High-pass cut-off frequency for normal velocity when computing axial drag force [-]
    REAL(ReKi)  :: JAxFDLoFSc = 0.0_ReKi      !< Scaling factor for low frequency axial drag force [-]
    INTEGER(IntKi)  :: JAxFDMod = 0_IntKi      !< Switch for the axial drag formulation {0: original formulation, 1: Away from member only} [-]
    REAL(ReKi)  :: FillDensity = 0.0_ReKi      !< Fill fluid density [kg/m^3]
    REAL(ReKi)  :: tMG = 0.0_ReKi      !< Nodal thickness with marine growth  [m]
    REAL(ReKi)  :: MGdensity = 0.0_ReKi      !< Nodal density of marine growth [kg/m^3]
  END TYPE Morison_NodeType
! =======================
! =========  Morison_MemberType  =======
  TYPE, PUBLIC :: Morison_MemberType
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIndx      !< Index of each of the member's nodes in the master node list [-]
    INTEGER(IntKi)  :: MemberID = 0_IntKi      !< User-supplied integer ID for this member [-]
    INTEGER(IntKi)  :: NElements = 0_IntKi      !< number of elements in this member [-]
    REAL(ReKi)  :: RefLength = 0.0_ReKi      !< the reference total length for this member [m]
    REAL(ReKi)  :: cosPhi_ref = 0.0_ReKi      !< the reference cosine of the inclination angle of the member [-]
    REAL(ReKi)  :: dl = 0.0_ReKi      !< the reference element length for this member (may be less than MDivSize to achieve uniform element lengths) [m]
    REAL(ReKi) , DIMENSION(1:3)  :: k = 0.0_ReKi      !< unit vector of the member's orientation (may be changed to per-element once additional flexibility is accounted for in HydroDyn) [m]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: kkt = 0.0_ReKi      !< matrix of matmul(k_hat, transpose(k_hat) [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Ak = 0.0_ReKi      !< matrix of I - kkt [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: R      !< outer member radius at each node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RMG      !< radius at each node including marine growth [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RMGB      !< radius at each node including marine growth scaled by sqrt(Cb) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Rin      !< inner member radius at node, equivalent to radius of water ballast at this node if filled [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: tMG      !< Nodal thickness with marine growth (of member at node location) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MGdensity      !< Nodal density of marine growth [kg/m^3]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dRdl_mg      !< taper dr/dl of outer surface including marine growth of each element [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dRdl_mg_b      !< taper dr/dl of outer surface including marine growth of each element with scaling of sqrt(Cb) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dRdl_in      !< taper dr/dl of interior surface of each element [-]
    REAL(ReKi)  :: Vinner = 0.0_ReKi      !< Member volume without marine growth [m^3]
    REAL(ReKi)  :: Vouter = 0.0_ReKi      !< Member volume including marine growth [m^3]
    REAL(ReKi)  :: Vballast = 0.0_ReKi      !< Member ballast volume [m^3]
    REAL(ReKi)  :: Vsubmerged = 0.0_ReKi      !< Submerged volume corresponding to portion of Member in the water [m^3]
    REAL(ReKi)  :: l_fill = 0.0_ReKi      !< fill length along member axis from start node 1 [m]
    REAL(ReKi)  :: h_fill = 0.0_ReKi      !< fill length of partially flooded element [m]
    REAL(ReKi)  :: z_overfill = 0.0_ReKi      !< if member is fully filled, the head height of the fill pressure at the end node N+1. Zero if member is partially filled. [m]
    REAL(ReKi)  :: h_floor = 0.0_ReKi      !< the distance from the node to the seabed along the member axis (negative value) [m]
    INTEGER(IntKi)  :: i_floor = 0_IntKi      !< the number of the element that pierces the seabed (zero if the member doesn't pierce it) [-]
    LOGICAL  :: doEndBuoyancy = .false.      !< compute the end plate effect for the hightest node of this member [-]
    INTEGER(IntKi)  :: memfloodstatus = 0_IntKi      !< Member-level flooded status for each elemen: 0 unflooded or fully below seabed, 2 partially flooded, 1 fully flooded  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: floodstatus      !< flooded status for each element: 0 unflooded or fully below seabed, 1 fully flooded, 2 partially flooded [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: alpha      !< relative volume centroid of each element including marine growth, from node i to node i+1 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: alpha_fb      !< relative volume centroid of each element's flooded ballast, from node i to node i+1 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: alpha_fb_star      !< load distribution factor for each element after adjusting alpha_fb for node reference depths [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cd      !< Member Cd at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Ca      !< Member Ca at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cp      !< Member Cp at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AxCd      !< Member axial Cd at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AxCa      !< Member axial Ca at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AxCp      !< Member axial Cp at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cb      !< Member Cb at each node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: m_fb_l      !< mass of flooded ballast in lower portion of each element [kg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: m_fb_u      !< mass of flooded ballast in upper portion of each element [kg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: h_cfb_l      !< distance to flooded ballast centroid from node point in lower portion of each element [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: h_cfb_u      !< distance to flooded ballast centroid from node point in upper portion of each element [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_lfb_l      !< axial moment of inertia of flooded ballast in lower portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_lfb_u      !< axial moment of inertia of flooded ballast in upper portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_rfb_l      !< radial moment of inertia of flooded ballast in lower portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_rfb_u      !< radial moment of inertia of flooded ballast in upper portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: m_mg_l      !< mass of marine growth in lower portion of each element [kg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: m_mg_u      !< mass of marine growth in upper portion of each element [kg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: h_cmg_l      !< distance to marine growth centroid from node point in lower portion of each element [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: h_cmg_u      !< distance to marine growth centroid from node point in upper portion of each element [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_lmg_l      !< axial moment of inertia of marine growth in lower portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_lmg_u      !< axial moment of inertia of marine growth in upper portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_rmg_l      !< radial moment of inertia of marine growth in lower portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: I_rmg_u      !< radial moment of inertia of flooded ballast in upper portion of each element [kg-m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cfl_fb      !< axial force constant due to flooded ballast, for each element [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cfr_fb      !< radial force constant due to flooded ballast, for each element [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CM0_fb      !< moment constant due to flooded ballast, for each element about lower node [Nm]
    REAL(ReKi)  :: MGvolume = 0.0_ReKi      !< Volume of marine growth material for this member/element [m^3]
    REAL(ReKi)  :: MDivSize = 0.0_ReKi      !< User-requested final element length (actual length may vary from this request) [m]
    INTEGER(IntKi)  :: MCoefMod = 0_IntKi      !< Coefs model for member: 1 = simple, 2 =depth, 3 = member-based  [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx = 0_IntKi      !< If MCoefMod=3, then this is the index for the member's coefs in the master Member Coefs Table [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx = 0_IntKi      !< If this member is part of a fill group, this is the index into the master fill group table, if not = -1 [-]
    INTEGER(IntKi)  :: MHstLMod = 0_IntKi      !< Hydrostatic model for member [1=column-type, 2=ship-type] [-]
    REAL(ReKi)  :: FillFSLoc = 0.0_ReKi      !< Z-location of the filled free-surface [m]
    REAL(ReKi)  :: FillDens = 0.0_ReKi      !< Filled fluid density [kg/m^3]
    LOGICAL  :: PropPot = .false.      !< Is this element/member modeled with potential flow theory T/F [-]
    LOGICAL  :: PropMCF = .false.      !< Flag T/F for whether the member is modeled with the MacCamy-Fuchs diffraction model [-]
    LOGICAL  :: Flipped = .false.      !< Was the member flipped in a reordering event?  Need to know this to get the correct normal vector to the ends [-]
  END TYPE Morison_MemberType
! =======================
! =========  Morison_MemberLoads  =======
  TYPE, PUBLIC :: Morison_MemberLoads
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_D      !< Member-based (side-effects) Nodal viscous drag loads at time t [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_I      !< Member-based (side-effects) Nodal inertial loads at time t [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_A      !< Member-based (side-effects) Nodal added mass loads at time t [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_B      !< Member-based (side-effects) Nodal buoyancy loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_BF      !< Member-based (side-effects) Nodal flooded ballast weight/buoyancy loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_If      !< Member-based (side-effects) Nodal flooded ballast inertia loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_WMG      !< Member-based (side-effects) Nodal marine growth weight loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_IMG      !< Member-based (side-effects) Nodal marine growth inertia loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FV      !< Fluid velocity at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FA      !< Fluid acceleration at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_DP      !< Lumped dynamic pressure loads at time t, which may not correspond to the WaveTime array of times [-]
  END TYPE Morison_MemberLoads
! =======================
! =========  Morison_CoefMembers  =======
  TYPE, PUBLIC :: Morison_CoefMembers
    INTEGER(IntKi)  :: MemberID = 0_IntKi      !< User-specified integer id for the Member-based coefs [-]
    REAL(ReKi)  :: MemberCd1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCd2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCdMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCdMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCa1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCa2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCaMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCaMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCp1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCp2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCpMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCpMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCd1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCd2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCdMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCdMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCa1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCa2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCaMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCaMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCp1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCp2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCpMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberAxCpMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCb1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCb2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCbMG1 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    REAL(ReKi)  :: MemberCbMG2 = 0.0_ReKi      !< Member-based coefs, see above descriptions for meanings (1 = start, 2=end) [-]
    LOGICAL  :: MemberMCF = .false.      !< Flag T/F for whether the member is modeled with the MacCamy-Fuchs diffraction model [-]
  END TYPE Morison_CoefMembers
! =======================
! =========  Morison_MGDepthsType  =======
  TYPE, PUBLIC :: Morison_MGDepthsType
    REAL(ReKi)  :: MGDpth = 0.0_ReKi      !< Marine growth depth location for these properties [m]
    REAL(ReKi)  :: MGThck = 0.0_ReKi      !< Marine growth thickness [m]
    REAL(ReKi)  :: MGDens = 0.0_ReKi      !< Marine growth density [kg/m^3]
  END TYPE Morison_MGDepthsType
! =======================
! =========  Morison_MOutput  =======
  TYPE, PUBLIC :: Morison_MOutput
    INTEGER(IntKi)  :: MemberID = 0_IntKi      !< Member ID for requested output [-]
    INTEGER(IntKi)  :: NOutLoc = 0_IntKi      !< The number of requested output locations [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NodeLocs      !< Normalized locations along user-specified member for the outputs [-]
    INTEGER(IntKi)  :: MemberIDIndx = 0_IntKi      !< Index for member in the master list [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MeshIndx1      !< Index of node in Mesh for the start of the member element [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MeshIndx2      !< Index of node in Mesh for the end of the member element [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MemberIndx1      !< Index of Member nodes for the start of the member element [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MemberIndx2      !< Index of Member nodes for the end of the member element [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: s      !< Linear interpolation factor between node1 and node2 for the output location [-]
  END TYPE Morison_MOutput
! =======================
! =========  Morison_JOutput  =======
  TYPE, PUBLIC :: Morison_JOutput
    INTEGER(IntKi)  :: JointID = 0_IntKi      !< Joint ID for the requested output [-]
    INTEGER(IntKi)  :: JointIDIndx = 0_IntKi      !< Joint index in the master list [-]
  END TYPE Morison_JOutput
! =======================
! =========  Morison_InitInputType  =======
  TYPE, PUBLIC :: Morison_InitInputType
    REAL(ReKi)  :: Gravity = 0.0_ReKi      !< Gravity (scalar, positive-valued) [m/s^2]
    INTEGER(IntKi)  :: WaveDisp = 0_IntKi      !< Method of computing Wave Kinematics. (0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position)  [-]
    INTEGER(IntKi)  :: AMMod = 0_IntKi      !< Method of computing distributed added-mass force. (0: Only and always on nodes below SWL at the undisplaced position. 1: Up to the instantaneous free surface) [overwrite to 0 when WaveMod = 0 or 6 or when WaveStMod = 0 in SeaState] [-]
    INTEGER(IntKi)  :: NJoints = 0_IntKi      !< Number of user-specified joints [-]
    INTEGER(IntKi)  :: NNodes = 0_IntKi      !< Total number of nodes in the final software model [-]
    TYPE(Morison_JointType) , DIMENSION(:), ALLOCATABLE  :: InpJoints      !< Array of user-specified joints [-]
    TYPE(Morison_NodeType) , DIMENSION(:), ALLOCATABLE  :: Nodes      !< Array of simulation node (some correspond to user-specified joints, others are created by software) [-]
    INTEGER(IntKi)  :: NAxCoefs = 0_IntKi      !< Number of axial Coefs entries in input file table [-]
    TYPE(Morison_AxialCoefType) , DIMENSION(:), ALLOCATABLE  :: AxialCoefs      !< List of axial coefs [-]
    INTEGER(IntKi)  :: NPropSets = 0_IntKi      !< Number of member property sets [-]
    TYPE(Morison_MemberPropType) , DIMENSION(:), ALLOCATABLE  :: MPropSets      !< List of Member property sets [-]
    REAL(ReKi)  :: SimplCd = 0.0_ReKi      !< Simple model drag coef [-]
    REAL(ReKi)  :: SimplCdMG = 0.0_ReKi      !< Simple model drag coef for marine growth [-]
    REAL(ReKi)  :: SimplCa = 0.0_ReKi      !< Simple model Ca [-]
    REAL(ReKi)  :: SimplCaMG = 0.0_ReKi      !< Simple model Ca for marine growth [-]
    REAL(ReKi)  :: SimplCp = 0.0_ReKi      !< Simple model Cp [-]
    REAL(ReKi)  :: SimplCpMG = 0.0_ReKi      !< Simple model Cp for marine growth [-]
    REAL(ReKi)  :: SimplAxCd = 0.0_ReKi      !< Simple model Axial Cd [-]
    REAL(ReKi)  :: SimplAxCdMG = 0.0_ReKi      !< Simple model Axial Cd for marine growth [-]
    REAL(ReKi)  :: SimplAxCa = 0.0_ReKi      !< Simple model Axial Ca [-]
    REAL(ReKi)  :: SimplAxCaMG = 0.0_ReKi      !< Simple model Axial Ca for marine growth [-]
    REAL(ReKi)  :: SimplAxCp = 0.0_ReKi      !< Simple model Axial Cp [-]
    REAL(ReKi)  :: SimplAxCpMG = 0.0_ReKi      !< Simple model Axial Cp for marine growth [-]
    REAL(ReKi)  :: SimplCb = 0.0_ReKi      !< Simple model hydrostatic/buoyancy load coefficient [-]
    REAL(ReKi)  :: SimplCbMg = 0.0_ReKi      !< Simple model hydrostatic/buoyancy load coefficient for marine growth [-]
    LOGICAL  :: SimplMCF = .false.      !< Flag T/F for whether the member is modeled with the MacCamy-Fuchs diffraction model [-]
    INTEGER(IntKi)  :: NCoefDpth = 0_IntKi      !<  [-]
    TYPE(Morison_CoefDpths) , DIMENSION(:), ALLOCATABLE  :: CoefDpths      !<  [-]
    INTEGER(IntKi)  :: NCoefMembers = 0_IntKi      !<  [-]
    TYPE(Morison_CoefMembers) , DIMENSION(:), ALLOCATABLE  :: CoefMembers      !<  [-]
    INTEGER(IntKi)  :: NMembers = 0_IntKi      !< Number of user-specified members in the input file [-]
    TYPE(Morison_MemberInputType) , DIMENSION(:), ALLOCATABLE  :: InpMembers      !< Array of user-specified members [-]
    INTEGER(IntKi)  :: NFillGroups = 0_IntKi      !<  [-]
    TYPE(Morison_FilledGroupType) , DIMENSION(:), ALLOCATABLE  :: FilledGroups      !<  [-]
    INTEGER(IntKi)  :: NMGDepths = 0_IntKi      !<  [-]
    TYPE(Morison_MGDepthsType) , DIMENSION(:), ALLOCATABLE  :: MGDepths      !<  [-]
    REAL(ReKi)  :: MGTop = 0.0_ReKi      !<  [-]
    REAL(ReKi)  :: MGBottom = 0.0_ReKi      !<  [-]
    INTEGER(IntKi)  :: NMOutputs = 0_IntKi      !<  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !<  [-]
    INTEGER(IntKi)  :: NJOutputs = 0_IntKi      !<  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !<  [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< This list size needs to be the maximum # of possible outputs because of the use of ReadAry(). Use MaxMrsnOutputs [-]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: UnSum = 0_IntKi      !<  [-]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< Pointer to SeaState wave field [-]
    LOGICAL  :: VisMeshes = .false.      !< Output visualization meshes [-]
    INTEGER(IntKi)  :: PtfmYMod = 0_IntKi      !< Large yaw model [-]
  END TYPE Morison_InitInputType
! =======================
! =========  Morison_InitOutputType  =======
  TYPE, PUBLIC :: Morison_InitOutputType
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: MorisonVisRad      !< radius of node (for FAST visualization) [(m)]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< User-requested Output channel names [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !<  [-]
  END TYPE Morison_InitOutputType
! =======================
! =========  Morison_ContinuousStateType  =======
  TYPE, PUBLIC :: Morison_ContinuousStateType
    REAL(SiKi)  :: DummyContState = 0.0_R4Ki      !< Remove this variable if you have continuous states [-]
  END TYPE Morison_ContinuousStateType
! =======================
! =========  Morison_DiscreteStateType  =======
  TYPE, PUBLIC :: Morison_DiscreteStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: V_rel_n_FiltStat      !< State of the high-pass filter for the joint relative normal velocity [m/s]
  END TYPE Morison_DiscreteStateType
! =======================
! =========  Morison_ConstraintStateType  =======
  TYPE, PUBLIC :: Morison_ConstraintStateType
    REAL(SiKi)  :: DummyConstrState = 0.0_R4Ki      !< Remove this variable if you have constraint states [-]
  END TYPE Morison_ConstraintStateType
! =======================
! =========  Morison_OtherStateType  =======
  TYPE, PUBLIC :: Morison_OtherStateType
    INTEGER(IntKi)  :: DummyOtherState = 0_IntKi      !< Remove this variable if you have other states [-]
  END TYPE Morison_OtherStateType
! =======================
! =========  Morison_MiscVarType  =======
  TYPE, PUBLIC :: Morison_MiscVarType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DispNodePosHdn      !< Instantaneous displaced position of the line element nodes at time t for hydrodynamic load calculation [(m)]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DispNodePosHst      !< Instantaneous displaced position of the line element nodes at time t for hydrostatic and other load calcuation [(m)]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FV      !< Fluid velocity at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FA      !< Fluid acceleration at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAMCF      !< Fluid acceleration at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FDynP      !< Fluid dynamic pressure at line element node at time t, which may not correspond to the WaveTime array of times [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev      !< Total wave elevation [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev1      !< First order wave elevation [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev2      !< Second order wave elevation [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: vrel      !< velocity of structural node relative to the water [m/s^2]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nodeInWater      !< Logical flag indicating if the node at the given time step is in the water, and hence needs to have hydrodynamic forces calculated [-]
    TYPE(Morison_MemberLoads) , DIMENSION(:), ALLOCATABLE  :: memberLoads      !< Array (NMembers long) of member-based side-effects load contributions [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_B_End      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_D_End      !< Lumped viscous drag loads at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_I_End      !< Lumped intertia loads at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_IMG_End      !< Joint marine growth intertia loads at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_A_End      !< Lumped added mass loads at time t, which may not correspond to the WaveTime array of times [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_BF_End      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: V_rel_n      !< Normal relative flow velocity at joints [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: V_rel_n_HiPass      !< High-pass filtered normal relative flow velocity at joints [m/s]
    TYPE(MeshMapType)  :: VisMeshMap      !< Mesh mapping for visualization mesh [-]
    TYPE(SeaSt_WaveField_MiscVarType)  :: WaveField_m      !< misc var information from the SeaState Interpolation module [-]
  END TYPE Morison_MiscVarType
! =======================
! =========  Morison_ParameterType  =======
  TYPE, PUBLIC :: Morison_ParameterType
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< Time step for continuous state integration & discrete state update [(sec)]
    REAL(ReKi)  :: Gravity = 0.0_ReKi      !< Gravity (scalar, positive-valued) [m/s^2]
    INTEGER(IntKi)  :: WaveDisp = 0_IntKi      !< Method of computing Wave Kinematics. (0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position)  [-]
    INTEGER(IntKi)  :: AMMod = 0_IntKi      !< Method of computing distributed added-mass force. (0: Only and always on nodes below SWL at the undisplaced position. 1: Up to the instantaneous free surface) [overwrite to 0 when WaveMod = 0 or 6 or when WaveStMod = 0 in SeaState] [-]
    INTEGER(IntKi)  :: NMembers = 0_IntKi      !< number of members [-]
    TYPE(Morison_MemberType) , DIMENSION(:), ALLOCATABLE  :: Members      !< Array of Morison members used during simulation [-]
    INTEGER(IntKi)  :: NNodes = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NJoints = 0_IntKi      !< Number of user-specified joints [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: I_MG_End      !< Inertial matrix associated with marine growth mass at joint [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: An_End      !< directional area vector of each joint [m^2]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DragConst_End      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VRelNFiltConst      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DragMod_End      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DragLoFSc_End      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_WMG_End      !< Joint marine growth weight loads, constant for all t [N]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DP_Const_End      !< Constant part of Joint dynamic pressure term [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Mass_MG_End      !< Joint marine growth mass [kg]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AM_End      !< 3x3 Joint added mass matrix, constant for all t [N]
    INTEGER(IntKi)  :: NMOutputs = 0_IntKi      !<  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !<  [-]
    INTEGER(IntKi)  :: NJOutputs = 0_IntKi      !<  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !<  [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !<  [-]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !<  [-]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< SeaState wave field [-]
    LOGICAL  :: VisMeshes = .false.      !< Output visualization meshes [-]
    INTEGER(IntKi)  :: PtfmYMod = 0_IntKi      !< Large yaw model [-]
  END TYPE Morison_ParameterType
! =======================
! =========  Morison_InputType  =======
  TYPE, PUBLIC :: Morison_InputType
    TYPE(MeshType)  :: Mesh      !< Kinematics of each node input mesh [-]
    REAL(ReKi)  :: PtfmRefY = 0.0_ReKi      !< Reference platform yaw offset [(rad)]
  END TYPE Morison_InputType
! =======================
! =========  Morison_OutputType  =======
  TYPE, PUBLIC :: Morison_OutputType
    TYPE(MeshType)  :: Mesh      !< Loads on each node output mesh [-]
    TYPE(MeshType)  :: VisMesh      !< Line mesh for visualization [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !<  [-]
  END TYPE Morison_OutputType
! =======================
   integer(IntKi), public, parameter :: Morison_x_DummyContState         =   1 ! Morison%DummyContState
   integer(IntKi), public, parameter :: Morison_z_DummyConstrState       =   2 ! Morison%DummyConstrState
   integer(IntKi), public, parameter :: Morison_u_Mesh                   =   3 ! Morison%Mesh
   integer(IntKi), public, parameter :: Morison_u_PtfmRefY               =   4 ! Morison%PtfmRefY
   integer(IntKi), public, parameter :: Morison_y_Mesh                   =   5 ! Morison%Mesh
   integer(IntKi), public, parameter :: Morison_y_VisMesh                =   6 ! Morison%VisMesh
   integer(IntKi), public, parameter :: Morison_y_WriteOutput            =   7 ! Morison%WriteOutput

contains

subroutine Morison_CopyJointType(SrcJointTypeData, DstJointTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_JointType), intent(in) :: SrcJointTypeData
   type(Morison_JointType), intent(inout) :: DstJointTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyJointType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstJointTypeData%JointID = SrcJointTypeData%JointID
   DstJointTypeData%Position = SrcJointTypeData%Position
   DstJointTypeData%JointAxID = SrcJointTypeData%JointAxID
   DstJointTypeData%JointAxIDIndx = SrcJointTypeData%JointAxIDIndx
   DstJointTypeData%JointOvrlp = SrcJointTypeData%JointOvrlp
   DstJointTypeData%NConnections = SrcJointTypeData%NConnections
   DstJointTypeData%ConnectionList = SrcJointTypeData%ConnectionList
end subroutine

subroutine Morison_DestroyJointType(JointTypeData, ErrStat, ErrMsg)
   type(Morison_JointType), intent(inout) :: JointTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyJointType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackJointType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_JointType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackJointType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%JointID)
   call RegPack(RF, InData%Position)
   call RegPack(RF, InData%JointAxID)
   call RegPack(RF, InData%JointAxIDIndx)
   call RegPack(RF, InData%JointOvrlp)
   call RegPack(RF, InData%NConnections)
   call RegPack(RF, InData%ConnectionList)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackJointType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_JointType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackJointType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%JointID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Position); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointAxID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointAxIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointOvrlp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NConnections); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConnectionList); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMemberPropType(SrcMemberPropTypeData, DstMemberPropTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MemberPropType), intent(in) :: SrcMemberPropTypeData
   type(Morison_MemberPropType), intent(inout) :: DstMemberPropTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyMemberPropType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMemberPropTypeData%PropSetID = SrcMemberPropTypeData%PropSetID
   DstMemberPropTypeData%PropD = SrcMemberPropTypeData%PropD
   DstMemberPropTypeData%PropThck = SrcMemberPropTypeData%PropThck
end subroutine

subroutine Morison_DestroyMemberPropType(MemberPropTypeData, ErrStat, ErrMsg)
   type(Morison_MemberPropType), intent(inout) :: MemberPropTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMemberPropType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackMemberPropType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MemberPropType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMemberPropType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%PropSetID)
   call RegPack(RF, InData%PropD)
   call RegPack(RF, InData%PropThck)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMemberPropType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MemberPropType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMemberPropType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%PropSetID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropThck); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyFilledGroupType(SrcFilledGroupTypeData, DstFilledGroupTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_FilledGroupType), intent(in) :: SrcFilledGroupTypeData
   type(Morison_FilledGroupType), intent(inout) :: DstFilledGroupTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyFilledGroupType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstFilledGroupTypeData%FillNumM = SrcFilledGroupTypeData%FillNumM
   if (allocated(SrcFilledGroupTypeData%FillMList)) then
      LB(1:1) = lbound(SrcFilledGroupTypeData%FillMList, kind=B8Ki)
      UB(1:1) = ubound(SrcFilledGroupTypeData%FillMList, kind=B8Ki)
      if (.not. allocated(DstFilledGroupTypeData%FillMList)) then
         allocate(DstFilledGroupTypeData%FillMList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFilledGroupTypeData%FillMList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFilledGroupTypeData%FillMList = SrcFilledGroupTypeData%FillMList
   end if
   DstFilledGroupTypeData%FillFSLoc = SrcFilledGroupTypeData%FillFSLoc
   DstFilledGroupTypeData%FillDensChr = SrcFilledGroupTypeData%FillDensChr
   DstFilledGroupTypeData%FillDens = SrcFilledGroupTypeData%FillDens
end subroutine

subroutine Morison_DestroyFilledGroupType(FilledGroupTypeData, ErrStat, ErrMsg)
   type(Morison_FilledGroupType), intent(inout) :: FilledGroupTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyFilledGroupType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FilledGroupTypeData%FillMList)) then
      deallocate(FilledGroupTypeData%FillMList)
   end if
end subroutine

subroutine Morison_PackFilledGroupType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_FilledGroupType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackFilledGroupType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%FillNumM)
   call RegPackAlloc(RF, InData%FillMList)
   call RegPack(RF, InData%FillFSLoc)
   call RegPack(RF, InData%FillDensChr)
   call RegPack(RF, InData%FillDens)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackFilledGroupType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_FilledGroupType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackFilledGroupType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%FillNumM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FillMList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillFSLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillDensChr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillDens); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyCoefDpths(SrcCoefDpthsData, DstCoefDpthsData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_CoefDpths), intent(in) :: SrcCoefDpthsData
   type(Morison_CoefDpths), intent(inout) :: DstCoefDpthsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyCoefDpths'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstCoefDpthsData%Dpth = SrcCoefDpthsData%Dpth
   DstCoefDpthsData%DpthCd = SrcCoefDpthsData%DpthCd
   DstCoefDpthsData%DpthCdMG = SrcCoefDpthsData%DpthCdMG
   DstCoefDpthsData%DpthCa = SrcCoefDpthsData%DpthCa
   DstCoefDpthsData%DpthCaMG = SrcCoefDpthsData%DpthCaMG
   DstCoefDpthsData%DpthCp = SrcCoefDpthsData%DpthCp
   DstCoefDpthsData%DpthCpMG = SrcCoefDpthsData%DpthCpMG
   DstCoefDpthsData%DpthAxCd = SrcCoefDpthsData%DpthAxCd
   DstCoefDpthsData%DpthAxCdMG = SrcCoefDpthsData%DpthAxCdMG
   DstCoefDpthsData%DpthAxCa = SrcCoefDpthsData%DpthAxCa
   DstCoefDpthsData%DpthAxCaMG = SrcCoefDpthsData%DpthAxCaMG
   DstCoefDpthsData%DpthAxCp = SrcCoefDpthsData%DpthAxCp
   DstCoefDpthsData%DpthAxCpMG = SrcCoefDpthsData%DpthAxCpMG
   DstCoefDpthsData%DpthCb = SrcCoefDpthsData%DpthCb
   DstCoefDpthsData%DpthCbMg = SrcCoefDpthsData%DpthCbMg
   DstCoefDpthsData%DpthMCF = SrcCoefDpthsData%DpthMCF
end subroutine

subroutine Morison_DestroyCoefDpths(CoefDpthsData, ErrStat, ErrMsg)
   type(Morison_CoefDpths), intent(inout) :: CoefDpthsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyCoefDpths'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackCoefDpths(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_CoefDpths), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackCoefDpths'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Dpth)
   call RegPack(RF, InData%DpthCd)
   call RegPack(RF, InData%DpthCdMG)
   call RegPack(RF, InData%DpthCa)
   call RegPack(RF, InData%DpthCaMG)
   call RegPack(RF, InData%DpthCp)
   call RegPack(RF, InData%DpthCpMG)
   call RegPack(RF, InData%DpthAxCd)
   call RegPack(RF, InData%DpthAxCdMG)
   call RegPack(RF, InData%DpthAxCa)
   call RegPack(RF, InData%DpthAxCaMG)
   call RegPack(RF, InData%DpthAxCp)
   call RegPack(RF, InData%DpthAxCpMG)
   call RegPack(RF, InData%DpthCb)
   call RegPack(RF, InData%DpthCbMg)
   call RegPack(RF, InData%DpthMCF)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackCoefDpths(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_CoefDpths), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackCoefDpths'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Dpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCdMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCaMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCpMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCdMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCaMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthAxCpMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthCbMg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DpthMCF); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyAxialCoefType(SrcAxialCoefTypeData, DstAxialCoefTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_AxialCoefType), intent(in) :: SrcAxialCoefTypeData
   type(Morison_AxialCoefType), intent(inout) :: DstAxialCoefTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyAxialCoefType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstAxialCoefTypeData%AxCoefID = SrcAxialCoefTypeData%AxCoefID
   DstAxialCoefTypeData%AxCd = SrcAxialCoefTypeData%AxCd
   DstAxialCoefTypeData%AxCa = SrcAxialCoefTypeData%AxCa
   DstAxialCoefTypeData%AxCp = SrcAxialCoefTypeData%AxCp
   DstAxialCoefTypeData%AxVnCOff = SrcAxialCoefTypeData%AxVnCOff
   DstAxialCoefTypeData%AxFDLoFSc = SrcAxialCoefTypeData%AxFDLoFSc
   DstAxialCoefTypeData%AxFDMod = SrcAxialCoefTypeData%AxFDMod
end subroutine

subroutine Morison_DestroyAxialCoefType(AxialCoefTypeData, ErrStat, ErrMsg)
   type(Morison_AxialCoefType), intent(inout) :: AxialCoefTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyAxialCoefType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackAxialCoefType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_AxialCoefType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackAxialCoefType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%AxCoefID)
   call RegPack(RF, InData%AxCd)
   call RegPack(RF, InData%AxCa)
   call RegPack(RF, InData%AxCp)
   call RegPack(RF, InData%AxVnCOff)
   call RegPack(RF, InData%AxFDLoFSc)
   call RegPack(RF, InData%AxFDMod)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackAxialCoefType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_AxialCoefType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackAxialCoefType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%AxCoefID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxVnCOff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxFDLoFSc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AxFDMod); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMemberInputType(SrcMemberInputTypeData, DstMemberInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MemberInputType), intent(in) :: SrcMemberInputTypeData
   type(Morison_MemberInputType), intent(inout) :: DstMemberInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyMemberInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMemberInputTypeData%MemberID = SrcMemberInputTypeData%MemberID
   if (allocated(SrcMemberInputTypeData%NodeIndx)) then
      LB(1:1) = lbound(SrcMemberInputTypeData%NodeIndx, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberInputTypeData%NodeIndx, kind=B8Ki)
      if (.not. allocated(DstMemberInputTypeData%NodeIndx)) then
         allocate(DstMemberInputTypeData%NodeIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberInputTypeData%NodeIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberInputTypeData%NodeIndx = SrcMemberInputTypeData%NodeIndx
   end if
   DstMemberInputTypeData%MJointID1 = SrcMemberInputTypeData%MJointID1
   DstMemberInputTypeData%MJointID2 = SrcMemberInputTypeData%MJointID2
   DstMemberInputTypeData%MJointID1Indx = SrcMemberInputTypeData%MJointID1Indx
   DstMemberInputTypeData%MJointID2Indx = SrcMemberInputTypeData%MJointID2Indx
   DstMemberInputTypeData%MPropSetID1 = SrcMemberInputTypeData%MPropSetID1
   DstMemberInputTypeData%MPropSetID2 = SrcMemberInputTypeData%MPropSetID2
   DstMemberInputTypeData%MPropSetID1Indx = SrcMemberInputTypeData%MPropSetID1Indx
   DstMemberInputTypeData%MPropSetID2Indx = SrcMemberInputTypeData%MPropSetID2Indx
   DstMemberInputTypeData%MDivSize = SrcMemberInputTypeData%MDivSize
   DstMemberInputTypeData%MCoefMod = SrcMemberInputTypeData%MCoefMod
   DstMemberInputTypeData%MHstLMod = SrcMemberInputTypeData%MHstLMod
   DstMemberInputTypeData%MmbrCoefIDIndx = SrcMemberInputTypeData%MmbrCoefIDIndx
   DstMemberInputTypeData%MmbrFilledIDIndx = SrcMemberInputTypeData%MmbrFilledIDIndx
   DstMemberInputTypeData%PropPot = SrcMemberInputTypeData%PropPot
   DstMemberInputTypeData%PropMCF = SrcMemberInputTypeData%PropMCF
   DstMemberInputTypeData%NElements = SrcMemberInputTypeData%NElements
   DstMemberInputTypeData%RefLength = SrcMemberInputTypeData%RefLength
   DstMemberInputTypeData%dl = SrcMemberInputTypeData%dl
end subroutine

subroutine Morison_DestroyMemberInputType(MemberInputTypeData, ErrStat, ErrMsg)
   type(Morison_MemberInputType), intent(inout) :: MemberInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMemberInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MemberInputTypeData%NodeIndx)) then
      deallocate(MemberInputTypeData%NodeIndx)
   end if
end subroutine

subroutine Morison_PackMemberInputType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MemberInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMemberInputType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MemberID)
   call RegPackAlloc(RF, InData%NodeIndx)
   call RegPack(RF, InData%MJointID1)
   call RegPack(RF, InData%MJointID2)
   call RegPack(RF, InData%MJointID1Indx)
   call RegPack(RF, InData%MJointID2Indx)
   call RegPack(RF, InData%MPropSetID1)
   call RegPack(RF, InData%MPropSetID2)
   call RegPack(RF, InData%MPropSetID1Indx)
   call RegPack(RF, InData%MPropSetID2Indx)
   call RegPack(RF, InData%MDivSize)
   call RegPack(RF, InData%MCoefMod)
   call RegPack(RF, InData%MHstLMod)
   call RegPack(RF, InData%MmbrCoefIDIndx)
   call RegPack(RF, InData%MmbrFilledIDIndx)
   call RegPack(RF, InData%PropPot)
   call RegPack(RF, InData%PropMCF)
   call RegPack(RF, InData%NElements)
   call RegPack(RF, InData%RefLength)
   call RegPack(RF, InData%dl)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMemberInputType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MemberInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMemberInputType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MemberID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NodeIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MJointID1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MJointID2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MJointID1Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MJointID2Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MPropSetID1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MPropSetID2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MPropSetID1Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MPropSetID2Indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MDivSize); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MCoefMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHstLMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MmbrCoefIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MmbrFilledIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropPot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropMCF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NElements); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RefLength); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dl); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyNodeType(SrcNodeTypeData, DstNodeTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_NodeType), intent(in) :: SrcNodeTypeData
   type(Morison_NodeType), intent(inout) :: DstNodeTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyNodeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstNodeTypeData%JointIndx = SrcNodeTypeData%JointIndx
   DstNodeTypeData%Position = SrcNodeTypeData%Position
   DstNodeTypeData%JointOvrlp = SrcNodeTypeData%JointOvrlp
   DstNodeTypeData%JointAxIDIndx = SrcNodeTypeData%JointAxIDIndx
   DstNodeTypeData%NConnections = SrcNodeTypeData%NConnections
   DstNodeTypeData%ConnectionList = SrcNodeTypeData%ConnectionList
   DstNodeTypeData%JAxCd = SrcNodeTypeData%JAxCd
   DstNodeTypeData%JAxCa = SrcNodeTypeData%JAxCa
   DstNodeTypeData%JAxCp = SrcNodeTypeData%JAxCp
   DstNodeTypeData%JAxVnCOff = SrcNodeTypeData%JAxVnCOff
   DstNodeTypeData%JAxFDLoFSc = SrcNodeTypeData%JAxFDLoFSc
   DstNodeTypeData%JAxFDMod = SrcNodeTypeData%JAxFDMod
   DstNodeTypeData%FillDensity = SrcNodeTypeData%FillDensity
   DstNodeTypeData%tMG = SrcNodeTypeData%tMG
   DstNodeTypeData%MGdensity = SrcNodeTypeData%MGdensity
end subroutine

subroutine Morison_DestroyNodeType(NodeTypeData, ErrStat, ErrMsg)
   type(Morison_NodeType), intent(inout) :: NodeTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyNodeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackNodeType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_NodeType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackNodeType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%JointIndx)
   call RegPack(RF, InData%Position)
   call RegPack(RF, InData%JointOvrlp)
   call RegPack(RF, InData%JointAxIDIndx)
   call RegPack(RF, InData%NConnections)
   call RegPack(RF, InData%ConnectionList)
   call RegPack(RF, InData%JAxCd)
   call RegPack(RF, InData%JAxCa)
   call RegPack(RF, InData%JAxCp)
   call RegPack(RF, InData%JAxVnCOff)
   call RegPack(RF, InData%JAxFDLoFSc)
   call RegPack(RF, InData%JAxFDMod)
   call RegPack(RF, InData%FillDensity)
   call RegPack(RF, InData%tMG)
   call RegPack(RF, InData%MGdensity)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackNodeType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_NodeType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackNodeType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%JointIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Position); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointOvrlp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointAxIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NConnections); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConnectionList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxVnCOff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxFDLoFSc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JAxFDMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillDensity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%tMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MGdensity); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMemberType(SrcMemberTypeData, DstMemberTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MemberType), intent(in) :: SrcMemberTypeData
   type(Morison_MemberType), intent(inout) :: DstMemberTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyMemberType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMemberTypeData%NodeIndx)) then
      LB(1:1) = lbound(SrcMemberTypeData%NodeIndx, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%NodeIndx, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%NodeIndx)) then
         allocate(DstMemberTypeData%NodeIndx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%NodeIndx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%NodeIndx = SrcMemberTypeData%NodeIndx
   end if
   DstMemberTypeData%MemberID = SrcMemberTypeData%MemberID
   DstMemberTypeData%NElements = SrcMemberTypeData%NElements
   DstMemberTypeData%RefLength = SrcMemberTypeData%RefLength
   DstMemberTypeData%cosPhi_ref = SrcMemberTypeData%cosPhi_ref
   DstMemberTypeData%dl = SrcMemberTypeData%dl
   DstMemberTypeData%k = SrcMemberTypeData%k
   DstMemberTypeData%kkt = SrcMemberTypeData%kkt
   DstMemberTypeData%Ak = SrcMemberTypeData%Ak
   if (allocated(SrcMemberTypeData%R)) then
      LB(1:1) = lbound(SrcMemberTypeData%R, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%R, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%R)) then
         allocate(DstMemberTypeData%R(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%R.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%R = SrcMemberTypeData%R
   end if
   if (allocated(SrcMemberTypeData%RMG)) then
      LB(1:1) = lbound(SrcMemberTypeData%RMG, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%RMG, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%RMG)) then
         allocate(DstMemberTypeData%RMG(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%RMG.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%RMG = SrcMemberTypeData%RMG
   end if
   if (allocated(SrcMemberTypeData%RMGB)) then
      LB(1:1) = lbound(SrcMemberTypeData%RMGB, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%RMGB, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%RMGB)) then
         allocate(DstMemberTypeData%RMGB(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%RMGB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%RMGB = SrcMemberTypeData%RMGB
   end if
   if (allocated(SrcMemberTypeData%Rin)) then
      LB(1:1) = lbound(SrcMemberTypeData%Rin, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Rin, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Rin)) then
         allocate(DstMemberTypeData%Rin(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Rin.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Rin = SrcMemberTypeData%Rin
   end if
   if (allocated(SrcMemberTypeData%tMG)) then
      LB(1:1) = lbound(SrcMemberTypeData%tMG, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%tMG, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%tMG)) then
         allocate(DstMemberTypeData%tMG(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%tMG.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%tMG = SrcMemberTypeData%tMG
   end if
   if (allocated(SrcMemberTypeData%MGdensity)) then
      LB(1:1) = lbound(SrcMemberTypeData%MGdensity, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%MGdensity, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%MGdensity)) then
         allocate(DstMemberTypeData%MGdensity(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%MGdensity.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%MGdensity = SrcMemberTypeData%MGdensity
   end if
   if (allocated(SrcMemberTypeData%dRdl_mg)) then
      LB(1:1) = lbound(SrcMemberTypeData%dRdl_mg, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%dRdl_mg, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%dRdl_mg)) then
         allocate(DstMemberTypeData%dRdl_mg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%dRdl_mg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%dRdl_mg = SrcMemberTypeData%dRdl_mg
   end if
   if (allocated(SrcMemberTypeData%dRdl_mg_b)) then
      LB(1:1) = lbound(SrcMemberTypeData%dRdl_mg_b, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%dRdl_mg_b, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%dRdl_mg_b)) then
         allocate(DstMemberTypeData%dRdl_mg_b(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%dRdl_mg_b.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%dRdl_mg_b = SrcMemberTypeData%dRdl_mg_b
   end if
   if (allocated(SrcMemberTypeData%dRdl_in)) then
      LB(1:1) = lbound(SrcMemberTypeData%dRdl_in, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%dRdl_in, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%dRdl_in)) then
         allocate(DstMemberTypeData%dRdl_in(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%dRdl_in.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%dRdl_in = SrcMemberTypeData%dRdl_in
   end if
   DstMemberTypeData%Vinner = SrcMemberTypeData%Vinner
   DstMemberTypeData%Vouter = SrcMemberTypeData%Vouter
   DstMemberTypeData%Vballast = SrcMemberTypeData%Vballast
   DstMemberTypeData%Vsubmerged = SrcMemberTypeData%Vsubmerged
   DstMemberTypeData%l_fill = SrcMemberTypeData%l_fill
   DstMemberTypeData%h_fill = SrcMemberTypeData%h_fill
   DstMemberTypeData%z_overfill = SrcMemberTypeData%z_overfill
   DstMemberTypeData%h_floor = SrcMemberTypeData%h_floor
   DstMemberTypeData%i_floor = SrcMemberTypeData%i_floor
   DstMemberTypeData%doEndBuoyancy = SrcMemberTypeData%doEndBuoyancy
   DstMemberTypeData%memfloodstatus = SrcMemberTypeData%memfloodstatus
   if (allocated(SrcMemberTypeData%floodstatus)) then
      LB(1:1) = lbound(SrcMemberTypeData%floodstatus, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%floodstatus, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%floodstatus)) then
         allocate(DstMemberTypeData%floodstatus(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%floodstatus.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%floodstatus = SrcMemberTypeData%floodstatus
   end if
   if (allocated(SrcMemberTypeData%alpha)) then
      LB(1:1) = lbound(SrcMemberTypeData%alpha, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%alpha, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%alpha)) then
         allocate(DstMemberTypeData%alpha(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%alpha.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%alpha = SrcMemberTypeData%alpha
   end if
   if (allocated(SrcMemberTypeData%alpha_fb)) then
      LB(1:1) = lbound(SrcMemberTypeData%alpha_fb, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%alpha_fb, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%alpha_fb)) then
         allocate(DstMemberTypeData%alpha_fb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%alpha_fb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%alpha_fb = SrcMemberTypeData%alpha_fb
   end if
   if (allocated(SrcMemberTypeData%alpha_fb_star)) then
      LB(1:1) = lbound(SrcMemberTypeData%alpha_fb_star, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%alpha_fb_star, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%alpha_fb_star)) then
         allocate(DstMemberTypeData%alpha_fb_star(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%alpha_fb_star.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%alpha_fb_star = SrcMemberTypeData%alpha_fb_star
   end if
   if (allocated(SrcMemberTypeData%Cd)) then
      LB(1:1) = lbound(SrcMemberTypeData%Cd, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Cd, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Cd)) then
         allocate(DstMemberTypeData%Cd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Cd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Cd = SrcMemberTypeData%Cd
   end if
   if (allocated(SrcMemberTypeData%Ca)) then
      LB(1:1) = lbound(SrcMemberTypeData%Ca, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Ca, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Ca)) then
         allocate(DstMemberTypeData%Ca(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Ca.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Ca = SrcMemberTypeData%Ca
   end if
   if (allocated(SrcMemberTypeData%Cp)) then
      LB(1:1) = lbound(SrcMemberTypeData%Cp, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Cp, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Cp)) then
         allocate(DstMemberTypeData%Cp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Cp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Cp = SrcMemberTypeData%Cp
   end if
   if (allocated(SrcMemberTypeData%AxCd)) then
      LB(1:1) = lbound(SrcMemberTypeData%AxCd, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%AxCd, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%AxCd)) then
         allocate(DstMemberTypeData%AxCd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%AxCd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%AxCd = SrcMemberTypeData%AxCd
   end if
   if (allocated(SrcMemberTypeData%AxCa)) then
      LB(1:1) = lbound(SrcMemberTypeData%AxCa, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%AxCa, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%AxCa)) then
         allocate(DstMemberTypeData%AxCa(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%AxCa.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%AxCa = SrcMemberTypeData%AxCa
   end if
   if (allocated(SrcMemberTypeData%AxCp)) then
      LB(1:1) = lbound(SrcMemberTypeData%AxCp, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%AxCp, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%AxCp)) then
         allocate(DstMemberTypeData%AxCp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%AxCp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%AxCp = SrcMemberTypeData%AxCp
   end if
   if (allocated(SrcMemberTypeData%Cb)) then
      LB(1:1) = lbound(SrcMemberTypeData%Cb, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Cb, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Cb)) then
         allocate(DstMemberTypeData%Cb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Cb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Cb = SrcMemberTypeData%Cb
   end if
   if (allocated(SrcMemberTypeData%m_fb_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%m_fb_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%m_fb_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%m_fb_l)) then
         allocate(DstMemberTypeData%m_fb_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%m_fb_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%m_fb_l = SrcMemberTypeData%m_fb_l
   end if
   if (allocated(SrcMemberTypeData%m_fb_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%m_fb_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%m_fb_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%m_fb_u)) then
         allocate(DstMemberTypeData%m_fb_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%m_fb_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%m_fb_u = SrcMemberTypeData%m_fb_u
   end if
   if (allocated(SrcMemberTypeData%h_cfb_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%h_cfb_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%h_cfb_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%h_cfb_l)) then
         allocate(DstMemberTypeData%h_cfb_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%h_cfb_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%h_cfb_l = SrcMemberTypeData%h_cfb_l
   end if
   if (allocated(SrcMemberTypeData%h_cfb_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%h_cfb_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%h_cfb_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%h_cfb_u)) then
         allocate(DstMemberTypeData%h_cfb_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%h_cfb_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%h_cfb_u = SrcMemberTypeData%h_cfb_u
   end if
   if (allocated(SrcMemberTypeData%I_lfb_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_lfb_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_lfb_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_lfb_l)) then
         allocate(DstMemberTypeData%I_lfb_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_lfb_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_lfb_l = SrcMemberTypeData%I_lfb_l
   end if
   if (allocated(SrcMemberTypeData%I_lfb_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_lfb_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_lfb_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_lfb_u)) then
         allocate(DstMemberTypeData%I_lfb_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_lfb_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_lfb_u = SrcMemberTypeData%I_lfb_u
   end if
   if (allocated(SrcMemberTypeData%I_rfb_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_rfb_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_rfb_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_rfb_l)) then
         allocate(DstMemberTypeData%I_rfb_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_rfb_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_rfb_l = SrcMemberTypeData%I_rfb_l
   end if
   if (allocated(SrcMemberTypeData%I_rfb_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_rfb_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_rfb_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_rfb_u)) then
         allocate(DstMemberTypeData%I_rfb_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_rfb_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_rfb_u = SrcMemberTypeData%I_rfb_u
   end if
   if (allocated(SrcMemberTypeData%m_mg_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%m_mg_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%m_mg_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%m_mg_l)) then
         allocate(DstMemberTypeData%m_mg_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%m_mg_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%m_mg_l = SrcMemberTypeData%m_mg_l
   end if
   if (allocated(SrcMemberTypeData%m_mg_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%m_mg_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%m_mg_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%m_mg_u)) then
         allocate(DstMemberTypeData%m_mg_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%m_mg_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%m_mg_u = SrcMemberTypeData%m_mg_u
   end if
   if (allocated(SrcMemberTypeData%h_cmg_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%h_cmg_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%h_cmg_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%h_cmg_l)) then
         allocate(DstMemberTypeData%h_cmg_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%h_cmg_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%h_cmg_l = SrcMemberTypeData%h_cmg_l
   end if
   if (allocated(SrcMemberTypeData%h_cmg_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%h_cmg_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%h_cmg_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%h_cmg_u)) then
         allocate(DstMemberTypeData%h_cmg_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%h_cmg_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%h_cmg_u = SrcMemberTypeData%h_cmg_u
   end if
   if (allocated(SrcMemberTypeData%I_lmg_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_lmg_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_lmg_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_lmg_l)) then
         allocate(DstMemberTypeData%I_lmg_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_lmg_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_lmg_l = SrcMemberTypeData%I_lmg_l
   end if
   if (allocated(SrcMemberTypeData%I_lmg_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_lmg_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_lmg_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_lmg_u)) then
         allocate(DstMemberTypeData%I_lmg_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_lmg_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_lmg_u = SrcMemberTypeData%I_lmg_u
   end if
   if (allocated(SrcMemberTypeData%I_rmg_l)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_rmg_l, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_rmg_l, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_rmg_l)) then
         allocate(DstMemberTypeData%I_rmg_l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_rmg_l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_rmg_l = SrcMemberTypeData%I_rmg_l
   end if
   if (allocated(SrcMemberTypeData%I_rmg_u)) then
      LB(1:1) = lbound(SrcMemberTypeData%I_rmg_u, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%I_rmg_u, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%I_rmg_u)) then
         allocate(DstMemberTypeData%I_rmg_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%I_rmg_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%I_rmg_u = SrcMemberTypeData%I_rmg_u
   end if
   if (allocated(SrcMemberTypeData%Cfl_fb)) then
      LB(1:1) = lbound(SrcMemberTypeData%Cfl_fb, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Cfl_fb, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Cfl_fb)) then
         allocate(DstMemberTypeData%Cfl_fb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Cfl_fb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Cfl_fb = SrcMemberTypeData%Cfl_fb
   end if
   if (allocated(SrcMemberTypeData%Cfr_fb)) then
      LB(1:1) = lbound(SrcMemberTypeData%Cfr_fb, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%Cfr_fb, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%Cfr_fb)) then
         allocate(DstMemberTypeData%Cfr_fb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%Cfr_fb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%Cfr_fb = SrcMemberTypeData%Cfr_fb
   end if
   if (allocated(SrcMemberTypeData%CM0_fb)) then
      LB(1:1) = lbound(SrcMemberTypeData%CM0_fb, kind=B8Ki)
      UB(1:1) = ubound(SrcMemberTypeData%CM0_fb, kind=B8Ki)
      if (.not. allocated(DstMemberTypeData%CM0_fb)) then
         allocate(DstMemberTypeData%CM0_fb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberTypeData%CM0_fb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberTypeData%CM0_fb = SrcMemberTypeData%CM0_fb
   end if
   DstMemberTypeData%MGvolume = SrcMemberTypeData%MGvolume
   DstMemberTypeData%MDivSize = SrcMemberTypeData%MDivSize
   DstMemberTypeData%MCoefMod = SrcMemberTypeData%MCoefMod
   DstMemberTypeData%MmbrCoefIDIndx = SrcMemberTypeData%MmbrCoefIDIndx
   DstMemberTypeData%MmbrFilledIDIndx = SrcMemberTypeData%MmbrFilledIDIndx
   DstMemberTypeData%MHstLMod = SrcMemberTypeData%MHstLMod
   DstMemberTypeData%FillFSLoc = SrcMemberTypeData%FillFSLoc
   DstMemberTypeData%FillDens = SrcMemberTypeData%FillDens
   DstMemberTypeData%PropPot = SrcMemberTypeData%PropPot
   DstMemberTypeData%PropMCF = SrcMemberTypeData%PropMCF
   DstMemberTypeData%Flipped = SrcMemberTypeData%Flipped
end subroutine

subroutine Morison_DestroyMemberType(MemberTypeData, ErrStat, ErrMsg)
   type(Morison_MemberType), intent(inout) :: MemberTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMemberType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MemberTypeData%NodeIndx)) then
      deallocate(MemberTypeData%NodeIndx)
   end if
   if (allocated(MemberTypeData%R)) then
      deallocate(MemberTypeData%R)
   end if
   if (allocated(MemberTypeData%RMG)) then
      deallocate(MemberTypeData%RMG)
   end if
   if (allocated(MemberTypeData%RMGB)) then
      deallocate(MemberTypeData%RMGB)
   end if
   if (allocated(MemberTypeData%Rin)) then
      deallocate(MemberTypeData%Rin)
   end if
   if (allocated(MemberTypeData%tMG)) then
      deallocate(MemberTypeData%tMG)
   end if
   if (allocated(MemberTypeData%MGdensity)) then
      deallocate(MemberTypeData%MGdensity)
   end if
   if (allocated(MemberTypeData%dRdl_mg)) then
      deallocate(MemberTypeData%dRdl_mg)
   end if
   if (allocated(MemberTypeData%dRdl_mg_b)) then
      deallocate(MemberTypeData%dRdl_mg_b)
   end if
   if (allocated(MemberTypeData%dRdl_in)) then
      deallocate(MemberTypeData%dRdl_in)
   end if
   if (allocated(MemberTypeData%floodstatus)) then
      deallocate(MemberTypeData%floodstatus)
   end if
   if (allocated(MemberTypeData%alpha)) then
      deallocate(MemberTypeData%alpha)
   end if
   if (allocated(MemberTypeData%alpha_fb)) then
      deallocate(MemberTypeData%alpha_fb)
   end if
   if (allocated(MemberTypeData%alpha_fb_star)) then
      deallocate(MemberTypeData%alpha_fb_star)
   end if
   if (allocated(MemberTypeData%Cd)) then
      deallocate(MemberTypeData%Cd)
   end if
   if (allocated(MemberTypeData%Ca)) then
      deallocate(MemberTypeData%Ca)
   end if
   if (allocated(MemberTypeData%Cp)) then
      deallocate(MemberTypeData%Cp)
   end if
   if (allocated(MemberTypeData%AxCd)) then
      deallocate(MemberTypeData%AxCd)
   end if
   if (allocated(MemberTypeData%AxCa)) then
      deallocate(MemberTypeData%AxCa)
   end if
   if (allocated(MemberTypeData%AxCp)) then
      deallocate(MemberTypeData%AxCp)
   end if
   if (allocated(MemberTypeData%Cb)) then
      deallocate(MemberTypeData%Cb)
   end if
   if (allocated(MemberTypeData%m_fb_l)) then
      deallocate(MemberTypeData%m_fb_l)
   end if
   if (allocated(MemberTypeData%m_fb_u)) then
      deallocate(MemberTypeData%m_fb_u)
   end if
   if (allocated(MemberTypeData%h_cfb_l)) then
      deallocate(MemberTypeData%h_cfb_l)
   end if
   if (allocated(MemberTypeData%h_cfb_u)) then
      deallocate(MemberTypeData%h_cfb_u)
   end if
   if (allocated(MemberTypeData%I_lfb_l)) then
      deallocate(MemberTypeData%I_lfb_l)
   end if
   if (allocated(MemberTypeData%I_lfb_u)) then
      deallocate(MemberTypeData%I_lfb_u)
   end if
   if (allocated(MemberTypeData%I_rfb_l)) then
      deallocate(MemberTypeData%I_rfb_l)
   end if
   if (allocated(MemberTypeData%I_rfb_u)) then
      deallocate(MemberTypeData%I_rfb_u)
   end if
   if (allocated(MemberTypeData%m_mg_l)) then
      deallocate(MemberTypeData%m_mg_l)
   end if
   if (allocated(MemberTypeData%m_mg_u)) then
      deallocate(MemberTypeData%m_mg_u)
   end if
   if (allocated(MemberTypeData%h_cmg_l)) then
      deallocate(MemberTypeData%h_cmg_l)
   end if
   if (allocated(MemberTypeData%h_cmg_u)) then
      deallocate(MemberTypeData%h_cmg_u)
   end if
   if (allocated(MemberTypeData%I_lmg_l)) then
      deallocate(MemberTypeData%I_lmg_l)
   end if
   if (allocated(MemberTypeData%I_lmg_u)) then
      deallocate(MemberTypeData%I_lmg_u)
   end if
   if (allocated(MemberTypeData%I_rmg_l)) then
      deallocate(MemberTypeData%I_rmg_l)
   end if
   if (allocated(MemberTypeData%I_rmg_u)) then
      deallocate(MemberTypeData%I_rmg_u)
   end if
   if (allocated(MemberTypeData%Cfl_fb)) then
      deallocate(MemberTypeData%Cfl_fb)
   end if
   if (allocated(MemberTypeData%Cfr_fb)) then
      deallocate(MemberTypeData%Cfr_fb)
   end if
   if (allocated(MemberTypeData%CM0_fb)) then
      deallocate(MemberTypeData%CM0_fb)
   end if
end subroutine

subroutine Morison_PackMemberType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MemberType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMemberType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%NodeIndx)
   call RegPack(RF, InData%MemberID)
   call RegPack(RF, InData%NElements)
   call RegPack(RF, InData%RefLength)
   call RegPack(RF, InData%cosPhi_ref)
   call RegPack(RF, InData%dl)
   call RegPack(RF, InData%k)
   call RegPack(RF, InData%kkt)
   call RegPack(RF, InData%Ak)
   call RegPackAlloc(RF, InData%R)
   call RegPackAlloc(RF, InData%RMG)
   call RegPackAlloc(RF, InData%RMGB)
   call RegPackAlloc(RF, InData%Rin)
   call RegPackAlloc(RF, InData%tMG)
   call RegPackAlloc(RF, InData%MGdensity)
   call RegPackAlloc(RF, InData%dRdl_mg)
   call RegPackAlloc(RF, InData%dRdl_mg_b)
   call RegPackAlloc(RF, InData%dRdl_in)
   call RegPack(RF, InData%Vinner)
   call RegPack(RF, InData%Vouter)
   call RegPack(RF, InData%Vballast)
   call RegPack(RF, InData%Vsubmerged)
   call RegPack(RF, InData%l_fill)
   call RegPack(RF, InData%h_fill)
   call RegPack(RF, InData%z_overfill)
   call RegPack(RF, InData%h_floor)
   call RegPack(RF, InData%i_floor)
   call RegPack(RF, InData%doEndBuoyancy)
   call RegPack(RF, InData%memfloodstatus)
   call RegPackAlloc(RF, InData%floodstatus)
   call RegPackAlloc(RF, InData%alpha)
   call RegPackAlloc(RF, InData%alpha_fb)
   call RegPackAlloc(RF, InData%alpha_fb_star)
   call RegPackAlloc(RF, InData%Cd)
   call RegPackAlloc(RF, InData%Ca)
   call RegPackAlloc(RF, InData%Cp)
   call RegPackAlloc(RF, InData%AxCd)
   call RegPackAlloc(RF, InData%AxCa)
   call RegPackAlloc(RF, InData%AxCp)
   call RegPackAlloc(RF, InData%Cb)
   call RegPackAlloc(RF, InData%m_fb_l)
   call RegPackAlloc(RF, InData%m_fb_u)
   call RegPackAlloc(RF, InData%h_cfb_l)
   call RegPackAlloc(RF, InData%h_cfb_u)
   call RegPackAlloc(RF, InData%I_lfb_l)
   call RegPackAlloc(RF, InData%I_lfb_u)
   call RegPackAlloc(RF, InData%I_rfb_l)
   call RegPackAlloc(RF, InData%I_rfb_u)
   call RegPackAlloc(RF, InData%m_mg_l)
   call RegPackAlloc(RF, InData%m_mg_u)
   call RegPackAlloc(RF, InData%h_cmg_l)
   call RegPackAlloc(RF, InData%h_cmg_u)
   call RegPackAlloc(RF, InData%I_lmg_l)
   call RegPackAlloc(RF, InData%I_lmg_u)
   call RegPackAlloc(RF, InData%I_rmg_l)
   call RegPackAlloc(RF, InData%I_rmg_u)
   call RegPackAlloc(RF, InData%Cfl_fb)
   call RegPackAlloc(RF, InData%Cfr_fb)
   call RegPackAlloc(RF, InData%CM0_fb)
   call RegPack(RF, InData%MGvolume)
   call RegPack(RF, InData%MDivSize)
   call RegPack(RF, InData%MCoefMod)
   call RegPack(RF, InData%MmbrCoefIDIndx)
   call RegPack(RF, InData%MmbrFilledIDIndx)
   call RegPack(RF, InData%MHstLMod)
   call RegPack(RF, InData%FillFSLoc)
   call RegPack(RF, InData%FillDens)
   call RegPack(RF, InData%PropPot)
   call RegPack(RF, InData%PropMCF)
   call RegPack(RF, InData%Flipped)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMemberType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MemberType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMemberType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%NodeIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NElements); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RefLength); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%cosPhi_ref); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dl); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%k); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kkt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ak); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%R); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RMGB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Rin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%tMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MGdensity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dRdl_mg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dRdl_mg_b); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dRdl_in); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vinner); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vouter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vballast); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Vsubmerged); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%l_fill); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%h_fill); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%z_overfill); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%h_floor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%i_floor); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%doEndBuoyancy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%memfloodstatus); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%floodstatus); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%alpha); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%alpha_fb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%alpha_fb_star); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Cd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Ca); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Cp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AxCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AxCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AxCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Cb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%m_fb_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%m_fb_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%h_cfb_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%h_cfb_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_lfb_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_lfb_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_rfb_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_rfb_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%m_mg_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%m_mg_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%h_cmg_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%h_cmg_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_lmg_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_lmg_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_rmg_l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_rmg_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Cfl_fb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Cfr_fb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CM0_fb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MGvolume); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MDivSize); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MCoefMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MmbrCoefIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MmbrFilledIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHstLMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillFSLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FillDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropPot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropMCF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Flipped); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMemberLoads(SrcMemberLoadsData, DstMemberLoadsData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MemberLoads), intent(in) :: SrcMemberLoadsData
   type(Morison_MemberLoads), intent(inout) :: DstMemberLoadsData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyMemberLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMemberLoadsData%F_D)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_D, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_D, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_D)) then
         allocate(DstMemberLoadsData%F_D(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_D.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_D = SrcMemberLoadsData%F_D
   end if
   if (allocated(SrcMemberLoadsData%F_I)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_I, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_I, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_I)) then
         allocate(DstMemberLoadsData%F_I(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_I.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_I = SrcMemberLoadsData%F_I
   end if
   if (allocated(SrcMemberLoadsData%F_A)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_A, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_A, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_A)) then
         allocate(DstMemberLoadsData%F_A(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_A.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_A = SrcMemberLoadsData%F_A
   end if
   if (allocated(SrcMemberLoadsData%F_B)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_B, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_B, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_B)) then
         allocate(DstMemberLoadsData%F_B(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_B.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_B = SrcMemberLoadsData%F_B
   end if
   if (allocated(SrcMemberLoadsData%F_BF)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_BF, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_BF, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_BF)) then
         allocate(DstMemberLoadsData%F_BF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_BF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_BF = SrcMemberLoadsData%F_BF
   end if
   if (allocated(SrcMemberLoadsData%F_If)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_If, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_If, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_If)) then
         allocate(DstMemberLoadsData%F_If(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_If.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_If = SrcMemberLoadsData%F_If
   end if
   if (allocated(SrcMemberLoadsData%F_WMG)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_WMG, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_WMG, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_WMG)) then
         allocate(DstMemberLoadsData%F_WMG(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_WMG.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_WMG = SrcMemberLoadsData%F_WMG
   end if
   if (allocated(SrcMemberLoadsData%F_IMG)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_IMG, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_IMG, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_IMG)) then
         allocate(DstMemberLoadsData%F_IMG(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_IMG.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_IMG = SrcMemberLoadsData%F_IMG
   end if
   if (allocated(SrcMemberLoadsData%FV)) then
      LB(1:2) = lbound(SrcMemberLoadsData%FV, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%FV, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%FV)) then
         allocate(DstMemberLoadsData%FV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%FV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%FV = SrcMemberLoadsData%FV
   end if
   if (allocated(SrcMemberLoadsData%FA)) then
      LB(1:2) = lbound(SrcMemberLoadsData%FA, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%FA, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%FA)) then
         allocate(DstMemberLoadsData%FA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%FA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%FA = SrcMemberLoadsData%FA
   end if
   if (allocated(SrcMemberLoadsData%F_DP)) then
      LB(1:2) = lbound(SrcMemberLoadsData%F_DP, kind=B8Ki)
      UB(1:2) = ubound(SrcMemberLoadsData%F_DP, kind=B8Ki)
      if (.not. allocated(DstMemberLoadsData%F_DP)) then
         allocate(DstMemberLoadsData%F_DP(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMemberLoadsData%F_DP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMemberLoadsData%F_DP = SrcMemberLoadsData%F_DP
   end if
end subroutine

subroutine Morison_DestroyMemberLoads(MemberLoadsData, ErrStat, ErrMsg)
   type(Morison_MemberLoads), intent(inout) :: MemberLoadsData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMemberLoads'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MemberLoadsData%F_D)) then
      deallocate(MemberLoadsData%F_D)
   end if
   if (allocated(MemberLoadsData%F_I)) then
      deallocate(MemberLoadsData%F_I)
   end if
   if (allocated(MemberLoadsData%F_A)) then
      deallocate(MemberLoadsData%F_A)
   end if
   if (allocated(MemberLoadsData%F_B)) then
      deallocate(MemberLoadsData%F_B)
   end if
   if (allocated(MemberLoadsData%F_BF)) then
      deallocate(MemberLoadsData%F_BF)
   end if
   if (allocated(MemberLoadsData%F_If)) then
      deallocate(MemberLoadsData%F_If)
   end if
   if (allocated(MemberLoadsData%F_WMG)) then
      deallocate(MemberLoadsData%F_WMG)
   end if
   if (allocated(MemberLoadsData%F_IMG)) then
      deallocate(MemberLoadsData%F_IMG)
   end if
   if (allocated(MemberLoadsData%FV)) then
      deallocate(MemberLoadsData%FV)
   end if
   if (allocated(MemberLoadsData%FA)) then
      deallocate(MemberLoadsData%FA)
   end if
   if (allocated(MemberLoadsData%F_DP)) then
      deallocate(MemberLoadsData%F_DP)
   end if
end subroutine

subroutine Morison_PackMemberLoads(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MemberLoads), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMemberLoads'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%F_D)
   call RegPackAlloc(RF, InData%F_I)
   call RegPackAlloc(RF, InData%F_A)
   call RegPackAlloc(RF, InData%F_B)
   call RegPackAlloc(RF, InData%F_BF)
   call RegPackAlloc(RF, InData%F_If)
   call RegPackAlloc(RF, InData%F_WMG)
   call RegPackAlloc(RF, InData%F_IMG)
   call RegPackAlloc(RF, InData%FV)
   call RegPackAlloc(RF, InData%FA)
   call RegPackAlloc(RF, InData%F_DP)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMemberLoads(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MemberLoads), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMemberLoads'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%F_D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_I); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_A); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_B); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_BF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_If); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_WMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_IMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_DP); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyCoefMembers(SrcCoefMembersData, DstCoefMembersData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_CoefMembers), intent(in) :: SrcCoefMembersData
   type(Morison_CoefMembers), intent(inout) :: DstCoefMembersData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyCoefMembers'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstCoefMembersData%MemberID = SrcCoefMembersData%MemberID
   DstCoefMembersData%MemberCd1 = SrcCoefMembersData%MemberCd1
   DstCoefMembersData%MemberCd2 = SrcCoefMembersData%MemberCd2
   DstCoefMembersData%MemberCdMG1 = SrcCoefMembersData%MemberCdMG1
   DstCoefMembersData%MemberCdMG2 = SrcCoefMembersData%MemberCdMG2
   DstCoefMembersData%MemberCa1 = SrcCoefMembersData%MemberCa1
   DstCoefMembersData%MemberCa2 = SrcCoefMembersData%MemberCa2
   DstCoefMembersData%MemberCaMG1 = SrcCoefMembersData%MemberCaMG1
   DstCoefMembersData%MemberCaMG2 = SrcCoefMembersData%MemberCaMG2
   DstCoefMembersData%MemberCp1 = SrcCoefMembersData%MemberCp1
   DstCoefMembersData%MemberCp2 = SrcCoefMembersData%MemberCp2
   DstCoefMembersData%MemberCpMG1 = SrcCoefMembersData%MemberCpMG1
   DstCoefMembersData%MemberCpMG2 = SrcCoefMembersData%MemberCpMG2
   DstCoefMembersData%MemberAxCd1 = SrcCoefMembersData%MemberAxCd1
   DstCoefMembersData%MemberAxCd2 = SrcCoefMembersData%MemberAxCd2
   DstCoefMembersData%MemberAxCdMG1 = SrcCoefMembersData%MemberAxCdMG1
   DstCoefMembersData%MemberAxCdMG2 = SrcCoefMembersData%MemberAxCdMG2
   DstCoefMembersData%MemberAxCa1 = SrcCoefMembersData%MemberAxCa1
   DstCoefMembersData%MemberAxCa2 = SrcCoefMembersData%MemberAxCa2
   DstCoefMembersData%MemberAxCaMG1 = SrcCoefMembersData%MemberAxCaMG1
   DstCoefMembersData%MemberAxCaMG2 = SrcCoefMembersData%MemberAxCaMG2
   DstCoefMembersData%MemberAxCp1 = SrcCoefMembersData%MemberAxCp1
   DstCoefMembersData%MemberAxCp2 = SrcCoefMembersData%MemberAxCp2
   DstCoefMembersData%MemberAxCpMG1 = SrcCoefMembersData%MemberAxCpMG1
   DstCoefMembersData%MemberAxCpMG2 = SrcCoefMembersData%MemberAxCpMG2
   DstCoefMembersData%MemberCb1 = SrcCoefMembersData%MemberCb1
   DstCoefMembersData%MemberCb2 = SrcCoefMembersData%MemberCb2
   DstCoefMembersData%MemberCbMG1 = SrcCoefMembersData%MemberCbMG1
   DstCoefMembersData%MemberCbMG2 = SrcCoefMembersData%MemberCbMG2
   DstCoefMembersData%MemberMCF = SrcCoefMembersData%MemberMCF
end subroutine

subroutine Morison_DestroyCoefMembers(CoefMembersData, ErrStat, ErrMsg)
   type(Morison_CoefMembers), intent(inout) :: CoefMembersData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyCoefMembers'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackCoefMembers(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_CoefMembers), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackCoefMembers'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MemberID)
   call RegPack(RF, InData%MemberCd1)
   call RegPack(RF, InData%MemberCd2)
   call RegPack(RF, InData%MemberCdMG1)
   call RegPack(RF, InData%MemberCdMG2)
   call RegPack(RF, InData%MemberCa1)
   call RegPack(RF, InData%MemberCa2)
   call RegPack(RF, InData%MemberCaMG1)
   call RegPack(RF, InData%MemberCaMG2)
   call RegPack(RF, InData%MemberCp1)
   call RegPack(RF, InData%MemberCp2)
   call RegPack(RF, InData%MemberCpMG1)
   call RegPack(RF, InData%MemberCpMG2)
   call RegPack(RF, InData%MemberAxCd1)
   call RegPack(RF, InData%MemberAxCd2)
   call RegPack(RF, InData%MemberAxCdMG1)
   call RegPack(RF, InData%MemberAxCdMG2)
   call RegPack(RF, InData%MemberAxCa1)
   call RegPack(RF, InData%MemberAxCa2)
   call RegPack(RF, InData%MemberAxCaMG1)
   call RegPack(RF, InData%MemberAxCaMG2)
   call RegPack(RF, InData%MemberAxCp1)
   call RegPack(RF, InData%MemberAxCp2)
   call RegPack(RF, InData%MemberAxCpMG1)
   call RegPack(RF, InData%MemberAxCpMG2)
   call RegPack(RF, InData%MemberCb1)
   call RegPack(RF, InData%MemberCb2)
   call RegPack(RF, InData%MemberCbMG1)
   call RegPack(RF, InData%MemberCbMG2)
   call RegPack(RF, InData%MemberMCF)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackCoefMembers(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_CoefMembers), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackCoefMembers'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MemberID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCd1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCd2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCdMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCdMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCa1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCa2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCaMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCaMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCp1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCp2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCpMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCpMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCd1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCd2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCdMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCdMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCa1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCa2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCaMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCaMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCp1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCp2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCpMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberAxCpMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCb1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCb2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCbMG1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberCbMG2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberMCF); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMGDepthsType(SrcMGDepthsTypeData, DstMGDepthsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MGDepthsType), intent(in) :: SrcMGDepthsTypeData
   type(Morison_MGDepthsType), intent(inout) :: DstMGDepthsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyMGDepthsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMGDepthsTypeData%MGDpth = SrcMGDepthsTypeData%MGDpth
   DstMGDepthsTypeData%MGThck = SrcMGDepthsTypeData%MGThck
   DstMGDepthsTypeData%MGDens = SrcMGDepthsTypeData%MGDens
end subroutine

subroutine Morison_DestroyMGDepthsType(MGDepthsTypeData, ErrStat, ErrMsg)
   type(Morison_MGDepthsType), intent(inout) :: MGDepthsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMGDepthsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackMGDepthsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MGDepthsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMGDepthsType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MGDpth)
   call RegPack(RF, InData%MGThck)
   call RegPack(RF, InData%MGDens)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMGDepthsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MGDepthsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMGDepthsType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MGDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MGThck); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MGDens); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMOutput(SrcMOutputData, DstMOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MOutput), intent(in) :: SrcMOutputData
   type(Morison_MOutput), intent(inout) :: DstMOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyMOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMOutputData%MemberID = SrcMOutputData%MemberID
   DstMOutputData%NOutLoc = SrcMOutputData%NOutLoc
   if (allocated(SrcMOutputData%NodeLocs)) then
      LB(1:1) = lbound(SrcMOutputData%NodeLocs, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%NodeLocs, kind=B8Ki)
      if (.not. allocated(DstMOutputData%NodeLocs)) then
         allocate(DstMOutputData%NodeLocs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%NodeLocs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%NodeLocs = SrcMOutputData%NodeLocs
   end if
   DstMOutputData%MemberIDIndx = SrcMOutputData%MemberIDIndx
   if (allocated(SrcMOutputData%MeshIndx1)) then
      LB(1:1) = lbound(SrcMOutputData%MeshIndx1, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%MeshIndx1, kind=B8Ki)
      if (.not. allocated(DstMOutputData%MeshIndx1)) then
         allocate(DstMOutputData%MeshIndx1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%MeshIndx1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%MeshIndx1 = SrcMOutputData%MeshIndx1
   end if
   if (allocated(SrcMOutputData%MeshIndx2)) then
      LB(1:1) = lbound(SrcMOutputData%MeshIndx2, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%MeshIndx2, kind=B8Ki)
      if (.not. allocated(DstMOutputData%MeshIndx2)) then
         allocate(DstMOutputData%MeshIndx2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%MeshIndx2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%MeshIndx2 = SrcMOutputData%MeshIndx2
   end if
   if (allocated(SrcMOutputData%MemberIndx1)) then
      LB(1:1) = lbound(SrcMOutputData%MemberIndx1, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%MemberIndx1, kind=B8Ki)
      if (.not. allocated(DstMOutputData%MemberIndx1)) then
         allocate(DstMOutputData%MemberIndx1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%MemberIndx1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%MemberIndx1 = SrcMOutputData%MemberIndx1
   end if
   if (allocated(SrcMOutputData%MemberIndx2)) then
      LB(1:1) = lbound(SrcMOutputData%MemberIndx2, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%MemberIndx2, kind=B8Ki)
      if (.not. allocated(DstMOutputData%MemberIndx2)) then
         allocate(DstMOutputData%MemberIndx2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%MemberIndx2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%MemberIndx2 = SrcMOutputData%MemberIndx2
   end if
   if (allocated(SrcMOutputData%s)) then
      LB(1:1) = lbound(SrcMOutputData%s, kind=B8Ki)
      UB(1:1) = ubound(SrcMOutputData%s, kind=B8Ki)
      if (.not. allocated(DstMOutputData%s)) then
         allocate(DstMOutputData%s(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%s.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMOutputData%s = SrcMOutputData%s
   end if
end subroutine

subroutine Morison_DestroyMOutput(MOutputData, ErrStat, ErrMsg)
   type(Morison_MOutput), intent(inout) :: MOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyMOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MOutputData%NodeLocs)) then
      deallocate(MOutputData%NodeLocs)
   end if
   if (allocated(MOutputData%MeshIndx1)) then
      deallocate(MOutputData%MeshIndx1)
   end if
   if (allocated(MOutputData%MeshIndx2)) then
      deallocate(MOutputData%MeshIndx2)
   end if
   if (allocated(MOutputData%MemberIndx1)) then
      deallocate(MOutputData%MemberIndx1)
   end if
   if (allocated(MOutputData%MemberIndx2)) then
      deallocate(MOutputData%MemberIndx2)
   end if
   if (allocated(MOutputData%s)) then
      deallocate(MOutputData%s)
   end if
end subroutine

subroutine Morison_PackMOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MOutput), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%MemberID)
   call RegPack(RF, InData%NOutLoc)
   call RegPackAlloc(RF, InData%NodeLocs)
   call RegPack(RF, InData%MemberIDIndx)
   call RegPackAlloc(RF, InData%MeshIndx1)
   call RegPackAlloc(RF, InData%MeshIndx2)
   call RegPackAlloc(RF, InData%MemberIndx1)
   call RegPackAlloc(RF, InData%MemberIndx2)
   call RegPackAlloc(RF, InData%s)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MOutput), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMOutput'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%MemberID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NOutLoc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NodeLocs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MemberIDIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MeshIndx1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MeshIndx2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MemberIndx1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MemberIndx2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%s); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyJOutput(SrcJOutputData, DstJOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_JOutput), intent(in) :: SrcJOutputData
   type(Morison_JOutput), intent(inout) :: DstJOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyJOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstJOutputData%JointID = SrcJOutputData%JointID
   DstJOutputData%JointIDIndx = SrcJOutputData%JointIDIndx
end subroutine

subroutine Morison_DestroyJOutput(JOutputData, ErrStat, ErrMsg)
   type(Morison_JOutput), intent(inout) :: JOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyJOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackJOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_JOutput), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackJOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%JointID)
   call RegPack(RF, InData%JointIDIndx)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackJOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_JOutput), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackJOutput'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%JointID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JointIDIndx); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_InitInputType), intent(in) :: SrcInitInputData
   type(Morison_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%WaveDisp = SrcInitInputData%WaveDisp
   DstInitInputData%AMMod = SrcInitInputData%AMMod
   DstInitInputData%NJoints = SrcInitInputData%NJoints
   DstInitInputData%NNodes = SrcInitInputData%NNodes
   if (allocated(SrcInitInputData%InpJoints)) then
      LB(1:1) = lbound(SrcInitInputData%InpJoints, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%InpJoints, kind=B8Ki)
      if (.not. allocated(DstInitInputData%InpJoints)) then
         allocate(DstInitInputData%InpJoints(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpJoints.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyJointType(SrcInitInputData%InpJoints(i1), DstInitInputData%InpJoints(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInitInputData%Nodes)) then
      LB(1:1) = lbound(SrcInitInputData%Nodes, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%Nodes, kind=B8Ki)
      if (.not. allocated(DstInitInputData%Nodes)) then
         allocate(DstInitInputData%Nodes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Nodes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyNodeType(SrcInitInputData%Nodes(i1), DstInitInputData%Nodes(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NAxCoefs = SrcInitInputData%NAxCoefs
   if (allocated(SrcInitInputData%AxialCoefs)) then
      LB(1:1) = lbound(SrcInitInputData%AxialCoefs, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%AxialCoefs, kind=B8Ki)
      if (.not. allocated(DstInitInputData%AxialCoefs)) then
         allocate(DstInitInputData%AxialCoefs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AxialCoefs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyAxialCoefType(SrcInitInputData%AxialCoefs(i1), DstInitInputData%AxialCoefs(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NPropSets = SrcInitInputData%NPropSets
   if (allocated(SrcInitInputData%MPropSets)) then
      LB(1:1) = lbound(SrcInitInputData%MPropSets, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%MPropSets, kind=B8Ki)
      if (.not. allocated(DstInitInputData%MPropSets)) then
         allocate(DstInitInputData%MPropSets(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MPropSets.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMemberPropType(SrcInitInputData%MPropSets(i1), DstInitInputData%MPropSets(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%SimplCd = SrcInitInputData%SimplCd
   DstInitInputData%SimplCdMG = SrcInitInputData%SimplCdMG
   DstInitInputData%SimplCa = SrcInitInputData%SimplCa
   DstInitInputData%SimplCaMG = SrcInitInputData%SimplCaMG
   DstInitInputData%SimplCp = SrcInitInputData%SimplCp
   DstInitInputData%SimplCpMG = SrcInitInputData%SimplCpMG
   DstInitInputData%SimplAxCd = SrcInitInputData%SimplAxCd
   DstInitInputData%SimplAxCdMG = SrcInitInputData%SimplAxCdMG
   DstInitInputData%SimplAxCa = SrcInitInputData%SimplAxCa
   DstInitInputData%SimplAxCaMG = SrcInitInputData%SimplAxCaMG
   DstInitInputData%SimplAxCp = SrcInitInputData%SimplAxCp
   DstInitInputData%SimplAxCpMG = SrcInitInputData%SimplAxCpMG
   DstInitInputData%SimplCb = SrcInitInputData%SimplCb
   DstInitInputData%SimplCbMg = SrcInitInputData%SimplCbMg
   DstInitInputData%SimplMCF = SrcInitInputData%SimplMCF
   DstInitInputData%NCoefDpth = SrcInitInputData%NCoefDpth
   if (allocated(SrcInitInputData%CoefDpths)) then
      LB(1:1) = lbound(SrcInitInputData%CoefDpths, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%CoefDpths, kind=B8Ki)
      if (.not. allocated(DstInitInputData%CoefDpths)) then
         allocate(DstInitInputData%CoefDpths(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefDpths.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyCoefDpths(SrcInitInputData%CoefDpths(i1), DstInitInputData%CoefDpths(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NCoefMembers = SrcInitInputData%NCoefMembers
   if (allocated(SrcInitInputData%CoefMembers)) then
      LB(1:1) = lbound(SrcInitInputData%CoefMembers, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%CoefMembers, kind=B8Ki)
      if (.not. allocated(DstInitInputData%CoefMembers)) then
         allocate(DstInitInputData%CoefMembers(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefMembers.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyCoefMembers(SrcInitInputData%CoefMembers(i1), DstInitInputData%CoefMembers(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NMembers = SrcInitInputData%NMembers
   if (allocated(SrcInitInputData%InpMembers)) then
      LB(1:1) = lbound(SrcInitInputData%InpMembers, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%InpMembers, kind=B8Ki)
      if (.not. allocated(DstInitInputData%InpMembers)) then
         allocate(DstInitInputData%InpMembers(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpMembers.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMemberInputType(SrcInitInputData%InpMembers(i1), DstInitInputData%InpMembers(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NFillGroups = SrcInitInputData%NFillGroups
   if (allocated(SrcInitInputData%FilledGroups)) then
      LB(1:1) = lbound(SrcInitInputData%FilledGroups, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%FilledGroups, kind=B8Ki)
      if (.not. allocated(DstInitInputData%FilledGroups)) then
         allocate(DstInitInputData%FilledGroups(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%FilledGroups.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyFilledGroupType(SrcInitInputData%FilledGroups(i1), DstInitInputData%FilledGroups(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NMGDepths = SrcInitInputData%NMGDepths
   if (allocated(SrcInitInputData%MGDepths)) then
      LB(1:1) = lbound(SrcInitInputData%MGDepths, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%MGDepths, kind=B8Ki)
      if (.not. allocated(DstInitInputData%MGDepths)) then
         allocate(DstInitInputData%MGDepths(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MGDepths.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMGDepthsType(SrcInitInputData%MGDepths(i1), DstInitInputData%MGDepths(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%MGTop = SrcInitInputData%MGTop
   DstInitInputData%MGBottom = SrcInitInputData%MGBottom
   DstInitInputData%NMOutputs = SrcInitInputData%NMOutputs
   if (allocated(SrcInitInputData%MOutLst)) then
      LB(1:1) = lbound(SrcInitInputData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%MOutLst, kind=B8Ki)
      if (.not. allocated(DstInitInputData%MOutLst)) then
         allocate(DstInitInputData%MOutLst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MOutLst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMOutput(SrcInitInputData%MOutLst(i1), DstInitInputData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstInitInputData%NJOutputs = SrcInitInputData%NJOutputs
   if (allocated(SrcInitInputData%JOutLst)) then
      LB(1:1) = lbound(SrcInitInputData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%JOutLst, kind=B8Ki)
      if (.not. allocated(DstInitInputData%JOutLst)) then
         allocate(DstInitInputData%JOutLst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%JOutLst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyJOutput(SrcInitInputData%JOutLst(i1), DstInitInputData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInitInputData%OutList)) then
      LB(1:1) = lbound(SrcInitInputData%OutList, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%OutList, kind=B8Ki)
      if (.not. allocated(DstInitInputData%OutList)) then
         allocate(DstInitInputData%OutList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%OutList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%OutList = SrcInitInputData%OutList
   end if
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
   DstInitInputData%UnSum = SrcInitInputData%UnSum
   DstInitInputData%WaveField => SrcInitInputData%WaveField
   DstInitInputData%VisMeshes = SrcInitInputData%VisMeshes
   DstInitInputData%PtfmYMod = SrcInitInputData%PtfmYMod
end subroutine

subroutine Morison_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(Morison_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%InpJoints)) then
      LB(1:1) = lbound(InitInputData%InpJoints, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%InpJoints, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyJointType(InitInputData%InpJoints(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%InpJoints)
   end if
   if (allocated(InitInputData%Nodes)) then
      LB(1:1) = lbound(InitInputData%Nodes, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%Nodes, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyNodeType(InitInputData%Nodes(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%Nodes)
   end if
   if (allocated(InitInputData%AxialCoefs)) then
      LB(1:1) = lbound(InitInputData%AxialCoefs, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%AxialCoefs, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyAxialCoefType(InitInputData%AxialCoefs(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%AxialCoefs)
   end if
   if (allocated(InitInputData%MPropSets)) then
      LB(1:1) = lbound(InitInputData%MPropSets, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%MPropSets, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMemberPropType(InitInputData%MPropSets(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%MPropSets)
   end if
   if (allocated(InitInputData%CoefDpths)) then
      LB(1:1) = lbound(InitInputData%CoefDpths, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%CoefDpths, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyCoefDpths(InitInputData%CoefDpths(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%CoefDpths)
   end if
   if (allocated(InitInputData%CoefMembers)) then
      LB(1:1) = lbound(InitInputData%CoefMembers, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%CoefMembers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyCoefMembers(InitInputData%CoefMembers(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%CoefMembers)
   end if
   if (allocated(InitInputData%InpMembers)) then
      LB(1:1) = lbound(InitInputData%InpMembers, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%InpMembers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMemberInputType(InitInputData%InpMembers(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%InpMembers)
   end if
   if (allocated(InitInputData%FilledGroups)) then
      LB(1:1) = lbound(InitInputData%FilledGroups, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%FilledGroups, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyFilledGroupType(InitInputData%FilledGroups(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%FilledGroups)
   end if
   if (allocated(InitInputData%MGDepths)) then
      LB(1:1) = lbound(InitInputData%MGDepths, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%MGDepths, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMGDepthsType(InitInputData%MGDepths(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%MGDepths)
   end if
   if (allocated(InitInputData%MOutLst)) then
      LB(1:1) = lbound(InitInputData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%MOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMOutput(InitInputData%MOutLst(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%MOutLst)
   end if
   if (allocated(InitInputData%JOutLst)) then
      LB(1:1) = lbound(InitInputData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(InitInputData%JOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyJOutput(InitInputData%JOutLst(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitInputData%JOutLst)
   end if
   if (allocated(InitInputData%OutList)) then
      deallocate(InitInputData%OutList)
   end if
   nullify(InitInputData%WaveField)
end subroutine

subroutine Morison_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackInitInput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%WaveDisp)
   call RegPack(RF, InData%AMMod)
   call RegPack(RF, InData%NJoints)
   call RegPack(RF, InData%NNodes)
   call RegPack(RF, allocated(InData%InpJoints))
   if (allocated(InData%InpJoints)) then
      call RegPackBounds(RF, 1, lbound(InData%InpJoints, kind=B8Ki), ubound(InData%InpJoints, kind=B8Ki))
      LB(1:1) = lbound(InData%InpJoints, kind=B8Ki)
      UB(1:1) = ubound(InData%InpJoints, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackJointType(RF, InData%InpJoints(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Nodes))
   if (allocated(InData%Nodes)) then
      call RegPackBounds(RF, 1, lbound(InData%Nodes, kind=B8Ki), ubound(InData%Nodes, kind=B8Ki))
      LB(1:1) = lbound(InData%Nodes, kind=B8Ki)
      UB(1:1) = ubound(InData%Nodes, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackNodeType(RF, InData%Nodes(i1)) 
      end do
   end if
   call RegPack(RF, InData%NAxCoefs)
   call RegPack(RF, allocated(InData%AxialCoefs))
   if (allocated(InData%AxialCoefs)) then
      call RegPackBounds(RF, 1, lbound(InData%AxialCoefs, kind=B8Ki), ubound(InData%AxialCoefs, kind=B8Ki))
      LB(1:1) = lbound(InData%AxialCoefs, kind=B8Ki)
      UB(1:1) = ubound(InData%AxialCoefs, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackAxialCoefType(RF, InData%AxialCoefs(i1)) 
      end do
   end if
   call RegPack(RF, InData%NPropSets)
   call RegPack(RF, allocated(InData%MPropSets))
   if (allocated(InData%MPropSets)) then
      call RegPackBounds(RF, 1, lbound(InData%MPropSets, kind=B8Ki), ubound(InData%MPropSets, kind=B8Ki))
      LB(1:1) = lbound(InData%MPropSets, kind=B8Ki)
      UB(1:1) = ubound(InData%MPropSets, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMemberPropType(RF, InData%MPropSets(i1)) 
      end do
   end if
   call RegPack(RF, InData%SimplCd)
   call RegPack(RF, InData%SimplCdMG)
   call RegPack(RF, InData%SimplCa)
   call RegPack(RF, InData%SimplCaMG)
   call RegPack(RF, InData%SimplCp)
   call RegPack(RF, InData%SimplCpMG)
   call RegPack(RF, InData%SimplAxCd)
   call RegPack(RF, InData%SimplAxCdMG)
   call RegPack(RF, InData%SimplAxCa)
   call RegPack(RF, InData%SimplAxCaMG)
   call RegPack(RF, InData%SimplAxCp)
   call RegPack(RF, InData%SimplAxCpMG)
   call RegPack(RF, InData%SimplCb)
   call RegPack(RF, InData%SimplCbMg)
   call RegPack(RF, InData%SimplMCF)
   call RegPack(RF, InData%NCoefDpth)
   call RegPack(RF, allocated(InData%CoefDpths))
   if (allocated(InData%CoefDpths)) then
      call RegPackBounds(RF, 1, lbound(InData%CoefDpths, kind=B8Ki), ubound(InData%CoefDpths, kind=B8Ki))
      LB(1:1) = lbound(InData%CoefDpths, kind=B8Ki)
      UB(1:1) = ubound(InData%CoefDpths, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackCoefDpths(RF, InData%CoefDpths(i1)) 
      end do
   end if
   call RegPack(RF, InData%NCoefMembers)
   call RegPack(RF, allocated(InData%CoefMembers))
   if (allocated(InData%CoefMembers)) then
      call RegPackBounds(RF, 1, lbound(InData%CoefMembers, kind=B8Ki), ubound(InData%CoefMembers, kind=B8Ki))
      LB(1:1) = lbound(InData%CoefMembers, kind=B8Ki)
      UB(1:1) = ubound(InData%CoefMembers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackCoefMembers(RF, InData%CoefMembers(i1)) 
      end do
   end if
   call RegPack(RF, InData%NMembers)
   call RegPack(RF, allocated(InData%InpMembers))
   if (allocated(InData%InpMembers)) then
      call RegPackBounds(RF, 1, lbound(InData%InpMembers, kind=B8Ki), ubound(InData%InpMembers, kind=B8Ki))
      LB(1:1) = lbound(InData%InpMembers, kind=B8Ki)
      UB(1:1) = ubound(InData%InpMembers, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMemberInputType(RF, InData%InpMembers(i1)) 
      end do
   end if
   call RegPack(RF, InData%NFillGroups)
   call RegPack(RF, allocated(InData%FilledGroups))
   if (allocated(InData%FilledGroups)) then
      call RegPackBounds(RF, 1, lbound(InData%FilledGroups, kind=B8Ki), ubound(InData%FilledGroups, kind=B8Ki))
      LB(1:1) = lbound(InData%FilledGroups, kind=B8Ki)
      UB(1:1) = ubound(InData%FilledGroups, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackFilledGroupType(RF, InData%FilledGroups(i1)) 
      end do
   end if
   call RegPack(RF, InData%NMGDepths)
   call RegPack(RF, allocated(InData%MGDepths))
   if (allocated(InData%MGDepths)) then
      call RegPackBounds(RF, 1, lbound(InData%MGDepths, kind=B8Ki), ubound(InData%MGDepths, kind=B8Ki))
      LB(1:1) = lbound(InData%MGDepths, kind=B8Ki)
      UB(1:1) = ubound(InData%MGDepths, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMGDepthsType(RF, InData%MGDepths(i1)) 
      end do
   end if
   call RegPack(RF, InData%MGTop)
   call RegPack(RF, InData%MGBottom)
   call RegPack(RF, InData%NMOutputs)
   call RegPack(RF, allocated(InData%MOutLst))
   if (allocated(InData%MOutLst)) then
      call RegPackBounds(RF, 1, lbound(InData%MOutLst, kind=B8Ki), ubound(InData%MOutLst, kind=B8Ki))
      LB(1:1) = lbound(InData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(InData%MOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMOutput(RF, InData%MOutLst(i1)) 
      end do
   end if
   call RegPack(RF, InData%NJOutputs)
   call RegPack(RF, allocated(InData%JOutLst))
   if (allocated(InData%JOutLst)) then
      call RegPackBounds(RF, 1, lbound(InData%JOutLst, kind=B8Ki), ubound(InData%JOutLst, kind=B8Ki))
      LB(1:1) = lbound(InData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(InData%JOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackJOutput(RF, InData%JOutLst(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%OutList)
   call RegPack(RF, InData%NumOuts)
   call RegPack(RF, InData%UnSum)
   call RegPack(RF, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(RF, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(RF, InData%WaveField) 
      end if
   end if
   call RegPack(RF, InData%VisMeshes)
   call RegPack(RF, InData%PtfmYMod)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackInitInput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AMMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NJoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NNodes); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%InpJoints)) deallocate(OutData%InpJoints)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%InpJoints(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InpJoints.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackJointType(RF, OutData%InpJoints(i1)) ! InpJoints 
      end do
   end if
   if (allocated(OutData%Nodes)) deallocate(OutData%Nodes)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Nodes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackNodeType(RF, OutData%Nodes(i1)) ! Nodes 
      end do
   end if
   call RegUnpack(RF, OutData%NAxCoefs); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%AxialCoefs)) deallocate(OutData%AxialCoefs)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%AxialCoefs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AxialCoefs.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackAxialCoefType(RF, OutData%AxialCoefs(i1)) ! AxialCoefs 
      end do
   end if
   call RegUnpack(RF, OutData%NPropSets); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%MPropSets)) deallocate(OutData%MPropSets)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%MPropSets(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MPropSets.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMemberPropType(RF, OutData%MPropSets(i1)) ! MPropSets 
      end do
   end if
   call RegUnpack(RF, OutData%SimplCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCdMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCaMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCpMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCdMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCaMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplAxCpMG); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplCbMg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimplMCF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NCoefDpth); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%CoefDpths)) deallocate(OutData%CoefDpths)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%CoefDpths(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoefDpths.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackCoefDpths(RF, OutData%CoefDpths(i1)) ! CoefDpths 
      end do
   end if
   call RegUnpack(RF, OutData%NCoefMembers); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%CoefMembers)) deallocate(OutData%CoefMembers)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%CoefMembers(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoefMembers.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackCoefMembers(RF, OutData%CoefMembers(i1)) ! CoefMembers 
      end do
   end if
   call RegUnpack(RF, OutData%NMembers); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%InpMembers)) deallocate(OutData%InpMembers)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%InpMembers(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InpMembers.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMemberInputType(RF, OutData%InpMembers(i1)) ! InpMembers 
      end do
   end if
   call RegUnpack(RF, OutData%NFillGroups); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%FilledGroups)) deallocate(OutData%FilledGroups)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%FilledGroups(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FilledGroups.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackFilledGroupType(RF, OutData%FilledGroups(i1)) ! FilledGroups 
      end do
   end if
   call RegUnpack(RF, OutData%NMGDepths); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%MGDepths)) deallocate(OutData%MGDepths)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%MGDepths(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MGDepths.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMGDepthsType(RF, OutData%MGDepths(i1)) ! MGDepths 
      end do
   end if
   call RegUnpack(RF, OutData%MGTop); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MGBottom); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NMOutputs); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%MOutLst)) deallocate(OutData%MOutLst)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%MOutLst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MOutLst.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMOutput(RF, OutData%MOutLst(i1)) ! MOutLst 
      end do
   end if
   call RegUnpack(RF, OutData%NJOutputs); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%JOutLst)) deallocate(OutData%JOutLst)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%JOutLst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%JOutLst.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackJOutput(RF, OutData%JOutLst(i1)) ! JOutLst 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%OutList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumOuts); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnSum); if (RegCheckErr(RF, RoutineName)) return
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(RF, Ptr, PtrIdx); if (RegCheckErr(RF, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', RF%ErrStat, RF%ErrMsg, RoutineName)
            return
         end if
         RF%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(RF, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
   call RegUnpack(RF, OutData%VisMeshes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmYMod); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_InitOutputType), intent(in) :: SrcInitOutputData
   type(Morison_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitOutputData%MorisonVisRad)) then
      LB(1:1) = lbound(SrcInitOutputData%MorisonVisRad, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%MorisonVisRad, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%MorisonVisRad)) then
         allocate(DstInitOutputData%MorisonVisRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%MorisonVisRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%MorisonVisRad = SrcInitOutputData%MorisonVisRad
   end if
   if (allocated(SrcInitOutputData%WriteOutputHdr)) then
      LB(1:1) = lbound(SrcInitOutputData%WriteOutputHdr, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%WriteOutputHdr, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%WriteOutputHdr)) then
         allocate(DstInitOutputData%WriteOutputHdr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
   end if
   if (allocated(SrcInitOutputData%WriteOutputUnt)) then
      LB(1:1) = lbound(SrcInitOutputData%WriteOutputUnt, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%WriteOutputUnt, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%WriteOutputUnt)) then
         allocate(DstInitOutputData%WriteOutputUnt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
   end if
end subroutine

subroutine Morison_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(Morison_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitOutputData%MorisonVisRad)) then
      deallocate(InitOutputData%MorisonVisRad)
   end if
   if (allocated(InitOutputData%WriteOutputHdr)) then
      deallocate(InitOutputData%WriteOutputHdr)
   end if
   if (allocated(InitOutputData%WriteOutputUnt)) then
      deallocate(InitOutputData%WriteOutputUnt)
   end if
end subroutine

subroutine Morison_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%MorisonVisRad)
   call RegPackAlloc(RF, InData%WriteOutputHdr)
   call RegPackAlloc(RF, InData%WriteOutputUnt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackInitOutput'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%MorisonVisRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputHdr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WriteOutputUnt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_ContinuousStateType), intent(in) :: SrcContStateData
   type(Morison_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstContStateData%DummyContState = SrcContStateData%DummyContState
end subroutine

subroutine Morison_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(Morison_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackContState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackContState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DummyContState)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackContState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackContState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DummyContState); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(Morison_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Morison_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcDiscStateData%V_rel_n_FiltStat)) then
      LB(1:1) = lbound(SrcDiscStateData%V_rel_n_FiltStat, kind=B8Ki)
      UB(1:1) = ubound(SrcDiscStateData%V_rel_n_FiltStat, kind=B8Ki)
      if (.not. allocated(DstDiscStateData%V_rel_n_FiltStat)) then
         allocate(DstDiscStateData%V_rel_n_FiltStat(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%V_rel_n_FiltStat.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstDiscStateData%V_rel_n_FiltStat = SrcDiscStateData%V_rel_n_FiltStat
   end if
end subroutine

subroutine Morison_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(Morison_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(DiscStateData%V_rel_n_FiltStat)) then
      deallocate(DiscStateData%V_rel_n_FiltStat)
   end if
end subroutine

subroutine Morison_PackDiscState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackDiscState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%V_rel_n_FiltStat)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackDiscState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackDiscState'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%V_rel_n_FiltStat); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(Morison_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
end subroutine

subroutine Morison_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(Morison_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackConstrState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackConstrState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DummyConstrState)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackConstrState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackConstrState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DummyConstrState); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_OtherStateType), intent(in) :: SrcOtherStateData
   type(Morison_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
end subroutine

subroutine Morison_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(Morison_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Morison_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Morison_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DummyOtherState)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackOtherState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DummyOtherState); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_MiscVarType), intent(inout) :: SrcMiscData
   type(Morison_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%DispNodePosHdn)) then
      LB(1:2) = lbound(SrcMiscData%DispNodePosHdn, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%DispNodePosHdn, kind=B8Ki)
      if (.not. allocated(DstMiscData%DispNodePosHdn)) then
         allocate(DstMiscData%DispNodePosHdn(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%DispNodePosHdn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%DispNodePosHdn = SrcMiscData%DispNodePosHdn
   end if
   if (allocated(SrcMiscData%DispNodePosHst)) then
      LB(1:2) = lbound(SrcMiscData%DispNodePosHst, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%DispNodePosHst, kind=B8Ki)
      if (.not. allocated(DstMiscData%DispNodePosHst)) then
         allocate(DstMiscData%DispNodePosHst(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%DispNodePosHst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%DispNodePosHst = SrcMiscData%DispNodePosHst
   end if
   if (allocated(SrcMiscData%FV)) then
      LB(1:2) = lbound(SrcMiscData%FV, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%FV, kind=B8Ki)
      if (.not. allocated(DstMiscData%FV)) then
         allocate(DstMiscData%FV(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FV = SrcMiscData%FV
   end if
   if (allocated(SrcMiscData%FA)) then
      LB(1:2) = lbound(SrcMiscData%FA, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%FA, kind=B8Ki)
      if (.not. allocated(DstMiscData%FA)) then
         allocate(DstMiscData%FA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FA = SrcMiscData%FA
   end if
   if (allocated(SrcMiscData%FAMCF)) then
      LB(1:2) = lbound(SrcMiscData%FAMCF, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%FAMCF, kind=B8Ki)
      if (.not. allocated(DstMiscData%FAMCF)) then
         allocate(DstMiscData%FAMCF(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FAMCF.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FAMCF = SrcMiscData%FAMCF
   end if
   if (allocated(SrcMiscData%FDynP)) then
      LB(1:1) = lbound(SrcMiscData%FDynP, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FDynP, kind=B8Ki)
      if (.not. allocated(DstMiscData%FDynP)) then
         allocate(DstMiscData%FDynP(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FDynP.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FDynP = SrcMiscData%FDynP
   end if
   if (allocated(SrcMiscData%WaveElev)) then
      LB(1:1) = lbound(SrcMiscData%WaveElev, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%WaveElev, kind=B8Ki)
      if (.not. allocated(DstMiscData%WaveElev)) then
         allocate(DstMiscData%WaveElev(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WaveElev.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WaveElev = SrcMiscData%WaveElev
   end if
   if (allocated(SrcMiscData%WaveElev1)) then
      LB(1:1) = lbound(SrcMiscData%WaveElev1, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%WaveElev1, kind=B8Ki)
      if (.not. allocated(DstMiscData%WaveElev1)) then
         allocate(DstMiscData%WaveElev1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WaveElev1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WaveElev1 = SrcMiscData%WaveElev1
   end if
   if (allocated(SrcMiscData%WaveElev2)) then
      LB(1:1) = lbound(SrcMiscData%WaveElev2, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%WaveElev2, kind=B8Ki)
      if (.not. allocated(DstMiscData%WaveElev2)) then
         allocate(DstMiscData%WaveElev2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WaveElev2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%WaveElev2 = SrcMiscData%WaveElev2
   end if
   if (allocated(SrcMiscData%vrel)) then
      LB(1:2) = lbound(SrcMiscData%vrel, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%vrel, kind=B8Ki)
      if (.not. allocated(DstMiscData%vrel)) then
         allocate(DstMiscData%vrel(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vrel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%vrel = SrcMiscData%vrel
   end if
   if (allocated(SrcMiscData%nodeInWater)) then
      LB(1:1) = lbound(SrcMiscData%nodeInWater, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%nodeInWater, kind=B8Ki)
      if (.not. allocated(DstMiscData%nodeInWater)) then
         allocate(DstMiscData%nodeInWater(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%nodeInWater.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%nodeInWater = SrcMiscData%nodeInWater
   end if
   if (allocated(SrcMiscData%memberLoads)) then
      LB(1:1) = lbound(SrcMiscData%memberLoads, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%memberLoads, kind=B8Ki)
      if (.not. allocated(DstMiscData%memberLoads)) then
         allocate(DstMiscData%memberLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%memberLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMemberLoads(SrcMiscData%memberLoads(i1), DstMiscData%memberLoads(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%F_B_End)) then
      LB(1:2) = lbound(SrcMiscData%F_B_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_B_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_B_End)) then
         allocate(DstMiscData%F_B_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_B_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_B_End = SrcMiscData%F_B_End
   end if
   if (allocated(SrcMiscData%F_D_End)) then
      LB(1:2) = lbound(SrcMiscData%F_D_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_D_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_D_End)) then
         allocate(DstMiscData%F_D_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_D_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_D_End = SrcMiscData%F_D_End
   end if
   if (allocated(SrcMiscData%F_I_End)) then
      LB(1:2) = lbound(SrcMiscData%F_I_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_I_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_I_End)) then
         allocate(DstMiscData%F_I_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_I_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_I_End = SrcMiscData%F_I_End
   end if
   if (allocated(SrcMiscData%F_IMG_End)) then
      LB(1:2) = lbound(SrcMiscData%F_IMG_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_IMG_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_IMG_End)) then
         allocate(DstMiscData%F_IMG_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_IMG_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_IMG_End = SrcMiscData%F_IMG_End
   end if
   if (allocated(SrcMiscData%F_A_End)) then
      LB(1:2) = lbound(SrcMiscData%F_A_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_A_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_A_End)) then
         allocate(DstMiscData%F_A_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_A_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_A_End = SrcMiscData%F_A_End
   end if
   if (allocated(SrcMiscData%F_BF_End)) then
      LB(1:2) = lbound(SrcMiscData%F_BF_End, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%F_BF_End, kind=B8Ki)
      if (.not. allocated(DstMiscData%F_BF_End)) then
         allocate(DstMiscData%F_BF_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_BF_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%F_BF_End = SrcMiscData%F_BF_End
   end if
   if (allocated(SrcMiscData%V_rel_n)) then
      LB(1:1) = lbound(SrcMiscData%V_rel_n, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%V_rel_n, kind=B8Ki)
      if (.not. allocated(DstMiscData%V_rel_n)) then
         allocate(DstMiscData%V_rel_n(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%V_rel_n.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%V_rel_n = SrcMiscData%V_rel_n
   end if
   if (allocated(SrcMiscData%V_rel_n_HiPass)) then
      LB(1:1) = lbound(SrcMiscData%V_rel_n_HiPass, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%V_rel_n_HiPass, kind=B8Ki)
      if (.not. allocated(DstMiscData%V_rel_n_HiPass)) then
         allocate(DstMiscData%V_rel_n_HiPass(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%V_rel_n_HiPass.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%V_rel_n_HiPass = SrcMiscData%V_rel_n_HiPass
   end if
   call NWTC_Library_CopyMeshMapType(SrcMiscData%VisMeshMap, DstMiscData%VisMeshMap, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SeaSt_WaveField_CopyMisc(SrcMiscData%WaveField_m, DstMiscData%WaveField_m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Morison_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(Morison_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%DispNodePosHdn)) then
      deallocate(MiscData%DispNodePosHdn)
   end if
   if (allocated(MiscData%DispNodePosHst)) then
      deallocate(MiscData%DispNodePosHst)
   end if
   if (allocated(MiscData%FV)) then
      deallocate(MiscData%FV)
   end if
   if (allocated(MiscData%FA)) then
      deallocate(MiscData%FA)
   end if
   if (allocated(MiscData%FAMCF)) then
      deallocate(MiscData%FAMCF)
   end if
   if (allocated(MiscData%FDynP)) then
      deallocate(MiscData%FDynP)
   end if
   if (allocated(MiscData%WaveElev)) then
      deallocate(MiscData%WaveElev)
   end if
   if (allocated(MiscData%WaveElev1)) then
      deallocate(MiscData%WaveElev1)
   end if
   if (allocated(MiscData%WaveElev2)) then
      deallocate(MiscData%WaveElev2)
   end if
   if (allocated(MiscData%vrel)) then
      deallocate(MiscData%vrel)
   end if
   if (allocated(MiscData%nodeInWater)) then
      deallocate(MiscData%nodeInWater)
   end if
   if (allocated(MiscData%memberLoads)) then
      LB(1:1) = lbound(MiscData%memberLoads, kind=B8Ki)
      UB(1:1) = ubound(MiscData%memberLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMemberLoads(MiscData%memberLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%memberLoads)
   end if
   if (allocated(MiscData%F_B_End)) then
      deallocate(MiscData%F_B_End)
   end if
   if (allocated(MiscData%F_D_End)) then
      deallocate(MiscData%F_D_End)
   end if
   if (allocated(MiscData%F_I_End)) then
      deallocate(MiscData%F_I_End)
   end if
   if (allocated(MiscData%F_IMG_End)) then
      deallocate(MiscData%F_IMG_End)
   end if
   if (allocated(MiscData%F_A_End)) then
      deallocate(MiscData%F_A_End)
   end if
   if (allocated(MiscData%F_BF_End)) then
      deallocate(MiscData%F_BF_End)
   end if
   if (allocated(MiscData%V_rel_n)) then
      deallocate(MiscData%V_rel_n)
   end if
   if (allocated(MiscData%V_rel_n_HiPass)) then
      deallocate(MiscData%V_rel_n_HiPass)
   end if
   call NWTC_Library_DestroyMeshMapType(MiscData%VisMeshMap, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SeaSt_WaveField_DestroyMisc(MiscData%WaveField_m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Morison_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%DispNodePosHdn)
   call RegPackAlloc(RF, InData%DispNodePosHst)
   call RegPackAlloc(RF, InData%FV)
   call RegPackAlloc(RF, InData%FA)
   call RegPackAlloc(RF, InData%FAMCF)
   call RegPackAlloc(RF, InData%FDynP)
   call RegPackAlloc(RF, InData%WaveElev)
   call RegPackAlloc(RF, InData%WaveElev1)
   call RegPackAlloc(RF, InData%WaveElev2)
   call RegPackAlloc(RF, InData%vrel)
   call RegPackAlloc(RF, InData%nodeInWater)
   call RegPack(RF, allocated(InData%memberLoads))
   if (allocated(InData%memberLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%memberLoads, kind=B8Ki), ubound(InData%memberLoads, kind=B8Ki))
      LB(1:1) = lbound(InData%memberLoads, kind=B8Ki)
      UB(1:1) = ubound(InData%memberLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMemberLoads(RF, InData%memberLoads(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%F_B_End)
   call RegPackAlloc(RF, InData%F_D_End)
   call RegPackAlloc(RF, InData%F_I_End)
   call RegPackAlloc(RF, InData%F_IMG_End)
   call RegPackAlloc(RF, InData%F_A_End)
   call RegPackAlloc(RF, InData%F_BF_End)
   call RegPackAlloc(RF, InData%V_rel_n)
   call RegPackAlloc(RF, InData%V_rel_n_HiPass)
   call NWTC_Library_PackMeshMapType(RF, InData%VisMeshMap) 
   call SeaSt_WaveField_PackMisc(RF, InData%WaveField_m) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%DispNodePosHdn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DispNodePosHst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FAMCF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FDynP); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElev); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElev1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElev2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%vrel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%nodeInWater); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%memberLoads)) deallocate(OutData%memberLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%memberLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%memberLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMemberLoads(RF, OutData%memberLoads(i1)) ! memberLoads 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%F_B_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_D_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_I_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_IMG_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_A_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_BF_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%V_rel_n); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%V_rel_n_HiPass); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%VisMeshMap) ! VisMeshMap 
   call SeaSt_WaveField_UnpackMisc(RF, OutData%WaveField_m) ! WaveField_m 
end subroutine

subroutine Morison_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_ParameterType), intent(in) :: SrcParamData
   type(Morison_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT = SrcParamData%DT
   DstParamData%Gravity = SrcParamData%Gravity
   DstParamData%WaveDisp = SrcParamData%WaveDisp
   DstParamData%AMMod = SrcParamData%AMMod
   DstParamData%NMembers = SrcParamData%NMembers
   if (allocated(SrcParamData%Members)) then
      LB(1:1) = lbound(SrcParamData%Members, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%Members, kind=B8Ki)
      if (.not. allocated(DstParamData%Members)) then
         allocate(DstParamData%Members(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Members.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMemberType(SrcParamData%Members(i1), DstParamData%Members(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%NNodes = SrcParamData%NNodes
   DstParamData%NJoints = SrcParamData%NJoints
   if (allocated(SrcParamData%I_MG_End)) then
      LB(1:3) = lbound(SrcParamData%I_MG_End, kind=B8Ki)
      UB(1:3) = ubound(SrcParamData%I_MG_End, kind=B8Ki)
      if (.not. allocated(DstParamData%I_MG_End)) then
         allocate(DstParamData%I_MG_End(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%I_MG_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%I_MG_End = SrcParamData%I_MG_End
   end if
   if (allocated(SrcParamData%An_End)) then
      LB(1:2) = lbound(SrcParamData%An_End, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%An_End, kind=B8Ki)
      if (.not. allocated(DstParamData%An_End)) then
         allocate(DstParamData%An_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%An_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%An_End = SrcParamData%An_End
   end if
   if (allocated(SrcParamData%DragConst_End)) then
      LB(1:1) = lbound(SrcParamData%DragConst_End, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%DragConst_End, kind=B8Ki)
      if (.not. allocated(DstParamData%DragConst_End)) then
         allocate(DstParamData%DragConst_End(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DragConst_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%DragConst_End = SrcParamData%DragConst_End
   end if
   if (allocated(SrcParamData%VRelNFiltConst)) then
      LB(1:1) = lbound(SrcParamData%VRelNFiltConst, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%VRelNFiltConst, kind=B8Ki)
      if (.not. allocated(DstParamData%VRelNFiltConst)) then
         allocate(DstParamData%VRelNFiltConst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%VRelNFiltConst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%VRelNFiltConst = SrcParamData%VRelNFiltConst
   end if
   if (allocated(SrcParamData%DragMod_End)) then
      LB(1:1) = lbound(SrcParamData%DragMod_End, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%DragMod_End, kind=B8Ki)
      if (.not. allocated(DstParamData%DragMod_End)) then
         allocate(DstParamData%DragMod_End(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DragMod_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%DragMod_End = SrcParamData%DragMod_End
   end if
   if (allocated(SrcParamData%DragLoFSc_End)) then
      LB(1:1) = lbound(SrcParamData%DragLoFSc_End, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%DragLoFSc_End, kind=B8Ki)
      if (.not. allocated(DstParamData%DragLoFSc_End)) then
         allocate(DstParamData%DragLoFSc_End(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DragLoFSc_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%DragLoFSc_End = SrcParamData%DragLoFSc_End
   end if
   if (allocated(SrcParamData%F_WMG_End)) then
      LB(1:2) = lbound(SrcParamData%F_WMG_End, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%F_WMG_End, kind=B8Ki)
      if (.not. allocated(DstParamData%F_WMG_End)) then
         allocate(DstParamData%F_WMG_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%F_WMG_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%F_WMG_End = SrcParamData%F_WMG_End
   end if
   if (allocated(SrcParamData%DP_Const_End)) then
      LB(1:2) = lbound(SrcParamData%DP_Const_End, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%DP_Const_End, kind=B8Ki)
      if (.not. allocated(DstParamData%DP_Const_End)) then
         allocate(DstParamData%DP_Const_End(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DP_Const_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%DP_Const_End = SrcParamData%DP_Const_End
   end if
   if (allocated(SrcParamData%Mass_MG_End)) then
      LB(1:1) = lbound(SrcParamData%Mass_MG_End, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%Mass_MG_End, kind=B8Ki)
      if (.not. allocated(DstParamData%Mass_MG_End)) then
         allocate(DstParamData%Mass_MG_End(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Mass_MG_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%Mass_MG_End = SrcParamData%Mass_MG_End
   end if
   if (allocated(SrcParamData%AM_End)) then
      LB(1:3) = lbound(SrcParamData%AM_End, kind=B8Ki)
      UB(1:3) = ubound(SrcParamData%AM_End, kind=B8Ki)
      if (.not. allocated(DstParamData%AM_End)) then
         allocate(DstParamData%AM_End(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM_End.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%AM_End = SrcParamData%AM_End
   end if
   DstParamData%NMOutputs = SrcParamData%NMOutputs
   if (allocated(SrcParamData%MOutLst)) then
      LB(1:1) = lbound(SrcParamData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%MOutLst, kind=B8Ki)
      if (.not. allocated(DstParamData%MOutLst)) then
         allocate(DstParamData%MOutLst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MOutLst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyMOutput(SrcParamData%MOutLst(i1), DstParamData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%NJOutputs = SrcParamData%NJOutputs
   if (allocated(SrcParamData%JOutLst)) then
      LB(1:1) = lbound(SrcParamData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%JOutLst, kind=B8Ki)
      if (.not. allocated(DstParamData%JOutLst)) then
         allocate(DstParamData%JOutLst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%JOutLst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Morison_CopyJOutput(SrcParamData%JOutLst(i1), DstParamData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcParamData%OutParam)) then
      LB(1:1) = lbound(SrcParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%OutParam, kind=B8Ki)
      if (.not. allocated(DstParamData%OutParam)) then
         allocate(DstParamData%OutParam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyOutParmType(SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%WaveField => SrcParamData%WaveField
   DstParamData%VisMeshes = SrcParamData%VisMeshes
   DstParamData%PtfmYMod = SrcParamData%PtfmYMod
end subroutine

subroutine Morison_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(Morison_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%Members)) then
      LB(1:1) = lbound(ParamData%Members, kind=B8Ki)
      UB(1:1) = ubound(ParamData%Members, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMemberType(ParamData%Members(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%Members)
   end if
   if (allocated(ParamData%I_MG_End)) then
      deallocate(ParamData%I_MG_End)
   end if
   if (allocated(ParamData%An_End)) then
      deallocate(ParamData%An_End)
   end if
   if (allocated(ParamData%DragConst_End)) then
      deallocate(ParamData%DragConst_End)
   end if
   if (allocated(ParamData%VRelNFiltConst)) then
      deallocate(ParamData%VRelNFiltConst)
   end if
   if (allocated(ParamData%DragMod_End)) then
      deallocate(ParamData%DragMod_End)
   end if
   if (allocated(ParamData%DragLoFSc_End)) then
      deallocate(ParamData%DragLoFSc_End)
   end if
   if (allocated(ParamData%F_WMG_End)) then
      deallocate(ParamData%F_WMG_End)
   end if
   if (allocated(ParamData%DP_Const_End)) then
      deallocate(ParamData%DP_Const_End)
   end if
   if (allocated(ParamData%Mass_MG_End)) then
      deallocate(ParamData%Mass_MG_End)
   end if
   if (allocated(ParamData%AM_End)) then
      deallocate(ParamData%AM_End)
   end if
   if (allocated(ParamData%MOutLst)) then
      LB(1:1) = lbound(ParamData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(ParamData%MOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyMOutput(ParamData%MOutLst(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%MOutLst)
   end if
   if (allocated(ParamData%JOutLst)) then
      LB(1:1) = lbound(ParamData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(ParamData%JOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_DestroyJOutput(ParamData%JOutLst(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%JOutLst)
   end if
   if (allocated(ParamData%OutParam)) then
      LB(1:1) = lbound(ParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(ParamData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyOutParmType(ParamData%OutParam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%OutParam)
   end if
   nullify(ParamData%WaveField)
end subroutine

subroutine Morison_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackParam'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%WaveDisp)
   call RegPack(RF, InData%AMMod)
   call RegPack(RF, InData%NMembers)
   call RegPack(RF, allocated(InData%Members))
   if (allocated(InData%Members)) then
      call RegPackBounds(RF, 1, lbound(InData%Members, kind=B8Ki), ubound(InData%Members, kind=B8Ki))
      LB(1:1) = lbound(InData%Members, kind=B8Ki)
      UB(1:1) = ubound(InData%Members, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMemberType(RF, InData%Members(i1)) 
      end do
   end if
   call RegPack(RF, InData%NNodes)
   call RegPack(RF, InData%NJoints)
   call RegPackAlloc(RF, InData%I_MG_End)
   call RegPackAlloc(RF, InData%An_End)
   call RegPackAlloc(RF, InData%DragConst_End)
   call RegPackAlloc(RF, InData%VRelNFiltConst)
   call RegPackAlloc(RF, InData%DragMod_End)
   call RegPackAlloc(RF, InData%DragLoFSc_End)
   call RegPackAlloc(RF, InData%F_WMG_End)
   call RegPackAlloc(RF, InData%DP_Const_End)
   call RegPackAlloc(RF, InData%Mass_MG_End)
   call RegPackAlloc(RF, InData%AM_End)
   call RegPack(RF, InData%NMOutputs)
   call RegPack(RF, allocated(InData%MOutLst))
   if (allocated(InData%MOutLst)) then
      call RegPackBounds(RF, 1, lbound(InData%MOutLst, kind=B8Ki), ubound(InData%MOutLst, kind=B8Ki))
      LB(1:1) = lbound(InData%MOutLst, kind=B8Ki)
      UB(1:1) = ubound(InData%MOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackMOutput(RF, InData%MOutLst(i1)) 
      end do
   end if
   call RegPack(RF, InData%NJOutputs)
   call RegPack(RF, allocated(InData%JOutLst))
   if (allocated(InData%JOutLst)) then
      call RegPackBounds(RF, 1, lbound(InData%JOutLst, kind=B8Ki), ubound(InData%JOutLst, kind=B8Ki))
      LB(1:1) = lbound(InData%JOutLst, kind=B8Ki)
      UB(1:1) = ubound(InData%JOutLst, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Morison_PackJOutput(RF, InData%JOutLst(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(RF, 1, lbound(InData%OutParam, kind=B8Ki), ubound(InData%OutParam, kind=B8Ki))
      LB(1:1) = lbound(InData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(InData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(RF, InData%OutParam(i1)) 
      end do
   end if
   call RegPack(RF, InData%NumOuts)
   call RegPack(RF, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(RF, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(RF, InData%WaveField) 
      end if
   end if
   call RegPack(RF, InData%VisMeshes)
   call RegPack(RF, InData%PtfmYMod)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackParam'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AMMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NMembers); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%Members)) deallocate(OutData%Members)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Members(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Members.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMemberType(RF, OutData%Members(i1)) ! Members 
      end do
   end if
   call RegUnpack(RF, OutData%NNodes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NJoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%I_MG_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%An_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DragConst_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%VRelNFiltConst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DragMod_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DragLoFSc_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%F_WMG_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DP_Const_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Mass_MG_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AM_End); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NMOutputs); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%MOutLst)) deallocate(OutData%MOutLst)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%MOutLst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MOutLst.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackMOutput(RF, OutData%MOutLst(i1)) ! MOutLst 
      end do
   end if
   call RegUnpack(RF, OutData%NJOutputs); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%JOutLst)) deallocate(OutData%JOutLst)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%JOutLst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%JOutLst.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Morison_UnpackJOutput(RF, OutData%JOutLst(i1)) ! JOutLst 
      end do
   end if
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(RF, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   call RegUnpack(RF, OutData%NumOuts); if (RegCheckErr(RF, RoutineName)) return
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(RF, Ptr, PtrIdx); if (RegCheckErr(RF, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', RF%ErrStat, RF%ErrMsg, RoutineName)
            return
         end if
         RF%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(RF, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
   call RegUnpack(RF, OutData%VisMeshes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmYMod); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_InputType), intent(inout) :: SrcInputData
   type(Morison_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcInputData%Mesh, DstInputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInputData%PtfmRefY = SrcInputData%PtfmRefY
end subroutine

subroutine Morison_DestroyInput(InputData, ErrStat, ErrMsg)
   type(Morison_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( InputData%Mesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Morison_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackInput'
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%Mesh) 
   call RegPack(RF, InData%PtfmRefY)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackInput'
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%Mesh) ! Mesh 
   call RegUnpack(RF, OutData%PtfmRefY); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(Morison_OutputType), intent(inout) :: SrcOutputData
   type(Morison_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshCopy(SrcOutputData%Mesh, DstOutputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcOutputData%VisMesh, DstOutputData%VisMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcOutputData%WriteOutput)) then
      LB(1:1) = lbound(SrcOutputData%WriteOutput, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%WriteOutput, kind=B8Ki)
      if (.not. allocated(DstOutputData%WriteOutput)) then
         allocate(DstOutputData%WriteOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%WriteOutput = SrcOutputData%WriteOutput
   end if
end subroutine

subroutine Morison_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(Morison_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Morison_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call MeshDestroy( OutputData%Mesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( OutputData%VisMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(OutputData%WriteOutput)) then
      deallocate(OutputData%WriteOutput)
   end if
end subroutine

subroutine Morison_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Morison_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Morison_PackOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call MeshPack(RF, InData%Mesh) 
   call MeshPack(RF, InData%VisMesh) 
   call RegPackAlloc(RF, InData%WriteOutput)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Morison_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Morison_UnPackOutput'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call MeshUnpack(RF, OutData%Mesh) ! Mesh 
   call MeshUnpack(RF, OutData%VisMesh) ! VisMesh 
   call RegUnpackAlloc(RF, OutData%WriteOutput); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Morison_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
   ! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(Morison_InputType), intent(inout)  :: u(:) ! Input at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Inputs
   type(Morison_InputType), intent(inout)  :: u_out ! Input at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'Morison_Input_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(u)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(u)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(u) - 1
   select case (order)
   case (0)
      call Morison_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call Morison_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call Morison_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(u) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE Morison_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

   TYPE(Morison_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
   TYPE(Morison_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
   TYPE(Morison_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'Morison_Input_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   CALL MeshExtrapInterp1(u1%Mesh, u2%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   u_out%PtfmRefY = a1*u1%PtfmRefY + a2*u2%PtfmRefY
END SUBROUTINE

SUBROUTINE Morison_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

   TYPE(Morison_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
   TYPE(Morison_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
   TYPE(Morison_InputType), INTENT(INOUT)  :: u3      ! Input at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
   TYPE(Morison_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'Morison_Input_ExtrapInterp2'
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   CALL MeshExtrapInterp2(u1%Mesh, u2%Mesh, u3%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   u_out%PtfmRefY = a1*u1%PtfmRefY + a2*u2%PtfmRefY + a3*u3%PtfmRefY
END SUBROUTINE

subroutine Morison_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
   ! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(Morison_OutputType), intent(inout)  :: y(:) ! Output at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Outputs
   type(Morison_OutputType), intent(inout)  :: y_out ! Output at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'Morison_Output_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(y)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(y)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(y) - 1
   select case (order)
   case (0)
      call Morison_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call Morison_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call Morison_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(y) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE Morison_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

   TYPE(Morison_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
   TYPE(Morison_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
   TYPE(Morison_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'Morison_Output_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   CALL MeshExtrapInterp1(y1%Mesh, y2%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   CALL MeshExtrapInterp1(y1%VisMesh, y2%VisMesh, tin, y_out%VisMesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
      y_out%WriteOutput = a1*y1%WriteOutput + a2*y2%WriteOutput
   END IF ! check if allocated
END SUBROUTINE

SUBROUTINE Morison_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

   TYPE(Morison_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
   TYPE(Morison_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
   TYPE(Morison_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
   TYPE(Morison_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'Morison_Output_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   CALL MeshExtrapInterp2(y1%Mesh, y2%Mesh, y3%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   CALL MeshExtrapInterp2(y1%VisMesh, y2%VisMesh, y3%VisMesh, tin, y_out%VisMesh, tin_out, ErrStat2, ErrMsg2)
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
      y_out%WriteOutput = a1*y1%WriteOutput + a2*y2%WriteOutput + a3*y3%WriteOutput
   END IF ! check if allocated
END SUBROUTINE

function Morison_InputMeshPointer(u, DL) result(Mesh)
   type(Morison_InputType), target, intent(in) :: u
   type(DatLoc), intent(in)               :: DL
   type(MeshType), pointer                :: Mesh
   nullify(Mesh)
   select case (DL%Num)
   case (Morison_u_Mesh)
       Mesh => u%Mesh
   end select
end function

function Morison_OutputMeshPointer(y, DL) result(Mesh)
   type(Morison_OutputType), target, intent(in) :: y
   type(DatLoc), intent(in)               :: DL
   type(MeshType), pointer                :: Mesh
   nullify(Mesh)
   select case (DL%Num)
   case (Morison_y_Mesh)
       Mesh => y%Mesh
   case (Morison_y_VisMesh)
       Mesh => y%VisMesh
   end select
end function

subroutine Morison_VarsPackContState(Vars, x, ValAry)
   type(Morison_ContinuousStateType), intent(in) :: x
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(inout)              :: ValAry(:)
   integer(IntKi)                         :: i
   do i = 1, size(Vars%x)
      call Morison_VarPackContState(Vars%x(i), x, ValAry)
   end do
end subroutine

subroutine Morison_VarPackContState(V, x, ValAry)
   type(ModVarType), intent(in)            :: V
   type(Morison_ContinuousStateType), intent(in) :: x
   real(R8Ki), intent(inout)               :: ValAry(:)
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_x_DummyContState)
         VarVals(1) = x%DummyContState                                        ! Scalar
      case default
         VarVals = 0.0_R8Ki
      end select
   end associate
end subroutine

subroutine Morison_VarsUnpackContState(Vars, ValAry, x)
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(in)                 :: ValAry(:)
   type(Morison_ContinuousStateType), intent(inout) :: x
   integer(IntKi)                         :: i
   do i = 1, size(Vars%x)
      call Morison_VarUnpackContState(Vars%x(i), ValAry, x)
   end do
end subroutine

subroutine Morison_VarUnpackContState(V, ValAry, x)
   type(ModVarType), intent(in)            :: V
   real(R8Ki), intent(in)                  :: ValAry(:)
   type(Morison_ContinuousStateType), intent(inout) :: x
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_x_DummyContState)
         x%DummyContState = VarVals(1)                                        ! Scalar
      end select
   end associate
end subroutine

function Morison_ContinuousStateFieldName(DL) result(Name)
   type(DatLoc), intent(in)      :: DL
   character(32)                 :: Name
   select case (DL%Num)
   case (Morison_x_DummyContState)
       Name = "x%DummyContState"
   case default
       Name = "Unknown Field"
   end select
end function

subroutine Morison_VarsPackContStateDeriv(Vars, x, ValAry)
   type(Morison_ContinuousStateType), intent(in) :: x
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(inout)              :: ValAry(:)
   integer(IntKi)                         :: i
   do i = 1, size(Vars%x)
      call Morison_VarPackContStateDeriv(Vars%x(i), x, ValAry)
   end do
end subroutine

subroutine Morison_VarPackContStateDeriv(V, x, ValAry)
   type(ModVarType), intent(in)            :: V
   type(Morison_ContinuousStateType), intent(in) :: x
   real(R8Ki), intent(inout)               :: ValAry(:)
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_x_DummyContState)
         VarVals(1) = x%DummyContState                                        ! Scalar
      case default
         VarVals = 0.0_R8Ki
      end select
   end associate
end subroutine

subroutine Morison_VarsPackConstrState(Vars, z, ValAry)
   type(Morison_ConstraintStateType), intent(in) :: z
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(inout)              :: ValAry(:)
   integer(IntKi)                         :: i
   do i = 1, size(Vars%z)
      call Morison_VarPackConstrState(Vars%z(i), z, ValAry)
   end do
end subroutine

subroutine Morison_VarPackConstrState(V, z, ValAry)
   type(ModVarType), intent(in)            :: V
   type(Morison_ConstraintStateType), intent(in) :: z
   real(R8Ki), intent(inout)               :: ValAry(:)
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_z_DummyConstrState)
         VarVals(1) = z%DummyConstrState                                      ! Scalar
      case default
         VarVals = 0.0_R8Ki
      end select
   end associate
end subroutine

subroutine Morison_VarsUnpackConstrState(Vars, ValAry, z)
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(in)                 :: ValAry(:)
   type(Morison_ConstraintStateType), intent(inout) :: z
   integer(IntKi)                         :: i
   do i = 1, size(Vars%z)
      call Morison_VarUnpackConstrState(Vars%z(i), ValAry, z)
   end do
end subroutine

subroutine Morison_VarUnpackConstrState(V, ValAry, z)
   type(ModVarType), intent(in)            :: V
   real(R8Ki), intent(in)                  :: ValAry(:)
   type(Morison_ConstraintStateType), intent(inout) :: z
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_z_DummyConstrState)
         z%DummyConstrState = VarVals(1)                                      ! Scalar
      end select
   end associate
end subroutine

function Morison_ConstraintStateFieldName(DL) result(Name)
   type(DatLoc), intent(in)      :: DL
   character(32)                 :: Name
   select case (DL%Num)
   case (Morison_z_DummyConstrState)
       Name = "z%DummyConstrState"
   case default
       Name = "Unknown Field"
   end select
end function

subroutine Morison_VarsPackInput(Vars, u, ValAry)
   type(Morison_InputType), intent(in)     :: u
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(inout)              :: ValAry(:)
   integer(IntKi)                         :: i
   do i = 1, size(Vars%u)
      call Morison_VarPackInput(Vars%u(i), u, ValAry)
   end do
end subroutine

subroutine Morison_VarPackInput(V, u, ValAry)
   type(ModVarType), intent(in)            :: V
   type(Morison_InputType), intent(in)     :: u
   real(R8Ki), intent(inout)               :: ValAry(:)
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_u_Mesh)
         call MV_PackMesh(V, u%Mesh, ValAry)                                  ! Mesh
      case (Morison_u_PtfmRefY)
         VarVals(1) = u%PtfmRefY                                              ! Scalar
      case default
         VarVals = 0.0_R8Ki
      end select
   end associate
end subroutine

subroutine Morison_VarsUnpackInput(Vars, ValAry, u)
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(in)                 :: ValAry(:)
   type(Morison_InputType), intent(inout)  :: u
   integer(IntKi)                         :: i
   do i = 1, size(Vars%u)
      call Morison_VarUnpackInput(Vars%u(i), ValAry, u)
   end do
end subroutine

subroutine Morison_VarUnpackInput(V, ValAry, u)
   type(ModVarType), intent(in)            :: V
   real(R8Ki), intent(in)                  :: ValAry(:)
   type(Morison_InputType), intent(inout)  :: u
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_u_Mesh)
         call MV_UnpackMesh(V, ValAry, u%Mesh)                                ! Mesh
      case (Morison_u_PtfmRefY)
         u%PtfmRefY = VarVals(1)                                              ! Scalar
      end select
   end associate
end subroutine

function Morison_InputFieldName(DL) result(Name)
   type(DatLoc), intent(in)      :: DL
   character(32)                 :: Name
   select case (DL%Num)
   case (Morison_u_Mesh)
       Name = "u%Mesh"
   case (Morison_u_PtfmRefY)
       Name = "u%PtfmRefY"
   case default
       Name = "Unknown Field"
   end select
end function

subroutine Morison_VarsPackOutput(Vars, y, ValAry)
   type(Morison_OutputType), intent(in)    :: y
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(inout)              :: ValAry(:)
   integer(IntKi)                         :: i
   do i = 1, size(Vars%y)
      call Morison_VarPackOutput(Vars%y(i), y, ValAry)
   end do
end subroutine

subroutine Morison_VarPackOutput(V, y, ValAry)
   type(ModVarType), intent(in)            :: V
   type(Morison_OutputType), intent(in)    :: y
   real(R8Ki), intent(inout)               :: ValAry(:)
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_y_Mesh)
         call MV_PackMesh(V, y%Mesh, ValAry)                                  ! Mesh
      case (Morison_y_VisMesh)
         call MV_PackMesh(V, y%VisMesh, ValAry)                               ! Mesh
      case (Morison_y_WriteOutput)
         VarVals = y%WriteOutput(V%iLB:V%iUB)                                 ! Rank 1 Array
      case default
         VarVals = 0.0_R8Ki
      end select
   end associate
end subroutine

subroutine Morison_VarsUnpackOutput(Vars, ValAry, y)
   type(ModVarsType), intent(in)          :: Vars
   real(R8Ki), intent(in)                 :: ValAry(:)
   type(Morison_OutputType), intent(inout) :: y
   integer(IntKi)                         :: i
   do i = 1, size(Vars%y)
      call Morison_VarUnpackOutput(Vars%y(i), ValAry, y)
   end do
end subroutine

subroutine Morison_VarUnpackOutput(V, ValAry, y)
   type(ModVarType), intent(in)            :: V
   real(R8Ki), intent(in)                  :: ValAry(:)
   type(Morison_OutputType), intent(inout) :: y
   associate (DL => V%DL, VarVals => ValAry(V%iLoc(1):V%iLoc(2)))
      select case (DL%Num)
      case (Morison_y_Mesh)
         call MV_UnpackMesh(V, ValAry, y%Mesh)                                ! Mesh
      case (Morison_y_VisMesh)
         call MV_UnpackMesh(V, ValAry, y%VisMesh)                             ! Mesh
      case (Morison_y_WriteOutput)
         y%WriteOutput(V%iLB:V%iUB) = VarVals                                 ! Rank 1 Array
      end select
   end associate
end subroutine

function Morison_OutputFieldName(DL) result(Name)
   type(DatLoc), intent(in)      :: DL
   character(32)                 :: Name
   select case (DL%Num)
   case (Morison_y_Mesh)
       Name = "y%Mesh"
   case (Morison_y_VisMesh)
       Name = "y%VisMesh"
   case (Morison_y_WriteOutput)
       Name = "y%WriteOutput"
   case default
       Name = "Unknown Field"
   end select
end function

END MODULE Morison_Types

!ENDOFREGISTRYGENERATEDFILE
