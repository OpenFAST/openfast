!STARTOFREGISTRYGENERATEDFILE 'Morison_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Morison_Types
!.................................................................................................................................
! This file is part of Morison.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Morison. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Morison_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxMrsnOutputs = 4032      !  [-]
! =========  Morison_JointType  =======
  TYPE, PUBLIC :: Morison_JointType
    INTEGER(IntKi)  :: JointID      !<  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: JointPos      !<  [-]
    INTEGER(IntKi)  :: JointAxID      !<  [-]
    INTEGER(IntKi)  :: JointAxIDIndx      !<  [-]
    INTEGER(IntKi)  :: JointOvrlp      !<  [-]
    INTEGER(IntKi)  :: NConnections      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: ConnectionList      !<  [-]
  END TYPE Morison_JointType
! =======================
! =========  Morison_MemberPropType  =======
  TYPE, PUBLIC :: Morison_MemberPropType
    INTEGER(IntKi)  :: PropSetID      !<  [-]
    REAL(ReKi)  :: PropD      !<  [-]
    REAL(ReKi)  :: PropThck      !<  [-]
  END TYPE Morison_MemberPropType
! =======================
! =========  Morison_FilledGroupType  =======
  TYPE, PUBLIC :: Morison_FilledGroupType
    INTEGER(IntKi)  :: FillNumM      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FillMList      !<  [-]
    REAL(ReKi)  :: FillFSLoc      !<  [-]
    CHARACTER(80)  :: FillDensChr      !<  [-]
    REAL(ReKi)  :: FillDens      !<  [-]
  END TYPE Morison_FilledGroupType
! =======================
! =========  Morison_CoefDpths  =======
  TYPE, PUBLIC :: Morison_CoefDpths
    REAL(ReKi)  :: Dpth      !<  [-]
    REAL(ReKi)  :: DpthCd      !<  [-]
    REAL(ReKi)  :: DpthCdMG      !<  [-]
    REAL(ReKi)  :: DpthCa      !<  [-]
    REAL(ReKi)  :: DpthCaMG      !<  [-]
    REAL(ReKi)  :: DpthCp      !<  [-]
    REAL(ReKi)  :: DpthCpMG      !<  [-]
    REAL(ReKi)  :: DpthAxCa      !<  [-]
    REAL(ReKi)  :: DpthAxCaMG      !<  [-]
    REAL(ReKi)  :: DpthAxCp      !<  [-]
    REAL(ReKi)  :: DpthAxCpMG      !<  [-]
  END TYPE Morison_CoefDpths
! =======================
! =========  Morison_AxialCoefType  =======
  TYPE, PUBLIC :: Morison_AxialCoefType
    INTEGER(IntKi)  :: AxCoefID      !<  [-]
    REAL(ReKi)  :: AxCd      !<  [-]
    REAL(ReKi)  :: AxCa      !<  [-]
    REAL(ReKi)  :: AxCp      !<  [-]
  END TYPE Morison_AxialCoefType
! =======================
! =========  Morison_MemberInputType  =======
  TYPE, PUBLIC :: Morison_MemberInputType
    INTEGER(IntKi)  :: MemberID      !<  [-]
    INTEGER(IntKi)  :: MJointID1      !<  [-]
    INTEGER(IntKi)  :: MJointID2      !<  [-]
    INTEGER(IntKi)  :: MJointID1Indx      !<  [-]
    INTEGER(IntKi)  :: MJointID2Indx      !<  [-]
    INTEGER(IntKi)  :: MPropSetID1      !<  [-]
    INTEGER(IntKi)  :: MPropSetID2      !<  [-]
    INTEGER(IntKi)  :: MPropSetID1Indx      !<  [-]
    INTEGER(IntKi)  :: MPropSetID2Indx      !<  [-]
    REAL(ReKi)  :: MDivSize      !<  [-]
    INTEGER(IntKi)  :: MCoefMod      !<  [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx      !<  [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx      !<  [-]
    LOGICAL  :: PropPot      !<  [-]
    INTEGER(IntKi)  :: NumSplits      !<  [-]
    REAL(ReKi) , DIMENSION(1:5)  :: Splits      !<  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !<  [-]
  END TYPE Morison_MemberInputType
! =======================
! =========  Morison_NodeType  =======
  TYPE, PUBLIC :: Morison_NodeType
    INTEGER(IntKi)  :: NodeType      !<  [-]
    INTEGER(IntKi)  :: JointIndx      !<  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: JointPos      !<  [-]
    INTEGER(IntKi)  :: JointOvrlp      !<  [-]
    INTEGER(IntKi)  :: JointAxIDIndx      !<  [-]
    INTEGER(IntKi)  :: NConnections      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: ConnectionList      !<  [-]
    INTEGER(IntKi)  :: NConnectPreSplit      !<  [-]
    REAL(ReKi)  :: Cd      !<  [-]
    REAL(ReKi)  :: CdMG      !<  [-]
    REAL(ReKi)  :: Ca      !<  [-]
    REAL(ReKi)  :: CaMG      !<  [-]
    REAL(ReKi)  :: Cp      !<  [-]
    REAL(ReKi)  :: CpMG      !<  [-]
    REAL(ReKi)  :: JAxCd      !<  [-]
    REAL(ReKi)  :: JAxCa      !<  [-]
    REAL(ReKi)  :: JAxCp      !<  [-]
    REAL(ReKi)  :: AxCa      !<  [-]
    REAL(ReKi)  :: AxCp      !<  [-]
    REAL(ReKi)  :: AxCaMG      !<  [-]
    REAL(ReKi)  :: AxCpMG      !<  [-]
    REAL(ReKi)  :: R      !<  [-]
    REAL(ReKi)  :: t      !<  [-]
    REAL(ReKi)  :: tMG      !<  [-]
    REAL(ReKi)  :: dRdz      !<  [-]
    REAL(ReKi)  :: MGdensity      !<  [-]
    REAL(ReKi)  :: FillFSLoc      !<  [-]
    LOGICAL  :: FillFlag      !<  [-]
    REAL(ReKi)  :: FillDensity      !<  [-]
    INTEGER(IntKi)  :: InpMbrIndx      !<  [-]
    REAL(ReKi)  :: InpMbrDist      !<  [-]
    LOGICAL  :: PropPot      !<  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !<  [-]
  END TYPE Morison_NodeType
! =======================
! =========  Morison_MemberType  =======
  TYPE, PUBLIC :: Morison_MemberType
    INTEGER(IntKi)  :: Node1Indx      !<  [-]
    INTEGER(IntKi)  :: Node2Indx      !<  [-]
    REAL(ReKi)  :: R1      !<  [-]
    REAL(ReKi)  :: t1      !<  [-]
    REAL(ReKi)  :: R2      !<  [-]
    REAL(ReKi)  :: t2      !<  [-]
    REAL(ReKi)  :: Cd1      !<  [-]
    REAL(ReKi)  :: CdMG1      !<  [-]
    REAL(ReKi)  :: Ca1      !<  [-]
    REAL(ReKi)  :: CaMG1      !<  [-]
    REAL(ReKi)  :: Cp1      !<  [-]
    REAL(ReKi)  :: CpMG1      !<  [-]
    REAL(ReKi)  :: AxCa1      !<  [-]
    REAL(ReKi)  :: AxCaMG1      !<  [-]
    REAL(ReKi)  :: AxCp1      !<  [-]
    REAL(ReKi)  :: AxCpMG1      !<  [-]
    REAL(ReKi)  :: Cd2      !<  [-]
    REAL(ReKi)  :: CdMG2      !<  [-]
    REAL(ReKi)  :: Ca2      !<  [-]
    REAL(ReKi)  :: CaMG2      !<  [-]
    REAL(ReKi)  :: Cp2      !<  [-]
    REAL(ReKi)  :: CpMG2      !<  [-]
    REAL(ReKi)  :: AxCa2      !<  [-]
    REAL(ReKi)  :: AxCaMG2      !<  [-]
    REAL(ReKi)  :: AxCp2      !<  [-]
    REAL(ReKi)  :: AxCpMG2      !<  [-]
    REAL(ReKi)  :: InpMbrDist1      !<  [-]
    REAL(ReKi)  :: InpMbrDist2      !<  [-]
    REAL(ReKi)  :: InpMbrLen      !<  [-]
    INTEGER(IntKi)  :: InpMbrIndx      !<  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !<  [-]
    INTEGER(IntKi)  :: NumSplits      !<  [-]
    REAL(ReKi) , DIMENSION(1:5)  :: Splits      !<  [-]
    REAL(ReKi)  :: MGvolume      !<  [-]
    REAL(ReKi)  :: MDivSize      !<  [-]
    INTEGER(IntKi)  :: MCoefMod      !<  [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx      !<  [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx      !<  [-]
    REAL(ReKi)  :: FillFSLoc      !<  [-]
    REAL(ReKi)  :: FillDens      !<  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_Bouy      !<  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_DP      !<  [-]
    LOGICAL  :: PropPot      !<  [-]
  END TYPE Morison_MemberType
! =======================
! =========  Morison_CoefMembers  =======
  TYPE, PUBLIC :: Morison_CoefMembers
    INTEGER(IntKi)  :: MemberID      !<  [-]
    REAL(ReKi)  :: MemberCd1      !<  [-]
    REAL(ReKi)  :: MemberCd2      !<  [-]
    REAL(ReKi)  :: MemberCdMG1      !<  [-]
    REAL(ReKi)  :: MemberCdMG2      !<  [-]
    REAL(ReKi)  :: MemberCa1      !<  [-]
    REAL(ReKi)  :: MemberCa2      !<  [-]
    REAL(ReKi)  :: MemberCaMG1      !<  [-]
    REAL(ReKi)  :: MemberCaMG2      !<  [-]
    REAL(ReKi)  :: MemberCp1      !<  [-]
    REAL(ReKi)  :: MemberCp2      !<  [-]
    REAL(ReKi)  :: MemberCpMG1      !<  [-]
    REAL(ReKi)  :: MemberCpMG2      !<  [-]
    REAL(ReKi)  :: MemberAxCa1      !<  [-]
    REAL(ReKi)  :: MemberAxCa2      !<  [-]
    REAL(ReKi)  :: MemberAxCaMG1      !<  [-]
    REAL(ReKi)  :: MemberAxCaMG2      !<  [-]
    REAL(ReKi)  :: MemberAxCp1      !<  [-]
    REAL(ReKi)  :: MemberAxCp2      !<  [-]
    REAL(ReKi)  :: MemberAxCpMG1      !<  [-]
    REAL(ReKi)  :: MemberAxCpMG2      !<  [-]
  END TYPE Morison_CoefMembers
! =======================
! =========  Morison_MGDepthsType  =======
  TYPE, PUBLIC :: Morison_MGDepthsType
    REAL(ReKi)  :: MGDpth      !<  [-]
    REAL(ReKi)  :: MGThck      !<  [-]
    REAL(ReKi)  :: MGDens      !<  [-]
  END TYPE Morison_MGDepthsType
! =======================
! =========  Morison_MOutput  =======
  TYPE, PUBLIC :: Morison_MOutput
    INTEGER(IntKi)  :: MemberID      !<  [-]
    INTEGER(IntKi)  :: NOutLoc      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NodeLocs      !<  [-]
    INTEGER(IntKi)  :: MemberIDIndx      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Marker1      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Marker2      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: s      !<  [-]
  END TYPE Morison_MOutput
! =======================
! =========  Morison_JOutput  =======
  TYPE, PUBLIC :: Morison_JOutput
    INTEGER(IntKi)  :: JointID      !<  [-]
    INTEGER(IntKi)  :: JointIDIndx      !<  [-]
    INTEGER(IntKi)  :: NumMarkers      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Markers      !<  [-]
  END TYPE Morison_JOutput
! =======================
! =========  Morison_InitInputType  =======
  TYPE, PUBLIC :: Morison_InitInputType
    REAL(ReKi)  :: Gravity      !<  [-]
    REAL(ReKi)  :: WtrDens      !<  [-]
    REAL(ReKi)  :: WtrDpth      !<  [-]
    REAL(ReKi)  :: MSL2SWL      !<  [-]
    INTEGER(IntKi)  :: NJoints      !<  [-]
    INTEGER(IntKi)  :: NNodes      !<  [-]
    INTEGER(IntKi)  :: TotalPossibleSuperMembers      !<  [-]
    TYPE(Morison_JointType) , DIMENSION(:), ALLOCATABLE  :: InpJoints      !<  [-]
    TYPE(Morison_NodeType) , DIMENSION(:), ALLOCATABLE  :: Nodes      !<  [-]
    INTEGER(IntKi)  :: NElements      !<  [-]
    TYPE(Morison_MemberType) , DIMENSION(:), ALLOCATABLE  :: Elements      !<  [-]
    INTEGER(IntKi)  :: NAxCoefs      !<  [-]
    TYPE(Morison_AxialCoefType) , DIMENSION(:), ALLOCATABLE  :: AxialCoefs      !<  [-]
    INTEGER(IntKi)  :: NPropSets      !<  [-]
    TYPE(Morison_MemberPropType) , DIMENSION(:), ALLOCATABLE  :: MPropSets      !<  [-]
    REAL(ReKi)  :: SimplCd      !<  [-]
    REAL(ReKi)  :: SimplCdMG      !<  [-]
    REAL(ReKi)  :: SimplCa      !<  [-]
    REAL(ReKi)  :: SimplCaMG      !<  [-]
    REAL(ReKi)  :: SimplCp      !<  [-]
    REAL(ReKi)  :: SimplCpMG      !<  [-]
    REAL(ReKi)  :: SimplAxCa      !<  [-]
    REAL(ReKi)  :: SimplAxCaMG      !<  [-]
    REAL(ReKi)  :: SimplAxCp      !<  [-]
    REAL(ReKi)  :: SimplAxCpMG      !<  [-]
    INTEGER(IntKi)  :: NCoefDpth      !<  [-]
    TYPE(Morison_CoefDpths) , DIMENSION(:), ALLOCATABLE  :: CoefDpths      !<  [-]
    INTEGER(IntKi)  :: NCoefMembers      !<  [-]
    TYPE(Morison_CoefMembers) , DIMENSION(:), ALLOCATABLE  :: CoefMembers      !<  [-]
    INTEGER(IntKi)  :: NMembers      !<  [-]
    TYPE(Morison_MemberInputType) , DIMENSION(:), ALLOCATABLE  :: InpMembers      !<  [-]
    INTEGER(IntKi)  :: NFillGroups      !<  [-]
    TYPE(Morison_FilledGroupType) , DIMENSION(:), ALLOCATABLE  :: FilledGroups      !<  [-]
    INTEGER(IntKi)  :: NMGDepths      !<  [-]
    TYPE(Morison_MGDepthsType) , DIMENSION(:), ALLOCATABLE  :: MGDepths      !<  [-]
    REAL(ReKi)  :: MGTop      !<  [-]
    REAL(ReKi)  :: MGBottom      !<  [-]
    INTEGER(IntKi)  :: NMOutputs      !<  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !<  [-]
    INTEGER(IntKi)  :: NJOutputs      !<  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !<  [-]
    CHARACTER(ChanLen) , DIMENSION(1:4032)  :: OutList      !< This list size needs to be the maximum   of possible outputs because of the use of ReadAry() [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: ValidOutList      !<  [-]
    INTEGER(IntKi)  :: NumOuts      !<  [-]
    INTEGER(IntKi)  :: OutSwtch      !<  [-]
    LOGICAL  :: OutAll      !<  [-]
    CHARACTER(1024)  :: OutRootName      !<  [-]
    INTEGER(IntKi)  :: UnOutFile      !<  [-]
    INTEGER(IntKi)  :: UnSum      !<  [-]
    INTEGER(IntKi)  :: NStepWave      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !<  [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveDynP      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel      !<  [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: nodeInWater      !< Logical flag indicating if the node at the given time step is in the water, and hence needs to have hydrodynamic forces calculated [-]
  END TYPE Morison_InitInputType
! =======================
! =========  Morison_InitOutputType  =======
  TYPE, PUBLIC :: Morison_InitOutputType
    TYPE(MeshType)  :: DistribMesh      !<  [-]
    TYPE(MeshType)  :: LumpedMesh      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: Morison_Rad      !< radius of node (for FAST visualization) [(m)]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !<  [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !<  [-]
  END TYPE Morison_InitOutputType
! =======================
! =========  Morison_ContinuousStateType  =======
  TYPE, PUBLIC :: Morison_ContinuousStateType
    REAL(SiKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE Morison_ContinuousStateType
! =======================
! =========  Morison_DiscreteStateType  =======
  TYPE, PUBLIC :: Morison_DiscreteStateType
    REAL(SiKi)  :: DummyDiscState      !<  [-]
  END TYPE Morison_DiscreteStateType
! =======================
! =========  Morison_ConstraintStateType  =======
  TYPE, PUBLIC :: Morison_ConstraintStateType
    REAL(SiKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE Morison_ConstraintStateType
! =======================
! =========  Morison_OtherStateType  =======
  TYPE, PUBLIC :: Morison_OtherStateType
    INTEGER(IntKi)  :: DummyOtherState      !< Remove this variable if you have other states [-]
  END TYPE Morison_OtherStateType
! =======================
! =========  Morison_MiscVarType  =======
  TYPE, PUBLIC :: Morison_MiscVarType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_D      !< Distributed viscous drag loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_I      !< Distributed inertial loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_B      !< Distributed bounancy loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM      !< Distributed total added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_M      !< Distributed member added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_MG      !< Distributed marine growth added mass (weight) loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_F      !< Distributed added mass loads due to flooding/filled fluid [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_FV      !< Fluid velocity at line element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_FA      !< Fluid acceleration at line element node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_FDynP      !< Fluid dynamic pressure at line element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_B      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_D      !< Lumped viscous drag loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_I      !< Lumped intertia loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_DP      !< Lumped dynamic pressure loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_AM      !< Lumped added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_FV      !< Fluid velocity at point element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_FA      !< Fluid acceleration at point element node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: L_FDynP      !< Fluid dynamic pressure at point element node [-]
    INTEGER(IntKi)  :: LastIndWave      !< Last time index used in the wave kinematics arrays [-]
  END TYPE Morison_MiscVarType
! =======================
! =========  Morison_ParameterType  =======
  TYPE, PUBLIC :: Morison_ParameterType
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [(sec)]
    REAL(ReKi)  :: WtrDens      !<  [-]
    INTEGER(IntKi)  :: NNodes      !<  [-]
    TYPE(Morison_NodeType) , DIMENSION(:), ALLOCATABLE  :: Nodes      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_F_I      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_F_DP      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_dragConst      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_An      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_B      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_F_I      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_F_DP      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_BF      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_AM_M      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: L_dragConst      !<  [-]
    INTEGER(IntKi)  :: NDistribMarkers      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: distribToNodeIndx      !<  [-]
    INTEGER(IntKi)  :: NLumpedMarkers      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: lumpedToNodeIndx      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc      !<  [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveDynP      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !<  [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: elementWaterState      !< State indicating if the element a node is attached to at the given time step is in the water [0], above the water [1], or in the seabed [2] [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: elementFillState      !< State indicating if the element a node is attached to is in the filled fluid [0], above the fluid [1], or in the seabed [2] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: nodeInWater      !< Logical flag indicating if the node at the given time step is in the water, and hence needs to have hydrodynamic forces calculated [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_B      !< Distributed buoyancy loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_BF      !< Distributed filled buoyancy loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_MG      !< Distributed marine growth loads [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_AM_M      !< Distributed member added mass matrix [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_AM_MG      !< Distributed marine growth added mass matrix (weight) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_AM_F      !< Distributed added mass matrix due to flooding/filled fluid [-]
    INTEGER(IntKi)  :: NStepWave      !<  [-]
    INTEGER(IntKi)  :: NMOutputs      !<  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !<  [-]
    INTEGER(IntKi)  :: NJOutputs      !<  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !<  [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !<  [-]
    INTEGER(IntKi)  :: NumOuts      !<  [-]
    INTEGER(IntKi)  :: NumOutAll      !<  [-]
    INTEGER(IntKi)  :: OutSwtch      !<  [-]
    INTEGER(IntKi)  :: UnOutFile      !<  [-]
    CHARACTER(20)  :: OutFmt      !<  [-]
    CHARACTER(20)  :: OutSFmt      !<  [-]
    CHARACTER(ChanLen)  :: Delim      !<  [-]
  END TYPE Morison_ParameterType
! =======================
! =========  Morison_InputType  =======
  TYPE, PUBLIC :: Morison_InputType
    TYPE(MeshType)  :: DistribMesh      !< Distributed Loads Meshed input data [-]
    TYPE(MeshType)  :: LumpedMesh      !< Lumped Loads Meshed input data [-]
  END TYPE Morison_InputType
! =======================
! =========  Morison_OutputType  =======
  TYPE, PUBLIC :: Morison_OutputType
    TYPE(MeshType)  :: DistribMesh      !< Distributed Loads Meshed output data [-]
    TYPE(MeshType)  :: LumpedMesh      !< Lumped Loads Meshed output data [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !<  [-]
  END TYPE Morison_OutputType
! =======================
CONTAINS
 SUBROUTINE Morison_CopyJointType( SrcJointTypeData, DstJointTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_JointType), INTENT(IN) :: SrcJointTypeData
   TYPE(Morison_JointType), INTENT(INOUT) :: DstJointTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyJointType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstJointTypeData%JointID = SrcJointTypeData%JointID
    DstJointTypeData%JointPos = SrcJointTypeData%JointPos
    DstJointTypeData%JointAxID = SrcJointTypeData%JointAxID
    DstJointTypeData%JointAxIDIndx = SrcJointTypeData%JointAxIDIndx
    DstJointTypeData%JointOvrlp = SrcJointTypeData%JointOvrlp
    DstJointTypeData%NConnections = SrcJointTypeData%NConnections
    DstJointTypeData%ConnectionList = SrcJointTypeData%ConnectionList
 END SUBROUTINE Morison_CopyJointType

 SUBROUTINE Morison_DestroyJointType( JointTypeData, ErrStat, ErrMsg )
  TYPE(Morison_JointType), INTENT(INOUT) :: JointTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyJointType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyJointType

 SUBROUTINE Morison_PackJointType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_JointType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackJointType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! JointID
      Re_BufSz   = Re_BufSz   + SIZE(InData%JointPos)  ! JointPos
      Int_BufSz  = Int_BufSz  + 1  ! JointAxID
      Int_BufSz  = Int_BufSz  + 1  ! JointAxIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! JointOvrlp
      Int_BufSz  = Int_BufSz  + 1  ! NConnections
      Int_BufSz  = Int_BufSz  + SIZE(InData%ConnectionList)  ! ConnectionList
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%JointID
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%JointPos,1), UBOUND(InData%JointPos,1)
      ReKiBuf(Re_Xferred) = InData%JointPos(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%JointAxID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%JointAxIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%JointOvrlp
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NConnections
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%ConnectionList,1), UBOUND(InData%ConnectionList,1)
      IntKiBuf(Int_Xferred) = InData%ConnectionList(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
 END SUBROUTINE Morison_PackJointType

 SUBROUTINE Morison_UnPackJointType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_JointType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackJointType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%JointID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%JointPos,1)
    i1_u = UBOUND(OutData%JointPos,1)
    DO i1 = LBOUND(OutData%JointPos,1), UBOUND(OutData%JointPos,1)
      OutData%JointPos(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%JointAxID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%JointAxIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%JointOvrlp = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NConnections = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%ConnectionList,1)
    i1_u = UBOUND(OutData%ConnectionList,1)
    DO i1 = LBOUND(OutData%ConnectionList,1), UBOUND(OutData%ConnectionList,1)
      OutData%ConnectionList(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
 END SUBROUTINE Morison_UnPackJointType

 SUBROUTINE Morison_CopyMemberPropType( SrcMemberPropTypeData, DstMemberPropTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MemberPropType), INTENT(IN) :: SrcMemberPropTypeData
   TYPE(Morison_MemberPropType), INTENT(INOUT) :: DstMemberPropTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMemberPropType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMemberPropTypeData%PropSetID = SrcMemberPropTypeData%PropSetID
    DstMemberPropTypeData%PropD = SrcMemberPropTypeData%PropD
    DstMemberPropTypeData%PropThck = SrcMemberPropTypeData%PropThck
 END SUBROUTINE Morison_CopyMemberPropType

 SUBROUTINE Morison_DestroyMemberPropType( MemberPropTypeData, ErrStat, ErrMsg )
  TYPE(Morison_MemberPropType), INTENT(INOUT) :: MemberPropTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMemberPropType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyMemberPropType

 SUBROUTINE Morison_PackMemberPropType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MemberPropType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMemberPropType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! PropSetID
      Re_BufSz   = Re_BufSz   + 1  ! PropD
      Re_BufSz   = Re_BufSz   + 1  ! PropThck
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%PropSetID
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PropD
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PropThck
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackMemberPropType

 SUBROUTINE Morison_UnPackMemberPropType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MemberPropType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMemberPropType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%PropSetID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PropD = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PropThck = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackMemberPropType

 SUBROUTINE Morison_CopyFilledGroupType( SrcFilledGroupTypeData, DstFilledGroupTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_FilledGroupType), INTENT(IN) :: SrcFilledGroupTypeData
   TYPE(Morison_FilledGroupType), INTENT(INOUT) :: DstFilledGroupTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyFilledGroupType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFilledGroupTypeData%FillNumM = SrcFilledGroupTypeData%FillNumM
IF (ALLOCATED(SrcFilledGroupTypeData%FillMList)) THEN
  i1_l = LBOUND(SrcFilledGroupTypeData%FillMList,1)
  i1_u = UBOUND(SrcFilledGroupTypeData%FillMList,1)
  IF (.NOT. ALLOCATED(DstFilledGroupTypeData%FillMList)) THEN 
    ALLOCATE(DstFilledGroupTypeData%FillMList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFilledGroupTypeData%FillMList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFilledGroupTypeData%FillMList = SrcFilledGroupTypeData%FillMList
ENDIF
    DstFilledGroupTypeData%FillFSLoc = SrcFilledGroupTypeData%FillFSLoc
    DstFilledGroupTypeData%FillDensChr = SrcFilledGroupTypeData%FillDensChr
    DstFilledGroupTypeData%FillDens = SrcFilledGroupTypeData%FillDens
 END SUBROUTINE Morison_CopyFilledGroupType

 SUBROUTINE Morison_DestroyFilledGroupType( FilledGroupTypeData, ErrStat, ErrMsg )
  TYPE(Morison_FilledGroupType), INTENT(INOUT) :: FilledGroupTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyFilledGroupType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(FilledGroupTypeData%FillMList)) THEN
  DEALLOCATE(FilledGroupTypeData%FillMList)
ENDIF
 END SUBROUTINE Morison_DestroyFilledGroupType

 SUBROUTINE Morison_PackFilledGroupType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_FilledGroupType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackFilledGroupType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! FillNumM
  Int_BufSz   = Int_BufSz   + 1     ! FillMList allocated yes/no
  IF ( ALLOCATED(InData%FillMList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FillMList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%FillMList)  ! FillMList
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FillDensChr)  ! FillDensChr
      Re_BufSz   = Re_BufSz   + 1  ! FillDens
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%FillNumM
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%FillMList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FillMList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FillMList,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%FillMList,1), UBOUND(InData%FillMList,1)
        IntKiBuf(Int_Xferred) = InData%FillMList(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%FillFSLoc
    Re_Xferred = Re_Xferred + 1
    DO I = 1, LEN(InData%FillDensChr)
      IntKiBuf(Int_Xferred) = ICHAR(InData%FillDensChr(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    ReKiBuf(Re_Xferred) = InData%FillDens
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackFilledGroupType

 SUBROUTINE Morison_UnPackFilledGroupType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_FilledGroupType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackFilledGroupType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%FillNumM = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FillMList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FillMList)) DEALLOCATE(OutData%FillMList)
    ALLOCATE(OutData%FillMList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FillMList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%FillMList,1), UBOUND(OutData%FillMList,1)
        OutData%FillMList(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    OutData%FillFSLoc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    DO I = 1, LEN(OutData%FillDensChr)
      OutData%FillDensChr(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%FillDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackFilledGroupType

 SUBROUTINE Morison_CopyCoefDpths( SrcCoefDpthsData, DstCoefDpthsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_CoefDpths), INTENT(IN) :: SrcCoefDpthsData
   TYPE(Morison_CoefDpths), INTENT(INOUT) :: DstCoefDpthsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyCoefDpths'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstCoefDpthsData%Dpth = SrcCoefDpthsData%Dpth
    DstCoefDpthsData%DpthCd = SrcCoefDpthsData%DpthCd
    DstCoefDpthsData%DpthCdMG = SrcCoefDpthsData%DpthCdMG
    DstCoefDpthsData%DpthCa = SrcCoefDpthsData%DpthCa
    DstCoefDpthsData%DpthCaMG = SrcCoefDpthsData%DpthCaMG
    DstCoefDpthsData%DpthCp = SrcCoefDpthsData%DpthCp
    DstCoefDpthsData%DpthCpMG = SrcCoefDpthsData%DpthCpMG
    DstCoefDpthsData%DpthAxCa = SrcCoefDpthsData%DpthAxCa
    DstCoefDpthsData%DpthAxCaMG = SrcCoefDpthsData%DpthAxCaMG
    DstCoefDpthsData%DpthAxCp = SrcCoefDpthsData%DpthAxCp
    DstCoefDpthsData%DpthAxCpMG = SrcCoefDpthsData%DpthAxCpMG
 END SUBROUTINE Morison_CopyCoefDpths

 SUBROUTINE Morison_DestroyCoefDpths( CoefDpthsData, ErrStat, ErrMsg )
  TYPE(Morison_CoefDpths), INTENT(INOUT) :: CoefDpthsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyCoefDpths'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyCoefDpths

 SUBROUTINE Morison_PackCoefDpths( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_CoefDpths),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackCoefDpths'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Dpth
      Re_BufSz   = Re_BufSz   + 1  ! DpthCd
      Re_BufSz   = Re_BufSz   + 1  ! DpthCdMG
      Re_BufSz   = Re_BufSz   + 1  ! DpthCa
      Re_BufSz   = Re_BufSz   + 1  ! DpthCaMG
      Re_BufSz   = Re_BufSz   + 1  ! DpthCp
      Re_BufSz   = Re_BufSz   + 1  ! DpthCpMG
      Re_BufSz   = Re_BufSz   + 1  ! DpthAxCa
      Re_BufSz   = Re_BufSz   + 1  ! DpthAxCaMG
      Re_BufSz   = Re_BufSz   + 1  ! DpthAxCp
      Re_BufSz   = Re_BufSz   + 1  ! DpthAxCpMG
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%Dpth
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCdMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthCpMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthAxCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthAxCaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthAxCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DpthAxCpMG
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackCoefDpths

 SUBROUTINE Morison_UnPackCoefDpths( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_CoefDpths), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackCoefDpths'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Dpth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCdMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthCpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthAxCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthAxCaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthAxCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DpthAxCpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackCoefDpths

 SUBROUTINE Morison_CopyAxialCoefType( SrcAxialCoefTypeData, DstAxialCoefTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_AxialCoefType), INTENT(IN) :: SrcAxialCoefTypeData
   TYPE(Morison_AxialCoefType), INTENT(INOUT) :: DstAxialCoefTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyAxialCoefType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstAxialCoefTypeData%AxCoefID = SrcAxialCoefTypeData%AxCoefID
    DstAxialCoefTypeData%AxCd = SrcAxialCoefTypeData%AxCd
    DstAxialCoefTypeData%AxCa = SrcAxialCoefTypeData%AxCa
    DstAxialCoefTypeData%AxCp = SrcAxialCoefTypeData%AxCp
 END SUBROUTINE Morison_CopyAxialCoefType

 SUBROUTINE Morison_DestroyAxialCoefType( AxialCoefTypeData, ErrStat, ErrMsg )
  TYPE(Morison_AxialCoefType), INTENT(INOUT) :: AxialCoefTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyAxialCoefType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyAxialCoefType

 SUBROUTINE Morison_PackAxialCoefType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_AxialCoefType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackAxialCoefType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! AxCoefID
      Re_BufSz   = Re_BufSz   + 1  ! AxCd
      Re_BufSz   = Re_BufSz   + 1  ! AxCa
      Re_BufSz   = Re_BufSz   + 1  ! AxCp
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%AxCoefID
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCp
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackAxialCoefType

 SUBROUTINE Morison_UnPackAxialCoefType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_AxialCoefType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackAxialCoefType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%AxCoefID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%AxCd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackAxialCoefType

 SUBROUTINE Morison_CopyMemberInputType( SrcMemberInputTypeData, DstMemberInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MemberInputType), INTENT(IN) :: SrcMemberInputTypeData
   TYPE(Morison_MemberInputType), INTENT(INOUT) :: DstMemberInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMemberInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMemberInputTypeData%MemberID = SrcMemberInputTypeData%MemberID
    DstMemberInputTypeData%MJointID1 = SrcMemberInputTypeData%MJointID1
    DstMemberInputTypeData%MJointID2 = SrcMemberInputTypeData%MJointID2
    DstMemberInputTypeData%MJointID1Indx = SrcMemberInputTypeData%MJointID1Indx
    DstMemberInputTypeData%MJointID2Indx = SrcMemberInputTypeData%MJointID2Indx
    DstMemberInputTypeData%MPropSetID1 = SrcMemberInputTypeData%MPropSetID1
    DstMemberInputTypeData%MPropSetID2 = SrcMemberInputTypeData%MPropSetID2
    DstMemberInputTypeData%MPropSetID1Indx = SrcMemberInputTypeData%MPropSetID1Indx
    DstMemberInputTypeData%MPropSetID2Indx = SrcMemberInputTypeData%MPropSetID2Indx
    DstMemberInputTypeData%MDivSize = SrcMemberInputTypeData%MDivSize
    DstMemberInputTypeData%MCoefMod = SrcMemberInputTypeData%MCoefMod
    DstMemberInputTypeData%MmbrCoefIDIndx = SrcMemberInputTypeData%MmbrCoefIDIndx
    DstMemberInputTypeData%MmbrFilledIDIndx = SrcMemberInputTypeData%MmbrFilledIDIndx
    DstMemberInputTypeData%PropPot = SrcMemberInputTypeData%PropPot
    DstMemberInputTypeData%NumSplits = SrcMemberInputTypeData%NumSplits
    DstMemberInputTypeData%Splits = SrcMemberInputTypeData%Splits
    DstMemberInputTypeData%R_LToG = SrcMemberInputTypeData%R_LToG
 END SUBROUTINE Morison_CopyMemberInputType

 SUBROUTINE Morison_DestroyMemberInputType( MemberInputTypeData, ErrStat, ErrMsg )
  TYPE(Morison_MemberInputType), INTENT(INOUT) :: MemberInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMemberInputType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyMemberInputType

 SUBROUTINE Morison_PackMemberInputType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MemberInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMemberInputType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MemberID
      Int_BufSz  = Int_BufSz  + 1  ! MJointID1
      Int_BufSz  = Int_BufSz  + 1  ! MJointID2
      Int_BufSz  = Int_BufSz  + 1  ! MJointID1Indx
      Int_BufSz  = Int_BufSz  + 1  ! MJointID2Indx
      Int_BufSz  = Int_BufSz  + 1  ! MPropSetID1
      Int_BufSz  = Int_BufSz  + 1  ! MPropSetID2
      Int_BufSz  = Int_BufSz  + 1  ! MPropSetID1Indx
      Int_BufSz  = Int_BufSz  + 1  ! MPropSetID2Indx
      Re_BufSz   = Re_BufSz   + 1  ! MDivSize
      Int_BufSz  = Int_BufSz  + 1  ! MCoefMod
      Int_BufSz  = Int_BufSz  + 1  ! MmbrCoefIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! MmbrFilledIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! PropPot
      Int_BufSz  = Int_BufSz  + 1  ! NumSplits
      Re_BufSz   = Re_BufSz   + SIZE(InData%Splits)  ! Splits
      Re_BufSz   = Re_BufSz   + SIZE(InData%R_LToG)  ! R_LToG
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%MemberID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MJointID1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MJointID2
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MJointID1Indx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MJointID2Indx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MPropSetID1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MPropSetID2
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MPropSetID1Indx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MPropSetID2Indx
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MDivSize
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MCoefMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MmbrCoefIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MmbrFilledIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%PropPot, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumSplits
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%Splits,1), UBOUND(InData%Splits,1)
      ReKiBuf(Re_Xferred) = InData%Splits(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i2 = LBOUND(InData%R_LToG,2), UBOUND(InData%R_LToG,2)
      DO i1 = LBOUND(InData%R_LToG,1), UBOUND(InData%R_LToG,1)
        ReKiBuf(Re_Xferred) = InData%R_LToG(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
 END SUBROUTINE Morison_PackMemberInputType

 SUBROUTINE Morison_UnPackMemberInputType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MemberInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMemberInputType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%MemberID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MJointID1 = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MJointID2 = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MJointID1Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MJointID2Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MPropSetID1 = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MPropSetID2 = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MPropSetID1Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MPropSetID2Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MDivSize = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MCoefMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MmbrCoefIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MmbrFilledIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PropPot = TRANSFER(IntKiBuf(Int_Xferred), OutData%PropPot)
    Int_Xferred = Int_Xferred + 1
    OutData%NumSplits = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%Splits,1)
    i1_u = UBOUND(OutData%Splits,1)
    DO i1 = LBOUND(OutData%Splits,1), UBOUND(OutData%Splits,1)
      OutData%Splits(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%R_LToG,1)
    i1_u = UBOUND(OutData%R_LToG,1)
    i2_l = LBOUND(OutData%R_LToG,2)
    i2_u = UBOUND(OutData%R_LToG,2)
    DO i2 = LBOUND(OutData%R_LToG,2), UBOUND(OutData%R_LToG,2)
      DO i1 = LBOUND(OutData%R_LToG,1), UBOUND(OutData%R_LToG,1)
        OutData%R_LToG(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
 END SUBROUTINE Morison_UnPackMemberInputType

 SUBROUTINE Morison_CopyNodeType( SrcNodeTypeData, DstNodeTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_NodeType), INTENT(IN) :: SrcNodeTypeData
   TYPE(Morison_NodeType), INTENT(INOUT) :: DstNodeTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyNodeType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstNodeTypeData%NodeType = SrcNodeTypeData%NodeType
    DstNodeTypeData%JointIndx = SrcNodeTypeData%JointIndx
    DstNodeTypeData%JointPos = SrcNodeTypeData%JointPos
    DstNodeTypeData%JointOvrlp = SrcNodeTypeData%JointOvrlp
    DstNodeTypeData%JointAxIDIndx = SrcNodeTypeData%JointAxIDIndx
    DstNodeTypeData%NConnections = SrcNodeTypeData%NConnections
    DstNodeTypeData%ConnectionList = SrcNodeTypeData%ConnectionList
    DstNodeTypeData%NConnectPreSplit = SrcNodeTypeData%NConnectPreSplit
    DstNodeTypeData%Cd = SrcNodeTypeData%Cd
    DstNodeTypeData%CdMG = SrcNodeTypeData%CdMG
    DstNodeTypeData%Ca = SrcNodeTypeData%Ca
    DstNodeTypeData%CaMG = SrcNodeTypeData%CaMG
    DstNodeTypeData%Cp = SrcNodeTypeData%Cp
    DstNodeTypeData%CpMG = SrcNodeTypeData%CpMG
    DstNodeTypeData%JAxCd = SrcNodeTypeData%JAxCd
    DstNodeTypeData%JAxCa = SrcNodeTypeData%JAxCa
    DstNodeTypeData%JAxCp = SrcNodeTypeData%JAxCp
    DstNodeTypeData%AxCa = SrcNodeTypeData%AxCa
    DstNodeTypeData%AxCp = SrcNodeTypeData%AxCp
    DstNodeTypeData%AxCaMG = SrcNodeTypeData%AxCaMG
    DstNodeTypeData%AxCpMG = SrcNodeTypeData%AxCpMG
    DstNodeTypeData%R = SrcNodeTypeData%R
    DstNodeTypeData%t = SrcNodeTypeData%t
    DstNodeTypeData%tMG = SrcNodeTypeData%tMG
    DstNodeTypeData%dRdz = SrcNodeTypeData%dRdz
    DstNodeTypeData%MGdensity = SrcNodeTypeData%MGdensity
    DstNodeTypeData%FillFSLoc = SrcNodeTypeData%FillFSLoc
    DstNodeTypeData%FillFlag = SrcNodeTypeData%FillFlag
    DstNodeTypeData%FillDensity = SrcNodeTypeData%FillDensity
    DstNodeTypeData%InpMbrIndx = SrcNodeTypeData%InpMbrIndx
    DstNodeTypeData%InpMbrDist = SrcNodeTypeData%InpMbrDist
    DstNodeTypeData%PropPot = SrcNodeTypeData%PropPot
    DstNodeTypeData%R_LToG = SrcNodeTypeData%R_LToG
 END SUBROUTINE Morison_CopyNodeType

 SUBROUTINE Morison_DestroyNodeType( NodeTypeData, ErrStat, ErrMsg )
  TYPE(Morison_NodeType), INTENT(INOUT) :: NodeTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyNodeType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyNodeType

 SUBROUTINE Morison_PackNodeType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_NodeType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackNodeType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NodeType
      Int_BufSz  = Int_BufSz  + 1  ! JointIndx
      Re_BufSz   = Re_BufSz   + SIZE(InData%JointPos)  ! JointPos
      Int_BufSz  = Int_BufSz  + 1  ! JointOvrlp
      Int_BufSz  = Int_BufSz  + 1  ! JointAxIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! NConnections
      Int_BufSz  = Int_BufSz  + SIZE(InData%ConnectionList)  ! ConnectionList
      Int_BufSz  = Int_BufSz  + 1  ! NConnectPreSplit
      Re_BufSz   = Re_BufSz   + 1  ! Cd
      Re_BufSz   = Re_BufSz   + 1  ! CdMG
      Re_BufSz   = Re_BufSz   + 1  ! Ca
      Re_BufSz   = Re_BufSz   + 1  ! CaMG
      Re_BufSz   = Re_BufSz   + 1  ! Cp
      Re_BufSz   = Re_BufSz   + 1  ! CpMG
      Re_BufSz   = Re_BufSz   + 1  ! JAxCd
      Re_BufSz   = Re_BufSz   + 1  ! JAxCa
      Re_BufSz   = Re_BufSz   + 1  ! JAxCp
      Re_BufSz   = Re_BufSz   + 1  ! AxCa
      Re_BufSz   = Re_BufSz   + 1  ! AxCp
      Re_BufSz   = Re_BufSz   + 1  ! AxCaMG
      Re_BufSz   = Re_BufSz   + 1  ! AxCpMG
      Re_BufSz   = Re_BufSz   + 1  ! R
      Re_BufSz   = Re_BufSz   + 1  ! t
      Re_BufSz   = Re_BufSz   + 1  ! tMG
      Re_BufSz   = Re_BufSz   + 1  ! dRdz
      Re_BufSz   = Re_BufSz   + 1  ! MGdensity
      Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
      Int_BufSz  = Int_BufSz  + 1  ! FillFlag
      Re_BufSz   = Re_BufSz   + 1  ! FillDensity
      Int_BufSz  = Int_BufSz  + 1  ! InpMbrIndx
      Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist
      Int_BufSz  = Int_BufSz  + 1  ! PropPot
      Re_BufSz   = Re_BufSz   + SIZE(InData%R_LToG)  ! R_LToG
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%NodeType
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%JointIndx
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%JointPos,1), UBOUND(InData%JointPos,1)
      ReKiBuf(Re_Xferred) = InData%JointPos(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%JointOvrlp
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%JointAxIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NConnections
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%ConnectionList,1), UBOUND(InData%ConnectionList,1)
      IntKiBuf(Int_Xferred) = InData%ConnectionList(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%NConnectPreSplit
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CdMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Ca
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CpMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%JAxCd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%JAxCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%JAxCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCpMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%R
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%t
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%tMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%dRdz
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MGdensity
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FillFSLoc
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%FillFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FillDensity
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%InpMbrIndx
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InpMbrDist
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%PropPot, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO i2 = LBOUND(InData%R_LToG,2), UBOUND(InData%R_LToG,2)
      DO i1 = LBOUND(InData%R_LToG,1), UBOUND(InData%R_LToG,1)
        ReKiBuf(Re_Xferred) = InData%R_LToG(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
 END SUBROUTINE Morison_PackNodeType

 SUBROUTINE Morison_UnPackNodeType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_NodeType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackNodeType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%NodeType = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%JointIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%JointPos,1)
    i1_u = UBOUND(OutData%JointPos,1)
    DO i1 = LBOUND(OutData%JointPos,1), UBOUND(OutData%JointPos,1)
      OutData%JointPos(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%JointOvrlp = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%JointAxIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NConnections = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%ConnectionList,1)
    i1_u = UBOUND(OutData%ConnectionList,1)
    DO i1 = LBOUND(OutData%ConnectionList,1), UBOUND(OutData%ConnectionList,1)
      OutData%ConnectionList(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%NConnectPreSplit = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%Cd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CdMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Ca = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%JAxCd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%JAxCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%JAxCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%R = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%t = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%tMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%dRdz = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MGdensity = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FillFSLoc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FillFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%FillFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%FillDensity = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InpMbrIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%InpMbrDist = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PropPot = TRANSFER(IntKiBuf(Int_Xferred), OutData%PropPot)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%R_LToG,1)
    i1_u = UBOUND(OutData%R_LToG,1)
    i2_l = LBOUND(OutData%R_LToG,2)
    i2_u = UBOUND(OutData%R_LToG,2)
    DO i2 = LBOUND(OutData%R_LToG,2), UBOUND(OutData%R_LToG,2)
      DO i1 = LBOUND(OutData%R_LToG,1), UBOUND(OutData%R_LToG,1)
        OutData%R_LToG(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
 END SUBROUTINE Morison_UnPackNodeType

 SUBROUTINE Morison_CopyMemberType( SrcMemberTypeData, DstMemberTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MemberType), INTENT(IN) :: SrcMemberTypeData
   TYPE(Morison_MemberType), INTENT(INOUT) :: DstMemberTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMemberType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMemberTypeData%Node1Indx = SrcMemberTypeData%Node1Indx
    DstMemberTypeData%Node2Indx = SrcMemberTypeData%Node2Indx
    DstMemberTypeData%R1 = SrcMemberTypeData%R1
    DstMemberTypeData%t1 = SrcMemberTypeData%t1
    DstMemberTypeData%R2 = SrcMemberTypeData%R2
    DstMemberTypeData%t2 = SrcMemberTypeData%t2
    DstMemberTypeData%Cd1 = SrcMemberTypeData%Cd1
    DstMemberTypeData%CdMG1 = SrcMemberTypeData%CdMG1
    DstMemberTypeData%Ca1 = SrcMemberTypeData%Ca1
    DstMemberTypeData%CaMG1 = SrcMemberTypeData%CaMG1
    DstMemberTypeData%Cp1 = SrcMemberTypeData%Cp1
    DstMemberTypeData%CpMG1 = SrcMemberTypeData%CpMG1
    DstMemberTypeData%AxCa1 = SrcMemberTypeData%AxCa1
    DstMemberTypeData%AxCaMG1 = SrcMemberTypeData%AxCaMG1
    DstMemberTypeData%AxCp1 = SrcMemberTypeData%AxCp1
    DstMemberTypeData%AxCpMG1 = SrcMemberTypeData%AxCpMG1
    DstMemberTypeData%Cd2 = SrcMemberTypeData%Cd2
    DstMemberTypeData%CdMG2 = SrcMemberTypeData%CdMG2
    DstMemberTypeData%Ca2 = SrcMemberTypeData%Ca2
    DstMemberTypeData%CaMG2 = SrcMemberTypeData%CaMG2
    DstMemberTypeData%Cp2 = SrcMemberTypeData%Cp2
    DstMemberTypeData%CpMG2 = SrcMemberTypeData%CpMG2
    DstMemberTypeData%AxCa2 = SrcMemberTypeData%AxCa2
    DstMemberTypeData%AxCaMG2 = SrcMemberTypeData%AxCaMG2
    DstMemberTypeData%AxCp2 = SrcMemberTypeData%AxCp2
    DstMemberTypeData%AxCpMG2 = SrcMemberTypeData%AxCpMG2
    DstMemberTypeData%InpMbrDist1 = SrcMemberTypeData%InpMbrDist1
    DstMemberTypeData%InpMbrDist2 = SrcMemberTypeData%InpMbrDist2
    DstMemberTypeData%InpMbrLen = SrcMemberTypeData%InpMbrLen
    DstMemberTypeData%InpMbrIndx = SrcMemberTypeData%InpMbrIndx
    DstMemberTypeData%R_LToG = SrcMemberTypeData%R_LToG
    DstMemberTypeData%NumSplits = SrcMemberTypeData%NumSplits
    DstMemberTypeData%Splits = SrcMemberTypeData%Splits
    DstMemberTypeData%MGvolume = SrcMemberTypeData%MGvolume
    DstMemberTypeData%MDivSize = SrcMemberTypeData%MDivSize
    DstMemberTypeData%MCoefMod = SrcMemberTypeData%MCoefMod
    DstMemberTypeData%MmbrCoefIDIndx = SrcMemberTypeData%MmbrCoefIDIndx
    DstMemberTypeData%MmbrFilledIDIndx = SrcMemberTypeData%MmbrFilledIDIndx
    DstMemberTypeData%FillFSLoc = SrcMemberTypeData%FillFSLoc
    DstMemberTypeData%FillDens = SrcMemberTypeData%FillDens
    DstMemberTypeData%F_Bouy = SrcMemberTypeData%F_Bouy
    DstMemberTypeData%F_DP = SrcMemberTypeData%F_DP
    DstMemberTypeData%PropPot = SrcMemberTypeData%PropPot
 END SUBROUTINE Morison_CopyMemberType

 SUBROUTINE Morison_DestroyMemberType( MemberTypeData, ErrStat, ErrMsg )
  TYPE(Morison_MemberType), INTENT(INOUT) :: MemberTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMemberType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyMemberType

 SUBROUTINE Morison_PackMemberType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MemberType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMemberType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Node1Indx
      Int_BufSz  = Int_BufSz  + 1  ! Node2Indx
      Re_BufSz   = Re_BufSz   + 1  ! R1
      Re_BufSz   = Re_BufSz   + 1  ! t1
      Re_BufSz   = Re_BufSz   + 1  ! R2
      Re_BufSz   = Re_BufSz   + 1  ! t2
      Re_BufSz   = Re_BufSz   + 1  ! Cd1
      Re_BufSz   = Re_BufSz   + 1  ! CdMG1
      Re_BufSz   = Re_BufSz   + 1  ! Ca1
      Re_BufSz   = Re_BufSz   + 1  ! CaMG1
      Re_BufSz   = Re_BufSz   + 1  ! Cp1
      Re_BufSz   = Re_BufSz   + 1  ! CpMG1
      Re_BufSz   = Re_BufSz   + 1  ! AxCa1
      Re_BufSz   = Re_BufSz   + 1  ! AxCaMG1
      Re_BufSz   = Re_BufSz   + 1  ! AxCp1
      Re_BufSz   = Re_BufSz   + 1  ! AxCpMG1
      Re_BufSz   = Re_BufSz   + 1  ! Cd2
      Re_BufSz   = Re_BufSz   + 1  ! CdMG2
      Re_BufSz   = Re_BufSz   + 1  ! Ca2
      Re_BufSz   = Re_BufSz   + 1  ! CaMG2
      Re_BufSz   = Re_BufSz   + 1  ! Cp2
      Re_BufSz   = Re_BufSz   + 1  ! CpMG2
      Re_BufSz   = Re_BufSz   + 1  ! AxCa2
      Re_BufSz   = Re_BufSz   + 1  ! AxCaMG2
      Re_BufSz   = Re_BufSz   + 1  ! AxCp2
      Re_BufSz   = Re_BufSz   + 1  ! AxCpMG2
      Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist1
      Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist2
      Re_BufSz   = Re_BufSz   + 1  ! InpMbrLen
      Int_BufSz  = Int_BufSz  + 1  ! InpMbrIndx
      Re_BufSz   = Re_BufSz   + SIZE(InData%R_LToG)  ! R_LToG
      Int_BufSz  = Int_BufSz  + 1  ! NumSplits
      Re_BufSz   = Re_BufSz   + SIZE(InData%Splits)  ! Splits
      Re_BufSz   = Re_BufSz   + 1  ! MGvolume
      Re_BufSz   = Re_BufSz   + 1  ! MDivSize
      Int_BufSz  = Int_BufSz  + 1  ! MCoefMod
      Int_BufSz  = Int_BufSz  + 1  ! MmbrCoefIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! MmbrFilledIDIndx
      Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
      Re_BufSz   = Re_BufSz   + 1  ! FillDens
      Re_BufSz   = Re_BufSz   + SIZE(InData%F_Bouy)  ! F_Bouy
      Re_BufSz   = Re_BufSz   + SIZE(InData%F_DP)  ! F_DP
      Int_BufSz  = Int_BufSz  + 1  ! PropPot
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%Node1Indx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%Node2Indx
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%R1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%t1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%R2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%t2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cd1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CdMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Ca1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CaMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cp1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CpMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCa1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCaMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCp1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCpMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cd2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CdMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Ca2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CaMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cp2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CpMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCa2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCaMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCp2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AxCpMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InpMbrDist1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InpMbrDist2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InpMbrLen
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%InpMbrIndx
    Int_Xferred = Int_Xferred + 1
    DO i2 = LBOUND(InData%R_LToG,2), UBOUND(InData%R_LToG,2)
      DO i1 = LBOUND(InData%R_LToG,1), UBOUND(InData%R_LToG,1)
        ReKiBuf(Re_Xferred) = InData%R_LToG(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    IntKiBuf(Int_Xferred) = InData%NumSplits
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%Splits,1), UBOUND(InData%Splits,1)
      ReKiBuf(Re_Xferred) = InData%Splits(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%MGvolume
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MDivSize
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MCoefMod
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MmbrCoefIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MmbrFilledIDIndx
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FillFSLoc
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FillDens
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%F_Bouy,1), UBOUND(InData%F_Bouy,1)
      ReKiBuf(Re_Xferred) = InData%F_Bouy(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%F_DP,1), UBOUND(InData%F_DP,1)
      ReKiBuf(Re_Xferred) = InData%F_DP(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = TRANSFER(InData%PropPot, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_PackMemberType

 SUBROUTINE Morison_UnPackMemberType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MemberType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMemberType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Node1Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%Node2Indx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%R1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%t1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%R2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%t2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cd1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CdMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Ca1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CaMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cp1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CpMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCa1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCaMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCp1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCpMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cd2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CdMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Ca2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CaMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cp2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CpMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCa2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCaMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCp2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AxCpMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InpMbrDist1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InpMbrDist2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InpMbrLen = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InpMbrIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%R_LToG,1)
    i1_u = UBOUND(OutData%R_LToG,1)
    i2_l = LBOUND(OutData%R_LToG,2)
    i2_u = UBOUND(OutData%R_LToG,2)
    DO i2 = LBOUND(OutData%R_LToG,2), UBOUND(OutData%R_LToG,2)
      DO i1 = LBOUND(OutData%R_LToG,1), UBOUND(OutData%R_LToG,1)
        OutData%R_LToG(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    OutData%NumSplits = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%Splits,1)
    i1_u = UBOUND(OutData%Splits,1)
    DO i1 = LBOUND(OutData%Splits,1), UBOUND(OutData%Splits,1)
      OutData%Splits(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%MGvolume = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MDivSize = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MCoefMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MmbrCoefIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MmbrFilledIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FillFSLoc = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FillDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%F_Bouy,1)
    i1_u = UBOUND(OutData%F_Bouy,1)
    DO i1 = LBOUND(OutData%F_Bouy,1), UBOUND(OutData%F_Bouy,1)
      OutData%F_Bouy(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%F_DP,1)
    i1_u = UBOUND(OutData%F_DP,1)
    DO i1 = LBOUND(OutData%F_DP,1), UBOUND(OutData%F_DP,1)
      OutData%F_DP(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%PropPot = TRANSFER(IntKiBuf(Int_Xferred), OutData%PropPot)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_UnPackMemberType

 SUBROUTINE Morison_CopyCoefMembers( SrcCoefMembersData, DstCoefMembersData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_CoefMembers), INTENT(IN) :: SrcCoefMembersData
   TYPE(Morison_CoefMembers), INTENT(INOUT) :: DstCoefMembersData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyCoefMembers'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstCoefMembersData%MemberID = SrcCoefMembersData%MemberID
    DstCoefMembersData%MemberCd1 = SrcCoefMembersData%MemberCd1
    DstCoefMembersData%MemberCd2 = SrcCoefMembersData%MemberCd2
    DstCoefMembersData%MemberCdMG1 = SrcCoefMembersData%MemberCdMG1
    DstCoefMembersData%MemberCdMG2 = SrcCoefMembersData%MemberCdMG2
    DstCoefMembersData%MemberCa1 = SrcCoefMembersData%MemberCa1
    DstCoefMembersData%MemberCa2 = SrcCoefMembersData%MemberCa2
    DstCoefMembersData%MemberCaMG1 = SrcCoefMembersData%MemberCaMG1
    DstCoefMembersData%MemberCaMG2 = SrcCoefMembersData%MemberCaMG2
    DstCoefMembersData%MemberCp1 = SrcCoefMembersData%MemberCp1
    DstCoefMembersData%MemberCp2 = SrcCoefMembersData%MemberCp2
    DstCoefMembersData%MemberCpMG1 = SrcCoefMembersData%MemberCpMG1
    DstCoefMembersData%MemberCpMG2 = SrcCoefMembersData%MemberCpMG2
    DstCoefMembersData%MemberAxCa1 = SrcCoefMembersData%MemberAxCa1
    DstCoefMembersData%MemberAxCa2 = SrcCoefMembersData%MemberAxCa2
    DstCoefMembersData%MemberAxCaMG1 = SrcCoefMembersData%MemberAxCaMG1
    DstCoefMembersData%MemberAxCaMG2 = SrcCoefMembersData%MemberAxCaMG2
    DstCoefMembersData%MemberAxCp1 = SrcCoefMembersData%MemberAxCp1
    DstCoefMembersData%MemberAxCp2 = SrcCoefMembersData%MemberAxCp2
    DstCoefMembersData%MemberAxCpMG1 = SrcCoefMembersData%MemberAxCpMG1
    DstCoefMembersData%MemberAxCpMG2 = SrcCoefMembersData%MemberAxCpMG2
 END SUBROUTINE Morison_CopyCoefMembers

 SUBROUTINE Morison_DestroyCoefMembers( CoefMembersData, ErrStat, ErrMsg )
  TYPE(Morison_CoefMembers), INTENT(INOUT) :: CoefMembersData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyCoefMembers'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyCoefMembers

 SUBROUTINE Morison_PackCoefMembers( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_CoefMembers),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackCoefMembers'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MemberID
      Re_BufSz   = Re_BufSz   + 1  ! MemberCd1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCd2
      Re_BufSz   = Re_BufSz   + 1  ! MemberCdMG1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCdMG2
      Re_BufSz   = Re_BufSz   + 1  ! MemberCa1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCa2
      Re_BufSz   = Re_BufSz   + 1  ! MemberCaMG1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCaMG2
      Re_BufSz   = Re_BufSz   + 1  ! MemberCp1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCp2
      Re_BufSz   = Re_BufSz   + 1  ! MemberCpMG1
      Re_BufSz   = Re_BufSz   + 1  ! MemberCpMG2
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCa1
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCa2
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCaMG1
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCaMG2
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCp1
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCp2
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCpMG1
      Re_BufSz   = Re_BufSz   + 1  ! MemberAxCpMG2
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%MemberID
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCd1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCd2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCdMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCdMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCa1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCa2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCaMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCaMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCp1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCp2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCpMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberCpMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCa1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCa2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCaMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCaMG2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCp1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCp2
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCpMG1
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MemberAxCpMG2
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackCoefMembers

 SUBROUTINE Morison_UnPackCoefMembers( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_CoefMembers), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackCoefMembers'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%MemberID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MemberCd1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCd2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCdMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCdMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCa1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCa2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCaMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCaMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCp1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCp2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCpMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberCpMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCa1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCa2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCaMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCaMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCp1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCp2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCpMG1 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MemberAxCpMG2 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackCoefMembers

 SUBROUTINE Morison_CopyMGDepthsType( SrcMGDepthsTypeData, DstMGDepthsTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MGDepthsType), INTENT(IN) :: SrcMGDepthsTypeData
   TYPE(Morison_MGDepthsType), INTENT(INOUT) :: DstMGDepthsTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMGDepthsType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMGDepthsTypeData%MGDpth = SrcMGDepthsTypeData%MGDpth
    DstMGDepthsTypeData%MGThck = SrcMGDepthsTypeData%MGThck
    DstMGDepthsTypeData%MGDens = SrcMGDepthsTypeData%MGDens
 END SUBROUTINE Morison_CopyMGDepthsType

 SUBROUTINE Morison_DestroyMGDepthsType( MGDepthsTypeData, ErrStat, ErrMsg )
  TYPE(Morison_MGDepthsType), INTENT(INOUT) :: MGDepthsTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMGDepthsType'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyMGDepthsType

 SUBROUTINE Morison_PackMGDepthsType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MGDepthsType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMGDepthsType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! MGDpth
      Re_BufSz   = Re_BufSz   + 1  ! MGThck
      Re_BufSz   = Re_BufSz   + 1  ! MGDens
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%MGDpth
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MGThck
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MGDens
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackMGDepthsType

 SUBROUTINE Morison_UnPackMGDepthsType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MGDepthsType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMGDepthsType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%MGDpth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MGThck = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MGDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackMGDepthsType

 SUBROUTINE Morison_CopyMOutput( SrcMOutputData, DstMOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MOutput), INTENT(IN) :: SrcMOutputData
   TYPE(Morison_MOutput), INTENT(INOUT) :: DstMOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMOutputData%MemberID = SrcMOutputData%MemberID
    DstMOutputData%NOutLoc = SrcMOutputData%NOutLoc
IF (ALLOCATED(SrcMOutputData%NodeLocs)) THEN
  i1_l = LBOUND(SrcMOutputData%NodeLocs,1)
  i1_u = UBOUND(SrcMOutputData%NodeLocs,1)
  IF (.NOT. ALLOCATED(DstMOutputData%NodeLocs)) THEN 
    ALLOCATE(DstMOutputData%NodeLocs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%NodeLocs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMOutputData%NodeLocs = SrcMOutputData%NodeLocs
ENDIF
    DstMOutputData%MemberIDIndx = SrcMOutputData%MemberIDIndx
IF (ALLOCATED(SrcMOutputData%Marker1)) THEN
  i1_l = LBOUND(SrcMOutputData%Marker1,1)
  i1_u = UBOUND(SrcMOutputData%Marker1,1)
  IF (.NOT. ALLOCATED(DstMOutputData%Marker1)) THEN 
    ALLOCATE(DstMOutputData%Marker1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%Marker1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMOutputData%Marker1 = SrcMOutputData%Marker1
ENDIF
IF (ALLOCATED(SrcMOutputData%Marker2)) THEN
  i1_l = LBOUND(SrcMOutputData%Marker2,1)
  i1_u = UBOUND(SrcMOutputData%Marker2,1)
  IF (.NOT. ALLOCATED(DstMOutputData%Marker2)) THEN 
    ALLOCATE(DstMOutputData%Marker2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%Marker2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMOutputData%Marker2 = SrcMOutputData%Marker2
ENDIF
IF (ALLOCATED(SrcMOutputData%s)) THEN
  i1_l = LBOUND(SrcMOutputData%s,1)
  i1_u = UBOUND(SrcMOutputData%s,1)
  IF (.NOT. ALLOCATED(DstMOutputData%s)) THEN 
    ALLOCATE(DstMOutputData%s(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMOutputData%s.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMOutputData%s = SrcMOutputData%s
ENDIF
 END SUBROUTINE Morison_CopyMOutput

 SUBROUTINE Morison_DestroyMOutput( MOutputData, ErrStat, ErrMsg )
  TYPE(Morison_MOutput), INTENT(INOUT) :: MOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MOutputData%NodeLocs)) THEN
  DEALLOCATE(MOutputData%NodeLocs)
ENDIF
IF (ALLOCATED(MOutputData%Marker1)) THEN
  DEALLOCATE(MOutputData%Marker1)
ENDIF
IF (ALLOCATED(MOutputData%Marker2)) THEN
  DEALLOCATE(MOutputData%Marker2)
ENDIF
IF (ALLOCATED(MOutputData%s)) THEN
  DEALLOCATE(MOutputData%s)
ENDIF
 END SUBROUTINE Morison_DestroyMOutput

 SUBROUTINE Morison_PackMOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MOutput),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MemberID
      Int_BufSz  = Int_BufSz  + 1  ! NOutLoc
  Int_BufSz   = Int_BufSz   + 1     ! NodeLocs allocated yes/no
  IF ( ALLOCATED(InData%NodeLocs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! NodeLocs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%NodeLocs)  ! NodeLocs
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! MemberIDIndx
  Int_BufSz   = Int_BufSz   + 1     ! Marker1 allocated yes/no
  IF ( ALLOCATED(InData%Marker1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Marker1 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%Marker1)  ! Marker1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Marker2 allocated yes/no
  IF ( ALLOCATED(InData%Marker2) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Marker2 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%Marker2)  ! Marker2
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! s allocated yes/no
  IF ( ALLOCATED(InData%s) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! s upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%s)  ! s
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%MemberID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NOutLoc
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%NodeLocs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%NodeLocs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%NodeLocs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%NodeLocs,1), UBOUND(InData%NodeLocs,1)
        ReKiBuf(Re_Xferred) = InData%NodeLocs(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%MemberIDIndx
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Marker1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Marker1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Marker1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Marker1,1), UBOUND(InData%Marker1,1)
        IntKiBuf(Int_Xferred) = InData%Marker1(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Marker2) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Marker2,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Marker2,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Marker2,1), UBOUND(InData%Marker2,1)
        IntKiBuf(Int_Xferred) = InData%Marker2(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%s) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%s,1), UBOUND(InData%s,1)
        ReKiBuf(Re_Xferred) = InData%s(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE Morison_PackMOutput

 SUBROUTINE Morison_UnPackMOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MOutput), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%MemberID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NOutLoc = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! NodeLocs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%NodeLocs)) DEALLOCATE(OutData%NodeLocs)
    ALLOCATE(OutData%NodeLocs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodeLocs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%NodeLocs,1), UBOUND(OutData%NodeLocs,1)
        OutData%NodeLocs(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%MemberIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Marker1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Marker1)) DEALLOCATE(OutData%Marker1)
    ALLOCATE(OutData%Marker1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Marker1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Marker1,1), UBOUND(OutData%Marker1,1)
        OutData%Marker1(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Marker2 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Marker2)) DEALLOCATE(OutData%Marker2)
    ALLOCATE(OutData%Marker2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Marker2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Marker2,1), UBOUND(OutData%Marker2,1)
        OutData%Marker2(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! s not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%s)) DEALLOCATE(OutData%s)
    ALLOCATE(OutData%s(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%s.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%s,1), UBOUND(OutData%s,1)
        OutData%s(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE Morison_UnPackMOutput

 SUBROUTINE Morison_CopyJOutput( SrcJOutputData, DstJOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_JOutput), INTENT(IN) :: SrcJOutputData
   TYPE(Morison_JOutput), INTENT(INOUT) :: DstJOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyJOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstJOutputData%JointID = SrcJOutputData%JointID
    DstJOutputData%JointIDIndx = SrcJOutputData%JointIDIndx
    DstJOutputData%NumMarkers = SrcJOutputData%NumMarkers
    DstJOutputData%Markers = SrcJOutputData%Markers
 END SUBROUTINE Morison_CopyJOutput

 SUBROUTINE Morison_DestroyJOutput( JOutputData, ErrStat, ErrMsg )
  TYPE(Morison_JOutput), INTENT(INOUT) :: JOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyJOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyJOutput

 SUBROUTINE Morison_PackJOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_JOutput),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackJOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! JointID
      Int_BufSz  = Int_BufSz  + 1  ! JointIDIndx
      Int_BufSz  = Int_BufSz  + 1  ! NumMarkers
      Int_BufSz  = Int_BufSz  + SIZE(InData%Markers)  ! Markers
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%JointID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%JointIDIndx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumMarkers
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%Markers,1), UBOUND(InData%Markers,1)
      IntKiBuf(Int_Xferred) = InData%Markers(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
 END SUBROUTINE Morison_PackJOutput

 SUBROUTINE Morison_UnPackJOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_JOutput), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackJOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%JointID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%JointIDIndx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumMarkers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%Markers,1)
    i1_u = UBOUND(OutData%Markers,1)
    DO i1 = LBOUND(OutData%Markers,1), UBOUND(OutData%Markers,1)
      OutData%Markers(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
 END SUBROUTINE Morison_UnPackJOutput

 SUBROUTINE Morison_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(Morison_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
    DstInitInputData%NJoints = SrcInitInputData%NJoints
    DstInitInputData%NNodes = SrcInitInputData%NNodes
    DstInitInputData%TotalPossibleSuperMembers = SrcInitInputData%TotalPossibleSuperMembers
IF (ALLOCATED(SrcInitInputData%InpJoints)) THEN
  i1_l = LBOUND(SrcInitInputData%InpJoints,1)
  i1_u = UBOUND(SrcInitInputData%InpJoints,1)
  IF (.NOT. ALLOCATED(DstInitInputData%InpJoints)) THEN 
    ALLOCATE(DstInitInputData%InpJoints(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpJoints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%InpJoints,1), UBOUND(SrcInitInputData%InpJoints,1)
      CALL Morison_Copyjointtype( SrcInitInputData%InpJoints(i1), DstInitInputData%InpJoints(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInitInputData%Nodes)) THEN
  i1_l = LBOUND(SrcInitInputData%Nodes,1)
  i1_u = UBOUND(SrcInitInputData%Nodes,1)
  IF (.NOT. ALLOCATED(DstInitInputData%Nodes)) THEN 
    ALLOCATE(DstInitInputData%Nodes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Nodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%Nodes,1), UBOUND(SrcInitInputData%Nodes,1)
      CALL Morison_Copynodetype( SrcInitInputData%Nodes(i1), DstInitInputData%Nodes(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NElements = SrcInitInputData%NElements
IF (ALLOCATED(SrcInitInputData%Elements)) THEN
  i1_l = LBOUND(SrcInitInputData%Elements,1)
  i1_u = UBOUND(SrcInitInputData%Elements,1)
  IF (.NOT. ALLOCATED(DstInitInputData%Elements)) THEN 
    ALLOCATE(DstInitInputData%Elements(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Elements.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%Elements,1), UBOUND(SrcInitInputData%Elements,1)
      CALL Morison_Copymembertype( SrcInitInputData%Elements(i1), DstInitInputData%Elements(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NAxCoefs = SrcInitInputData%NAxCoefs
IF (ALLOCATED(SrcInitInputData%AxialCoefs)) THEN
  i1_l = LBOUND(SrcInitInputData%AxialCoefs,1)
  i1_u = UBOUND(SrcInitInputData%AxialCoefs,1)
  IF (.NOT. ALLOCATED(DstInitInputData%AxialCoefs)) THEN 
    ALLOCATE(DstInitInputData%AxialCoefs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AxialCoefs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%AxialCoefs,1), UBOUND(SrcInitInputData%AxialCoefs,1)
      CALL Morison_Copyaxialcoeftype( SrcInitInputData%AxialCoefs(i1), DstInitInputData%AxialCoefs(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NPropSets = SrcInitInputData%NPropSets
IF (ALLOCATED(SrcInitInputData%MPropSets)) THEN
  i1_l = LBOUND(SrcInitInputData%MPropSets,1)
  i1_u = UBOUND(SrcInitInputData%MPropSets,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MPropSets)) THEN 
    ALLOCATE(DstInitInputData%MPropSets(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MPropSets.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%MPropSets,1), UBOUND(SrcInitInputData%MPropSets,1)
      CALL Morison_Copymemberproptype( SrcInitInputData%MPropSets(i1), DstInitInputData%MPropSets(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%SimplCd = SrcInitInputData%SimplCd
    DstInitInputData%SimplCdMG = SrcInitInputData%SimplCdMG
    DstInitInputData%SimplCa = SrcInitInputData%SimplCa
    DstInitInputData%SimplCaMG = SrcInitInputData%SimplCaMG
    DstInitInputData%SimplCp = SrcInitInputData%SimplCp
    DstInitInputData%SimplCpMG = SrcInitInputData%SimplCpMG
    DstInitInputData%SimplAxCa = SrcInitInputData%SimplAxCa
    DstInitInputData%SimplAxCaMG = SrcInitInputData%SimplAxCaMG
    DstInitInputData%SimplAxCp = SrcInitInputData%SimplAxCp
    DstInitInputData%SimplAxCpMG = SrcInitInputData%SimplAxCpMG
    DstInitInputData%NCoefDpth = SrcInitInputData%NCoefDpth
IF (ALLOCATED(SrcInitInputData%CoefDpths)) THEN
  i1_l = LBOUND(SrcInitInputData%CoefDpths,1)
  i1_u = UBOUND(SrcInitInputData%CoefDpths,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CoefDpths)) THEN 
    ALLOCATE(DstInitInputData%CoefDpths(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefDpths.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%CoefDpths,1), UBOUND(SrcInitInputData%CoefDpths,1)
      CALL Morison_Copycoefdpths( SrcInitInputData%CoefDpths(i1), DstInitInputData%CoefDpths(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NCoefMembers = SrcInitInputData%NCoefMembers
IF (ALLOCATED(SrcInitInputData%CoefMembers)) THEN
  i1_l = LBOUND(SrcInitInputData%CoefMembers,1)
  i1_u = UBOUND(SrcInitInputData%CoefMembers,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CoefMembers)) THEN 
    ALLOCATE(DstInitInputData%CoefMembers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefMembers.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%CoefMembers,1), UBOUND(SrcInitInputData%CoefMembers,1)
      CALL Morison_Copycoefmembers( SrcInitInputData%CoefMembers(i1), DstInitInputData%CoefMembers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NMembers = SrcInitInputData%NMembers
IF (ALLOCATED(SrcInitInputData%InpMembers)) THEN
  i1_l = LBOUND(SrcInitInputData%InpMembers,1)
  i1_u = UBOUND(SrcInitInputData%InpMembers,1)
  IF (.NOT. ALLOCATED(DstInitInputData%InpMembers)) THEN 
    ALLOCATE(DstInitInputData%InpMembers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpMembers.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%InpMembers,1), UBOUND(SrcInitInputData%InpMembers,1)
      CALL Morison_Copymemberinputtype( SrcInitInputData%InpMembers(i1), DstInitInputData%InpMembers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NFillGroups = SrcInitInputData%NFillGroups
IF (ALLOCATED(SrcInitInputData%FilledGroups)) THEN
  i1_l = LBOUND(SrcInitInputData%FilledGroups,1)
  i1_u = UBOUND(SrcInitInputData%FilledGroups,1)
  IF (.NOT. ALLOCATED(DstInitInputData%FilledGroups)) THEN 
    ALLOCATE(DstInitInputData%FilledGroups(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%FilledGroups.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%FilledGroups,1), UBOUND(SrcInitInputData%FilledGroups,1)
      CALL Morison_Copyfilledgrouptype( SrcInitInputData%FilledGroups(i1), DstInitInputData%FilledGroups(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NMGDepths = SrcInitInputData%NMGDepths
IF (ALLOCATED(SrcInitInputData%MGDepths)) THEN
  i1_l = LBOUND(SrcInitInputData%MGDepths,1)
  i1_u = UBOUND(SrcInitInputData%MGDepths,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MGDepths)) THEN 
    ALLOCATE(DstInitInputData%MGDepths(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MGDepths.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%MGDepths,1), UBOUND(SrcInitInputData%MGDepths,1)
      CALL Morison_Copymgdepthstype( SrcInitInputData%MGDepths(i1), DstInitInputData%MGDepths(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%MGTop = SrcInitInputData%MGTop
    DstInitInputData%MGBottom = SrcInitInputData%MGBottom
    DstInitInputData%NMOutputs = SrcInitInputData%NMOutputs
IF (ALLOCATED(SrcInitInputData%MOutLst)) THEN
  i1_l = LBOUND(SrcInitInputData%MOutLst,1)
  i1_u = UBOUND(SrcInitInputData%MOutLst,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MOutLst)) THEN 
    ALLOCATE(DstInitInputData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MOutLst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%MOutLst,1), UBOUND(SrcInitInputData%MOutLst,1)
      CALL Morison_Copymoutput( SrcInitInputData%MOutLst(i1), DstInitInputData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%NJOutputs = SrcInitInputData%NJOutputs
IF (ALLOCATED(SrcInitInputData%JOutLst)) THEN
  i1_l = LBOUND(SrcInitInputData%JOutLst,1)
  i1_u = UBOUND(SrcInitInputData%JOutLst,1)
  IF (.NOT. ALLOCATED(DstInitInputData%JOutLst)) THEN 
    ALLOCATE(DstInitInputData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%JOutLst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%JOutLst,1), UBOUND(SrcInitInputData%JOutLst,1)
      CALL Morison_Copyjoutput( SrcInitInputData%JOutLst(i1), DstInitInputData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%OutList = SrcInitInputData%OutList
IF (ALLOCATED(SrcInitInputData%ValidOutList)) THEN
  i1_l = LBOUND(SrcInitInputData%ValidOutList,1)
  i1_u = UBOUND(SrcInitInputData%ValidOutList,1)
  IF (.NOT. ALLOCATED(DstInitInputData%ValidOutList)) THEN 
    ALLOCATE(DstInitInputData%ValidOutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%ValidOutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%ValidOutList = SrcInitInputData%ValidOutList
ENDIF
    DstInitInputData%NumOuts = SrcInitInputData%NumOuts
    DstInitInputData%OutSwtch = SrcInitInputData%OutSwtch
    DstInitInputData%OutAll = SrcInitInputData%OutAll
    DstInitInputData%OutRootName = SrcInitInputData%OutRootName
    DstInitInputData%UnOutFile = SrcInitInputData%UnOutFile
    DstInitInputData%UnSum = SrcInitInputData%UnSum
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
IF (ALLOCATED(SrcInitInputData%WaveAcc)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveAcc,1)
  i1_u = UBOUND(SrcInitInputData%WaveAcc,1)
  i2_l = LBOUND(SrcInitInputData%WaveAcc,2)
  i2_u = UBOUND(SrcInitInputData%WaveAcc,2)
  i3_l = LBOUND(SrcInitInputData%WaveAcc,3)
  i3_u = UBOUND(SrcInitInputData%WaveAcc,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveAcc)) THEN 
    ALLOCATE(DstInitInputData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveAcc = SrcInitInputData%WaveAcc
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveTime,1)
  i1_u = UBOUND(SrcInitInputData%WaveTime,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
    ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveDynP)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveDynP,1)
  i1_u = UBOUND(SrcInitInputData%WaveDynP,1)
  i2_l = LBOUND(SrcInitInputData%WaveDynP,2)
  i2_u = UBOUND(SrcInitInputData%WaveDynP,2)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveDynP)) THEN 
    ALLOCATE(DstInitInputData%WaveDynP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveDynP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveDynP = SrcInitInputData%WaveDynP
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveVel)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveVel,1)
  i1_u = UBOUND(SrcInitInputData%WaveVel,1)
  i2_l = LBOUND(SrcInitInputData%WaveVel,2)
  i2_u = UBOUND(SrcInitInputData%WaveVel,2)
  i3_l = LBOUND(SrcInitInputData%WaveVel,3)
  i3_u = UBOUND(SrcInitInputData%WaveVel,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveVel)) THEN 
    ALLOCATE(DstInitInputData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveVel = SrcInitInputData%WaveVel
ENDIF
IF (ALLOCATED(SrcInitInputData%nodeInWater)) THEN
  i1_l = LBOUND(SrcInitInputData%nodeInWater,1)
  i1_u = UBOUND(SrcInitInputData%nodeInWater,1)
  i2_l = LBOUND(SrcInitInputData%nodeInWater,2)
  i2_u = UBOUND(SrcInitInputData%nodeInWater,2)
  IF (.NOT. ALLOCATED(DstInitInputData%nodeInWater)) THEN 
    ALLOCATE(DstInitInputData%nodeInWater(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%nodeInWater.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%nodeInWater = SrcInitInputData%nodeInWater
ENDIF
 END SUBROUTINE Morison_CopyInitInput

 SUBROUTINE Morison_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Morison_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%InpJoints)) THEN
DO i1 = LBOUND(InitInputData%InpJoints,1), UBOUND(InitInputData%InpJoints,1)
  CALL Morison_Destroyjointtype( InitInputData%InpJoints(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%InpJoints)
ENDIF
IF (ALLOCATED(InitInputData%Nodes)) THEN
DO i1 = LBOUND(InitInputData%Nodes,1), UBOUND(InitInputData%Nodes,1)
  CALL Morison_Destroynodetype( InitInputData%Nodes(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%Nodes)
ENDIF
IF (ALLOCATED(InitInputData%Elements)) THEN
DO i1 = LBOUND(InitInputData%Elements,1), UBOUND(InitInputData%Elements,1)
  CALL Morison_Destroymembertype( InitInputData%Elements(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%Elements)
ENDIF
IF (ALLOCATED(InitInputData%AxialCoefs)) THEN
DO i1 = LBOUND(InitInputData%AxialCoefs,1), UBOUND(InitInputData%AxialCoefs,1)
  CALL Morison_Destroyaxialcoeftype( InitInputData%AxialCoefs(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%AxialCoefs)
ENDIF
IF (ALLOCATED(InitInputData%MPropSets)) THEN
DO i1 = LBOUND(InitInputData%MPropSets,1), UBOUND(InitInputData%MPropSets,1)
  CALL Morison_Destroymemberproptype( InitInputData%MPropSets(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%MPropSets)
ENDIF
IF (ALLOCATED(InitInputData%CoefDpths)) THEN
DO i1 = LBOUND(InitInputData%CoefDpths,1), UBOUND(InitInputData%CoefDpths,1)
  CALL Morison_Destroycoefdpths( InitInputData%CoefDpths(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%CoefDpths)
ENDIF
IF (ALLOCATED(InitInputData%CoefMembers)) THEN
DO i1 = LBOUND(InitInputData%CoefMembers,1), UBOUND(InitInputData%CoefMembers,1)
  CALL Morison_Destroycoefmembers( InitInputData%CoefMembers(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%CoefMembers)
ENDIF
IF (ALLOCATED(InitInputData%InpMembers)) THEN
DO i1 = LBOUND(InitInputData%InpMembers,1), UBOUND(InitInputData%InpMembers,1)
  CALL Morison_Destroymemberinputtype( InitInputData%InpMembers(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%InpMembers)
ENDIF
IF (ALLOCATED(InitInputData%FilledGroups)) THEN
DO i1 = LBOUND(InitInputData%FilledGroups,1), UBOUND(InitInputData%FilledGroups,1)
  CALL Morison_Destroyfilledgrouptype( InitInputData%FilledGroups(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%FilledGroups)
ENDIF
IF (ALLOCATED(InitInputData%MGDepths)) THEN
DO i1 = LBOUND(InitInputData%MGDepths,1), UBOUND(InitInputData%MGDepths,1)
  CALL Morison_Destroymgdepthstype( InitInputData%MGDepths(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%MGDepths)
ENDIF
IF (ALLOCATED(InitInputData%MOutLst)) THEN
DO i1 = LBOUND(InitInputData%MOutLst,1), UBOUND(InitInputData%MOutLst,1)
  CALL Morison_Destroymoutput( InitInputData%MOutLst(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%MOutLst)
ENDIF
IF (ALLOCATED(InitInputData%JOutLst)) THEN
DO i1 = LBOUND(InitInputData%JOutLst,1), UBOUND(InitInputData%JOutLst,1)
  CALL Morison_Destroyjoutput( InitInputData%JOutLst(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%JOutLst)
ENDIF
IF (ALLOCATED(InitInputData%ValidOutList)) THEN
  DEALLOCATE(InitInputData%ValidOutList)
ENDIF
IF (ALLOCATED(InitInputData%WaveAcc)) THEN
  DEALLOCATE(InitInputData%WaveAcc)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
  DEALLOCATE(InitInputData%WaveTime)
ENDIF
IF (ALLOCATED(InitInputData%WaveDynP)) THEN
  DEALLOCATE(InitInputData%WaveDynP)
ENDIF
IF (ALLOCATED(InitInputData%WaveVel)) THEN
  DEALLOCATE(InitInputData%WaveVel)
ENDIF
IF (ALLOCATED(InitInputData%nodeInWater)) THEN
  DEALLOCATE(InitInputData%nodeInWater)
ENDIF
 END SUBROUTINE Morison_DestroyInitInput

 SUBROUTINE Morison_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Gravity
      Re_BufSz   = Re_BufSz   + 1  ! WtrDens
      Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
      Re_BufSz   = Re_BufSz   + 1  ! MSL2SWL
      Int_BufSz  = Int_BufSz  + 1  ! NJoints
      Int_BufSz  = Int_BufSz  + 1  ! NNodes
      Int_BufSz  = Int_BufSz  + 1  ! TotalPossibleSuperMembers
  Int_BufSz   = Int_BufSz   + 1     ! InpJoints allocated yes/no
  IF ( ALLOCATED(InData%InpJoints) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! InpJoints upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%InpJoints,1), UBOUND(InData%InpJoints,1)
      Int_BufSz   = Int_BufSz + 3  ! InpJoints: size of buffers for each call to pack subtype
      CALL Morison_Packjointtype( Re_Buf, Db_Buf, Int_Buf, InData%InpJoints(i1), ErrStat2, ErrMsg2, .TRUE. ) ! InpJoints 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InpJoints
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InpJoints
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InpJoints
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Nodes allocated yes/no
  IF ( ALLOCATED(InData%Nodes) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Nodes upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
      Int_BufSz   = Int_BufSz + 3  ! Nodes: size of buffers for each call to pack subtype
      CALL Morison_Packnodetype( Re_Buf, Db_Buf, Int_Buf, InData%Nodes(i1), ErrStat2, ErrMsg2, .TRUE. ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Nodes
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Nodes
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Nodes
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NElements
  Int_BufSz   = Int_BufSz   + 1     ! Elements allocated yes/no
  IF ( ALLOCATED(InData%Elements) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Elements upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%Elements,1), UBOUND(InData%Elements,1)
      Int_BufSz   = Int_BufSz + 3  ! Elements: size of buffers for each call to pack subtype
      CALL Morison_Packmembertype( Re_Buf, Db_Buf, Int_Buf, InData%Elements(i1), ErrStat2, ErrMsg2, .TRUE. ) ! Elements 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Elements
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Elements
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Elements
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NAxCoefs
  Int_BufSz   = Int_BufSz   + 1     ! AxialCoefs allocated yes/no
  IF ( ALLOCATED(InData%AxialCoefs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AxialCoefs upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%AxialCoefs,1), UBOUND(InData%AxialCoefs,1)
      Int_BufSz   = Int_BufSz + 3  ! AxialCoefs: size of buffers for each call to pack subtype
      CALL Morison_Packaxialcoeftype( Re_Buf, Db_Buf, Int_Buf, InData%AxialCoefs(i1), ErrStat2, ErrMsg2, .TRUE. ) ! AxialCoefs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! AxialCoefs
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! AxialCoefs
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! AxialCoefs
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NPropSets
  Int_BufSz   = Int_BufSz   + 1     ! MPropSets allocated yes/no
  IF ( ALLOCATED(InData%MPropSets) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! MPropSets upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%MPropSets,1), UBOUND(InData%MPropSets,1)
      Int_BufSz   = Int_BufSz + 3  ! MPropSets: size of buffers for each call to pack subtype
      CALL Morison_Packmemberproptype( Re_Buf, Db_Buf, Int_Buf, InData%MPropSets(i1), ErrStat2, ErrMsg2, .TRUE. ) ! MPropSets 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! MPropSets
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! MPropSets
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! MPropSets
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! SimplCd
      Re_BufSz   = Re_BufSz   + 1  ! SimplCdMG
      Re_BufSz   = Re_BufSz   + 1  ! SimplCa
      Re_BufSz   = Re_BufSz   + 1  ! SimplCaMG
      Re_BufSz   = Re_BufSz   + 1  ! SimplCp
      Re_BufSz   = Re_BufSz   + 1  ! SimplCpMG
      Re_BufSz   = Re_BufSz   + 1  ! SimplAxCa
      Re_BufSz   = Re_BufSz   + 1  ! SimplAxCaMG
      Re_BufSz   = Re_BufSz   + 1  ! SimplAxCp
      Re_BufSz   = Re_BufSz   + 1  ! SimplAxCpMG
      Int_BufSz  = Int_BufSz  + 1  ! NCoefDpth
  Int_BufSz   = Int_BufSz   + 1     ! CoefDpths allocated yes/no
  IF ( ALLOCATED(InData%CoefDpths) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CoefDpths upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%CoefDpths,1), UBOUND(InData%CoefDpths,1)
      Int_BufSz   = Int_BufSz + 3  ! CoefDpths: size of buffers for each call to pack subtype
      CALL Morison_Packcoefdpths( Re_Buf, Db_Buf, Int_Buf, InData%CoefDpths(i1), ErrStat2, ErrMsg2, .TRUE. ) ! CoefDpths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! CoefDpths
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! CoefDpths
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! CoefDpths
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NCoefMembers
  Int_BufSz   = Int_BufSz   + 1     ! CoefMembers allocated yes/no
  IF ( ALLOCATED(InData%CoefMembers) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CoefMembers upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%CoefMembers,1), UBOUND(InData%CoefMembers,1)
      Int_BufSz   = Int_BufSz + 3  ! CoefMembers: size of buffers for each call to pack subtype
      CALL Morison_Packcoefmembers( Re_Buf, Db_Buf, Int_Buf, InData%CoefMembers(i1), ErrStat2, ErrMsg2, .TRUE. ) ! CoefMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! CoefMembers
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! CoefMembers
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! CoefMembers
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NMembers
  Int_BufSz   = Int_BufSz   + 1     ! InpMembers allocated yes/no
  IF ( ALLOCATED(InData%InpMembers) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! InpMembers upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%InpMembers,1), UBOUND(InData%InpMembers,1)
      Int_BufSz   = Int_BufSz + 3  ! InpMembers: size of buffers for each call to pack subtype
      CALL Morison_Packmemberinputtype( Re_Buf, Db_Buf, Int_Buf, InData%InpMembers(i1), ErrStat2, ErrMsg2, .TRUE. ) ! InpMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InpMembers
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InpMembers
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InpMembers
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NFillGroups
  Int_BufSz   = Int_BufSz   + 1     ! FilledGroups allocated yes/no
  IF ( ALLOCATED(InData%FilledGroups) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FilledGroups upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%FilledGroups,1), UBOUND(InData%FilledGroups,1)
      Int_BufSz   = Int_BufSz + 3  ! FilledGroups: size of buffers for each call to pack subtype
      CALL Morison_Packfilledgrouptype( Re_Buf, Db_Buf, Int_Buf, InData%FilledGroups(i1), ErrStat2, ErrMsg2, .TRUE. ) ! FilledGroups 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! FilledGroups
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! FilledGroups
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! FilledGroups
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NMGDepths
  Int_BufSz   = Int_BufSz   + 1     ! MGDepths allocated yes/no
  IF ( ALLOCATED(InData%MGDepths) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! MGDepths upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%MGDepths,1), UBOUND(InData%MGDepths,1)
      Int_BufSz   = Int_BufSz + 3  ! MGDepths: size of buffers for each call to pack subtype
      CALL Morison_Packmgdepthstype( Re_Buf, Db_Buf, Int_Buf, InData%MGDepths(i1), ErrStat2, ErrMsg2, .TRUE. ) ! MGDepths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! MGDepths
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! MGDepths
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! MGDepths
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! MGTop
      Re_BufSz   = Re_BufSz   + 1  ! MGBottom
      Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz   = Int_BufSz   + 1     ! MOutLst allocated yes/no
  IF ( ALLOCATED(InData%MOutLst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! MOutLst upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
      Int_BufSz   = Int_BufSz + 3  ! MOutLst: size of buffers for each call to pack subtype
      CALL Morison_Packmoutput( Re_Buf, Db_Buf, Int_Buf, InData%MOutLst(i1), ErrStat2, ErrMsg2, .TRUE. ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! MOutLst
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! MOutLst
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! MOutLst
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NJOutputs
  Int_BufSz   = Int_BufSz   + 1     ! JOutLst allocated yes/no
  IF ( ALLOCATED(InData%JOutLst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! JOutLst upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
      Int_BufSz   = Int_BufSz + 3  ! JOutLst: size of buffers for each call to pack subtype
      CALL Morison_Packjoutput( Re_Buf, Db_Buf, Int_Buf, InData%JOutLst(i1), ErrStat2, ErrMsg2, .TRUE. ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! JOutLst
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! JOutLst
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! JOutLst
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutList)*LEN(InData%OutList)  ! OutList
  Int_BufSz   = Int_BufSz   + 1     ! ValidOutList allocated yes/no
  IF ( ALLOCATED(InData%ValidOutList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ValidOutList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ValidOutList)  ! ValidOutList
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumOuts
      Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
      Int_BufSz  = Int_BufSz  + 1  ! OutAll
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%OutRootName)  ! OutRootName
      Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
      Int_BufSz  = Int_BufSz  + 1  ! UnSum
      Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  Int_BufSz   = Int_BufSz   + 1     ! WaveAcc allocated yes/no
  IF ( ALLOCATED(InData%WaveAcc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveAcc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveAcc)  ! WaveAcc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveTime allocated yes/no
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveTime upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveTime)  ! WaveTime
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveDynP allocated yes/no
  IF ( ALLOCATED(InData%WaveDynP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! WaveDynP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveDynP)  ! WaveDynP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveVel allocated yes/no
  IF ( ALLOCATED(InData%WaveVel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveVel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveVel)  ! WaveVel
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! nodeInWater allocated yes/no
  IF ( ALLOCATED(InData%nodeInWater) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! nodeInWater upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%nodeInWater)  ! nodeInWater
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%Gravity
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDens
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDpth
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MSL2SWL
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NJoints
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NNodes
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TotalPossibleSuperMembers
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%InpJoints) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InpJoints,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InpJoints,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%InpJoints,1), UBOUND(InData%InpJoints,1)
      CALL Morison_Packjointtype( Re_Buf, Db_Buf, Int_Buf, InData%InpJoints(i1), ErrStat2, ErrMsg2, OnlySize ) ! InpJoints 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Nodes) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Nodes,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Nodes,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
      CALL Morison_Packnodetype( Re_Buf, Db_Buf, Int_Buf, InData%Nodes(i1), ErrStat2, ErrMsg2, OnlySize ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NElements
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Elements) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Elements,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Elements,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%Elements,1), UBOUND(InData%Elements,1)
      CALL Morison_Packmembertype( Re_Buf, Db_Buf, Int_Buf, InData%Elements(i1), ErrStat2, ErrMsg2, OnlySize ) ! Elements 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NAxCoefs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%AxialCoefs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AxialCoefs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AxialCoefs,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%AxialCoefs,1), UBOUND(InData%AxialCoefs,1)
      CALL Morison_Packaxialcoeftype( Re_Buf, Db_Buf, Int_Buf, InData%AxialCoefs(i1), ErrStat2, ErrMsg2, OnlySize ) ! AxialCoefs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NPropSets
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%MPropSets) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MPropSets,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MPropSets,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%MPropSets,1), UBOUND(InData%MPropSets,1)
      CALL Morison_Packmemberproptype( Re_Buf, Db_Buf, Int_Buf, InData%MPropSets(i1), ErrStat2, ErrMsg2, OnlySize ) ! MPropSets 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%SimplCd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplCdMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplCaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplCpMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplAxCa
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplAxCaMG
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplAxCp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SimplAxCpMG
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NCoefDpth
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%CoefDpths) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CoefDpths,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CoefDpths,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%CoefDpths,1), UBOUND(InData%CoefDpths,1)
      CALL Morison_Packcoefdpths( Re_Buf, Db_Buf, Int_Buf, InData%CoefDpths(i1), ErrStat2, ErrMsg2, OnlySize ) ! CoefDpths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NCoefMembers
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%CoefMembers) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CoefMembers,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CoefMembers,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%CoefMembers,1), UBOUND(InData%CoefMembers,1)
      CALL Morison_Packcoefmembers( Re_Buf, Db_Buf, Int_Buf, InData%CoefMembers(i1), ErrStat2, ErrMsg2, OnlySize ) ! CoefMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NMembers
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%InpMembers) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%InpMembers,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%InpMembers,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%InpMembers,1), UBOUND(InData%InpMembers,1)
      CALL Morison_Packmemberinputtype( Re_Buf, Db_Buf, Int_Buf, InData%InpMembers(i1), ErrStat2, ErrMsg2, OnlySize ) ! InpMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NFillGroups
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%FilledGroups) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FilledGroups,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FilledGroups,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%FilledGroups,1), UBOUND(InData%FilledGroups,1)
      CALL Morison_Packfilledgrouptype( Re_Buf, Db_Buf, Int_Buf, InData%FilledGroups(i1), ErrStat2, ErrMsg2, OnlySize ) ! FilledGroups 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NMGDepths
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%MGDepths) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MGDepths,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MGDepths,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%MGDepths,1), UBOUND(InData%MGDepths,1)
      CALL Morison_Packmgdepthstype( Re_Buf, Db_Buf, Int_Buf, InData%MGDepths(i1), ErrStat2, ErrMsg2, OnlySize ) ! MGDepths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%MGTop
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MGBottom
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NMOutputs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%MOutLst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MOutLst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MOutLst,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
      CALL Morison_Packmoutput( Re_Buf, Db_Buf, Int_Buf, InData%MOutLst(i1), ErrStat2, ErrMsg2, OnlySize ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NJOutputs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%JOutLst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%JOutLst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%JOutLst,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
      CALL Morison_Packjoutput( Re_Buf, Db_Buf, Int_Buf, InData%JOutLst(i1), ErrStat2, ErrMsg2, OnlySize ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    DO i1 = LBOUND(InData%OutList,1), UBOUND(InData%OutList,1)
      DO I = 1, LEN(InData%OutList)
        IntKiBuf(Int_Xferred) = ICHAR(InData%OutList(i1)(I:I), IntKi)
        Int_Xferred = Int_Xferred + 1
      END DO ! I
    END DO
  IF ( .NOT. ALLOCATED(InData%ValidOutList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ValidOutList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ValidOutList,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ValidOutList,1), UBOUND(InData%ValidOutList,1)
        IntKiBuf(Int_Xferred) = TRANSFER(InData%ValidOutList(i1), IntKiBuf(1))
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumOuts
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%OutSwtch
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%OutAll, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%OutRootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%OutRootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = InData%UnOutFile
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%UnSum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NStepWave
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%WaveAcc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveAcc,3), UBOUND(InData%WaveAcc,3)
        DO i2 = LBOUND(InData%WaveAcc,2), UBOUND(InData%WaveAcc,2)
          DO i1 = LBOUND(InData%WaveAcc,1), UBOUND(InData%WaveAcc,1)
            ReKiBuf(Re_Xferred) = InData%WaveAcc(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveTime) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveTime,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveTime,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveTime,1), UBOUND(InData%WaveTime,1)
        ReKiBuf(Re_Xferred) = InData%WaveTime(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveDynP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveDynP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveDynP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveDynP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveDynP,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%WaveDynP,2), UBOUND(InData%WaveDynP,2)
        DO i1 = LBOUND(InData%WaveDynP,1), UBOUND(InData%WaveDynP,1)
          ReKiBuf(Re_Xferred) = InData%WaveDynP(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveVel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveVel,3), UBOUND(InData%WaveVel,3)
        DO i2 = LBOUND(InData%WaveVel,2), UBOUND(InData%WaveVel,2)
          DO i1 = LBOUND(InData%WaveVel,1), UBOUND(InData%WaveVel,1)
            ReKiBuf(Re_Xferred) = InData%WaveVel(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%nodeInWater) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%nodeInWater,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%nodeInWater,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%nodeInWater,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%nodeInWater,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%nodeInWater,2), UBOUND(InData%nodeInWater,2)
        DO i1 = LBOUND(InData%nodeInWater,1), UBOUND(InData%nodeInWater,1)
          IntKiBuf(Int_Xferred) = InData%nodeInWater(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE Morison_PackInitInput

 SUBROUTINE Morison_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Gravity = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDpth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MSL2SWL = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NJoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NNodes = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TotalPossibleSuperMembers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InpJoints not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InpJoints)) DEALLOCATE(OutData%InpJoints)
    ALLOCATE(OutData%InpJoints(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InpJoints.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%InpJoints,1), UBOUND(OutData%InpJoints,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackjointtype( Re_Buf, Db_Buf, Int_Buf, OutData%InpJoints(i1), ErrStat2, ErrMsg2 ) ! InpJoints 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Nodes not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Nodes)) DEALLOCATE(OutData%Nodes)
    ALLOCATE(OutData%Nodes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%Nodes,1), UBOUND(OutData%Nodes,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpacknodetype( Re_Buf, Db_Buf, Int_Buf, OutData%Nodes(i1), ErrStat2, ErrMsg2 ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NElements = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Elements not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Elements)) DEALLOCATE(OutData%Elements)
    ALLOCATE(OutData%Elements(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Elements.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%Elements,1), UBOUND(OutData%Elements,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmembertype( Re_Buf, Db_Buf, Int_Buf, OutData%Elements(i1), ErrStat2, ErrMsg2 ) ! Elements 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NAxCoefs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AxialCoefs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AxialCoefs)) DEALLOCATE(OutData%AxialCoefs)
    ALLOCATE(OutData%AxialCoefs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AxialCoefs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%AxialCoefs,1), UBOUND(OutData%AxialCoefs,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackaxialcoeftype( Re_Buf, Db_Buf, Int_Buf, OutData%AxialCoefs(i1), ErrStat2, ErrMsg2 ) ! AxialCoefs 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NPropSets = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MPropSets not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MPropSets)) DEALLOCATE(OutData%MPropSets)
    ALLOCATE(OutData%MPropSets(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MPropSets.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%MPropSets,1), UBOUND(OutData%MPropSets,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmemberproptype( Re_Buf, Db_Buf, Int_Buf, OutData%MPropSets(i1), ErrStat2, ErrMsg2 ) ! MPropSets 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%SimplCd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplCdMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplCaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplCpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplAxCa = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplAxCaMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplAxCp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SimplAxCpMG = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NCoefDpth = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CoefDpths not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CoefDpths)) DEALLOCATE(OutData%CoefDpths)
    ALLOCATE(OutData%CoefDpths(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoefDpths.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%CoefDpths,1), UBOUND(OutData%CoefDpths,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackcoefdpths( Re_Buf, Db_Buf, Int_Buf, OutData%CoefDpths(i1), ErrStat2, ErrMsg2 ) ! CoefDpths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NCoefMembers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CoefMembers not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CoefMembers)) DEALLOCATE(OutData%CoefMembers)
    ALLOCATE(OutData%CoefMembers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoefMembers.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%CoefMembers,1), UBOUND(OutData%CoefMembers,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackcoefmembers( Re_Buf, Db_Buf, Int_Buf, OutData%CoefMembers(i1), ErrStat2, ErrMsg2 ) ! CoefMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NMembers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! InpMembers not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%InpMembers)) DEALLOCATE(OutData%InpMembers)
    ALLOCATE(OutData%InpMembers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%InpMembers.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%InpMembers,1), UBOUND(OutData%InpMembers,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmemberinputtype( Re_Buf, Db_Buf, Int_Buf, OutData%InpMembers(i1), ErrStat2, ErrMsg2 ) ! InpMembers 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NFillGroups = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FilledGroups not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FilledGroups)) DEALLOCATE(OutData%FilledGroups)
    ALLOCATE(OutData%FilledGroups(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FilledGroups.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%FilledGroups,1), UBOUND(OutData%FilledGroups,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackfilledgrouptype( Re_Buf, Db_Buf, Int_Buf, OutData%FilledGroups(i1), ErrStat2, ErrMsg2 ) ! FilledGroups 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NMGDepths = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MGDepths not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MGDepths)) DEALLOCATE(OutData%MGDepths)
    ALLOCATE(OutData%MGDepths(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MGDepths.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%MGDepths,1), UBOUND(OutData%MGDepths,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmgdepthstype( Re_Buf, Db_Buf, Int_Buf, OutData%MGDepths(i1), ErrStat2, ErrMsg2 ) ! MGDepths 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%MGTop = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MGBottom = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NMOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MOutLst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MOutLst)) DEALLOCATE(OutData%MOutLst)
    ALLOCATE(OutData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MOutLst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%MOutLst,1), UBOUND(OutData%MOutLst,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmoutput( Re_Buf, Db_Buf, Int_Buf, OutData%MOutLst(i1), ErrStat2, ErrMsg2 ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NJOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! JOutLst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%JOutLst)) DEALLOCATE(OutData%JOutLst)
    ALLOCATE(OutData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%JOutLst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%JOutLst,1), UBOUND(OutData%JOutLst,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackjoutput( Re_Buf, Db_Buf, Int_Buf, OutData%JOutLst(i1), ErrStat2, ErrMsg2 ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    i1_l = LBOUND(OutData%OutList,1)
    i1_u = UBOUND(OutData%OutList,1)
    DO i1 = LBOUND(OutData%OutList,1), UBOUND(OutData%OutList,1)
      DO I = 1, LEN(OutData%OutList)
        OutData%OutList(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred + 1
      END DO ! I
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ValidOutList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ValidOutList)) DEALLOCATE(OutData%ValidOutList)
    ALLOCATE(OutData%ValidOutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ValidOutList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ValidOutList,1), UBOUND(OutData%ValidOutList,1)
        OutData%ValidOutList(i1) = TRANSFER(IntKiBuf(Int_Xferred), OutData%ValidOutList(i1))
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    OutData%NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%OutSwtch = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%OutAll = TRANSFER(IntKiBuf(Int_Xferred), OutData%OutAll)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%OutRootName)
      OutData%OutRootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%UnOutFile = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UnSum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NStepWave = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveAcc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveAcc)) DEALLOCATE(OutData%WaveAcc)
    ALLOCATE(OutData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveAcc,3), UBOUND(OutData%WaveAcc,3)
        DO i2 = LBOUND(OutData%WaveAcc,2), UBOUND(OutData%WaveAcc,2)
          DO i1 = LBOUND(OutData%WaveAcc,1), UBOUND(OutData%WaveAcc,1)
            OutData%WaveAcc(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveTime not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveTime)) DEALLOCATE(OutData%WaveTime)
    ALLOCATE(OutData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveTime,1), UBOUND(OutData%WaveTime,1)
        OutData%WaveTime(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveDynP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveDynP)) DEALLOCATE(OutData%WaveDynP)
    ALLOCATE(OutData%WaveDynP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDynP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%WaveDynP,2), UBOUND(OutData%WaveDynP,2)
        DO i1 = LBOUND(OutData%WaveDynP,1), UBOUND(OutData%WaveDynP,1)
          OutData%WaveDynP(i1,i2) = REAL(ReKiBuf(Re_Xferred), SiKi)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveVel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveVel)) DEALLOCATE(OutData%WaveVel)
    ALLOCATE(OutData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveVel,3), UBOUND(OutData%WaveVel,3)
        DO i2 = LBOUND(OutData%WaveVel,2), UBOUND(OutData%WaveVel,2)
          DO i1 = LBOUND(OutData%WaveVel,1), UBOUND(OutData%WaveVel,1)
            OutData%WaveVel(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! nodeInWater not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%nodeInWater)) DEALLOCATE(OutData%nodeInWater)
    ALLOCATE(OutData%nodeInWater(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%nodeInWater.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%nodeInWater,2), UBOUND(OutData%nodeInWater,2)
        DO i1 = LBOUND(OutData%nodeInWater,1), UBOUND(OutData%nodeInWater,1)
          OutData%nodeInWater(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE Morison_UnPackInitInput

 SUBROUTINE Morison_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_InitOutputType), INTENT(INOUT) :: SrcInitOutputData
   TYPE(Morison_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInitOutputData%DistribMesh, DstInitOutputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInitOutputData%LumpedMesh, DstInitOutputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%Morison_Rad)) THEN
  i1_l = LBOUND(SrcInitOutputData%Morison_Rad,1)
  i1_u = UBOUND(SrcInitOutputData%Morison_Rad,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%Morison_Rad)) THEN 
    ALLOCATE(DstInitOutputData%Morison_Rad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%Morison_Rad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%Morison_Rad = SrcInitOutputData%Morison_Rad
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE Morison_CopyInitOutput

 SUBROUTINE Morison_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Morison_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InitOutputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InitOutputData%LumpedMesh, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%Morison_Rad)) THEN
  DEALLOCATE(InitOutputData%Morison_Rad)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE Morison_DestroyInitOutput

 SUBROUTINE Morison_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DistribMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DistribMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DistribMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DistribMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! LumpedMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! LumpedMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! LumpedMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! LumpedMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! Morison_Rad allocated yes/no
  IF ( ALLOCATED(InData%Morison_Rad) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Morison_Rad upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Morison_Rad)  ! Morison_Rad
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutputHdr allocated yes/no
  IF ( ALLOCATED(InData%WriteOutputHdr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutputHdr upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WriteOutputHdr)*LEN(InData%WriteOutputHdr)  ! WriteOutputHdr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutputUnt allocated yes/no
  IF ( ALLOCATED(InData%WriteOutputUnt) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutputUnt upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WriteOutputUnt)*LEN(InData%WriteOutputUnt)  ! WriteOutputUnt
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%Morison_Rad) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Morison_Rad,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Morison_Rad,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Morison_Rad,1), UBOUND(InData%Morison_Rad,1)
        ReKiBuf(Re_Xferred) = InData%Morison_Rad(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WriteOutputHdr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutputHdr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutputHdr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutputHdr,1), UBOUND(InData%WriteOutputHdr,1)
        DO I = 1, LEN(InData%WriteOutputHdr)
          IntKiBuf(Int_Xferred) = ICHAR(InData%WriteOutputHdr(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WriteOutputUnt) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutputUnt,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutputUnt,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutputUnt,1), UBOUND(InData%WriteOutputUnt,1)
        DO I = 1, LEN(InData%WriteOutputUnt)
          IntKiBuf(Int_Xferred) = ICHAR(InData%WriteOutputUnt(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
 END SUBROUTINE Morison_PackInitOutput

 SUBROUTINE Morison_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Morison_Rad not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Morison_Rad)) DEALLOCATE(OutData%Morison_Rad)
    ALLOCATE(OutData%Morison_Rad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Morison_Rad.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Morison_Rad,1), UBOUND(OutData%Morison_Rad,1)
        OutData%Morison_Rad(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutputHdr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutputHdr)) DEALLOCATE(OutData%WriteOutputHdr)
    ALLOCATE(OutData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutputHdr,1), UBOUND(OutData%WriteOutputHdr,1)
        DO I = 1, LEN(OutData%WriteOutputHdr)
          OutData%WriteOutputHdr(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutputUnt not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutputUnt)) DEALLOCATE(OutData%WriteOutputUnt)
    ALLOCATE(OutData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutputUnt,1), UBOUND(OutData%WriteOutputUnt,1)
        DO I = 1, LEN(OutData%WriteOutputUnt)
          OutData%WriteOutputUnt(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
 END SUBROUTINE Morison_UnPackInitOutput

 SUBROUTINE Morison_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(Morison_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE Morison_CopyContState

 SUBROUTINE Morison_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(Morison_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyContState

 SUBROUTINE Morison_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyContState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackContState

 SUBROUTINE Morison_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyContState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackContState

 SUBROUTINE Morison_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(Morison_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE Morison_CopyDiscState

 SUBROUTINE Morison_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(Morison_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyDiscState

 SUBROUTINE Morison_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyDiscState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackDiscState

 SUBROUTINE Morison_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyDiscState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackDiscState

 SUBROUTINE Morison_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(Morison_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE Morison_CopyConstrState

 SUBROUTINE Morison_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(Morison_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyConstrState

 SUBROUTINE Morison_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyConstrState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_PackConstrState

 SUBROUTINE Morison_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyConstrState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Morison_UnPackConstrState

 SUBROUTINE Morison_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(Morison_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE Morison_CopyOtherState

 SUBROUTINE Morison_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(Morison_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyOtherState

 SUBROUTINE Morison_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! DummyOtherState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%DummyOtherState
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_PackOtherState

 SUBROUTINE Morison_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyOtherState = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_UnPackOtherState

 SUBROUTINE Morison_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(Morison_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%D_F_D)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_D,1)
  i1_u = UBOUND(SrcMiscData%D_F_D,1)
  i2_l = LBOUND(SrcMiscData%D_F_D,2)
  i2_u = UBOUND(SrcMiscData%D_F_D,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_D)) THEN 
    ALLOCATE(DstMiscData%D_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_D.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_D = SrcMiscData%D_F_D
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_I)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_I,1)
  i1_u = UBOUND(SrcMiscData%D_F_I,1)
  i2_l = LBOUND(SrcMiscData%D_F_I,2)
  i2_u = UBOUND(SrcMiscData%D_F_I,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_I)) THEN 
    ALLOCATE(DstMiscData%D_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_I.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_I = SrcMiscData%D_F_I
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_B)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_B,1)
  i1_u = UBOUND(SrcMiscData%D_F_B,1)
  i2_l = LBOUND(SrcMiscData%D_F_B,2)
  i2_u = UBOUND(SrcMiscData%D_F_B,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_B)) THEN 
    ALLOCATE(DstMiscData%D_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_B = SrcMiscData%D_F_B
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_AM)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_AM,1)
  i1_u = UBOUND(SrcMiscData%D_F_AM,1)
  i2_l = LBOUND(SrcMiscData%D_F_AM,2)
  i2_u = UBOUND(SrcMiscData%D_F_AM,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_AM)) THEN 
    ALLOCATE(DstMiscData%D_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_AM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_AM = SrcMiscData%D_F_AM
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_AM_M)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_AM_M,1)
  i1_u = UBOUND(SrcMiscData%D_F_AM_M,1)
  i2_l = LBOUND(SrcMiscData%D_F_AM_M,2)
  i2_u = UBOUND(SrcMiscData%D_F_AM_M,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_AM_M)) THEN 
    ALLOCATE(DstMiscData%D_F_AM_M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_AM_M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_AM_M = SrcMiscData%D_F_AM_M
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_AM_MG)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_AM_MG,1)
  i1_u = UBOUND(SrcMiscData%D_F_AM_MG,1)
  i2_l = LBOUND(SrcMiscData%D_F_AM_MG,2)
  i2_u = UBOUND(SrcMiscData%D_F_AM_MG,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_AM_MG)) THEN 
    ALLOCATE(DstMiscData%D_F_AM_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_AM_MG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_AM_MG = SrcMiscData%D_F_AM_MG
ENDIF
IF (ALLOCATED(SrcMiscData%D_F_AM_F)) THEN
  i1_l = LBOUND(SrcMiscData%D_F_AM_F,1)
  i1_u = UBOUND(SrcMiscData%D_F_AM_F,1)
  i2_l = LBOUND(SrcMiscData%D_F_AM_F,2)
  i2_u = UBOUND(SrcMiscData%D_F_AM_F,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_F_AM_F)) THEN 
    ALLOCATE(DstMiscData%D_F_AM_F(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_F_AM_F.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_F_AM_F = SrcMiscData%D_F_AM_F
ENDIF
IF (ALLOCATED(SrcMiscData%D_FV)) THEN
  i1_l = LBOUND(SrcMiscData%D_FV,1)
  i1_u = UBOUND(SrcMiscData%D_FV,1)
  i2_l = LBOUND(SrcMiscData%D_FV,2)
  i2_u = UBOUND(SrcMiscData%D_FV,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_FV)) THEN 
    ALLOCATE(DstMiscData%D_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_FV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_FV = SrcMiscData%D_FV
ENDIF
IF (ALLOCATED(SrcMiscData%D_FA)) THEN
  i1_l = LBOUND(SrcMiscData%D_FA,1)
  i1_u = UBOUND(SrcMiscData%D_FA,1)
  i2_l = LBOUND(SrcMiscData%D_FA,2)
  i2_u = UBOUND(SrcMiscData%D_FA,2)
  IF (.NOT. ALLOCATED(DstMiscData%D_FA)) THEN 
    ALLOCATE(DstMiscData%D_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_FA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_FA = SrcMiscData%D_FA
ENDIF
IF (ALLOCATED(SrcMiscData%D_FDynP)) THEN
  i1_l = LBOUND(SrcMiscData%D_FDynP,1)
  i1_u = UBOUND(SrcMiscData%D_FDynP,1)
  IF (.NOT. ALLOCATED(DstMiscData%D_FDynP)) THEN 
    ALLOCATE(DstMiscData%D_FDynP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%D_FDynP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%D_FDynP = SrcMiscData%D_FDynP
ENDIF
IF (ALLOCATED(SrcMiscData%L_F_B)) THEN
  i1_l = LBOUND(SrcMiscData%L_F_B,1)
  i1_u = UBOUND(SrcMiscData%L_F_B,1)
  i2_l = LBOUND(SrcMiscData%L_F_B,2)
  i2_u = UBOUND(SrcMiscData%L_F_B,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_F_B)) THEN 
    ALLOCATE(DstMiscData%L_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_F_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_F_B = SrcMiscData%L_F_B
ENDIF
IF (ALLOCATED(SrcMiscData%L_F_D)) THEN
  i1_l = LBOUND(SrcMiscData%L_F_D,1)
  i1_u = UBOUND(SrcMiscData%L_F_D,1)
  i2_l = LBOUND(SrcMiscData%L_F_D,2)
  i2_u = UBOUND(SrcMiscData%L_F_D,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_F_D)) THEN 
    ALLOCATE(DstMiscData%L_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_F_D.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_F_D = SrcMiscData%L_F_D
ENDIF
IF (ALLOCATED(SrcMiscData%L_F_I)) THEN
  i1_l = LBOUND(SrcMiscData%L_F_I,1)
  i1_u = UBOUND(SrcMiscData%L_F_I,1)
  i2_l = LBOUND(SrcMiscData%L_F_I,2)
  i2_u = UBOUND(SrcMiscData%L_F_I,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_F_I)) THEN 
    ALLOCATE(DstMiscData%L_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_F_I.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_F_I = SrcMiscData%L_F_I
ENDIF
IF (ALLOCATED(SrcMiscData%L_F_DP)) THEN
  i1_l = LBOUND(SrcMiscData%L_F_DP,1)
  i1_u = UBOUND(SrcMiscData%L_F_DP,1)
  i2_l = LBOUND(SrcMiscData%L_F_DP,2)
  i2_u = UBOUND(SrcMiscData%L_F_DP,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_F_DP)) THEN 
    ALLOCATE(DstMiscData%L_F_DP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_F_DP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_F_DP = SrcMiscData%L_F_DP
ENDIF
IF (ALLOCATED(SrcMiscData%L_F_AM)) THEN
  i1_l = LBOUND(SrcMiscData%L_F_AM,1)
  i1_u = UBOUND(SrcMiscData%L_F_AM,1)
  i2_l = LBOUND(SrcMiscData%L_F_AM,2)
  i2_u = UBOUND(SrcMiscData%L_F_AM,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_F_AM)) THEN 
    ALLOCATE(DstMiscData%L_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_F_AM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_F_AM = SrcMiscData%L_F_AM
ENDIF
IF (ALLOCATED(SrcMiscData%L_FV)) THEN
  i1_l = LBOUND(SrcMiscData%L_FV,1)
  i1_u = UBOUND(SrcMiscData%L_FV,1)
  i2_l = LBOUND(SrcMiscData%L_FV,2)
  i2_u = UBOUND(SrcMiscData%L_FV,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_FV)) THEN 
    ALLOCATE(DstMiscData%L_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_FV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_FV = SrcMiscData%L_FV
ENDIF
IF (ALLOCATED(SrcMiscData%L_FA)) THEN
  i1_l = LBOUND(SrcMiscData%L_FA,1)
  i1_u = UBOUND(SrcMiscData%L_FA,1)
  i2_l = LBOUND(SrcMiscData%L_FA,2)
  i2_u = UBOUND(SrcMiscData%L_FA,2)
  IF (.NOT. ALLOCATED(DstMiscData%L_FA)) THEN 
    ALLOCATE(DstMiscData%L_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_FA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_FA = SrcMiscData%L_FA
ENDIF
IF (ALLOCATED(SrcMiscData%L_FDynP)) THEN
  i1_l = LBOUND(SrcMiscData%L_FDynP,1)
  i1_u = UBOUND(SrcMiscData%L_FDynP,1)
  IF (.NOT. ALLOCATED(DstMiscData%L_FDynP)) THEN 
    ALLOCATE(DstMiscData%L_FDynP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%L_FDynP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%L_FDynP = SrcMiscData%L_FDynP
ENDIF
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
 END SUBROUTINE Morison_CopyMisc

 SUBROUTINE Morison_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(Morison_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MiscData%D_F_D)) THEN
  DEALLOCATE(MiscData%D_F_D)
ENDIF
IF (ALLOCATED(MiscData%D_F_I)) THEN
  DEALLOCATE(MiscData%D_F_I)
ENDIF
IF (ALLOCATED(MiscData%D_F_B)) THEN
  DEALLOCATE(MiscData%D_F_B)
ENDIF
IF (ALLOCATED(MiscData%D_F_AM)) THEN
  DEALLOCATE(MiscData%D_F_AM)
ENDIF
IF (ALLOCATED(MiscData%D_F_AM_M)) THEN
  DEALLOCATE(MiscData%D_F_AM_M)
ENDIF
IF (ALLOCATED(MiscData%D_F_AM_MG)) THEN
  DEALLOCATE(MiscData%D_F_AM_MG)
ENDIF
IF (ALLOCATED(MiscData%D_F_AM_F)) THEN
  DEALLOCATE(MiscData%D_F_AM_F)
ENDIF
IF (ALLOCATED(MiscData%D_FV)) THEN
  DEALLOCATE(MiscData%D_FV)
ENDIF
IF (ALLOCATED(MiscData%D_FA)) THEN
  DEALLOCATE(MiscData%D_FA)
ENDIF
IF (ALLOCATED(MiscData%D_FDynP)) THEN
  DEALLOCATE(MiscData%D_FDynP)
ENDIF
IF (ALLOCATED(MiscData%L_F_B)) THEN
  DEALLOCATE(MiscData%L_F_B)
ENDIF
IF (ALLOCATED(MiscData%L_F_D)) THEN
  DEALLOCATE(MiscData%L_F_D)
ENDIF
IF (ALLOCATED(MiscData%L_F_I)) THEN
  DEALLOCATE(MiscData%L_F_I)
ENDIF
IF (ALLOCATED(MiscData%L_F_DP)) THEN
  DEALLOCATE(MiscData%L_F_DP)
ENDIF
IF (ALLOCATED(MiscData%L_F_AM)) THEN
  DEALLOCATE(MiscData%L_F_AM)
ENDIF
IF (ALLOCATED(MiscData%L_FV)) THEN
  DEALLOCATE(MiscData%L_FV)
ENDIF
IF (ALLOCATED(MiscData%L_FA)) THEN
  DEALLOCATE(MiscData%L_FA)
ENDIF
IF (ALLOCATED(MiscData%L_FDynP)) THEN
  DEALLOCATE(MiscData%L_FDynP)
ENDIF
 END SUBROUTINE Morison_DestroyMisc

 SUBROUTINE Morison_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! D_F_D allocated yes/no
  IF ( ALLOCATED(InData%D_F_D) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_D upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_D)  ! D_F_D
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_I allocated yes/no
  IF ( ALLOCATED(InData%D_F_I) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_I upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_I)  ! D_F_I
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_B allocated yes/no
  IF ( ALLOCATED(InData%D_F_B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_B upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_B)  ! D_F_B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_AM allocated yes/no
  IF ( ALLOCATED(InData%D_F_AM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_AM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_AM)  ! D_F_AM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_AM_M allocated yes/no
  IF ( ALLOCATED(InData%D_F_AM_M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_AM_M upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_AM_M)  ! D_F_AM_M
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_AM_MG allocated yes/no
  IF ( ALLOCATED(InData%D_F_AM_MG) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_AM_MG upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_AM_MG)  ! D_F_AM_MG
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_AM_F allocated yes/no
  IF ( ALLOCATED(InData%D_F_AM_F) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_AM_F upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_AM_F)  ! D_F_AM_F
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_FV allocated yes/no
  IF ( ALLOCATED(InData%D_FV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_FV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_FV)  ! D_FV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_FA allocated yes/no
  IF ( ALLOCATED(InData%D_FA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_FA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_FA)  ! D_FA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_FDynP allocated yes/no
  IF ( ALLOCATED(InData%D_FDynP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! D_FDynP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_FDynP)  ! D_FDynP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_B allocated yes/no
  IF ( ALLOCATED(InData%L_F_B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_B upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_B)  ! L_F_B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_D allocated yes/no
  IF ( ALLOCATED(InData%L_F_D) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_D upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_D)  ! L_F_D
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_I allocated yes/no
  IF ( ALLOCATED(InData%L_F_I) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_I upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_I)  ! L_F_I
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_DP allocated yes/no
  IF ( ALLOCATED(InData%L_F_DP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_DP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_DP)  ! L_F_DP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_AM allocated yes/no
  IF ( ALLOCATED(InData%L_F_AM) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_AM upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_AM)  ! L_F_AM
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_FV allocated yes/no
  IF ( ALLOCATED(InData%L_FV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_FV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_FV)  ! L_FV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_FA allocated yes/no
  IF ( ALLOCATED(InData%L_FA) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_FA upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_FA)  ! L_FA
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_FDynP allocated yes/no
  IF ( ALLOCATED(InData%L_FDynP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! L_FDynP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_FDynP)  ! L_FDynP
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! LastIndWave
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%D_F_D) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_D,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_D,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_D,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_D,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_D,2), UBOUND(InData%D_F_D,2)
        DO i1 = LBOUND(InData%D_F_D,1), UBOUND(InData%D_F_D,1)
          ReKiBuf(Re_Xferred) = InData%D_F_D(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_I) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_I,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_I,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_I,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_I,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_I,2), UBOUND(InData%D_F_I,2)
        DO i1 = LBOUND(InData%D_F_I,1), UBOUND(InData%D_F_I,1)
          ReKiBuf(Re_Xferred) = InData%D_F_I(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_B,2), UBOUND(InData%D_F_B,2)
        DO i1 = LBOUND(InData%D_F_B,1), UBOUND(InData%D_F_B,1)
          ReKiBuf(Re_Xferred) = InData%D_F_B(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_AM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_AM,2), UBOUND(InData%D_F_AM,2)
        DO i1 = LBOUND(InData%D_F_AM,1), UBOUND(InData%D_F_AM,1)
          ReKiBuf(Re_Xferred) = InData%D_F_AM(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_AM_M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_M,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_AM_M,2), UBOUND(InData%D_F_AM_M,2)
        DO i1 = LBOUND(InData%D_F_AM_M,1), UBOUND(InData%D_F_AM_M,1)
          ReKiBuf(Re_Xferred) = InData%D_F_AM_M(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_AM_MG) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_MG,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_MG,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_MG,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_MG,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_AM_MG,2), UBOUND(InData%D_F_AM_MG,2)
        DO i1 = LBOUND(InData%D_F_AM_MG,1), UBOUND(InData%D_F_AM_MG,1)
          ReKiBuf(Re_Xferred) = InData%D_F_AM_MG(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_AM_F) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_F,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_F,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_AM_F,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_AM_F,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_AM_F,2), UBOUND(InData%D_F_AM_F,2)
        DO i1 = LBOUND(InData%D_F_AM_F,1), UBOUND(InData%D_F_AM_F,1)
          ReKiBuf(Re_Xferred) = InData%D_F_AM_F(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_FV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_FV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_FV,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_FV,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_FV,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_FV,2), UBOUND(InData%D_FV,2)
        DO i1 = LBOUND(InData%D_FV,1), UBOUND(InData%D_FV,1)
          ReKiBuf(Re_Xferred) = InData%D_FV(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_FA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_FA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_FA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_FA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_FA,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_FA,2), UBOUND(InData%D_FA,2)
        DO i1 = LBOUND(InData%D_FA,1), UBOUND(InData%D_FA,1)
          ReKiBuf(Re_Xferred) = InData%D_FA(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_FDynP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_FDynP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_FDynP,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%D_FDynP,1), UBOUND(InData%D_FDynP,1)
        ReKiBuf(Re_Xferred) = InData%D_FDynP(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_B,2), UBOUND(InData%L_F_B,2)
        DO i1 = LBOUND(InData%L_F_B,1), UBOUND(InData%L_F_B,1)
          ReKiBuf(Re_Xferred) = InData%L_F_B(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_D) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_D,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_D,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_D,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_D,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_D,2), UBOUND(InData%L_F_D,2)
        DO i1 = LBOUND(InData%L_F_D,1), UBOUND(InData%L_F_D,1)
          ReKiBuf(Re_Xferred) = InData%L_F_D(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_I) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_I,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_I,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_I,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_I,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_I,2), UBOUND(InData%L_F_I,2)
        DO i1 = LBOUND(InData%L_F_I,1), UBOUND(InData%L_F_I,1)
          ReKiBuf(Re_Xferred) = InData%L_F_I(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_DP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_DP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_DP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_DP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_DP,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_DP,2), UBOUND(InData%L_F_DP,2)
        DO i1 = LBOUND(InData%L_F_DP,1), UBOUND(InData%L_F_DP,1)
          ReKiBuf(Re_Xferred) = InData%L_F_DP(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_AM) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_AM,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_AM,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_AM,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_AM,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_AM,2), UBOUND(InData%L_F_AM,2)
        DO i1 = LBOUND(InData%L_F_AM,1), UBOUND(InData%L_F_AM,1)
          ReKiBuf(Re_Xferred) = InData%L_F_AM(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_FV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_FV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_FV,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_FV,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_FV,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_FV,2), UBOUND(InData%L_FV,2)
        DO i1 = LBOUND(InData%L_FV,1), UBOUND(InData%L_FV,1)
          ReKiBuf(Re_Xferred) = InData%L_FV(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_FA) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_FA,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_FA,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_FA,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_FA,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_FA,2), UBOUND(InData%L_FA,2)
        DO i1 = LBOUND(InData%L_FA,1), UBOUND(InData%L_FA,1)
          ReKiBuf(Re_Xferred) = InData%L_FA(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_FDynP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_FDynP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_FDynP,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%L_FDynP,1), UBOUND(InData%L_FDynP,1)
        ReKiBuf(Re_Xferred) = InData%L_FDynP(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%LastIndWave
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_PackMisc

 SUBROUTINE Morison_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_D not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_D)) DEALLOCATE(OutData%D_F_D)
    ALLOCATE(OutData%D_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_D.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_D,2), UBOUND(OutData%D_F_D,2)
        DO i1 = LBOUND(OutData%D_F_D,1), UBOUND(OutData%D_F_D,1)
          OutData%D_F_D(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_I not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_I)) DEALLOCATE(OutData%D_F_I)
    ALLOCATE(OutData%D_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_I.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_I,2), UBOUND(OutData%D_F_I,2)
        DO i1 = LBOUND(OutData%D_F_I,1), UBOUND(OutData%D_F_I,1)
          OutData%D_F_I(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_B)) DEALLOCATE(OutData%D_F_B)
    ALLOCATE(OutData%D_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_B,2), UBOUND(OutData%D_F_B,2)
        DO i1 = LBOUND(OutData%D_F_B,1), UBOUND(OutData%D_F_B,1)
          OutData%D_F_B(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_AM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_AM)) DEALLOCATE(OutData%D_F_AM)
    ALLOCATE(OutData%D_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_AM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_AM,2), UBOUND(OutData%D_F_AM,2)
        DO i1 = LBOUND(OutData%D_F_AM,1), UBOUND(OutData%D_F_AM,1)
          OutData%D_F_AM(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_AM_M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_AM_M)) DEALLOCATE(OutData%D_F_AM_M)
    ALLOCATE(OutData%D_F_AM_M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_AM_M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_AM_M,2), UBOUND(OutData%D_F_AM_M,2)
        DO i1 = LBOUND(OutData%D_F_AM_M,1), UBOUND(OutData%D_F_AM_M,1)
          OutData%D_F_AM_M(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_AM_MG not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_AM_MG)) DEALLOCATE(OutData%D_F_AM_MG)
    ALLOCATE(OutData%D_F_AM_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_AM_MG.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_AM_MG,2), UBOUND(OutData%D_F_AM_MG,2)
        DO i1 = LBOUND(OutData%D_F_AM_MG,1), UBOUND(OutData%D_F_AM_MG,1)
          OutData%D_F_AM_MG(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_AM_F not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_AM_F)) DEALLOCATE(OutData%D_F_AM_F)
    ALLOCATE(OutData%D_F_AM_F(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_AM_F.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_AM_F,2), UBOUND(OutData%D_F_AM_F,2)
        DO i1 = LBOUND(OutData%D_F_AM_F,1), UBOUND(OutData%D_F_AM_F,1)
          OutData%D_F_AM_F(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_FV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_FV)) DEALLOCATE(OutData%D_FV)
    ALLOCATE(OutData%D_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_FV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_FV,2), UBOUND(OutData%D_FV,2)
        DO i1 = LBOUND(OutData%D_FV,1), UBOUND(OutData%D_FV,1)
          OutData%D_FV(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_FA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_FA)) DEALLOCATE(OutData%D_FA)
    ALLOCATE(OutData%D_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_FA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_FA,2), UBOUND(OutData%D_FA,2)
        DO i1 = LBOUND(OutData%D_FA,1), UBOUND(OutData%D_FA,1)
          OutData%D_FA(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_FDynP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_FDynP)) DEALLOCATE(OutData%D_FDynP)
    ALLOCATE(OutData%D_FDynP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_FDynP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%D_FDynP,1), UBOUND(OutData%D_FDynP,1)
        OutData%D_FDynP(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_B)) DEALLOCATE(OutData%L_F_B)
    ALLOCATE(OutData%L_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_B,2), UBOUND(OutData%L_F_B,2)
        DO i1 = LBOUND(OutData%L_F_B,1), UBOUND(OutData%L_F_B,1)
          OutData%L_F_B(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_D not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_D)) DEALLOCATE(OutData%L_F_D)
    ALLOCATE(OutData%L_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_D.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_D,2), UBOUND(OutData%L_F_D,2)
        DO i1 = LBOUND(OutData%L_F_D,1), UBOUND(OutData%L_F_D,1)
          OutData%L_F_D(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_I not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_I)) DEALLOCATE(OutData%L_F_I)
    ALLOCATE(OutData%L_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_I.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_I,2), UBOUND(OutData%L_F_I,2)
        DO i1 = LBOUND(OutData%L_F_I,1), UBOUND(OutData%L_F_I,1)
          OutData%L_F_I(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_DP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_DP)) DEALLOCATE(OutData%L_F_DP)
    ALLOCATE(OutData%L_F_DP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_DP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_DP,2), UBOUND(OutData%L_F_DP,2)
        DO i1 = LBOUND(OutData%L_F_DP,1), UBOUND(OutData%L_F_DP,1)
          OutData%L_F_DP(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_AM not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_AM)) DEALLOCATE(OutData%L_F_AM)
    ALLOCATE(OutData%L_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_AM.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_AM,2), UBOUND(OutData%L_F_AM,2)
        DO i1 = LBOUND(OutData%L_F_AM,1), UBOUND(OutData%L_F_AM,1)
          OutData%L_F_AM(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_FV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_FV)) DEALLOCATE(OutData%L_FV)
    ALLOCATE(OutData%L_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_FV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_FV,2), UBOUND(OutData%L_FV,2)
        DO i1 = LBOUND(OutData%L_FV,1), UBOUND(OutData%L_FV,1)
          OutData%L_FV(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_FA not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_FA)) DEALLOCATE(OutData%L_FA)
    ALLOCATE(OutData%L_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_FA.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_FA,2), UBOUND(OutData%L_FA,2)
        DO i1 = LBOUND(OutData%L_FA,1), UBOUND(OutData%L_FA,1)
          OutData%L_FA(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_FDynP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_FDynP)) DEALLOCATE(OutData%L_FDynP)
    ALLOCATE(OutData%L_FDynP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_FDynP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%L_FDynP,1), UBOUND(OutData%L_FDynP,1)
        OutData%L_FDynP(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%LastIndWave = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Morison_UnPackMisc

 SUBROUTINE Morison_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(Morison_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%WtrDens = SrcParamData%WtrDens
    DstParamData%NNodes = SrcParamData%NNodes
IF (ALLOCATED(SrcParamData%Nodes)) THEN
  i1_l = LBOUND(SrcParamData%Nodes,1)
  i1_u = UBOUND(SrcParamData%Nodes,1)
  IF (.NOT. ALLOCATED(DstParamData%Nodes)) THEN 
    ALLOCATE(DstParamData%Nodes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Nodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%Nodes,1), UBOUND(SrcParamData%Nodes,1)
      CALL Morison_Copynodetype( SrcParamData%Nodes(i1), DstParamData%Nodes(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%D_F_I)) THEN
  i1_l = LBOUND(SrcParamData%D_F_I,1)
  i1_u = UBOUND(SrcParamData%D_F_I,1)
  i2_l = LBOUND(SrcParamData%D_F_I,2)
  i2_u = UBOUND(SrcParamData%D_F_I,2)
  i3_l = LBOUND(SrcParamData%D_F_I,3)
  i3_u = UBOUND(SrcParamData%D_F_I,3)
  IF (.NOT. ALLOCATED(DstParamData%D_F_I)) THEN 
    ALLOCATE(DstParamData%D_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_I.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_F_I = SrcParamData%D_F_I
ENDIF
IF (ALLOCATED(SrcParamData%D_F_DP)) THEN
  i1_l = LBOUND(SrcParamData%D_F_DP,1)
  i1_u = UBOUND(SrcParamData%D_F_DP,1)
  i2_l = LBOUND(SrcParamData%D_F_DP,2)
  i2_u = UBOUND(SrcParamData%D_F_DP,2)
  i3_l = LBOUND(SrcParamData%D_F_DP,3)
  i3_u = UBOUND(SrcParamData%D_F_DP,3)
  IF (.NOT. ALLOCATED(DstParamData%D_F_DP)) THEN 
    ALLOCATE(DstParamData%D_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_DP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_F_DP = SrcParamData%D_F_DP
ENDIF
IF (ALLOCATED(SrcParamData%D_dragConst)) THEN
  i1_l = LBOUND(SrcParamData%D_dragConst,1)
  i1_u = UBOUND(SrcParamData%D_dragConst,1)
  IF (.NOT. ALLOCATED(DstParamData%D_dragConst)) THEN 
    ALLOCATE(DstParamData%D_dragConst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_dragConst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_dragConst = SrcParamData%D_dragConst
ENDIF
IF (ALLOCATED(SrcParamData%L_An)) THEN
  i1_l = LBOUND(SrcParamData%L_An,1)
  i1_u = UBOUND(SrcParamData%L_An,1)
  i2_l = LBOUND(SrcParamData%L_An,2)
  i2_u = UBOUND(SrcParamData%L_An,2)
  IF (.NOT. ALLOCATED(DstParamData%L_An)) THEN 
    ALLOCATE(DstParamData%L_An(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_An.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_An = SrcParamData%L_An
ENDIF
IF (ALLOCATED(SrcParamData%L_F_B)) THEN
  i1_l = LBOUND(SrcParamData%L_F_B,1)
  i1_u = UBOUND(SrcParamData%L_F_B,1)
  i2_l = LBOUND(SrcParamData%L_F_B,2)
  i2_u = UBOUND(SrcParamData%L_F_B,2)
  IF (.NOT. ALLOCATED(DstParamData%L_F_B)) THEN 
    ALLOCATE(DstParamData%L_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_F_B = SrcParamData%L_F_B
ENDIF
IF (ALLOCATED(SrcParamData%L_F_I)) THEN
  i1_l = LBOUND(SrcParamData%L_F_I,1)
  i1_u = UBOUND(SrcParamData%L_F_I,1)
  i2_l = LBOUND(SrcParamData%L_F_I,2)
  i2_u = UBOUND(SrcParamData%L_F_I,2)
  i3_l = LBOUND(SrcParamData%L_F_I,3)
  i3_u = UBOUND(SrcParamData%L_F_I,3)
  IF (.NOT. ALLOCATED(DstParamData%L_F_I)) THEN 
    ALLOCATE(DstParamData%L_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_I.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_F_I = SrcParamData%L_F_I
ENDIF
IF (ALLOCATED(SrcParamData%L_F_DP)) THEN
  i1_l = LBOUND(SrcParamData%L_F_DP,1)
  i1_u = UBOUND(SrcParamData%L_F_DP,1)
  i2_l = LBOUND(SrcParamData%L_F_DP,2)
  i2_u = UBOUND(SrcParamData%L_F_DP,2)
  i3_l = LBOUND(SrcParamData%L_F_DP,3)
  i3_u = UBOUND(SrcParamData%L_F_DP,3)
  IF (.NOT. ALLOCATED(DstParamData%L_F_DP)) THEN 
    ALLOCATE(DstParamData%L_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_DP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_F_DP = SrcParamData%L_F_DP
ENDIF
IF (ALLOCATED(SrcParamData%L_F_BF)) THEN
  i1_l = LBOUND(SrcParamData%L_F_BF,1)
  i1_u = UBOUND(SrcParamData%L_F_BF,1)
  i2_l = LBOUND(SrcParamData%L_F_BF,2)
  i2_u = UBOUND(SrcParamData%L_F_BF,2)
  IF (.NOT. ALLOCATED(DstParamData%L_F_BF)) THEN 
    ALLOCATE(DstParamData%L_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_BF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_F_BF = SrcParamData%L_F_BF
ENDIF
IF (ALLOCATED(SrcParamData%L_AM_M)) THEN
  i1_l = LBOUND(SrcParamData%L_AM_M,1)
  i1_u = UBOUND(SrcParamData%L_AM_M,1)
  i2_l = LBOUND(SrcParamData%L_AM_M,2)
  i2_u = UBOUND(SrcParamData%L_AM_M,2)
  i3_l = LBOUND(SrcParamData%L_AM_M,3)
  i3_u = UBOUND(SrcParamData%L_AM_M,3)
  IF (.NOT. ALLOCATED(DstParamData%L_AM_M)) THEN 
    ALLOCATE(DstParamData%L_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_AM_M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_AM_M = SrcParamData%L_AM_M
ENDIF
IF (ALLOCATED(SrcParamData%L_dragConst)) THEN
  i1_l = LBOUND(SrcParamData%L_dragConst,1)
  i1_u = UBOUND(SrcParamData%L_dragConst,1)
  IF (.NOT. ALLOCATED(DstParamData%L_dragConst)) THEN 
    ALLOCATE(DstParamData%L_dragConst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_dragConst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%L_dragConst = SrcParamData%L_dragConst
ENDIF
    DstParamData%NDistribMarkers = SrcParamData%NDistribMarkers
IF (ALLOCATED(SrcParamData%distribToNodeIndx)) THEN
  i1_l = LBOUND(SrcParamData%distribToNodeIndx,1)
  i1_u = UBOUND(SrcParamData%distribToNodeIndx,1)
  IF (.NOT. ALLOCATED(DstParamData%distribToNodeIndx)) THEN 
    ALLOCATE(DstParamData%distribToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%distribToNodeIndx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%distribToNodeIndx = SrcParamData%distribToNodeIndx
ENDIF
    DstParamData%NLumpedMarkers = SrcParamData%NLumpedMarkers
IF (ALLOCATED(SrcParamData%lumpedToNodeIndx)) THEN
  i1_l = LBOUND(SrcParamData%lumpedToNodeIndx,1)
  i1_u = UBOUND(SrcParamData%lumpedToNodeIndx,1)
  IF (.NOT. ALLOCATED(DstParamData%lumpedToNodeIndx)) THEN 
    ALLOCATE(DstParamData%lumpedToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%lumpedToNodeIndx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%lumpedToNodeIndx = SrcParamData%lumpedToNodeIndx
ENDIF
IF (ALLOCATED(SrcParamData%WaveVel)) THEN
  i1_l = LBOUND(SrcParamData%WaveVel,1)
  i1_u = UBOUND(SrcParamData%WaveVel,1)
  i2_l = LBOUND(SrcParamData%WaveVel,2)
  i2_u = UBOUND(SrcParamData%WaveVel,2)
  i3_l = LBOUND(SrcParamData%WaveVel,3)
  i3_u = UBOUND(SrcParamData%WaveVel,3)
  IF (.NOT. ALLOCATED(DstParamData%WaveVel)) THEN 
    ALLOCATE(DstParamData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveVel = SrcParamData%WaveVel
ENDIF
IF (ALLOCATED(SrcParamData%WaveAcc)) THEN
  i1_l = LBOUND(SrcParamData%WaveAcc,1)
  i1_u = UBOUND(SrcParamData%WaveAcc,1)
  i2_l = LBOUND(SrcParamData%WaveAcc,2)
  i2_u = UBOUND(SrcParamData%WaveAcc,2)
  i3_l = LBOUND(SrcParamData%WaveAcc,3)
  i3_u = UBOUND(SrcParamData%WaveAcc,3)
  IF (.NOT. ALLOCATED(DstParamData%WaveAcc)) THEN 
    ALLOCATE(DstParamData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveAcc = SrcParamData%WaveAcc
ENDIF
IF (ALLOCATED(SrcParamData%WaveDynP)) THEN
  i1_l = LBOUND(SrcParamData%WaveDynP,1)
  i1_u = UBOUND(SrcParamData%WaveDynP,1)
  i2_l = LBOUND(SrcParamData%WaveDynP,2)
  i2_u = UBOUND(SrcParamData%WaveDynP,2)
  IF (.NOT. ALLOCATED(DstParamData%WaveDynP)) THEN 
    ALLOCATE(DstParamData%WaveDynP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveDynP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveDynP = SrcParamData%WaveDynP
ENDIF
IF (ALLOCATED(SrcParamData%WaveTime)) THEN
  i1_l = LBOUND(SrcParamData%WaveTime,1)
  i1_u = UBOUND(SrcParamData%WaveTime,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveTime)) THEN 
    ALLOCATE(DstParamData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveTime.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveTime = SrcParamData%WaveTime
ENDIF
IF (ALLOCATED(SrcParamData%elementWaterState)) THEN
  i1_l = LBOUND(SrcParamData%elementWaterState,1)
  i1_u = UBOUND(SrcParamData%elementWaterState,1)
  i2_l = LBOUND(SrcParamData%elementWaterState,2)
  i2_u = UBOUND(SrcParamData%elementWaterState,2)
  IF (.NOT. ALLOCATED(DstParamData%elementWaterState)) THEN 
    ALLOCATE(DstParamData%elementWaterState(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%elementWaterState.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%elementWaterState = SrcParamData%elementWaterState
ENDIF
IF (ALLOCATED(SrcParamData%elementFillState)) THEN
  i1_l = LBOUND(SrcParamData%elementFillState,1)
  i1_u = UBOUND(SrcParamData%elementFillState,1)
  IF (.NOT. ALLOCATED(DstParamData%elementFillState)) THEN 
    ALLOCATE(DstParamData%elementFillState(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%elementFillState.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%elementFillState = SrcParamData%elementFillState
ENDIF
IF (ALLOCATED(SrcParamData%nodeInWater)) THEN
  i1_l = LBOUND(SrcParamData%nodeInWater,1)
  i1_u = UBOUND(SrcParamData%nodeInWater,1)
  i2_l = LBOUND(SrcParamData%nodeInWater,2)
  i2_u = UBOUND(SrcParamData%nodeInWater,2)
  IF (.NOT. ALLOCATED(DstParamData%nodeInWater)) THEN 
    ALLOCATE(DstParamData%nodeInWater(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nodeInWater.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%nodeInWater = SrcParamData%nodeInWater
ENDIF
IF (ALLOCATED(SrcParamData%D_F_B)) THEN
  i1_l = LBOUND(SrcParamData%D_F_B,1)
  i1_u = UBOUND(SrcParamData%D_F_B,1)
  i2_l = LBOUND(SrcParamData%D_F_B,2)
  i2_u = UBOUND(SrcParamData%D_F_B,2)
  IF (.NOT. ALLOCATED(DstParamData%D_F_B)) THEN 
    ALLOCATE(DstParamData%D_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_F_B = SrcParamData%D_F_B
ENDIF
IF (ALLOCATED(SrcParamData%D_F_BF)) THEN
  i1_l = LBOUND(SrcParamData%D_F_BF,1)
  i1_u = UBOUND(SrcParamData%D_F_BF,1)
  i2_l = LBOUND(SrcParamData%D_F_BF,2)
  i2_u = UBOUND(SrcParamData%D_F_BF,2)
  IF (.NOT. ALLOCATED(DstParamData%D_F_BF)) THEN 
    ALLOCATE(DstParamData%D_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_BF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_F_BF = SrcParamData%D_F_BF
ENDIF
IF (ALLOCATED(SrcParamData%D_F_MG)) THEN
  i1_l = LBOUND(SrcParamData%D_F_MG,1)
  i1_u = UBOUND(SrcParamData%D_F_MG,1)
  i2_l = LBOUND(SrcParamData%D_F_MG,2)
  i2_u = UBOUND(SrcParamData%D_F_MG,2)
  IF (.NOT. ALLOCATED(DstParamData%D_F_MG)) THEN 
    ALLOCATE(DstParamData%D_F_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_MG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_F_MG = SrcParamData%D_F_MG
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_M)) THEN
  i1_l = LBOUND(SrcParamData%D_AM_M,1)
  i1_u = UBOUND(SrcParamData%D_AM_M,1)
  i2_l = LBOUND(SrcParamData%D_AM_M,2)
  i2_u = UBOUND(SrcParamData%D_AM_M,2)
  i3_l = LBOUND(SrcParamData%D_AM_M,3)
  i3_u = UBOUND(SrcParamData%D_AM_M,3)
  IF (.NOT. ALLOCATED(DstParamData%D_AM_M)) THEN 
    ALLOCATE(DstParamData%D_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_AM_M = SrcParamData%D_AM_M
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_MG)) THEN
  i1_l = LBOUND(SrcParamData%D_AM_MG,1)
  i1_u = UBOUND(SrcParamData%D_AM_MG,1)
  IF (.NOT. ALLOCATED(DstParamData%D_AM_MG)) THEN 
    ALLOCATE(DstParamData%D_AM_MG(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_MG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_AM_MG = SrcParamData%D_AM_MG
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_F)) THEN
  i1_l = LBOUND(SrcParamData%D_AM_F,1)
  i1_u = UBOUND(SrcParamData%D_AM_F,1)
  IF (.NOT. ALLOCATED(DstParamData%D_AM_F)) THEN 
    ALLOCATE(DstParamData%D_AM_F(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_F.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D_AM_F = SrcParamData%D_AM_F
ENDIF
    DstParamData%NStepWave = SrcParamData%NStepWave
    DstParamData%NMOutputs = SrcParamData%NMOutputs
IF (ALLOCATED(SrcParamData%MOutLst)) THEN
  i1_l = LBOUND(SrcParamData%MOutLst,1)
  i1_u = UBOUND(SrcParamData%MOutLst,1)
  IF (.NOT. ALLOCATED(DstParamData%MOutLst)) THEN 
    ALLOCATE(DstParamData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MOutLst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%MOutLst,1), UBOUND(SrcParamData%MOutLst,1)
      CALL Morison_Copymoutput( SrcParamData%MOutLst(i1), DstParamData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%NJOutputs = SrcParamData%NJOutputs
IF (ALLOCATED(SrcParamData%JOutLst)) THEN
  i1_l = LBOUND(SrcParamData%JOutLst,1)
  i1_u = UBOUND(SrcParamData%JOutLst,1)
  IF (.NOT. ALLOCATED(DstParamData%JOutLst)) THEN 
    ALLOCATE(DstParamData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%JOutLst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%JOutLst,1), UBOUND(SrcParamData%JOutLst,1)
      CALL Morison_Copyjoutput( SrcParamData%JOutLst(i1), DstParamData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%NumOutAll = SrcParamData%NumOutAll
    DstParamData%OutSwtch = SrcParamData%OutSwtch
    DstParamData%UnOutFile = SrcParamData%UnOutFile
    DstParamData%OutFmt = SrcParamData%OutFmt
    DstParamData%OutSFmt = SrcParamData%OutSFmt
    DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE Morison_CopyParam

 SUBROUTINE Morison_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(Morison_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%Nodes)) THEN
DO i1 = LBOUND(ParamData%Nodes,1), UBOUND(ParamData%Nodes,1)
  CALL Morison_Destroynodetype( ParamData%Nodes(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(ParamData%Nodes)
ENDIF
IF (ALLOCATED(ParamData%D_F_I)) THEN
  DEALLOCATE(ParamData%D_F_I)
ENDIF
IF (ALLOCATED(ParamData%D_F_DP)) THEN
  DEALLOCATE(ParamData%D_F_DP)
ENDIF
IF (ALLOCATED(ParamData%D_dragConst)) THEN
  DEALLOCATE(ParamData%D_dragConst)
ENDIF
IF (ALLOCATED(ParamData%L_An)) THEN
  DEALLOCATE(ParamData%L_An)
ENDIF
IF (ALLOCATED(ParamData%L_F_B)) THEN
  DEALLOCATE(ParamData%L_F_B)
ENDIF
IF (ALLOCATED(ParamData%L_F_I)) THEN
  DEALLOCATE(ParamData%L_F_I)
ENDIF
IF (ALLOCATED(ParamData%L_F_DP)) THEN
  DEALLOCATE(ParamData%L_F_DP)
ENDIF
IF (ALLOCATED(ParamData%L_F_BF)) THEN
  DEALLOCATE(ParamData%L_F_BF)
ENDIF
IF (ALLOCATED(ParamData%L_AM_M)) THEN
  DEALLOCATE(ParamData%L_AM_M)
ENDIF
IF (ALLOCATED(ParamData%L_dragConst)) THEN
  DEALLOCATE(ParamData%L_dragConst)
ENDIF
IF (ALLOCATED(ParamData%distribToNodeIndx)) THEN
  DEALLOCATE(ParamData%distribToNodeIndx)
ENDIF
IF (ALLOCATED(ParamData%lumpedToNodeIndx)) THEN
  DEALLOCATE(ParamData%lumpedToNodeIndx)
ENDIF
IF (ALLOCATED(ParamData%WaveVel)) THEN
  DEALLOCATE(ParamData%WaveVel)
ENDIF
IF (ALLOCATED(ParamData%WaveAcc)) THEN
  DEALLOCATE(ParamData%WaveAcc)
ENDIF
IF (ALLOCATED(ParamData%WaveDynP)) THEN
  DEALLOCATE(ParamData%WaveDynP)
ENDIF
IF (ALLOCATED(ParamData%WaveTime)) THEN
  DEALLOCATE(ParamData%WaveTime)
ENDIF
IF (ALLOCATED(ParamData%elementWaterState)) THEN
  DEALLOCATE(ParamData%elementWaterState)
ENDIF
IF (ALLOCATED(ParamData%elementFillState)) THEN
  DEALLOCATE(ParamData%elementFillState)
ENDIF
IF (ALLOCATED(ParamData%nodeInWater)) THEN
  DEALLOCATE(ParamData%nodeInWater)
ENDIF
IF (ALLOCATED(ParamData%D_F_B)) THEN
  DEALLOCATE(ParamData%D_F_B)
ENDIF
IF (ALLOCATED(ParamData%D_F_BF)) THEN
  DEALLOCATE(ParamData%D_F_BF)
ENDIF
IF (ALLOCATED(ParamData%D_F_MG)) THEN
  DEALLOCATE(ParamData%D_F_MG)
ENDIF
IF (ALLOCATED(ParamData%D_AM_M)) THEN
  DEALLOCATE(ParamData%D_AM_M)
ENDIF
IF (ALLOCATED(ParamData%D_AM_MG)) THEN
  DEALLOCATE(ParamData%D_AM_MG)
ENDIF
IF (ALLOCATED(ParamData%D_AM_F)) THEN
  DEALLOCATE(ParamData%D_AM_F)
ENDIF
IF (ALLOCATED(ParamData%MOutLst)) THEN
DO i1 = LBOUND(ParamData%MOutLst,1), UBOUND(ParamData%MOutLst,1)
  CALL Morison_Destroymoutput( ParamData%MOutLst(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(ParamData%MOutLst)
ENDIF
IF (ALLOCATED(ParamData%JOutLst)) THEN
DO i1 = LBOUND(ParamData%JOutLst,1), UBOUND(ParamData%JOutLst,1)
  CALL Morison_Destroyjoutput( ParamData%JOutLst(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(ParamData%JOutLst)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE Morison_DestroyParam

 SUBROUTINE Morison_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Db_BufSz   = Db_BufSz   + 1  ! DT
      Re_BufSz   = Re_BufSz   + 1  ! WtrDens
      Int_BufSz  = Int_BufSz  + 1  ! NNodes
  Int_BufSz   = Int_BufSz   + 1     ! Nodes allocated yes/no
  IF ( ALLOCATED(InData%Nodes) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Nodes upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
      Int_BufSz   = Int_BufSz + 3  ! Nodes: size of buffers for each call to pack subtype
      CALL Morison_Packnodetype( Re_Buf, Db_Buf, Int_Buf, InData%Nodes(i1), ErrStat2, ErrMsg2, .TRUE. ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Nodes
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Nodes
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Nodes
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_I allocated yes/no
  IF ( ALLOCATED(InData%D_F_I) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! D_F_I upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_I)  ! D_F_I
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_DP allocated yes/no
  IF ( ALLOCATED(InData%D_F_DP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! D_F_DP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_DP)  ! D_F_DP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_dragConst allocated yes/no
  IF ( ALLOCATED(InData%D_dragConst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! D_dragConst upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_dragConst)  ! D_dragConst
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_An allocated yes/no
  IF ( ALLOCATED(InData%L_An) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_An upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_An)  ! L_An
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_B allocated yes/no
  IF ( ALLOCATED(InData%L_F_B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_B upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_B)  ! L_F_B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_I allocated yes/no
  IF ( ALLOCATED(InData%L_F_I) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! L_F_I upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_I)  ! L_F_I
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_DP allocated yes/no
  IF ( ALLOCATED(InData%L_F_DP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! L_F_DP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_DP)  ! L_F_DP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_F_BF allocated yes/no
  IF ( ALLOCATED(InData%L_F_BF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! L_F_BF upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_F_BF)  ! L_F_BF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_AM_M allocated yes/no
  IF ( ALLOCATED(InData%L_AM_M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! L_AM_M upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_AM_M)  ! L_AM_M
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! L_dragConst allocated yes/no
  IF ( ALLOCATED(InData%L_dragConst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! L_dragConst upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%L_dragConst)  ! L_dragConst
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NDistribMarkers
  Int_BufSz   = Int_BufSz   + 1     ! distribToNodeIndx allocated yes/no
  IF ( ALLOCATED(InData%distribToNodeIndx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! distribToNodeIndx upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%distribToNodeIndx)  ! distribToNodeIndx
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NLumpedMarkers
  Int_BufSz   = Int_BufSz   + 1     ! lumpedToNodeIndx allocated yes/no
  IF ( ALLOCATED(InData%lumpedToNodeIndx) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! lumpedToNodeIndx upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%lumpedToNodeIndx)  ! lumpedToNodeIndx
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveVel allocated yes/no
  IF ( ALLOCATED(InData%WaveVel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveVel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveVel)  ! WaveVel
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveAcc allocated yes/no
  IF ( ALLOCATED(InData%WaveAcc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveAcc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveAcc)  ! WaveAcc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveDynP allocated yes/no
  IF ( ALLOCATED(InData%WaveDynP) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! WaveDynP upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveDynP)  ! WaveDynP
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveTime allocated yes/no
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveTime upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveTime)  ! WaveTime
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! elementWaterState allocated yes/no
  IF ( ALLOCATED(InData%elementWaterState) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! elementWaterState upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%elementWaterState)  ! elementWaterState
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! elementFillState allocated yes/no
  IF ( ALLOCATED(InData%elementFillState) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! elementFillState upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%elementFillState)  ! elementFillState
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! nodeInWater allocated yes/no
  IF ( ALLOCATED(InData%nodeInWater) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! nodeInWater upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%nodeInWater)  ! nodeInWater
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_B allocated yes/no
  IF ( ALLOCATED(InData%D_F_B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_B upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_B)  ! D_F_B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_BF allocated yes/no
  IF ( ALLOCATED(InData%D_F_BF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_BF upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_BF)  ! D_F_BF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_F_MG allocated yes/no
  IF ( ALLOCATED(InData%D_F_MG) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! D_F_MG upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_F_MG)  ! D_F_MG
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_AM_M allocated yes/no
  IF ( ALLOCATED(InData%D_AM_M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! D_AM_M upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_AM_M)  ! D_AM_M
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_AM_MG allocated yes/no
  IF ( ALLOCATED(InData%D_AM_MG) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! D_AM_MG upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_AM_MG)  ! D_AM_MG
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! D_AM_F allocated yes/no
  IF ( ALLOCATED(InData%D_AM_F) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! D_AM_F upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%D_AM_F)  ! D_AM_F
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NStepWave
      Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz   = Int_BufSz   + 1     ! MOutLst allocated yes/no
  IF ( ALLOCATED(InData%MOutLst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! MOutLst upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
      Int_BufSz   = Int_BufSz + 3  ! MOutLst: size of buffers for each call to pack subtype
      CALL Morison_Packmoutput( Re_Buf, Db_Buf, Int_Buf, InData%MOutLst(i1), ErrStat2, ErrMsg2, .TRUE. ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! MOutLst
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! MOutLst
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! MOutLst
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NJOutputs
  Int_BufSz   = Int_BufSz   + 1     ! JOutLst allocated yes/no
  IF ( ALLOCATED(InData%JOutLst) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! JOutLst upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
      Int_BufSz   = Int_BufSz + 3  ! JOutLst: size of buffers for each call to pack subtype
      CALL Morison_Packjoutput( Re_Buf, Db_Buf, Int_Buf, InData%JOutLst(i1), ErrStat2, ErrMsg2, .TRUE. ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! JOutLst
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! JOutLst
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! JOutLst
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! OutParam allocated yes/no
  IF ( ALLOCATED(InData%OutParam) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! OutParam upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
      Int_BufSz   = Int_BufSz + 3  ! OutParam: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%OutParam(i1), ErrStat2, ErrMsg2, .TRUE. ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! OutParam
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! OutParam
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! OutParam
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumOuts
      Int_BufSz  = Int_BufSz  + 1  ! NumOutAll
      Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
      Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%OutFmt)  ! OutFmt
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%OutSFmt)  ! OutSFmt
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%Delim)  ! Delim
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DbKiBuf(Db_Xferred) = InData%DT
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDens
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NNodes
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Nodes) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Nodes,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Nodes,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
      CALL Morison_Packnodetype( Re_Buf, Db_Buf, Int_Buf, InData%Nodes(i1), ErrStat2, ErrMsg2, OnlySize ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_I) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_I,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_I,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_I,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_I,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_I,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_I,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%D_F_I,3), UBOUND(InData%D_F_I,3)
        DO i2 = LBOUND(InData%D_F_I,2), UBOUND(InData%D_F_I,2)
          DO i1 = LBOUND(InData%D_F_I,1), UBOUND(InData%D_F_I,1)
            ReKiBuf(Re_Xferred) = InData%D_F_I(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_DP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_DP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_DP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_DP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_DP,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_DP,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_DP,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%D_F_DP,3), UBOUND(InData%D_F_DP,3)
        DO i2 = LBOUND(InData%D_F_DP,2), UBOUND(InData%D_F_DP,2)
          DO i1 = LBOUND(InData%D_F_DP,1), UBOUND(InData%D_F_DP,1)
            ReKiBuf(Re_Xferred) = InData%D_F_DP(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_dragConst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_dragConst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_dragConst,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%D_dragConst,1), UBOUND(InData%D_dragConst,1)
        ReKiBuf(Re_Xferred) = InData%D_dragConst(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_An) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_An,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_An,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_An,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_An,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_An,2), UBOUND(InData%L_An,2)
        DO i1 = LBOUND(InData%L_An,1), UBOUND(InData%L_An,1)
          ReKiBuf(Re_Xferred) = InData%L_An(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_B,2), UBOUND(InData%L_F_B,2)
        DO i1 = LBOUND(InData%L_F_B,1), UBOUND(InData%L_F_B,1)
          ReKiBuf(Re_Xferred) = InData%L_F_B(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_I) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_I,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_I,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_I,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_I,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_I,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_I,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%L_F_I,3), UBOUND(InData%L_F_I,3)
        DO i2 = LBOUND(InData%L_F_I,2), UBOUND(InData%L_F_I,2)
          DO i1 = LBOUND(InData%L_F_I,1), UBOUND(InData%L_F_I,1)
            ReKiBuf(Re_Xferred) = InData%L_F_I(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_DP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_DP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_DP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_DP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_DP,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_DP,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_DP,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%L_F_DP,3), UBOUND(InData%L_F_DP,3)
        DO i2 = LBOUND(InData%L_F_DP,2), UBOUND(InData%L_F_DP,2)
          DO i1 = LBOUND(InData%L_F_DP,1), UBOUND(InData%L_F_DP,1)
            ReKiBuf(Re_Xferred) = InData%L_F_DP(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_F_BF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_BF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_BF,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_F_BF,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_F_BF,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%L_F_BF,2), UBOUND(InData%L_F_BF,2)
        DO i1 = LBOUND(InData%L_F_BF,1), UBOUND(InData%L_F_BF,1)
          ReKiBuf(Re_Xferred) = InData%L_F_BF(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_AM_M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_AM_M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_AM_M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_AM_M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_AM_M,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_AM_M,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_AM_M,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%L_AM_M,3), UBOUND(InData%L_AM_M,3)
        DO i2 = LBOUND(InData%L_AM_M,2), UBOUND(InData%L_AM_M,2)
          DO i1 = LBOUND(InData%L_AM_M,1), UBOUND(InData%L_AM_M,1)
            ReKiBuf(Re_Xferred) = InData%L_AM_M(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%L_dragConst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%L_dragConst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%L_dragConst,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%L_dragConst,1), UBOUND(InData%L_dragConst,1)
        ReKiBuf(Re_Xferred) = InData%L_dragConst(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NDistribMarkers
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%distribToNodeIndx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%distribToNodeIndx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%distribToNodeIndx,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%distribToNodeIndx,1), UBOUND(InData%distribToNodeIndx,1)
        IntKiBuf(Int_Xferred) = InData%distribToNodeIndx(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NLumpedMarkers
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%lumpedToNodeIndx) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%lumpedToNodeIndx,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%lumpedToNodeIndx,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%lumpedToNodeIndx,1), UBOUND(InData%lumpedToNodeIndx,1)
        IntKiBuf(Int_Xferred) = InData%lumpedToNodeIndx(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveVel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveVel,3), UBOUND(InData%WaveVel,3)
        DO i2 = LBOUND(InData%WaveVel,2), UBOUND(InData%WaveVel,2)
          DO i1 = LBOUND(InData%WaveVel,1), UBOUND(InData%WaveVel,1)
            ReKiBuf(Re_Xferred) = InData%WaveVel(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveAcc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveAcc,3), UBOUND(InData%WaveAcc,3)
        DO i2 = LBOUND(InData%WaveAcc,2), UBOUND(InData%WaveAcc,2)
          DO i1 = LBOUND(InData%WaveAcc,1), UBOUND(InData%WaveAcc,1)
            ReKiBuf(Re_Xferred) = InData%WaveAcc(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveDynP) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveDynP,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveDynP,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveDynP,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveDynP,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%WaveDynP,2), UBOUND(InData%WaveDynP,2)
        DO i1 = LBOUND(InData%WaveDynP,1), UBOUND(InData%WaveDynP,1)
          ReKiBuf(Re_Xferred) = InData%WaveDynP(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveTime) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveTime,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveTime,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveTime,1), UBOUND(InData%WaveTime,1)
        ReKiBuf(Re_Xferred) = InData%WaveTime(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%elementWaterState) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%elementWaterState,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%elementWaterState,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%elementWaterState,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%elementWaterState,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%elementWaterState,2), UBOUND(InData%elementWaterState,2)
        DO i1 = LBOUND(InData%elementWaterState,1), UBOUND(InData%elementWaterState,1)
          IntKiBuf(Int_Xferred) = InData%elementWaterState(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%elementFillState) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%elementFillState,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%elementFillState,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%elementFillState,1), UBOUND(InData%elementFillState,1)
        IntKiBuf(Int_Xferred) = InData%elementFillState(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%nodeInWater) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%nodeInWater,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%nodeInWater,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%nodeInWater,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%nodeInWater,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%nodeInWater,2), UBOUND(InData%nodeInWater,2)
        DO i1 = LBOUND(InData%nodeInWater,1), UBOUND(InData%nodeInWater,1)
          IntKiBuf(Int_Xferred) = InData%nodeInWater(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_B,2), UBOUND(InData%D_F_B,2)
        DO i1 = LBOUND(InData%D_F_B,1), UBOUND(InData%D_F_B,1)
          ReKiBuf(Re_Xferred) = InData%D_F_B(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_BF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_BF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_BF,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_BF,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_BF,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_BF,2), UBOUND(InData%D_F_BF,2)
        DO i1 = LBOUND(InData%D_F_BF,1), UBOUND(InData%D_F_BF,1)
          ReKiBuf(Re_Xferred) = InData%D_F_BF(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_F_MG) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_MG,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_MG,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_F_MG,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_F_MG,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%D_F_MG,2), UBOUND(InData%D_F_MG,2)
        DO i1 = LBOUND(InData%D_F_MG,1), UBOUND(InData%D_F_MG,1)
          ReKiBuf(Re_Xferred) = InData%D_F_MG(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_AM_M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_AM_M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_AM_M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_AM_M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_AM_M,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_AM_M,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_AM_M,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%D_AM_M,3), UBOUND(InData%D_AM_M,3)
        DO i2 = LBOUND(InData%D_AM_M,2), UBOUND(InData%D_AM_M,2)
          DO i1 = LBOUND(InData%D_AM_M,1), UBOUND(InData%D_AM_M,1)
            ReKiBuf(Re_Xferred) = InData%D_AM_M(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_AM_MG) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_AM_MG,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_AM_MG,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%D_AM_MG,1), UBOUND(InData%D_AM_MG,1)
        ReKiBuf(Re_Xferred) = InData%D_AM_MG(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%D_AM_F) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%D_AM_F,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%D_AM_F,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%D_AM_F,1), UBOUND(InData%D_AM_F,1)
        ReKiBuf(Re_Xferred) = InData%D_AM_F(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NStepWave
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NMOutputs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%MOutLst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MOutLst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MOutLst,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
      CALL Morison_Packmoutput( Re_Buf, Db_Buf, Int_Buf, InData%MOutLst(i1), ErrStat2, ErrMsg2, OnlySize ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NJOutputs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%JOutLst) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%JOutLst,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%JOutLst,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
      CALL Morison_Packjoutput( Re_Buf, Db_Buf, Int_Buf, InData%JOutLst(i1), ErrStat2, ErrMsg2, OnlySize ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%OutParam) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OutParam,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OutParam,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
      CALL NWTC_Library_Packoutparmtype( Re_Buf, Db_Buf, Int_Buf, InData%OutParam(i1), ErrStat2, ErrMsg2, OnlySize ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumOuts
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumOutAll
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%OutSwtch
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%UnOutFile
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%OutFmt)
      IntKiBuf(Int_Xferred) = ICHAR(InData%OutFmt(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%OutSFmt)
      IntKiBuf(Int_Xferred) = ICHAR(InData%OutSFmt(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%Delim)
      IntKiBuf(Int_Xferred) = ICHAR(InData%Delim(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
 END SUBROUTINE Morison_PackParam

 SUBROUTINE Morison_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DT = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%WtrDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NNodes = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Nodes not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Nodes)) DEALLOCATE(OutData%Nodes)
    ALLOCATE(OutData%Nodes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%Nodes,1), UBOUND(OutData%Nodes,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpacknodetype( Re_Buf, Db_Buf, Int_Buf, OutData%Nodes(i1), ErrStat2, ErrMsg2 ) ! Nodes 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_I not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_I)) DEALLOCATE(OutData%D_F_I)
    ALLOCATE(OutData%D_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_I.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%D_F_I,3), UBOUND(OutData%D_F_I,3)
        DO i2 = LBOUND(OutData%D_F_I,2), UBOUND(OutData%D_F_I,2)
          DO i1 = LBOUND(OutData%D_F_I,1), UBOUND(OutData%D_F_I,1)
            OutData%D_F_I(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_DP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_DP)) DEALLOCATE(OutData%D_F_DP)
    ALLOCATE(OutData%D_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_DP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%D_F_DP,3), UBOUND(OutData%D_F_DP,3)
        DO i2 = LBOUND(OutData%D_F_DP,2), UBOUND(OutData%D_F_DP,2)
          DO i1 = LBOUND(OutData%D_F_DP,1), UBOUND(OutData%D_F_DP,1)
            OutData%D_F_DP(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_dragConst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_dragConst)) DEALLOCATE(OutData%D_dragConst)
    ALLOCATE(OutData%D_dragConst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_dragConst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%D_dragConst,1), UBOUND(OutData%D_dragConst,1)
        OutData%D_dragConst(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_An not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_An)) DEALLOCATE(OutData%L_An)
    ALLOCATE(OutData%L_An(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_An.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_An,2), UBOUND(OutData%L_An,2)
        DO i1 = LBOUND(OutData%L_An,1), UBOUND(OutData%L_An,1)
          OutData%L_An(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_B)) DEALLOCATE(OutData%L_F_B)
    ALLOCATE(OutData%L_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_B,2), UBOUND(OutData%L_F_B,2)
        DO i1 = LBOUND(OutData%L_F_B,1), UBOUND(OutData%L_F_B,1)
          OutData%L_F_B(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_I not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_I)) DEALLOCATE(OutData%L_F_I)
    ALLOCATE(OutData%L_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_I.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%L_F_I,3), UBOUND(OutData%L_F_I,3)
        DO i2 = LBOUND(OutData%L_F_I,2), UBOUND(OutData%L_F_I,2)
          DO i1 = LBOUND(OutData%L_F_I,1), UBOUND(OutData%L_F_I,1)
            OutData%L_F_I(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_DP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_DP)) DEALLOCATE(OutData%L_F_DP)
    ALLOCATE(OutData%L_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_DP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%L_F_DP,3), UBOUND(OutData%L_F_DP,3)
        DO i2 = LBOUND(OutData%L_F_DP,2), UBOUND(OutData%L_F_DP,2)
          DO i1 = LBOUND(OutData%L_F_DP,1), UBOUND(OutData%L_F_DP,1)
            OutData%L_F_DP(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_F_BF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_F_BF)) DEALLOCATE(OutData%L_F_BF)
    ALLOCATE(OutData%L_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_F_BF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%L_F_BF,2), UBOUND(OutData%L_F_BF,2)
        DO i1 = LBOUND(OutData%L_F_BF,1), UBOUND(OutData%L_F_BF,1)
          OutData%L_F_BF(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_AM_M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_AM_M)) DEALLOCATE(OutData%L_AM_M)
    ALLOCATE(OutData%L_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_AM_M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%L_AM_M,3), UBOUND(OutData%L_AM_M,3)
        DO i2 = LBOUND(OutData%L_AM_M,2), UBOUND(OutData%L_AM_M,2)
          DO i1 = LBOUND(OutData%L_AM_M,1), UBOUND(OutData%L_AM_M,1)
            OutData%L_AM_M(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! L_dragConst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%L_dragConst)) DEALLOCATE(OutData%L_dragConst)
    ALLOCATE(OutData%L_dragConst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%L_dragConst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%L_dragConst,1), UBOUND(OutData%L_dragConst,1)
        OutData%L_dragConst(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%NDistribMarkers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! distribToNodeIndx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%distribToNodeIndx)) DEALLOCATE(OutData%distribToNodeIndx)
    ALLOCATE(OutData%distribToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%distribToNodeIndx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%distribToNodeIndx,1), UBOUND(OutData%distribToNodeIndx,1)
        OutData%distribToNodeIndx(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    OutData%NLumpedMarkers = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! lumpedToNodeIndx not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%lumpedToNodeIndx)) DEALLOCATE(OutData%lumpedToNodeIndx)
    ALLOCATE(OutData%lumpedToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%lumpedToNodeIndx.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%lumpedToNodeIndx,1), UBOUND(OutData%lumpedToNodeIndx,1)
        OutData%lumpedToNodeIndx(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveVel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveVel)) DEALLOCATE(OutData%WaveVel)
    ALLOCATE(OutData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveVel,3), UBOUND(OutData%WaveVel,3)
        DO i2 = LBOUND(OutData%WaveVel,2), UBOUND(OutData%WaveVel,2)
          DO i1 = LBOUND(OutData%WaveVel,1), UBOUND(OutData%WaveVel,1)
            OutData%WaveVel(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveAcc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveAcc)) DEALLOCATE(OutData%WaveAcc)
    ALLOCATE(OutData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveAcc,3), UBOUND(OutData%WaveAcc,3)
        DO i2 = LBOUND(OutData%WaveAcc,2), UBOUND(OutData%WaveAcc,2)
          DO i1 = LBOUND(OutData%WaveAcc,1), UBOUND(OutData%WaveAcc,1)
            OutData%WaveAcc(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveDynP not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveDynP)) DEALLOCATE(OutData%WaveDynP)
    ALLOCATE(OutData%WaveDynP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDynP.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%WaveDynP,2), UBOUND(OutData%WaveDynP,2)
        DO i1 = LBOUND(OutData%WaveDynP,1), UBOUND(OutData%WaveDynP,1)
          OutData%WaveDynP(i1,i2) = REAL(ReKiBuf(Re_Xferred), SiKi)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveTime not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveTime)) DEALLOCATE(OutData%WaveTime)
    ALLOCATE(OutData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveTime,1), UBOUND(OutData%WaveTime,1)
        OutData%WaveTime(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! elementWaterState not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%elementWaterState)) DEALLOCATE(OutData%elementWaterState)
    ALLOCATE(OutData%elementWaterState(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%elementWaterState.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%elementWaterState,2), UBOUND(OutData%elementWaterState,2)
        DO i1 = LBOUND(OutData%elementWaterState,1), UBOUND(OutData%elementWaterState,1)
          OutData%elementWaterState(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! elementFillState not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%elementFillState)) DEALLOCATE(OutData%elementFillState)
    ALLOCATE(OutData%elementFillState(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%elementFillState.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%elementFillState,1), UBOUND(OutData%elementFillState,1)
        OutData%elementFillState(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! nodeInWater not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%nodeInWater)) DEALLOCATE(OutData%nodeInWater)
    ALLOCATE(OutData%nodeInWater(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%nodeInWater.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%nodeInWater,2), UBOUND(OutData%nodeInWater,2)
        DO i1 = LBOUND(OutData%nodeInWater,1), UBOUND(OutData%nodeInWater,1)
          OutData%nodeInWater(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_B)) DEALLOCATE(OutData%D_F_B)
    ALLOCATE(OutData%D_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_B,2), UBOUND(OutData%D_F_B,2)
        DO i1 = LBOUND(OutData%D_F_B,1), UBOUND(OutData%D_F_B,1)
          OutData%D_F_B(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_BF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_BF)) DEALLOCATE(OutData%D_F_BF)
    ALLOCATE(OutData%D_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_BF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_BF,2), UBOUND(OutData%D_F_BF,2)
        DO i1 = LBOUND(OutData%D_F_BF,1), UBOUND(OutData%D_F_BF,1)
          OutData%D_F_BF(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_F_MG not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_F_MG)) DEALLOCATE(OutData%D_F_MG)
    ALLOCATE(OutData%D_F_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_F_MG.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%D_F_MG,2), UBOUND(OutData%D_F_MG,2)
        DO i1 = LBOUND(OutData%D_F_MG,1), UBOUND(OutData%D_F_MG,1)
          OutData%D_F_MG(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_AM_M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_AM_M)) DEALLOCATE(OutData%D_AM_M)
    ALLOCATE(OutData%D_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_AM_M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%D_AM_M,3), UBOUND(OutData%D_AM_M,3)
        DO i2 = LBOUND(OutData%D_AM_M,2), UBOUND(OutData%D_AM_M,2)
          DO i1 = LBOUND(OutData%D_AM_M,1), UBOUND(OutData%D_AM_M,1)
            OutData%D_AM_M(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_AM_MG not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_AM_MG)) DEALLOCATE(OutData%D_AM_MG)
    ALLOCATE(OutData%D_AM_MG(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_AM_MG.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%D_AM_MG,1), UBOUND(OutData%D_AM_MG,1)
        OutData%D_AM_MG(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! D_AM_F not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%D_AM_F)) DEALLOCATE(OutData%D_AM_F)
    ALLOCATE(OutData%D_AM_F(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_AM_F.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%D_AM_F,1), UBOUND(OutData%D_AM_F,1)
        OutData%D_AM_F(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%NStepWave = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NMOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MOutLst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MOutLst)) DEALLOCATE(OutData%MOutLst)
    ALLOCATE(OutData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MOutLst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%MOutLst,1), UBOUND(OutData%MOutLst,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackmoutput( Re_Buf, Db_Buf, Int_Buf, OutData%MOutLst(i1), ErrStat2, ErrMsg2 ) ! MOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NJOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! JOutLst not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%JOutLst)) DEALLOCATE(OutData%JOutLst)
    ALLOCATE(OutData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%JOutLst.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%JOutLst,1), UBOUND(OutData%JOutLst,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL Morison_Unpackjoutput( Re_Buf, Db_Buf, Int_Buf, OutData%JOutLst(i1), ErrStat2, ErrMsg2 ) ! JOutLst 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OutParam not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OutParam)) DEALLOCATE(OutData%OutParam)
    ALLOCATE(OutData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackoutparmtype( Re_Buf, Db_Buf, Int_Buf, OutData%OutParam(i1), ErrStat2, ErrMsg2 ) ! OutParam 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
    OutData%NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NumOutAll = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%OutSwtch = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UnOutFile = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%OutFmt)
      OutData%OutFmt(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%OutSFmt)
      OutData%OutSFmt(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%Delim)
      OutData%Delim(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
 END SUBROUTINE Morison_UnPackParam

 SUBROUTINE Morison_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(Morison_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInputData%DistribMesh, DstInputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%LumpedMesh, DstInputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE Morison_CopyInput

 SUBROUTINE Morison_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(Morison_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LumpedMesh, ErrStat, ErrMsg )
 END SUBROUTINE Morison_DestroyInput

 SUBROUTINE Morison_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DistribMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DistribMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DistribMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DistribMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! LumpedMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! LumpedMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! LumpedMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! LumpedMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE Morison_PackInput

 SUBROUTINE Morison_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE Morison_UnPackInput

 SUBROUTINE Morison_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(Morison_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcOutputData%DistribMesh, DstOutputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcOutputData%LumpedMesh, DstOutputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE Morison_CopyOutput

 SUBROUTINE Morison_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(Morison_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'Morison_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%LumpedMesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE Morison_DestroyOutput

 SUBROUTINE Morison_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! DistribMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! DistribMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! DistribMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! DistribMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! LumpedMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! LumpedMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! LumpedMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! LumpedMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutput allocated yes/no
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutput upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WriteOutput)  ! WriteOutput
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL MeshPack( InData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%WriteOutput) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutput,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutput,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutput,1), UBOUND(InData%WriteOutput,1)
        ReKiBuf(Re_Xferred) = InData%WriteOutput(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE Morison_PackOutput

 SUBROUTINE Morison_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Morison_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%DistribMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! DistribMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%LumpedMesh, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! LumpedMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutput not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutput)) DEALLOCATE(OutData%WriteOutput)
    ALLOCATE(OutData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutput,1), UBOUND(OutData%WriteOutput,1)
        OutData%WriteOutput(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE Morison_UnPackOutput


 SUBROUTINE Morison_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Morison_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(Morison_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Morison_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL Morison_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Morison_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Morison_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Morison_Input_ExtrapInterp


 SUBROUTINE Morison_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(Morison_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(Morison_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(Morison_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Morison_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(u1%DistribMesh, u2%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%LumpedMesh, u2%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE Morison_Input_ExtrapInterp1


 SUBROUTINE Morison_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(Morison_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(Morison_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(Morison_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(Morison_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Morison_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(u1%DistribMesh, u2%DistribMesh, u3%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%LumpedMesh, u2%LumpedMesh, u3%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE Morison_Input_ExtrapInterp2


 SUBROUTINE Morison_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Morison_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Morison_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL Morison_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Morison_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Morison_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Morison_Output_ExtrapInterp


 SUBROUTINE Morison_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(Morison_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Morison_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(y1%DistribMesh, y2%DistribMesh, tin, y_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(y1%LumpedMesh, y2%LumpedMesh, tin, y_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE Morison_Output_ExtrapInterp1


 SUBROUTINE Morison_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(Morison_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(Morison_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Morison_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(y1%DistribMesh, y2%DistribMesh, y3%DistribMesh, tin, y_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(y1%LumpedMesh, y2%LumpedMesh, y3%LumpedMesh, tin, y_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE Morison_Output_ExtrapInterp2

END MODULE Morison_Types
!ENDOFREGISTRYGENERATEDFILE
