!STARTOFREGISTRYGENERATEDFILE 'Glue_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Glue_Types
!.................................................................................................................................
! This file is part of Glue.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Glue. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Glue_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_LoadMesh                     = 1      ! Load mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_MotionMesh                   = 2      ! Motion mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Variable                     = 3      ! Individual variable mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Custom                       = 4      ! Custom mapping not used for linearization [-]
! =========  MappingType  =======
  TYPE, PUBLIC :: MappingType
    character(128)  :: Desc      !< Description of mapping (used to lookup non-mesh maps) [-]
    INTEGER(IntKi)  :: iModSrc = 0      !< Source module index in ModData array [-]
    INTEGER(IntKi)  :: iModDst = 0      !< Destination module index in ModData array [-]
    INTEGER(IntKi)  :: SrcModID = 0      !< Source module ID [-]
    INTEGER(IntKi)  :: DstModID = 0      !< Destination module ID [-]
    INTEGER(IntKi)  :: SrcIns = 0      !< Source module Instance [-]
    INTEGER(IntKi)  :: DstIns = 0      !< Destination module Instance [-]
    INTEGER(IntKi)  :: SrcMeshID = 0      !< Source mesh identifier [-]
    INTEGER(IntKi)  :: DstMeshID = 0      !< Destination mesh identifier [-]
    INTEGER(IntKi)  :: iVarSrc = 0      !< Source variable index [-]
    INTEGER(IntKi)  :: iVarDst = 0      !< Destination variable index [-]
    INTEGER(IntKi)  :: SrcDispMeshID = 0      !< Source displacement mesh identifier [-]
    INTEGER(IntKi)  :: DstDispMeshID = 0      !< Destination displacement mesh identifier [-]
    TYPE(MeshLocType)  :: SrcMeshLoc      !< Source mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: DstMeshLoc      !< Destination mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: SrcDispMeshLoc      !< Source displacement mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: DstDispMeshLoc      !< Destination displacement mesh locator (number and indices) [-]
    INTEGER(IntKi)  :: MapType = 0      !< Integer denoting mapping type (1=Load Mesh, 2=Motion Mesh, 3=Non-Mesh) [-]
    INTEGER(IntKi)  :: XfrType = 0      !< Integer denoting transfer type (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    INTEGER(IntKi)  :: XfrTypeAux = 0      !< Integer denoting transfer type (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    LOGICAL  :: Ready = .false.      !< Flag indicating Source has been ready to be transferred [-]
    LOGICAL  :: DstUsesSibling = .false.      !< Flag indicating the destination displacement mesh is a sibling of the destination load mesh [-]
    TYPE(MeshType)  :: TmpLoadMesh      !< Temporary load mesh for intermediate transfers [-]
    TYPE(MeshType)  :: TmpMotionMesh      !< Temporary motion mesh for intermediate transfers [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: TmpMatrix      !< Temporary matrix for performing transfer for destination load meshes without sibling motion meshes [-]
    TYPE(MeshMapType)  :: MeshMap      !< Mesh mapping from Source variable to Destination variable [-]
    TYPE(MeshMapType)  :: MeshMapAux      !< Auxiliary mesh mapping for destination load meshes without sibling motion mesh [-]
    INTEGER(IntKi)  :: iVarSrcTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcTransVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcTransAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcAngularVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcAngularAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcForce = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcMoment = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcDispTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstAngularVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstAngularAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstForce = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstMoment = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstDispTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstDispOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
  END TYPE MappingType
! =======================
! =========  Glue_LinType  =======
  TYPE, PUBLIC :: Glue_LinType
    character(ChanLen)  :: Abbr      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xd      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !<  [-]
  END TYPE Glue_LinType
! =======================
! =========  VarXfrType  =======
  TYPE, PUBLIC :: VarXfrType
    INTEGER(IntKi)  :: iVar = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NumVals = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iSrc = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iDst = 0_IntKi      !<  [-]
  END TYPE VarXfrType
! =======================
! =========  ModXfrType  =======
  TYPE, PUBLIC :: ModXfrType
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: xd      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    TYPE(VarXfrType) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
  END TYPE ModXfrType
! =======================
! =========  ModDataType  =======
  TYPE, PUBLIC :: ModDataType
    character(ChanLen)  :: Abbr      !< Module name abbreviation [-]
    INTEGER(IntKi)  :: ID = 0      !< Module identification number [-]
    INTEGER(IntKi)  :: iMod = 0      !< Module index in array of modules [-]
    INTEGER(IntKi)  :: Ins = 0      !< Module instance number [-]
    REAL(R8Ki)  :: DT = 0      !< Module time step [-]
    INTEGER(IntKi)  :: SubSteps = 0      !< Module number of substeps per solver time step [-]
    TYPE(ModVarsType) , POINTER :: Vars => NULL()      !< Pointer to module variables type [-]
    TYPE(ModXfrType) , DIMENSION(:), ALLOCATABLE  :: Xfr      !< Variable index for combined modules [-]
    TYPE(Glue_LinType)  :: Lin      !< Module linearization data [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: SrcMaps      !< Indices of mappings where module is the source [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DstMaps      !< Indices of mappings where module is the destination [-]
  END TYPE ModDataType
! =======================
! =========  Glue_LinParam  =======
  TYPE, PUBLIC :: Glue_LinParam
    INTEGER(IntKi)  :: NumTimes = 0_IntKi      !< Number of times to linearize [-]
    INTEGER(IntKi)  :: InterpOrder = 0_IntKi      !< Interpolation order [-]
    LOGICAL  :: SaveOPs = .false.      !< flag to save operating points during linearization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iMod      !< ModData index order for linearization [-]
  END TYPE Glue_LinParam
! =======================
! =========  Glue_ParameterType  =======
  TYPE, PUBLIC :: Glue_ParameterType
    TYPE(Glue_LinParam)  :: Lin      !< Linearization parameters [-]
    REAL(R8Ki)  :: DT = 0.0_R8Ki      !< solution time step [-]
    REAL(R8Ki)  :: ConvTol = 0.0_R8Ki      !< Solution convergence tolerance [-]
    INTEGER(IntKi)  :: NumCrctn = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: MaxConvIter = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NIter_UJac = 0_IntKi      !< Number of solution iterations between updating the Jacobian [-]
    INTEGER(IntKi)  :: NStep_UJac = 0_IntKi      !< Number of global time steps between updating the Jacobian [-]
    REAL(R8Ki)  :: Scale_UJac = 0.0_R8Ki      !<  [-]
    REAL(R8Ki)  :: AccBlend = 1      !<  [-]
    REAL(R8Ki)  :: RhoInf = 0.0_R8Ki      !< Rho infinity used for calculating Generalized-alpha coefficients [-]
    REAL(R8Ki)  :: AlphaM = 0.0_R8Ki      !< Generalized-alpha alpha_m coefficient [-]
    REAL(R8Ki)  :: AlphaF = 0.0_R8Ki      !< Generalized-alpha alpha_f coefficient [-]
    REAL(R8Ki)  :: Beta = 0.0_R8Ki      !< Generalized-alpha beta coefficient [-]
    REAL(R8Ki)  :: Gamma = 0.0_R8Ki      !< Generalized-alpha gamma coefficient [-]
    REAL(R8Ki) , DIMENSION(1:7)  :: C = 0.0_R8Ki      !< Generalized-alpha coefficient array [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX2 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iUT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iU1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iyT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iy1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJX = 0_IntKi      !< Indices of Jacobian q variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJU = 0_IntKi      !< Indices of Jacobian input variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJUT = 0_IntKi      !< Indices of Jacobian input variables from tight coupling [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iJL      !< Indices of Jacobian load variables [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ixqd      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModInit      !< ModData index order for step 0 initialization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModTC      !< ModData index order for tight coupling modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModBD      !< ModData index order for BD modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt1      !< ModData index order for option 1 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt1US      !< ModData index order for option 1 modules to update states [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt2      !< ModData index order for option 2 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModPost      !< ModData index order for post option 1 modules [-]
  END TYPE Glue_ParameterType
! =======================
! =========  Glue_LinSave  =======
  TYPE, PUBLIC :: Glue_LinSave
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: Times      !< linearization times [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: u      !< linearization operating point input [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: x      !< linearization operating point continuous state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< linearization operating point discrete state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: z      !< linearization operating point constraint state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< linearization operating point other state [-]
  END TYPE Glue_LinSave
! =======================
! =========  Glue_OutputFileType  =======
  TYPE, PUBLIC :: Glue_OutputFileType
    TYPE(Glue_LinSave)  :: Lin      !< Operating point data for linearization [-]
  END TYPE Glue_OutputFileType
! =======================
! =========  Glue_CalcSteady  =======
  TYPE, PUBLIC :: Glue_CalcSteady
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: AzimuthTarget      !< target azimuth positions where outputs are calculated [-]
    REAL(R8Ki)  :: AzimuthDelta = 0.0_R8Ki      !<  [-]
    LOGICAL  :: IsConverged = .false.      !< Steady State calculation is converged [-]
    LOGICAL  :: FoundSteady = .false.      !<  [-]
    LOGICAL  :: ForceLin = .false.      !<  [-]
    INTEGER(IntKi)  :: NumRotations = 0_IntKi      !< Number of rotor rotations [-]
    INTEGER(IntKi)  :: NumOutputs = 0_IntKi      !< Number of output values (ignoring write outputs) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: psi_buffer      !< azimuth buffer for interpolation [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: y_buffer      !< output buffer for interpolation [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: y_azimuth      !< output values at target azimuths [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_interp      !< output values interpolated to target azimuth [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_diff      !< difference between outputs from current and previous rotation [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_ref      !< reference output values for error calculation [-]
  END TYPE Glue_CalcSteady
! =======================
! =========  AeroMapCase  =======
  TYPE, PUBLIC :: AeroMapCase
    REAL(ReKi)  :: RotSpeed = 0.0_ReKi      !< Rotor speed for this case of the steady-state solve [>0] [rad/s]
    REAL(ReKi)  :: TSR = 0.0_ReKi      !< TSR for this case of the steady-state solve [>0] [-]
    REAL(ReKi)  :: WindSpeed = 0.0_ReKi      !< Windspeed for this case of the steady-state solve [>0] [m/s]
    REAL(ReKi)  :: Pitch = 0.0_ReKi      !< Pitch angle for this case of the steady-state solve [rad]
  END TYPE AeroMapCase
! =======================
! =========  Glue_AeroMap  =======
  TYPE, PUBLIC :: Glue_AeroMap
    TYPE(ModDataType)  :: Mod      !< Module combining all active modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOrder      !< Index of module order for AeroMap modules [-]
    INTEGER(IntKi)  :: iModED = 0_IntKi      !< Index of ElastoDyn module [-]
    INTEGER(IntKi)  :: iModBD = 0      !< Index of BeamDyn blade 1 module [-]
    INTEGER(IntKi)  :: iModAD = 0_IntKi      !< Index of AeroDyn module [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac11      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac12      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac21      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac22      !< Components of Jacobian matrix [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: JacPivot      !< Jacobian matrix pivot array [-]
    REAL(R8Ki)  :: JacScale = 0.0_R8Ki      !< Jacobian scaling factor for loads [-]
    REAL(R8Ki)  :: SolveTolerance = 0.0_R8Ki      !< Allowable solution tolerance [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: HubOrientation      !< Hub orientation matrix for each blade [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u1      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u2      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: Residual      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: SolveDelta      !<  [-]
    TYPE(AeroMapCase) , DIMENSION(:), ALLOCATABLE  :: Cases      !< cases to run for aero mapping [-]
    INTEGER(IntKi)  :: LinFileNum = 1      !< Linearization file number [-]
  END TYPE Glue_AeroMap
! =======================
! =========  Glue_LinMisc  =======
  TYPE, PUBLIC :: Glue_LinMisc
    INTEGER(IntKi)  :: TimeIndex = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: AzimuthIndex = 0_IntKi      !<  [-]
    LOGICAL  :: IsConverged = .false.      !<  [-]
  END TYPE Glue_LinMisc
! =======================
! =========  Glue_MiscVarType  =======
  TYPE, PUBLIC :: Glue_MiscVarType
    TYPE(ModDataType) , DIMENSION(:), ALLOCATABLE  :: Modules      !< Module variable and value data [-]
    TYPE(MappingType) , DIMENSION(:), ALLOCATABLE  :: Mappings      !< Module mapping [-]
    TYPE(ModDataType)  :: ModGlue      !< Glue code module [-]
    TYPE(Glue_LinMisc)  :: Lin      !< Linearization misc vars [-]
    TYPE(Glue_CalcSteady)  :: CS      !< CalcSteady calculation data [-]
    TYPE(Glue_AeroMap)  :: AM      !< AeroMap data [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: q      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: qn      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xn      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dxdt      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: un      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_tmp      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdyHat      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: XB      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: G      !< Used to merge state matrices [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IPIV      !<  [-]
    INTEGER(IntKi)  :: IterTotal = 0      !<  [-]
    INTEGER(IntKi)  :: IterUntilUJac = 0      !< Number of convergence iterations until Jacobian update [-]
    INTEGER(IntKi)  :: StepsUntilUJac = 0      !< Number of time steps until Jacobian update [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dq      !< Change in q [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !< Change in x [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: UDiff      !<  [-]
    LOGICAL  :: ConvWarn = .false.      !< Flag to warn about convergence failure [-]
  END TYPE Glue_MiscVarType
! =======================
CONTAINS

subroutine Glue_CopyMappingType(SrcMappingTypeData, DstMappingTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: SrcMappingTypeData
   type(MappingType), intent(inout) :: DstMappingTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMappingTypeData%Desc = SrcMappingTypeData%Desc
   DstMappingTypeData%iModSrc = SrcMappingTypeData%iModSrc
   DstMappingTypeData%iModDst = SrcMappingTypeData%iModDst
   DstMappingTypeData%SrcModID = SrcMappingTypeData%SrcModID
   DstMappingTypeData%DstModID = SrcMappingTypeData%DstModID
   DstMappingTypeData%SrcIns = SrcMappingTypeData%SrcIns
   DstMappingTypeData%DstIns = SrcMappingTypeData%DstIns
   DstMappingTypeData%SrcMeshID = SrcMappingTypeData%SrcMeshID
   DstMappingTypeData%DstMeshID = SrcMappingTypeData%DstMeshID
   DstMappingTypeData%iVarSrc = SrcMappingTypeData%iVarSrc
   DstMappingTypeData%iVarDst = SrcMappingTypeData%iVarDst
   DstMappingTypeData%SrcDispMeshID = SrcMappingTypeData%SrcDispMeshID
   DstMappingTypeData%DstDispMeshID = SrcMappingTypeData%DstDispMeshID
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%SrcMeshLoc, DstMappingTypeData%SrcMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%DstMeshLoc, DstMappingTypeData%DstMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%SrcDispMeshLoc, DstMappingTypeData%SrcDispMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%DstDispMeshLoc, DstMappingTypeData%DstDispMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMappingTypeData%MapType = SrcMappingTypeData%MapType
   DstMappingTypeData%XfrType = SrcMappingTypeData%XfrType
   DstMappingTypeData%XfrTypeAux = SrcMappingTypeData%XfrTypeAux
   DstMappingTypeData%Ready = SrcMappingTypeData%Ready
   DstMappingTypeData%DstUsesSibling = SrcMappingTypeData%DstUsesSibling
   call MeshCopy(SrcMappingTypeData%TmpLoadMesh, DstMappingTypeData%TmpLoadMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMappingTypeData%TmpMotionMesh, DstMappingTypeData%TmpMotionMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMappingTypeData%TmpMatrix)) then
      LB(1:2) = lbound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      UB(1:2) = ubound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      if (.not. allocated(DstMappingTypeData%TmpMatrix)) then
         allocate(DstMappingTypeData%TmpMatrix(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMappingTypeData%TmpMatrix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMappingTypeData%TmpMatrix = SrcMappingTypeData%TmpMatrix
   end if
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMap, DstMappingTypeData%MeshMap, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMapAux, DstMappingTypeData%MeshMapAux, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMappingTypeData%iVarSrcTransDisp = SrcMappingTypeData%iVarSrcTransDisp
   DstMappingTypeData%iVarSrcTransVel = SrcMappingTypeData%iVarSrcTransVel
   DstMappingTypeData%iVarSrcTransAcc = SrcMappingTypeData%iVarSrcTransAcc
   DstMappingTypeData%iVarSrcOrientation = SrcMappingTypeData%iVarSrcOrientation
   DstMappingTypeData%iVarSrcAngularVel = SrcMappingTypeData%iVarSrcAngularVel
   DstMappingTypeData%iVarSrcAngularAcc = SrcMappingTypeData%iVarSrcAngularAcc
   DstMappingTypeData%iVarSrcForce = SrcMappingTypeData%iVarSrcForce
   DstMappingTypeData%iVarSrcMoment = SrcMappingTypeData%iVarSrcMoment
   DstMappingTypeData%iVarSrcDispTransDisp = SrcMappingTypeData%iVarSrcDispTransDisp
   DstMappingTypeData%iVarDstTransDisp = SrcMappingTypeData%iVarDstTransDisp
   DstMappingTypeData%iVarDstTransVel = SrcMappingTypeData%iVarDstTransVel
   DstMappingTypeData%iVarDstTransAcc = SrcMappingTypeData%iVarDstTransAcc
   DstMappingTypeData%iVarDstOrientation = SrcMappingTypeData%iVarDstOrientation
   DstMappingTypeData%iVarDstAngularVel = SrcMappingTypeData%iVarDstAngularVel
   DstMappingTypeData%iVarDstAngularAcc = SrcMappingTypeData%iVarDstAngularAcc
   DstMappingTypeData%iVarDstForce = SrcMappingTypeData%iVarDstForce
   DstMappingTypeData%iVarDstMoment = SrcMappingTypeData%iVarDstMoment
   DstMappingTypeData%iVarDstDispTransDisp = SrcMappingTypeData%iVarDstDispTransDisp
   DstMappingTypeData%iVarDstDispOrientation = SrcMappingTypeData%iVarDstDispOrientation
end subroutine

subroutine Glue_DestroyMappingType(MappingTypeData, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: MappingTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%SrcMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%DstMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%SrcDispMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%DstDispMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpLoadMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpMotionMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MappingTypeData%TmpMatrix)) then
      deallocate(MappingTypeData%TmpMatrix)
   end if
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMap, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMapAux, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackMappingType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MappingType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMappingType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Desc)
   call RegPack(RF, InData%iModSrc)
   call RegPack(RF, InData%iModDst)
   call RegPack(RF, InData%SrcModID)
   call RegPack(RF, InData%DstModID)
   call RegPack(RF, InData%SrcIns)
   call RegPack(RF, InData%DstIns)
   call RegPack(RF, InData%SrcMeshID)
   call RegPack(RF, InData%DstMeshID)
   call RegPack(RF, InData%iVarSrc)
   call RegPack(RF, InData%iVarDst)
   call RegPack(RF, InData%SrcDispMeshID)
   call RegPack(RF, InData%DstDispMeshID)
   call NWTC_Library_PackMeshLocType(RF, InData%SrcMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%DstMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%SrcDispMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%DstDispMeshLoc) 
   call RegPack(RF, InData%MapType)
   call RegPack(RF, InData%XfrType)
   call RegPack(RF, InData%XfrTypeAux)
   call RegPack(RF, InData%Ready)
   call RegPack(RF, InData%DstUsesSibling)
   call MeshPack(RF, InData%TmpLoadMesh) 
   call MeshPack(RF, InData%TmpMotionMesh) 
   call RegPackAlloc(RF, InData%TmpMatrix)
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMap) 
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMapAux) 
   call RegPack(RF, InData%iVarSrcTransDisp)
   call RegPack(RF, InData%iVarSrcTransVel)
   call RegPack(RF, InData%iVarSrcTransAcc)
   call RegPack(RF, InData%iVarSrcOrientation)
   call RegPack(RF, InData%iVarSrcAngularVel)
   call RegPack(RF, InData%iVarSrcAngularAcc)
   call RegPack(RF, InData%iVarSrcForce)
   call RegPack(RF, InData%iVarSrcMoment)
   call RegPack(RF, InData%iVarSrcDispTransDisp)
   call RegPack(RF, InData%iVarDstTransDisp)
   call RegPack(RF, InData%iVarDstTransVel)
   call RegPack(RF, InData%iVarDstTransAcc)
   call RegPack(RF, InData%iVarDstOrientation)
   call RegPack(RF, InData%iVarDstAngularVel)
   call RegPack(RF, InData%iVarDstAngularAcc)
   call RegPack(RF, InData%iVarDstForce)
   call RegPack(RF, InData%iVarDstMoment)
   call RegPack(RF, InData%iVarDstDispTransDisp)
   call RegPack(RF, InData%iVarDstDispOrientation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMappingType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MappingType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMappingType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Desc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcIns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstIns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcDispMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstDispMeshID); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackMeshLocType(RF, OutData%SrcMeshLoc) ! SrcMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%DstMeshLoc) ! DstMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%SrcDispMeshLoc) ! SrcDispMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%DstDispMeshLoc) ! DstDispMeshLoc 
   call RegUnpack(RF, OutData%MapType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrTypeAux); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ready); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstUsesSibling); if (RegCheckErr(RF, RoutineName)) return
   call MeshUnpack(RF, OutData%TmpLoadMesh) ! TmpLoadMesh 
   call MeshUnpack(RF, OutData%TmpMotionMesh) ! TmpMotionMesh 
   call RegUnpackAlloc(RF, OutData%TmpMatrix); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMap) ! MeshMap 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMapAux) ! MeshMapAux 
   call RegUnpack(RF, OutData%iVarSrcTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcTransVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcTransAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcAngularVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcAngularAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcForce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcMoment); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcDispTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstAngularVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstAngularAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstForce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstMoment); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstDispTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstDispOrientation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinType(SrcLinTypeData, DstLinTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinType), intent(in) :: SrcLinTypeData
   type(Glue_LinType), intent(inout) :: DstLinTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinTypeData%Abbr = SrcLinTypeData%Abbr
   if (allocated(SrcLinTypeData%x)) then
      LB(1:1) = lbound(SrcLinTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x)) then
         allocate(DstLinTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x = SrcLinTypeData%x
   end if
   if (allocated(SrcLinTypeData%dx)) then
      LB(1:1) = lbound(SrcLinTypeData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%dx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dx)) then
         allocate(DstLinTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dx = SrcLinTypeData%dx
   end if
   if (allocated(SrcLinTypeData%xd)) then
      LB(1:1) = lbound(SrcLinTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%xd)) then
         allocate(DstLinTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%xd = SrcLinTypeData%xd
   end if
   if (allocated(SrcLinTypeData%z)) then
      LB(1:1) = lbound(SrcLinTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%z, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%z)) then
         allocate(DstLinTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%z = SrcLinTypeData%z
   end if
   if (allocated(SrcLinTypeData%u)) then
      LB(1:1) = lbound(SrcLinTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%u, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%u)) then
         allocate(DstLinTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%u = SrcLinTypeData%u
   end if
   if (allocated(SrcLinTypeData%y)) then
      LB(1:1) = lbound(SrcLinTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y)) then
         allocate(DstLinTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y = SrcLinTypeData%y
   end if
   if (allocated(SrcLinTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcLinTypeData%u_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%u_perturb, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%u_perturb)) then
         allocate(DstLinTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%u_perturb = SrcLinTypeData%u_perturb
   end if
   if (allocated(SrcLinTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcLinTypeData%x_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_perturb, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_perturb)) then
         allocate(DstLinTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_perturb = SrcLinTypeData%x_perturb
   end if
   if (allocated(SrcLinTypeData%x_pos)) then
      LB(1:1) = lbound(SrcLinTypeData%x_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_pos, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_pos)) then
         allocate(DstLinTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_pos = SrcLinTypeData%x_pos
   end if
   if (allocated(SrcLinTypeData%x_neg)) then
      LB(1:1) = lbound(SrcLinTypeData%x_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_neg, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_neg)) then
         allocate(DstLinTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_neg = SrcLinTypeData%x_neg
   end if
   if (allocated(SrcLinTypeData%y_pos)) then
      LB(1:1) = lbound(SrcLinTypeData%y_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y_pos, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y_pos)) then
         allocate(DstLinTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y_pos = SrcLinTypeData%y_pos
   end if
   if (allocated(SrcLinTypeData%y_neg)) then
      LB(1:1) = lbound(SrcLinTypeData%y_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y_neg, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y_neg)) then
         allocate(DstLinTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y_neg = SrcLinTypeData%y_neg
   end if
   if (allocated(SrcLinTypeData%J)) then
      LB(1:2) = lbound(SrcLinTypeData%J, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%J, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%J)) then
         allocate(DstLinTypeData%J(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%J.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%J = SrcLinTypeData%J
   end if
   if (allocated(SrcLinTypeData%dYdx)) then
      LB(1:2) = lbound(SrcLinTypeData%dYdx, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dYdx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dYdx)) then
         allocate(DstLinTypeData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dYdx = SrcLinTypeData%dYdx
   end if
   if (allocated(SrcLinTypeData%dXdx)) then
      LB(1:2) = lbound(SrcLinTypeData%dXdx, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dXdx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dXdx)) then
         allocate(DstLinTypeData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dXdx = SrcLinTypeData%dXdx
   end if
   if (allocated(SrcLinTypeData%dYdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dYdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dYdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dYdu)) then
         allocate(DstLinTypeData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dYdu = SrcLinTypeData%dYdu
   end if
   if (allocated(SrcLinTypeData%dXdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dXdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dXdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dXdu)) then
         allocate(DstLinTypeData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dXdu = SrcLinTypeData%dXdu
   end if
   if (allocated(SrcLinTypeData%dXdy)) then
      LB(1:2) = lbound(SrcLinTypeData%dXdy, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dXdy, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dXdy)) then
         allocate(DstLinTypeData%dXdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dXdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dXdy = SrcLinTypeData%dXdy
   end if
   if (allocated(SrcLinTypeData%dUdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dUdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dUdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dUdu)) then
         allocate(DstLinTypeData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dUdu = SrcLinTypeData%dUdu
   end if
   if (allocated(SrcLinTypeData%dUdy)) then
      LB(1:2) = lbound(SrcLinTypeData%dUdy, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dUdy, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dUdy)) then
         allocate(DstLinTypeData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dUdy = SrcLinTypeData%dUdy
   end if
   if (allocated(SrcLinTypeData%StateRotation)) then
      LB(1:2) = lbound(SrcLinTypeData%StateRotation, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%StateRotation, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%StateRotation)) then
         allocate(DstLinTypeData%StateRotation(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%StateRotation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%StateRotation = SrcLinTypeData%StateRotation
   end if
end subroutine

subroutine Glue_DestroyLinType(LinTypeData, ErrStat, ErrMsg)
   type(Glue_LinType), intent(inout) :: LinTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinTypeData%x)) then
      deallocate(LinTypeData%x)
   end if
   if (allocated(LinTypeData%dx)) then
      deallocate(LinTypeData%dx)
   end if
   if (allocated(LinTypeData%xd)) then
      deallocate(LinTypeData%xd)
   end if
   if (allocated(LinTypeData%z)) then
      deallocate(LinTypeData%z)
   end if
   if (allocated(LinTypeData%u)) then
      deallocate(LinTypeData%u)
   end if
   if (allocated(LinTypeData%y)) then
      deallocate(LinTypeData%y)
   end if
   if (allocated(LinTypeData%u_perturb)) then
      deallocate(LinTypeData%u_perturb)
   end if
   if (allocated(LinTypeData%x_perturb)) then
      deallocate(LinTypeData%x_perturb)
   end if
   if (allocated(LinTypeData%x_pos)) then
      deallocate(LinTypeData%x_pos)
   end if
   if (allocated(LinTypeData%x_neg)) then
      deallocate(LinTypeData%x_neg)
   end if
   if (allocated(LinTypeData%y_pos)) then
      deallocate(LinTypeData%y_pos)
   end if
   if (allocated(LinTypeData%y_neg)) then
      deallocate(LinTypeData%y_neg)
   end if
   if (allocated(LinTypeData%J)) then
      deallocate(LinTypeData%J)
   end if
   if (allocated(LinTypeData%dYdx)) then
      deallocate(LinTypeData%dYdx)
   end if
   if (allocated(LinTypeData%dXdx)) then
      deallocate(LinTypeData%dXdx)
   end if
   if (allocated(LinTypeData%dYdu)) then
      deallocate(LinTypeData%dYdu)
   end if
   if (allocated(LinTypeData%dXdu)) then
      deallocate(LinTypeData%dXdu)
   end if
   if (allocated(LinTypeData%dXdy)) then
      deallocate(LinTypeData%dXdy)
   end if
   if (allocated(LinTypeData%dUdu)) then
      deallocate(LinTypeData%dUdu)
   end if
   if (allocated(LinTypeData%dUdy)) then
      deallocate(LinTypeData%dUdy)
   end if
   if (allocated(LinTypeData%StateRotation)) then
      deallocate(LinTypeData%StateRotation)
   end if
end subroutine

subroutine Glue_PackLinType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Abbr)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   call RegPackAlloc(RF, InData%J)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dXdy)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%StateRotation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Abbr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StateRotation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyVarXfrType(SrcVarXfrTypeData, DstVarXfrTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarXfrType), intent(in) :: SrcVarXfrTypeData
   type(VarXfrType), intent(inout) :: DstVarXfrTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyVarXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVarXfrTypeData%iVar = SrcVarXfrTypeData%iVar
   DstVarXfrTypeData%NumVals = SrcVarXfrTypeData%NumVals
   DstVarXfrTypeData%iSrc = SrcVarXfrTypeData%iSrc
   DstVarXfrTypeData%iDst = SrcVarXfrTypeData%iDst
end subroutine

subroutine Glue_DestroyVarXfrType(VarXfrTypeData, ErrStat, ErrMsg)
   type(VarXfrType), intent(inout) :: VarXfrTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyVarXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackVarXfrType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarXfrType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackVarXfrType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%iVar)
   call RegPack(RF, InData%NumVals)
   call RegPack(RF, InData%iSrc)
   call RegPack(RF, InData%iDst)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackVarXfrType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarXfrType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackVarXfrType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%iVar); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumVals); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iDst); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyModXfrType(SrcModXfrTypeData, DstModXfrTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModXfrType), intent(in) :: SrcModXfrTypeData
   type(ModXfrType), intent(inout) :: DstModXfrTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyModXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcModXfrTypeData%x)) then
      LB(1:1) = lbound(SrcModXfrTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%x, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%x)) then
         allocate(DstModXfrTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarXfrType(SrcModXfrTypeData%x(i1), DstModXfrTypeData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%xd)) then
      LB(1:1) = lbound(SrcModXfrTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%xd)) then
         allocate(DstModXfrTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarXfrType(SrcModXfrTypeData%xd(i1), DstModXfrTypeData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%z)) then
      LB(1:1) = lbound(SrcModXfrTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%z, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%z)) then
         allocate(DstModXfrTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarXfrType(SrcModXfrTypeData%z(i1), DstModXfrTypeData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%u)) then
      LB(1:1) = lbound(SrcModXfrTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%u, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%u)) then
         allocate(DstModXfrTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarXfrType(SrcModXfrTypeData%u(i1), DstModXfrTypeData%u(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcModXfrTypeData%y)) then
      LB(1:1) = lbound(SrcModXfrTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcModXfrTypeData%y, kind=B8Ki)
      if (.not. allocated(DstModXfrTypeData%y)) then
         allocate(DstModXfrTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModXfrTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarXfrType(SrcModXfrTypeData%y(i1), DstModXfrTypeData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine Glue_DestroyModXfrType(ModXfrTypeData, ErrStat, ErrMsg)
   type(ModXfrType), intent(inout) :: ModXfrTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyModXfrType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModXfrTypeData%x)) then
      LB(1:1) = lbound(ModXfrTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarXfrType(ModXfrTypeData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%x)
   end if
   if (allocated(ModXfrTypeData%xd)) then
      LB(1:1) = lbound(ModXfrTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%xd, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarXfrType(ModXfrTypeData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%xd)
   end if
   if (allocated(ModXfrTypeData%z)) then
      LB(1:1) = lbound(ModXfrTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarXfrType(ModXfrTypeData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%z)
   end if
   if (allocated(ModXfrTypeData%u)) then
      LB(1:1) = lbound(ModXfrTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarXfrType(ModXfrTypeData%u(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%u)
   end if
   if (allocated(ModXfrTypeData%y)) then
      LB(1:1) = lbound(ModXfrTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(ModXfrTypeData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarXfrType(ModXfrTypeData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModXfrTypeData%y)
   end if
end subroutine

subroutine Glue_PackModXfrType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModXfrType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackModXfrType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x, kind=B8Ki), ubound(InData%x, kind=B8Ki))
      LB(1:1) = lbound(InData%x, kind=B8Ki)
      UB(1:1) = ubound(InData%x, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarXfrType(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd, kind=B8Ki), ubound(InData%xd, kind=B8Ki))
      LB(1:1) = lbound(InData%xd, kind=B8Ki)
      UB(1:1) = ubound(InData%xd, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarXfrType(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z, kind=B8Ki), ubound(InData%z, kind=B8Ki))
      LB(1:1) = lbound(InData%z, kind=B8Ki)
      UB(1:1) = ubound(InData%z, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarXfrType(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(RF, 1, lbound(InData%u, kind=B8Ki), ubound(InData%u, kind=B8Ki))
      LB(1:1) = lbound(InData%u, kind=B8Ki)
      UB(1:1) = ubound(InData%u, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarXfrType(RF, InData%u(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y, kind=B8Ki), ubound(InData%y, kind=B8Ki))
      LB(1:1) = lbound(InData%y, kind=B8Ki)
      UB(1:1) = ubound(InData%y, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarXfrType(RF, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackModXfrType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModXfrType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackModXfrType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarXfrType(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarXfrType(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarXfrType(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarXfrType(RF, OutData%u(i1)) ! u 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarXfrType(RF, OutData%y(i1)) ! y 
      end do
   end if
end subroutine

subroutine Glue_CopyModDataType(SrcModDataTypeData, DstModDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModDataType), intent(in) :: SrcModDataTypeData
   type(ModDataType), intent(inout) :: DstModDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModDataTypeData%Abbr = SrcModDataTypeData%Abbr
   DstModDataTypeData%ID = SrcModDataTypeData%ID
   DstModDataTypeData%iMod = SrcModDataTypeData%iMod
   DstModDataTypeData%Ins = SrcModDataTypeData%Ins
   DstModDataTypeData%DT = SrcModDataTypeData%DT
   DstModDataTypeData%SubSteps = SrcModDataTypeData%SubSteps
   DstModDataTypeData%Vars => SrcModDataTypeData%Vars
   if (allocated(SrcModDataTypeData%Xfr)) then
      LB(1:1) = lbound(SrcModDataTypeData%Xfr, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%Xfr, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%Xfr)) then
         allocate(DstModDataTypeData%Xfr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%Xfr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyModXfrType(SrcModDataTypeData%Xfr(i1), DstModDataTypeData%Xfr(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call Glue_CopyLinType(SrcModDataTypeData%Lin, DstModDataTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcModDataTypeData%SrcMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%SrcMaps)) then
         allocate(DstModDataTypeData%SrcMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%SrcMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%SrcMaps = SrcModDataTypeData%SrcMaps
   end if
   if (allocated(SrcModDataTypeData%DstMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%DstMaps)) then
         allocate(DstModDataTypeData%DstMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%DstMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%DstMaps = SrcModDataTypeData%DstMaps
   end if
end subroutine

subroutine Glue_DestroyModDataType(ModDataTypeData, ErrStat, ErrMsg)
   type(ModDataType), intent(inout) :: ModDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   nullify(ModDataTypeData%Vars)
   if (allocated(ModDataTypeData%Xfr)) then
      LB(1:1) = lbound(ModDataTypeData%Xfr, kind=B8Ki)
      UB(1:1) = ubound(ModDataTypeData%Xfr, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyModXfrType(ModDataTypeData%Xfr(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModDataTypeData%Xfr)
   end if
   call Glue_DestroyLinType(ModDataTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModDataTypeData%SrcMaps)) then
      deallocate(ModDataTypeData%SrcMaps)
   end if
   if (allocated(ModDataTypeData%DstMaps)) then
      deallocate(ModDataTypeData%DstMaps)
   end if
end subroutine

subroutine Glue_PackModDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackModDataType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Abbr)
   call RegPack(RF, InData%ID)
   call RegPack(RF, InData%iMod)
   call RegPack(RF, InData%Ins)
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%SubSteps)
   call RegPack(RF, associated(InData%Vars))
   if (associated(InData%Vars)) then
      call RegPackPointer(RF, c_loc(InData%Vars), PtrInIndex)
      if (.not. PtrInIndex) then
         call NWTC_Library_PackModVarsType(RF, InData%Vars) 
      end if
   end if
   call RegPack(RF, allocated(InData%Xfr))
   if (allocated(InData%Xfr)) then
      call RegPackBounds(RF, 1, lbound(InData%Xfr, kind=B8Ki), ubound(InData%Xfr, kind=B8Ki))
      LB(1:1) = lbound(InData%Xfr, kind=B8Ki)
      UB(1:1) = ubound(InData%Xfr, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackModXfrType(RF, InData%Xfr(i1)) 
      end do
   end if
   call Glue_PackLinType(RF, InData%Lin) 
   call RegPackAlloc(RF, InData%SrcMaps)
   call RegPackAlloc(RF, InData%DstMaps)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackModDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackModDataType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Abbr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ins); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SubSteps); if (RegCheckErr(RF, RoutineName)) return
   if (associated(OutData%Vars)) deallocate(OutData%Vars)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(RF, Ptr, PtrIdx); if (RegCheckErr(RF, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vars)
      else
         allocate(OutData%Vars,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vars.', RF%ErrStat, RF%ErrMsg, RoutineName)
            return
         end if
         RF%Pointers(PtrIdx) = c_loc(OutData%Vars)
         call NWTC_Library_UnpackModVarsType(RF, OutData%Vars) ! Vars 
      end if
   else
      OutData%Vars => null()
   end if
   if (allocated(OutData%Xfr)) deallocate(OutData%Xfr)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Xfr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Xfr.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackModXfrType(RF, OutData%Xfr(i1)) ! Xfr 
      end do
   end if
   call Glue_UnpackLinType(RF, OutData%Lin) ! Lin 
   call RegUnpackAlloc(RF, OutData%SrcMaps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DstMaps); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinParam(SrcLinParamData, DstLinParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinParam), intent(in) :: SrcLinParamData
   type(Glue_LinParam), intent(inout) :: DstLinParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinParamData%NumTimes = SrcLinParamData%NumTimes
   DstLinParamData%InterpOrder = SrcLinParamData%InterpOrder
   DstLinParamData%SaveOPs = SrcLinParamData%SaveOPs
   if (allocated(SrcLinParamData%iMod)) then
      LB(1:1) = lbound(SrcLinParamData%iMod, kind=B8Ki)
      UB(1:1) = ubound(SrcLinParamData%iMod, kind=B8Ki)
      if (.not. allocated(DstLinParamData%iMod)) then
         allocate(DstLinParamData%iMod(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinParamData%iMod.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinParamData%iMod = SrcLinParamData%iMod
   end if
end subroutine

subroutine Glue_DestroyLinParam(LinParamData, ErrStat, ErrMsg)
   type(Glue_LinParam), intent(inout) :: LinParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinParamData%iMod)) then
      deallocate(LinParamData%iMod)
   end if
end subroutine

subroutine Glue_PackLinParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinParam), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumTimes)
   call RegPack(RF, InData%InterpOrder)
   call RegPack(RF, InData%SaveOPs)
   call RegPackAlloc(RF, InData%iMod)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinParam), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinParam'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumTimes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SaveOPs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(in) :: SrcParamData
   type(Glue_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyLinParam(SrcParamData%Lin, DstParamData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%DT = SrcParamData%DT
   DstParamData%ConvTol = SrcParamData%ConvTol
   DstParamData%NumCrctn = SrcParamData%NumCrctn
   DstParamData%MaxConvIter = SrcParamData%MaxConvIter
   DstParamData%NIter_UJac = SrcParamData%NIter_UJac
   DstParamData%NStep_UJac = SrcParamData%NStep_UJac
   DstParamData%Scale_UJac = SrcParamData%Scale_UJac
   DstParamData%AccBlend = SrcParamData%AccBlend
   DstParamData%RhoInf = SrcParamData%RhoInf
   DstParamData%AlphaM = SrcParamData%AlphaM
   DstParamData%AlphaF = SrcParamData%AlphaF
   DstParamData%Beta = SrcParamData%Beta
   DstParamData%Gamma = SrcParamData%Gamma
   DstParamData%C = SrcParamData%C
   DstParamData%iX1 = SrcParamData%iX1
   DstParamData%iX2 = SrcParamData%iX2
   DstParamData%iUT = SrcParamData%iUT
   DstParamData%iU1 = SrcParamData%iU1
   DstParamData%iyT = SrcParamData%iyT
   DstParamData%iy1 = SrcParamData%iy1
   DstParamData%iJX = SrcParamData%iJX
   DstParamData%iJU = SrcParamData%iJU
   DstParamData%iJUT = SrcParamData%iJUT
   if (allocated(SrcParamData%iJL)) then
      LB(1:1) = lbound(SrcParamData%iJL, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iJL, kind=B8Ki)
      if (.not. allocated(DstParamData%iJL)) then
         allocate(DstParamData%iJL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iJL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iJL = SrcParamData%iJL
   end if
   if (allocated(SrcParamData%ixqd)) then
      LB(1:2) = lbound(SrcParamData%ixqd, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%ixqd, kind=B8Ki)
      if (.not. allocated(DstParamData%ixqd)) then
         allocate(DstParamData%ixqd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ixqd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%ixqd = SrcParamData%ixqd
   end if
   if (allocated(SrcParamData%iModInit)) then
      LB(1:1) = lbound(SrcParamData%iModInit, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModInit, kind=B8Ki)
      if (.not. allocated(DstParamData%iModInit)) then
         allocate(DstParamData%iModInit(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModInit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModInit = SrcParamData%iModInit
   end if
   if (allocated(SrcParamData%iModTC)) then
      LB(1:1) = lbound(SrcParamData%iModTC, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModTC, kind=B8Ki)
      if (.not. allocated(DstParamData%iModTC)) then
         allocate(DstParamData%iModTC(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModTC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModTC = SrcParamData%iModTC
   end if
   if (allocated(SrcParamData%iModBD)) then
      LB(1:1) = lbound(SrcParamData%iModBD, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModBD, kind=B8Ki)
      if (.not. allocated(DstParamData%iModBD)) then
         allocate(DstParamData%iModBD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModBD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModBD = SrcParamData%iModBD
   end if
   if (allocated(SrcParamData%iModOpt1)) then
      LB(1:1) = lbound(SrcParamData%iModOpt1, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt1, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt1)) then
         allocate(DstParamData%iModOpt1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt1 = SrcParamData%iModOpt1
   end if
   if (allocated(SrcParamData%iModOpt1US)) then
      LB(1:1) = lbound(SrcParamData%iModOpt1US, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt1US, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt1US)) then
         allocate(DstParamData%iModOpt1US(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt1US.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt1US = SrcParamData%iModOpt1US
   end if
   if (allocated(SrcParamData%iModOpt2)) then
      LB(1:1) = lbound(SrcParamData%iModOpt2, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt2, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt2)) then
         allocate(DstParamData%iModOpt2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt2 = SrcParamData%iModOpt2
   end if
   if (allocated(SrcParamData%iModPost)) then
      LB(1:1) = lbound(SrcParamData%iModPost, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModPost, kind=B8Ki)
      if (.not. allocated(DstParamData%iModPost)) then
         allocate(DstParamData%iModPost(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModPost.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModPost = SrcParamData%iModPost
   end if
end subroutine

subroutine Glue_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyLinParam(ParamData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ParamData%iJL)) then
      deallocate(ParamData%iJL)
   end if
   if (allocated(ParamData%ixqd)) then
      deallocate(ParamData%ixqd)
   end if
   if (allocated(ParamData%iModInit)) then
      deallocate(ParamData%iModInit)
   end if
   if (allocated(ParamData%iModTC)) then
      deallocate(ParamData%iModTC)
   end if
   if (allocated(ParamData%iModBD)) then
      deallocate(ParamData%iModBD)
   end if
   if (allocated(ParamData%iModOpt1)) then
      deallocate(ParamData%iModOpt1)
   end if
   if (allocated(ParamData%iModOpt1US)) then
      deallocate(ParamData%iModOpt1US)
   end if
   if (allocated(ParamData%iModOpt2)) then
      deallocate(ParamData%iModOpt2)
   end if
   if (allocated(ParamData%iModPost)) then
      deallocate(ParamData%iModPost)
   end if
end subroutine

subroutine Glue_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackLinParam(RF, InData%Lin) 
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%ConvTol)
   call RegPack(RF, InData%NumCrctn)
   call RegPack(RF, InData%MaxConvIter)
   call RegPack(RF, InData%NIter_UJac)
   call RegPack(RF, InData%NStep_UJac)
   call RegPack(RF, InData%Scale_UJac)
   call RegPack(RF, InData%AccBlend)
   call RegPack(RF, InData%RhoInf)
   call RegPack(RF, InData%AlphaM)
   call RegPack(RF, InData%AlphaF)
   call RegPack(RF, InData%Beta)
   call RegPack(RF, InData%Gamma)
   call RegPack(RF, InData%C)
   call RegPack(RF, InData%iX1)
   call RegPack(RF, InData%iX2)
   call RegPack(RF, InData%iUT)
   call RegPack(RF, InData%iU1)
   call RegPack(RF, InData%iyT)
   call RegPack(RF, InData%iy1)
   call RegPack(RF, InData%iJX)
   call RegPack(RF, InData%iJU)
   call RegPack(RF, InData%iJUT)
   call RegPackAlloc(RF, InData%iJL)
   call RegPackAlloc(RF, InData%ixqd)
   call RegPackAlloc(RF, InData%iModInit)
   call RegPackAlloc(RF, InData%iModTC)
   call RegPackAlloc(RF, InData%iModBD)
   call RegPackAlloc(RF, InData%iModOpt1)
   call RegPackAlloc(RF, InData%iModOpt1US)
   call RegPackAlloc(RF, InData%iModOpt2)
   call RegPackAlloc(RF, InData%iModPost)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackParam'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackLinParam(RF, OutData%Lin) ! Lin 
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvTol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumCrctn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MaxConvIter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NIter_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NStep_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Scale_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AccBlend); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RhoInf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Beta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Gamma); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%C); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iU1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iyT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iy1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iJL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ixqd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModTC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModBD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt1US); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModPost); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinSave(SrcLinSaveData, DstLinSaveData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(in) :: SrcLinSaveData
   type(Glue_LinSave), intent(inout) :: DstLinSaveData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLinSaveData%Times)) then
      LB(1:1) = lbound(SrcLinSaveData%Times, kind=B8Ki)
      UB(1:1) = ubound(SrcLinSaveData%Times, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%Times)) then
         allocate(DstLinSaveData%Times(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%Times.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%Times = SrcLinSaveData%Times
   end if
   if (allocated(SrcLinSaveData%u)) then
      LB(1:2) = lbound(SrcLinSaveData%u, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%u, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%u)) then
         allocate(DstLinSaveData%u(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%u = SrcLinSaveData%u
   end if
   if (allocated(SrcLinSaveData%x)) then
      LB(1:2) = lbound(SrcLinSaveData%x, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%x, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%x)) then
         allocate(DstLinSaveData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%x = SrcLinSaveData%x
   end if
   if (allocated(SrcLinSaveData%xd)) then
      LB(1:2) = lbound(SrcLinSaveData%xd, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%xd, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%xd)) then
         allocate(DstLinSaveData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%xd = SrcLinSaveData%xd
   end if
   if (allocated(SrcLinSaveData%z)) then
      LB(1:2) = lbound(SrcLinSaveData%z, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%z, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%z)) then
         allocate(DstLinSaveData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%z = SrcLinSaveData%z
   end if
   if (allocated(SrcLinSaveData%OtherSt)) then
      LB(1:2) = lbound(SrcLinSaveData%OtherSt, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%OtherSt, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%OtherSt)) then
         allocate(DstLinSaveData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%OtherSt = SrcLinSaveData%OtherSt
   end if
end subroutine

subroutine Glue_DestroyLinSave(LinSaveData, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(inout) :: LinSaveData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinSaveData%Times)) then
      deallocate(LinSaveData%Times)
   end if
   if (allocated(LinSaveData%u)) then
      deallocate(LinSaveData%u)
   end if
   if (allocated(LinSaveData%x)) then
      deallocate(LinSaveData%x)
   end if
   if (allocated(LinSaveData%xd)) then
      deallocate(LinSaveData%xd)
   end if
   if (allocated(LinSaveData%z)) then
      deallocate(LinSaveData%z)
   end if
   if (allocated(LinSaveData%OtherSt)) then
      deallocate(LinSaveData%OtherSt)
   end if
end subroutine

subroutine Glue_PackLinSave(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinSave), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinSave'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Times)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%OtherSt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinSave(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinSave), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinSave'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Times); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OtherSt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyOutputFileType(SrcOutputFileTypeData, DstOutputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(in) :: SrcOutputFileTypeData
   type(Glue_OutputFileType), intent(inout) :: DstOutputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyLinSave(SrcOutputFileTypeData%Lin, DstOutputFileTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyOutputFileType(OutputFileTypeData, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(inout) :: OutputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyLinSave(OutputFileTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackOutputFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_OutputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackOutputFileType'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackLinSave(RF, InData%Lin) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackOutputFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_OutputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackOutputFileType'
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackLinSave(RF, OutData%Lin) ! Lin 
end subroutine

subroutine Glue_CopyCalcSteady(SrcCalcSteadyData, DstCalcSteadyData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_CalcSteady), intent(in) :: SrcCalcSteadyData
   type(Glue_CalcSteady), intent(inout) :: DstCalcSteadyData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyCalcSteady'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcCalcSteadyData%AzimuthTarget)) then
      LB(1:1) = lbound(SrcCalcSteadyData%AzimuthTarget, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%AzimuthTarget, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%AzimuthTarget)) then
         allocate(DstCalcSteadyData%AzimuthTarget(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%AzimuthTarget.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%AzimuthTarget = SrcCalcSteadyData%AzimuthTarget
   end if
   DstCalcSteadyData%AzimuthDelta = SrcCalcSteadyData%AzimuthDelta
   DstCalcSteadyData%IsConverged = SrcCalcSteadyData%IsConverged
   DstCalcSteadyData%FoundSteady = SrcCalcSteadyData%FoundSteady
   DstCalcSteadyData%ForceLin = SrcCalcSteadyData%ForceLin
   DstCalcSteadyData%NumRotations = SrcCalcSteadyData%NumRotations
   DstCalcSteadyData%NumOutputs = SrcCalcSteadyData%NumOutputs
   if (allocated(SrcCalcSteadyData%psi_buffer)) then
      LB(1:1) = lbound(SrcCalcSteadyData%psi_buffer, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%psi_buffer, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%psi_buffer)) then
         allocate(DstCalcSteadyData%psi_buffer(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%psi_buffer.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%psi_buffer = SrcCalcSteadyData%psi_buffer
   end if
   if (allocated(SrcCalcSteadyData%y_buffer)) then
      LB(1:2) = lbound(SrcCalcSteadyData%y_buffer, kind=B8Ki)
      UB(1:2) = ubound(SrcCalcSteadyData%y_buffer, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_buffer)) then
         allocate(DstCalcSteadyData%y_buffer(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_buffer.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_buffer = SrcCalcSteadyData%y_buffer
   end if
   if (allocated(SrcCalcSteadyData%y_azimuth)) then
      LB(1:2) = lbound(SrcCalcSteadyData%y_azimuth, kind=B8Ki)
      UB(1:2) = ubound(SrcCalcSteadyData%y_azimuth, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_azimuth)) then
         allocate(DstCalcSteadyData%y_azimuth(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_azimuth.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_azimuth = SrcCalcSteadyData%y_azimuth
   end if
   if (allocated(SrcCalcSteadyData%y_interp)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_interp, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_interp, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_interp)) then
         allocate(DstCalcSteadyData%y_interp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_interp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_interp = SrcCalcSteadyData%y_interp
   end if
   if (allocated(SrcCalcSteadyData%y_diff)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_diff, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_diff, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_diff)) then
         allocate(DstCalcSteadyData%y_diff(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_diff.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_diff = SrcCalcSteadyData%y_diff
   end if
   if (allocated(SrcCalcSteadyData%y_ref)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_ref, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_ref, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_ref)) then
         allocate(DstCalcSteadyData%y_ref(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_ref.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_ref = SrcCalcSteadyData%y_ref
   end if
end subroutine

subroutine Glue_DestroyCalcSteady(CalcSteadyData, ErrStat, ErrMsg)
   type(Glue_CalcSteady), intent(inout) :: CalcSteadyData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyCalcSteady'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(CalcSteadyData%AzimuthTarget)) then
      deallocate(CalcSteadyData%AzimuthTarget)
   end if
   if (allocated(CalcSteadyData%psi_buffer)) then
      deallocate(CalcSteadyData%psi_buffer)
   end if
   if (allocated(CalcSteadyData%y_buffer)) then
      deallocate(CalcSteadyData%y_buffer)
   end if
   if (allocated(CalcSteadyData%y_azimuth)) then
      deallocate(CalcSteadyData%y_azimuth)
   end if
   if (allocated(CalcSteadyData%y_interp)) then
      deallocate(CalcSteadyData%y_interp)
   end if
   if (allocated(CalcSteadyData%y_diff)) then
      deallocate(CalcSteadyData%y_diff)
   end if
   if (allocated(CalcSteadyData%y_ref)) then
      deallocate(CalcSteadyData%y_ref)
   end if
end subroutine

subroutine Glue_PackCalcSteady(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_CalcSteady), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackCalcSteady'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%AzimuthTarget)
   call RegPack(RF, InData%AzimuthDelta)
   call RegPack(RF, InData%IsConverged)
   call RegPack(RF, InData%FoundSteady)
   call RegPack(RF, InData%ForceLin)
   call RegPack(RF, InData%NumRotations)
   call RegPack(RF, InData%NumOutputs)
   call RegPackAlloc(RF, InData%psi_buffer)
   call RegPackAlloc(RF, InData%y_buffer)
   call RegPackAlloc(RF, InData%y_azimuth)
   call RegPackAlloc(RF, InData%y_interp)
   call RegPackAlloc(RF, InData%y_diff)
   call RegPackAlloc(RF, InData%y_ref)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackCalcSteady(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_CalcSteady), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackCalcSteady'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%AzimuthTarget); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimuthDelta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsConverged); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FoundSteady); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ForceLin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumRotations); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumOutputs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%psi_buffer); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_buffer); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_azimuth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_interp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_diff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_ref); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyAeroMapCase(SrcAeroMapCaseData, DstAeroMapCaseData, CtrlCode, ErrStat, ErrMsg)
   type(AeroMapCase), intent(in) :: SrcAeroMapCaseData
   type(AeroMapCase), intent(inout) :: DstAeroMapCaseData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyAeroMapCase'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstAeroMapCaseData%RotSpeed = SrcAeroMapCaseData%RotSpeed
   DstAeroMapCaseData%TSR = SrcAeroMapCaseData%TSR
   DstAeroMapCaseData%WindSpeed = SrcAeroMapCaseData%WindSpeed
   DstAeroMapCaseData%Pitch = SrcAeroMapCaseData%Pitch
end subroutine

subroutine Glue_DestroyAeroMapCase(AeroMapCaseData, ErrStat, ErrMsg)
   type(AeroMapCase), intent(inout) :: AeroMapCaseData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyAeroMapCase'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackAeroMapCase(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AeroMapCase), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackAeroMapCase'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%TSR)
   call RegPack(RF, InData%WindSpeed)
   call RegPack(RF, InData%Pitch)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackAeroMapCase(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AeroMapCase), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackAeroMapCase'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TSR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WindSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pitch); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyAeroMap(SrcAeroMapData, DstAeroMapData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_AeroMap), intent(in) :: SrcAeroMapData
   type(Glue_AeroMap), intent(inout) :: DstAeroMapData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyAeroMap'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyModDataType(SrcAeroMapData%Mod, DstAeroMapData%Mod, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcAeroMapData%iModOrder)) then
      LB(1:1) = lbound(SrcAeroMapData%iModOrder, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%iModOrder, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%iModOrder)) then
         allocate(DstAeroMapData%iModOrder(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%iModOrder.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%iModOrder = SrcAeroMapData%iModOrder
   end if
   DstAeroMapData%iModED = SrcAeroMapData%iModED
   DstAeroMapData%iModBD = SrcAeroMapData%iModBD
   DstAeroMapData%iModAD = SrcAeroMapData%iModAD
   if (allocated(SrcAeroMapData%Jac11)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac11, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac11, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac11)) then
         allocate(DstAeroMapData%Jac11(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac11.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac11 = SrcAeroMapData%Jac11
   end if
   if (allocated(SrcAeroMapData%Jac12)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac12, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac12, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac12)) then
         allocate(DstAeroMapData%Jac12(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac12.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac12 = SrcAeroMapData%Jac12
   end if
   if (allocated(SrcAeroMapData%Jac21)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac21, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac21, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac21)) then
         allocate(DstAeroMapData%Jac21(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac21.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac21 = SrcAeroMapData%Jac21
   end if
   if (allocated(SrcAeroMapData%Jac22)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac22, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac22, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac22)) then
         allocate(DstAeroMapData%Jac22(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac22.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac22 = SrcAeroMapData%Jac22
   end if
   if (allocated(SrcAeroMapData%JacPivot)) then
      LB(1:1) = lbound(SrcAeroMapData%JacPivot, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%JacPivot, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%JacPivot)) then
         allocate(DstAeroMapData%JacPivot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%JacPivot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%JacPivot = SrcAeroMapData%JacPivot
   end if
   DstAeroMapData%JacScale = SrcAeroMapData%JacScale
   DstAeroMapData%SolveTolerance = SrcAeroMapData%SolveTolerance
   if (allocated(SrcAeroMapData%HubOrientation)) then
      LB(1:3) = lbound(SrcAeroMapData%HubOrientation, kind=B8Ki)
      UB(1:3) = ubound(SrcAeroMapData%HubOrientation, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%HubOrientation)) then
         allocate(DstAeroMapData%HubOrientation(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%HubOrientation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%HubOrientation = SrcAeroMapData%HubOrientation
   end if
   if (allocated(SrcAeroMapData%u1)) then
      LB(1:1) = lbound(SrcAeroMapData%u1, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%u1, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%u1)) then
         allocate(DstAeroMapData%u1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%u1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%u1 = SrcAeroMapData%u1
   end if
   if (allocated(SrcAeroMapData%u2)) then
      LB(1:1) = lbound(SrcAeroMapData%u2, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%u2, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%u2)) then
         allocate(DstAeroMapData%u2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%u2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%u2 = SrcAeroMapData%u2
   end if
   if (allocated(SrcAeroMapData%Residual)) then
      LB(1:1) = lbound(SrcAeroMapData%Residual, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%Residual, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Residual)) then
         allocate(DstAeroMapData%Residual(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Residual.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Residual = SrcAeroMapData%Residual
   end if
   if (allocated(SrcAeroMapData%SolveDelta)) then
      LB(1:1) = lbound(SrcAeroMapData%SolveDelta, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%SolveDelta, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%SolveDelta)) then
         allocate(DstAeroMapData%SolveDelta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%SolveDelta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%SolveDelta = SrcAeroMapData%SolveDelta
   end if
   if (allocated(SrcAeroMapData%Cases)) then
      LB(1:1) = lbound(SrcAeroMapData%Cases, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%Cases, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Cases)) then
         allocate(DstAeroMapData%Cases(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Cases.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyAeroMapCase(SrcAeroMapData%Cases(i1), DstAeroMapData%Cases(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstAeroMapData%LinFileNum = SrcAeroMapData%LinFileNum
end subroutine

subroutine Glue_DestroyAeroMap(AeroMapData, ErrStat, ErrMsg)
   type(Glue_AeroMap), intent(inout) :: AeroMapData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyAeroMap'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyModDataType(AeroMapData%Mod, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(AeroMapData%iModOrder)) then
      deallocate(AeroMapData%iModOrder)
   end if
   if (allocated(AeroMapData%Jac11)) then
      deallocate(AeroMapData%Jac11)
   end if
   if (allocated(AeroMapData%Jac12)) then
      deallocate(AeroMapData%Jac12)
   end if
   if (allocated(AeroMapData%Jac21)) then
      deallocate(AeroMapData%Jac21)
   end if
   if (allocated(AeroMapData%Jac22)) then
      deallocate(AeroMapData%Jac22)
   end if
   if (allocated(AeroMapData%JacPivot)) then
      deallocate(AeroMapData%JacPivot)
   end if
   if (allocated(AeroMapData%HubOrientation)) then
      deallocate(AeroMapData%HubOrientation)
   end if
   if (allocated(AeroMapData%u1)) then
      deallocate(AeroMapData%u1)
   end if
   if (allocated(AeroMapData%u2)) then
      deallocate(AeroMapData%u2)
   end if
   if (allocated(AeroMapData%Residual)) then
      deallocate(AeroMapData%Residual)
   end if
   if (allocated(AeroMapData%SolveDelta)) then
      deallocate(AeroMapData%SolveDelta)
   end if
   if (allocated(AeroMapData%Cases)) then
      LB(1:1) = lbound(AeroMapData%Cases, kind=B8Ki)
      UB(1:1) = ubound(AeroMapData%Cases, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyAeroMapCase(AeroMapData%Cases(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroMapData%Cases)
   end if
end subroutine

subroutine Glue_PackAeroMap(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_AeroMap), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackAeroMap'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackModDataType(RF, InData%Mod) 
   call RegPackAlloc(RF, InData%iModOrder)
   call RegPack(RF, InData%iModED)
   call RegPack(RF, InData%iModBD)
   call RegPack(RF, InData%iModAD)
   call RegPackAlloc(RF, InData%Jac11)
   call RegPackAlloc(RF, InData%Jac12)
   call RegPackAlloc(RF, InData%Jac21)
   call RegPackAlloc(RF, InData%Jac22)
   call RegPackAlloc(RF, InData%JacPivot)
   call RegPack(RF, InData%JacScale)
   call RegPack(RF, InData%SolveTolerance)
   call RegPackAlloc(RF, InData%HubOrientation)
   call RegPackAlloc(RF, InData%u1)
   call RegPackAlloc(RF, InData%u2)
   call RegPackAlloc(RF, InData%Residual)
   call RegPackAlloc(RF, InData%SolveDelta)
   call RegPack(RF, allocated(InData%Cases))
   if (allocated(InData%Cases)) then
      call RegPackBounds(RF, 1, lbound(InData%Cases, kind=B8Ki), ubound(InData%Cases, kind=B8Ki))
      LB(1:1) = lbound(InData%Cases, kind=B8Ki)
      UB(1:1) = ubound(InData%Cases, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackAeroMapCase(RF, InData%Cases(i1)) 
      end do
   end if
   call RegPack(RF, InData%LinFileNum)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackAeroMap(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_AeroMap), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackAeroMap'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackModDataType(RF, OutData%Mod) ! Mod 
   call RegUnpackAlloc(RF, OutData%iModOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModED); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModBD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModAD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac11); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac12); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac21); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac22); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%JacPivot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JacScale); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SolveTolerance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%HubOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Residual); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%SolveDelta); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%Cases)) deallocate(OutData%Cases)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Cases(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cases.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackAeroMapCase(RF, OutData%Cases(i1)) ! Cases 
      end do
   end if
   call RegUnpack(RF, OutData%LinFileNum); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinMisc(SrcLinMiscData, DstLinMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinMisc), intent(in) :: SrcLinMiscData
   type(Glue_LinMisc), intent(inout) :: DstLinMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyLinMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinMiscData%TimeIndex = SrcLinMiscData%TimeIndex
   DstLinMiscData%AzimuthIndex = SrcLinMiscData%AzimuthIndex
   DstLinMiscData%IsConverged = SrcLinMiscData%IsConverged
end subroutine

subroutine Glue_DestroyLinMisc(LinMiscData, ErrStat, ErrMsg)
   type(Glue_LinMisc), intent(inout) :: LinMiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackLinMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinMisc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%TimeIndex)
   call RegPack(RF, InData%AzimuthIndex)
   call RegPack(RF, InData%IsConverged)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinMisc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinMisc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%TimeIndex); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimuthIndex); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsConverged); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: SrcMiscData
   type(Glue_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%Modules)) then
      LB(1:1) = lbound(SrcMiscData%Modules, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%Modules, kind=B8Ki)
      if (.not. allocated(DstMiscData%Modules)) then
         allocate(DstMiscData%Modules(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Modules.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyModDataType(SrcMiscData%Modules(i1), DstMiscData%Modules(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%Mappings)) then
      LB(1:1) = lbound(SrcMiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%Mappings, kind=B8Ki)
      if (.not. allocated(DstMiscData%Mappings)) then
         allocate(DstMiscData%Mappings(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Mappings.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyMappingType(SrcMiscData%Mappings(i1), DstMiscData%Mappings(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call Glue_CopyModDataType(SrcMiscData%ModGlue, DstMiscData%ModGlue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyLinMisc(SrcMiscData%Lin, DstMiscData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyCalcSteady(SrcMiscData%CS, DstMiscData%CS, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyAeroMap(SrcMiscData%AM, DstMiscData%AM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMiscData%q)) then
      LB(1:2) = lbound(SrcMiscData%q, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%q, kind=B8Ki)
      if (.not. allocated(DstMiscData%q)) then
         allocate(DstMiscData%q(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%q.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%q = SrcMiscData%q
   end if
   if (allocated(SrcMiscData%qn)) then
      LB(1:2) = lbound(SrcMiscData%qn, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%qn, kind=B8Ki)
      if (.not. allocated(DstMiscData%qn)) then
         allocate(DstMiscData%qn(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%qn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%qn = SrcMiscData%qn
   end if
   if (allocated(SrcMiscData%x)) then
      LB(1:1) = lbound(SrcMiscData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%x, kind=B8Ki)
      if (.not. allocated(DstMiscData%x)) then
         allocate(DstMiscData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%x = SrcMiscData%x
   end if
   if (allocated(SrcMiscData%xn)) then
      LB(1:1) = lbound(SrcMiscData%xn, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%xn, kind=B8Ki)
      if (.not. allocated(DstMiscData%xn)) then
         allocate(DstMiscData%xn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%xn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%xn = SrcMiscData%xn
   end if
   if (allocated(SrcMiscData%dxdt)) then
      LB(1:1) = lbound(SrcMiscData%dxdt, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%dxdt, kind=B8Ki)
      if (.not. allocated(DstMiscData%dxdt)) then
         allocate(DstMiscData%dxdt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dxdt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dxdt = SrcMiscData%dxdt
   end if
   if (allocated(SrcMiscData%u)) then
      LB(1:1) = lbound(SrcMiscData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%u, kind=B8Ki)
      if (.not. allocated(DstMiscData%u)) then
         allocate(DstMiscData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%u = SrcMiscData%u
   end if
   if (allocated(SrcMiscData%un)) then
      LB(1:1) = lbound(SrcMiscData%un, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%un, kind=B8Ki)
      if (.not. allocated(DstMiscData%un)) then
         allocate(DstMiscData%un(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%un.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%un = SrcMiscData%un
   end if
   if (allocated(SrcMiscData%u_tmp)) then
      LB(1:1) = lbound(SrcMiscData%u_tmp, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%u_tmp, kind=B8Ki)
      if (.not. allocated(DstMiscData%u_tmp)) then
         allocate(DstMiscData%u_tmp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_tmp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%u_tmp = SrcMiscData%u_tmp
   end if
   if (allocated(SrcMiscData%y)) then
      LB(1:1) = lbound(SrcMiscData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%y, kind=B8Ki)
      if (.not. allocated(DstMiscData%y)) then
         allocate(DstMiscData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%y = SrcMiscData%y
   end if
   if (allocated(SrcMiscData%dYdx)) then
      LB(1:2) = lbound(SrcMiscData%dYdx, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dYdx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dYdx)) then
         allocate(DstMiscData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dYdx = SrcMiscData%dYdx
   end if
   if (allocated(SrcMiscData%dYdu)) then
      LB(1:2) = lbound(SrcMiscData%dYdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dYdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dYdu)) then
         allocate(DstMiscData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dYdu = SrcMiscData%dYdu
   end if
   if (allocated(SrcMiscData%dXdx)) then
      LB(1:2) = lbound(SrcMiscData%dXdx, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dXdx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dXdx)) then
         allocate(DstMiscData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dXdx = SrcMiscData%dXdx
   end if
   if (allocated(SrcMiscData%dXdu)) then
      LB(1:2) = lbound(SrcMiscData%dXdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dXdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dXdu)) then
         allocate(DstMiscData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dXdu = SrcMiscData%dXdu
   end if
   if (allocated(SrcMiscData%dUdu)) then
      LB(1:2) = lbound(SrcMiscData%dUdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdu)) then
         allocate(DstMiscData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdu = SrcMiscData%dUdu
   end if
   if (allocated(SrcMiscData%dUdy)) then
      LB(1:2) = lbound(SrcMiscData%dUdy, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdy, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdy)) then
         allocate(DstMiscData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdy = SrcMiscData%dUdy
   end if
   if (allocated(SrcMiscData%dUdyHat)) then
      LB(1:2) = lbound(SrcMiscData%dUdyHat, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdyHat, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdyHat)) then
         allocate(DstMiscData%dUdyHat(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdyHat.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdyHat = SrcMiscData%dUdyHat
   end if
   if (allocated(SrcMiscData%XB)) then
      LB(1:2) = lbound(SrcMiscData%XB, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%XB, kind=B8Ki)
      if (.not. allocated(DstMiscData%XB)) then
         allocate(DstMiscData%XB(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%XB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%XB = SrcMiscData%XB
   end if
   if (allocated(SrcMiscData%G)) then
      LB(1:2) = lbound(SrcMiscData%G, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%G, kind=B8Ki)
      if (.not. allocated(DstMiscData%G)) then
         allocate(DstMiscData%G(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%G.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%G = SrcMiscData%G
   end if
   if (allocated(SrcMiscData%Jac)) then
      LB(1:2) = lbound(SrcMiscData%Jac, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%Jac, kind=B8Ki)
      if (.not. allocated(DstMiscData%Jac)) then
         allocate(DstMiscData%Jac(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Jac.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%Jac = SrcMiscData%Jac
   end if
   if (allocated(SrcMiscData%IPIV)) then
      LB(1:1) = lbound(SrcMiscData%IPIV, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%IPIV, kind=B8Ki)
      if (.not. allocated(DstMiscData%IPIV)) then
         allocate(DstMiscData%IPIV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%IPIV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%IPIV = SrcMiscData%IPIV
   end if
   DstMiscData%IterTotal = SrcMiscData%IterTotal
   DstMiscData%IterUntilUJac = SrcMiscData%IterUntilUJac
   DstMiscData%StepsUntilUJac = SrcMiscData%StepsUntilUJac
   if (allocated(SrcMiscData%dq)) then
      LB(1:2) = lbound(SrcMiscData%dq, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dq, kind=B8Ki)
      if (.not. allocated(DstMiscData%dq)) then
         allocate(DstMiscData%dq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dq = SrcMiscData%dq
   end if
   if (allocated(SrcMiscData%dx)) then
      LB(1:1) = lbound(SrcMiscData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%dx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dx)) then
         allocate(DstMiscData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dx = SrcMiscData%dx
   end if
   if (allocated(SrcMiscData%du)) then
      LB(1:1) = lbound(SrcMiscData%du, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%du, kind=B8Ki)
      if (.not. allocated(DstMiscData%du)) then
         allocate(DstMiscData%du(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%du.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%du = SrcMiscData%du
   end if
   if (allocated(SrcMiscData%UDiff)) then
      LB(1:1) = lbound(SrcMiscData%UDiff, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%UDiff, kind=B8Ki)
      if (.not. allocated(DstMiscData%UDiff)) then
         allocate(DstMiscData%UDiff(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UDiff.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%UDiff = SrcMiscData%UDiff
   end if
   DstMiscData%ConvWarn = SrcMiscData%ConvWarn
end subroutine

subroutine Glue_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%Modules)) then
      LB(1:1) = lbound(MiscData%Modules, kind=B8Ki)
      UB(1:1) = ubound(MiscData%Modules, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyModDataType(MiscData%Modules(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%Modules)
   end if
   if (allocated(MiscData%Mappings)) then
      LB(1:1) = lbound(MiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(MiscData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyMappingType(MiscData%Mappings(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%Mappings)
   end if
   call Glue_DestroyModDataType(MiscData%ModGlue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyLinMisc(MiscData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyCalcSteady(MiscData%CS, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyAeroMap(MiscData%AM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%q)) then
      deallocate(MiscData%q)
   end if
   if (allocated(MiscData%qn)) then
      deallocate(MiscData%qn)
   end if
   if (allocated(MiscData%x)) then
      deallocate(MiscData%x)
   end if
   if (allocated(MiscData%xn)) then
      deallocate(MiscData%xn)
   end if
   if (allocated(MiscData%dxdt)) then
      deallocate(MiscData%dxdt)
   end if
   if (allocated(MiscData%u)) then
      deallocate(MiscData%u)
   end if
   if (allocated(MiscData%un)) then
      deallocate(MiscData%un)
   end if
   if (allocated(MiscData%u_tmp)) then
      deallocate(MiscData%u_tmp)
   end if
   if (allocated(MiscData%y)) then
      deallocate(MiscData%y)
   end if
   if (allocated(MiscData%dYdx)) then
      deallocate(MiscData%dYdx)
   end if
   if (allocated(MiscData%dYdu)) then
      deallocate(MiscData%dYdu)
   end if
   if (allocated(MiscData%dXdx)) then
      deallocate(MiscData%dXdx)
   end if
   if (allocated(MiscData%dXdu)) then
      deallocate(MiscData%dXdu)
   end if
   if (allocated(MiscData%dUdu)) then
      deallocate(MiscData%dUdu)
   end if
   if (allocated(MiscData%dUdy)) then
      deallocate(MiscData%dUdy)
   end if
   if (allocated(MiscData%dUdyHat)) then
      deallocate(MiscData%dUdyHat)
   end if
   if (allocated(MiscData%XB)) then
      deallocate(MiscData%XB)
   end if
   if (allocated(MiscData%G)) then
      deallocate(MiscData%G)
   end if
   if (allocated(MiscData%Jac)) then
      deallocate(MiscData%Jac)
   end if
   if (allocated(MiscData%IPIV)) then
      deallocate(MiscData%IPIV)
   end if
   if (allocated(MiscData%dq)) then
      deallocate(MiscData%dq)
   end if
   if (allocated(MiscData%dx)) then
      deallocate(MiscData%dx)
   end if
   if (allocated(MiscData%du)) then
      deallocate(MiscData%du)
   end if
   if (allocated(MiscData%UDiff)) then
      deallocate(MiscData%UDiff)
   end if
end subroutine

subroutine Glue_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%Modules))
   if (allocated(InData%Modules)) then
      call RegPackBounds(RF, 1, lbound(InData%Modules, kind=B8Ki), ubound(InData%Modules, kind=B8Ki))
      LB(1:1) = lbound(InData%Modules, kind=B8Ki)
      UB(1:1) = ubound(InData%Modules, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackModDataType(RF, InData%Modules(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Mappings))
   if (allocated(InData%Mappings)) then
      call RegPackBounds(RF, 1, lbound(InData%Mappings, kind=B8Ki), ubound(InData%Mappings, kind=B8Ki))
      LB(1:1) = lbound(InData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(InData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackMappingType(RF, InData%Mappings(i1)) 
      end do
   end if
   call Glue_PackModDataType(RF, InData%ModGlue) 
   call Glue_PackLinMisc(RF, InData%Lin) 
   call Glue_PackCalcSteady(RF, InData%CS) 
   call Glue_PackAeroMap(RF, InData%AM) 
   call RegPackAlloc(RF, InData%q)
   call RegPackAlloc(RF, InData%qn)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%xn)
   call RegPackAlloc(RF, InData%dxdt)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%un)
   call RegPackAlloc(RF, InData%u_tmp)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%dUdyHat)
   call RegPackAlloc(RF, InData%XB)
   call RegPackAlloc(RF, InData%G)
   call RegPackAlloc(RF, InData%Jac)
   call RegPackAlloc(RF, InData%IPIV)
   call RegPack(RF, InData%IterTotal)
   call RegPack(RF, InData%IterUntilUJac)
   call RegPack(RF, InData%StepsUntilUJac)
   call RegPackAlloc(RF, InData%dq)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%du)
   call RegPackAlloc(RF, InData%UDiff)
   call RegPack(RF, InData%ConvWarn)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%Modules)) deallocate(OutData%Modules)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Modules(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Modules.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackModDataType(RF, OutData%Modules(i1)) ! Modules 
      end do
   end if
   if (allocated(OutData%Mappings)) deallocate(OutData%Mappings)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Mappings(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mappings.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackMappingType(RF, OutData%Mappings(i1)) ! Mappings 
      end do
   end if
   call Glue_UnpackModDataType(RF, OutData%ModGlue) ! ModGlue 
   call Glue_UnpackLinMisc(RF, OutData%Lin) ! Lin 
   call Glue_UnpackCalcSteady(RF, OutData%CS) ! CS 
   call Glue_UnpackAeroMap(RF, OutData%AM) ! AM 
   call RegUnpackAlloc(RF, OutData%q); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%qn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dxdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%un); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_tmp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdyHat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%XB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%G); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%IPIV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IterTotal); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IterUntilUJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%StepsUntilUJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%du); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%UDiff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvWarn); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE Glue_Types
!ENDOFREGISTRYGENERATEDFILE
