!STARTOFREGISTRYGENERATEDFILE 'Glue_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Glue_Types
!.................................................................................................................................
! This file is part of Glue.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Glue. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Glue_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_LoadMesh                     = 1      ! Load mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_MotionMesh                   = 2      ! Motion mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Variable                     = 3      ! Individual variable mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Custom                       = 4      ! Custom mapping not used for linearization [-]
! =========  MappingType  =======
  TYPE, PUBLIC :: MappingType
    character(128)  :: Desc      !< Description of mapping (used to lookup non-mesh maps) [-]
    INTEGER(IntKi)  :: SrcModIdx = 0      !< Source module index in ModData array [-]
    INTEGER(IntKi)  :: DstModIdx = 0      !< Destination module index in ModData array [-]
    INTEGER(IntKi)  :: SrcModID = 0      !< Source module ID [-]
    INTEGER(IntKi)  :: DstModID = 0      !< Destination module ID [-]
    INTEGER(IntKi)  :: SrcIns = 0      !< Source module Instance [-]
    INTEGER(IntKi)  :: DstIns = 0      !< Destination module Instance [-]
    INTEGER(IntKi)  :: SrcMeshID = 0      !< Source mesh identifier [-]
    INTEGER(IntKi)  :: DstMeshID = 0      !< Destination mesh identifier [-]
    INTEGER(IntKi)  :: iVarSrc = 0      !< Source variable index [-]
    INTEGER(IntKi)  :: iVarDst = 0      !< Destination variable index [-]
    INTEGER(IntKi)  :: SrcDispMeshID = 0      !< Source displacement mesh identifier [-]
    INTEGER(IntKi)  :: DstDispMeshID = 0      !< Destination displacement mesh identifier [-]
    TYPE(MeshLocType)  :: SrcMeshLoc      !< Source mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: DstMeshLoc      !< Destination mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: SrcDispMeshLoc      !< Source displacement mesh locator (number and indices) [-]
    TYPE(MeshLocType)  :: DstDispMeshLoc      !< Destination displacement mesh locator (number and indices) [-]
    INTEGER(IntKi)  :: MapType = 0      !< Integer denoting mapping type (1=Load Mesh, 2=Motion Mesh, 3=Non-Mesh) [-]
    INTEGER(IntKi)  :: XfrType = 0      !< Integer denoting transfer type (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    INTEGER(IntKi)  :: XfrTypeAux = 0      !< Integer denoting transfer type (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    LOGICAL  :: Ready = .false.      !< Flag indicating Source has been ready to be transferred [-]
    LOGICAL  :: DstUsesSibling = .false.      !< Flag indicating the destination displacement mesh is a sibling of the destination load mesh [-]
    TYPE(MeshType)  :: TmpLoadMesh      !< Temporary load mesh for intermediate transfers [-]
    TYPE(MeshType)  :: TmpMotionMesh      !< Temporary motion mesh for intermediate transfers [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: TmpMatrix      !< Temporary matrix for performing transfer for destination load meshes without sibling motion meshes [-]
    TYPE(MeshMapType)  :: MeshMap      !< Mesh mapping from Source variable to Destination variable [-]
    TYPE(MeshMapType)  :: MeshMapAux      !< Auxiliary mesh mapping for destination load meshes without sibling motion mesh [-]
    INTEGER(IntKi)  :: iVarSrcTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcTransVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcTransAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcAngularVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcAngularAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcForce = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcMoment = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarSrcDispTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstTransAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstAngularVel = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstAngularAcc = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstForce = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstMoment = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstDispTransDisp = 0_IntKi      !< Var index for linearized mesh mapping [-]
    INTEGER(IntKi)  :: iVarDstDispOrientation = 0_IntKi      !< Var index for linearized mesh mapping [-]
  END TYPE MappingType
! =======================
! =========  Glue_LinType  =======
  TYPE, PUBLIC :: Glue_LinType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xd      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: z      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_perturb      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_pos      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_neg      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !<  [-]
  END TYPE Glue_LinType
! =======================
! =========  ModDataType  =======
  TYPE, PUBLIC :: ModDataType
    character(ChanLen)  :: Abbr      !< Module name abbreviation [-]
    INTEGER(IntKi)  :: ID = 0      !< Module identification number [-]
    INTEGER(IntKi)  :: Idx = 0      !< Module index in array of modules [-]
    INTEGER(IntKi)  :: Ins = 0      !< Module instance number [-]
    REAL(R8Ki)  :: DT = 0      !< Module time step [-]
    INTEGER(IntKi)  :: SubSteps = 0      !< Module number of substeps per solver time step [-]
    TYPE(ModVarsType) , POINTER :: Vars => NULL()      !< Pointer to module variables type [-]
    TYPE(Glue_LinType)  :: Lin      !< Module linearization data [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: SrcMaps      !< Indices of mappings where module is the source [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DstMaps      !< Indices of mappings where module is the destination [-]
  END TYPE ModDataType
! =======================
! =========  VarIdxType  =======
  TYPE, PUBLIC :: VarIdxType
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ModVarStart      !< Variable start index from module index [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ValLocGbl      !< Variable local and global value indices [-]
  END TYPE VarIdxType
! =======================
! =========  VarsIdxType  =======
  TYPE, PUBLIC :: VarsIdxType
    INTEGER(IntKi)  :: FlagFilter = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nx = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nxd = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nz = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Nu = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: Ny = 0_IntKi      !<  [-]
    TYPE(VarIdxType)  :: x      !<  [-]
    TYPE(VarIdxType)  :: xd      !<  [-]
    TYPE(VarIdxType)  :: z      !<  [-]
    TYPE(VarIdxType)  :: u      !<  [-]
    TYPE(VarIdxType)  :: y      !<  [-]
    TYPE(Glue_LinType)  :: Lin      !< Linearization matrices [-]
  END TYPE VarsIdxType
! =======================
! =========  Glue_ParameterType  =======
  TYPE, PUBLIC :: Glue_ParameterType
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iMod      !< ModData index order for linearization [-]
    TYPE(VarsIdxType)  :: IdxLin      !< Variable index for linearization data [-]
    REAL(R8Ki)  :: DT = 0.0_R8Ki      !< solution time step [-]
    REAL(R8Ki)  :: ConvTol = 0.0_R8Ki      !< Solution convergence tolerance [-]
    INTEGER(IntKi)  :: NumCrctn = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: MaxConvIter = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NIter_UJac = 0_IntKi      !< Number of solution iterations between updating the Jacobian [-]
    INTEGER(IntKi)  :: NStep_UJac = 0_IntKi      !< Number of global time steps between updating the Jacobian [-]
    REAL(R8Ki)  :: Scale_UJac = 0.0_R8Ki      !<  [-]
    REAL(R8Ki)  :: AccBlend = 1      !<  [-]
    REAL(R8Ki)  :: RhoInf = 0.0_R8Ki      !< Rho infinity used for calculating Generalized-alpha coefficients [-]
    REAL(R8Ki)  :: AlphaM = 0.0_R8Ki      !< Generalized-alpha alpha_m coefficient [-]
    REAL(R8Ki)  :: AlphaF = 0.0_R8Ki      !< Generalized-alpha alpha_f coefficient [-]
    REAL(R8Ki)  :: Beta = 0.0_R8Ki      !< Generalized-alpha beta coefficient [-]
    REAL(R8Ki)  :: Gamma = 0.0_R8Ki      !< Generalized-alpha gamma coefficient [-]
    REAL(R8Ki) , DIMENSION(1:7)  :: C = 0.0_R8Ki      !< Generalized-alpha coefficient array [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX2 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iUT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iU1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iyT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iy1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJX = 0_IntKi      !< Indices of Jacobian q variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJU = 0_IntKi      !< Indices of Jacobian input variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJUT = 0_IntKi      !< Indices of Jacobian input variables from tight coupling [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iJL      !< Indices of Jacobian load variables [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ixqd      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModInit      !< ModData index order for step 0 initialization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModTC      !< ModData index order for tight coupling modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModBD      !< ModData index order for BD modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt1      !< ModData index order for option 1 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt1US      !< ModData index order for option 1 modules to update states [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt2      !< ModData index order for option 2 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModPost      !< ModData index order for post option 1 modules [-]
  END TYPE Glue_ParameterType
! =======================
! =========  Glue_LinSave  =======
  TYPE, PUBLIC :: Glue_LinSave
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: x      !< linearization operating point continuous state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< linearization operating point discrete state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: z      !< linearization operating point constraint state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< linearization operating point other state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: u      !< linearization operating point input [-]
  END TYPE Glue_LinSave
! =======================
! =========  Glue_OutputFileType  =======
  TYPE, PUBLIC :: Glue_OutputFileType
    TYPE(ModDataType)  :: ModGlue      !< glue module data [-]
    TYPE(Glue_LinSave)  :: OP 
  END TYPE Glue_OutputFileType
! =======================
! =========  Glue_MiscVarType  =======
  TYPE, PUBLIC :: Glue_MiscVarType
    TYPE(ModDataType) , DIMENSION(:), ALLOCATABLE  :: ModData      !< module variable and value data [-]
    TYPE(MappingType) , DIMENSION(:), ALLOCATABLE  :: Mappings      !< Module mapping [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: q      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: qn      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: xn      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dxdt      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: un      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u_tmp      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dYdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdx      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dXdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdu      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdy      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dUdyHat      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: XB      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: G      !< Used to merge state matrices [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IPIV      !<  [-]
    INTEGER(IntKi)  :: IterTotal = 0      !<  [-]
    INTEGER(IntKi)  :: IterUntilUJac = 0      !< Number of convergence iterations until Jacobian update [-]
    INTEGER(IntKi)  :: StepsUntilUJac = 0      !< Number of time steps until Jacobian update [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: dq      !< Change in q [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !< Change in x [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: UDiff      !<  [-]
    LOGICAL  :: ConvWarn = .false.      !< Flag to warn about convergence failure [-]
  END TYPE Glue_MiscVarType
! =======================
CONTAINS

subroutine Glue_CopyMappingType(SrcMappingTypeData, DstMappingTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: SrcMappingTypeData
   type(MappingType), intent(inout) :: DstMappingTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMappingTypeData%Desc = SrcMappingTypeData%Desc
   DstMappingTypeData%SrcModIdx = SrcMappingTypeData%SrcModIdx
   DstMappingTypeData%DstModIdx = SrcMappingTypeData%DstModIdx
   DstMappingTypeData%SrcModID = SrcMappingTypeData%SrcModID
   DstMappingTypeData%DstModID = SrcMappingTypeData%DstModID
   DstMappingTypeData%SrcIns = SrcMappingTypeData%SrcIns
   DstMappingTypeData%DstIns = SrcMappingTypeData%DstIns
   DstMappingTypeData%SrcMeshID = SrcMappingTypeData%SrcMeshID
   DstMappingTypeData%DstMeshID = SrcMappingTypeData%DstMeshID
   DstMappingTypeData%iVarSrc = SrcMappingTypeData%iVarSrc
   DstMappingTypeData%iVarDst = SrcMappingTypeData%iVarDst
   DstMappingTypeData%SrcDispMeshID = SrcMappingTypeData%SrcDispMeshID
   DstMappingTypeData%DstDispMeshID = SrcMappingTypeData%DstDispMeshID
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%SrcMeshLoc, DstMappingTypeData%SrcMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%DstMeshLoc, DstMappingTypeData%DstMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%SrcDispMeshLoc, DstMappingTypeData%SrcDispMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshLocType(SrcMappingTypeData%DstDispMeshLoc, DstMappingTypeData%DstDispMeshLoc, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMappingTypeData%MapType = SrcMappingTypeData%MapType
   DstMappingTypeData%XfrType = SrcMappingTypeData%XfrType
   DstMappingTypeData%XfrTypeAux = SrcMappingTypeData%XfrTypeAux
   DstMappingTypeData%Ready = SrcMappingTypeData%Ready
   DstMappingTypeData%DstUsesSibling = SrcMappingTypeData%DstUsesSibling
   call MeshCopy(SrcMappingTypeData%TmpLoadMesh, DstMappingTypeData%TmpLoadMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMappingTypeData%TmpMotionMesh, DstMappingTypeData%TmpMotionMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMappingTypeData%TmpMatrix)) then
      LB(1:2) = lbound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      UB(1:2) = ubound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      if (.not. allocated(DstMappingTypeData%TmpMatrix)) then
         allocate(DstMappingTypeData%TmpMatrix(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMappingTypeData%TmpMatrix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMappingTypeData%TmpMatrix = SrcMappingTypeData%TmpMatrix
   end if
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMap, DstMappingTypeData%MeshMap, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMapAux, DstMappingTypeData%MeshMapAux, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMappingTypeData%iVarSrcTransDisp = SrcMappingTypeData%iVarSrcTransDisp
   DstMappingTypeData%iVarSrcTransVel = SrcMappingTypeData%iVarSrcTransVel
   DstMappingTypeData%iVarSrcTransAcc = SrcMappingTypeData%iVarSrcTransAcc
   DstMappingTypeData%iVarSrcOrientation = SrcMappingTypeData%iVarSrcOrientation
   DstMappingTypeData%iVarSrcAngularVel = SrcMappingTypeData%iVarSrcAngularVel
   DstMappingTypeData%iVarSrcAngularAcc = SrcMappingTypeData%iVarSrcAngularAcc
   DstMappingTypeData%iVarSrcForce = SrcMappingTypeData%iVarSrcForce
   DstMappingTypeData%iVarSrcMoment = SrcMappingTypeData%iVarSrcMoment
   DstMappingTypeData%iVarSrcDispTransDisp = SrcMappingTypeData%iVarSrcDispTransDisp
   DstMappingTypeData%iVarDstTransDisp = SrcMappingTypeData%iVarDstTransDisp
   DstMappingTypeData%iVarDstTransVel = SrcMappingTypeData%iVarDstTransVel
   DstMappingTypeData%iVarDstTransAcc = SrcMappingTypeData%iVarDstTransAcc
   DstMappingTypeData%iVarDstOrientation = SrcMappingTypeData%iVarDstOrientation
   DstMappingTypeData%iVarDstAngularVel = SrcMappingTypeData%iVarDstAngularVel
   DstMappingTypeData%iVarDstAngularAcc = SrcMappingTypeData%iVarDstAngularAcc
   DstMappingTypeData%iVarDstForce = SrcMappingTypeData%iVarDstForce
   DstMappingTypeData%iVarDstMoment = SrcMappingTypeData%iVarDstMoment
   DstMappingTypeData%iVarDstDispTransDisp = SrcMappingTypeData%iVarDstDispTransDisp
   DstMappingTypeData%iVarDstDispOrientation = SrcMappingTypeData%iVarDstDispOrientation
end subroutine

subroutine Glue_DestroyMappingType(MappingTypeData, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: MappingTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%SrcMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%DstMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%SrcDispMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshLocType(MappingTypeData%DstDispMeshLoc, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpLoadMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpMotionMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MappingTypeData%TmpMatrix)) then
      deallocate(MappingTypeData%TmpMatrix)
   end if
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMap, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMapAux, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackMappingType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MappingType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMappingType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Desc)
   call RegPack(RF, InData%SrcModIdx)
   call RegPack(RF, InData%DstModIdx)
   call RegPack(RF, InData%SrcModID)
   call RegPack(RF, InData%DstModID)
   call RegPack(RF, InData%SrcIns)
   call RegPack(RF, InData%DstIns)
   call RegPack(RF, InData%SrcMeshID)
   call RegPack(RF, InData%DstMeshID)
   call RegPack(RF, InData%iVarSrc)
   call RegPack(RF, InData%iVarDst)
   call RegPack(RF, InData%SrcDispMeshID)
   call RegPack(RF, InData%DstDispMeshID)
   call NWTC_Library_PackMeshLocType(RF, InData%SrcMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%DstMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%SrcDispMeshLoc) 
   call NWTC_Library_PackMeshLocType(RF, InData%DstDispMeshLoc) 
   call RegPack(RF, InData%MapType)
   call RegPack(RF, InData%XfrType)
   call RegPack(RF, InData%XfrTypeAux)
   call RegPack(RF, InData%Ready)
   call RegPack(RF, InData%DstUsesSibling)
   call MeshPack(RF, InData%TmpLoadMesh) 
   call MeshPack(RF, InData%TmpMotionMesh) 
   call RegPackAlloc(RF, InData%TmpMatrix)
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMap) 
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMapAux) 
   call RegPack(RF, InData%iVarSrcTransDisp)
   call RegPack(RF, InData%iVarSrcTransVel)
   call RegPack(RF, InData%iVarSrcTransAcc)
   call RegPack(RF, InData%iVarSrcOrientation)
   call RegPack(RF, InData%iVarSrcAngularVel)
   call RegPack(RF, InData%iVarSrcAngularAcc)
   call RegPack(RF, InData%iVarSrcForce)
   call RegPack(RF, InData%iVarSrcMoment)
   call RegPack(RF, InData%iVarSrcDispTransDisp)
   call RegPack(RF, InData%iVarDstTransDisp)
   call RegPack(RF, InData%iVarDstTransVel)
   call RegPack(RF, InData%iVarDstTransAcc)
   call RegPack(RF, InData%iVarDstOrientation)
   call RegPack(RF, InData%iVarDstAngularVel)
   call RegPack(RF, InData%iVarDstAngularAcc)
   call RegPack(RF, InData%iVarDstForce)
   call RegPack(RF, InData%iVarDstMoment)
   call RegPack(RF, InData%iVarDstDispTransDisp)
   call RegPack(RF, InData%iVarDstDispOrientation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMappingType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MappingType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMappingType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Desc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcModIdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstModIdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcIns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstIns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcDispMeshID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstDispMeshID); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackMeshLocType(RF, OutData%SrcMeshLoc) ! SrcMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%DstMeshLoc) ! DstMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%SrcDispMeshLoc) ! SrcDispMeshLoc 
   call NWTC_Library_UnpackMeshLocType(RF, OutData%DstDispMeshLoc) ! DstDispMeshLoc 
   call RegUnpack(RF, OutData%MapType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrTypeAux); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ready); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstUsesSibling); if (RegCheckErr(RF, RoutineName)) return
   call MeshUnpack(RF, OutData%TmpLoadMesh) ! TmpLoadMesh 
   call MeshUnpack(RF, OutData%TmpMotionMesh) ! TmpMotionMesh 
   call RegUnpackAlloc(RF, OutData%TmpMatrix); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMap) ! MeshMap 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMapAux) ! MeshMapAux 
   call RegUnpack(RF, OutData%iVarSrcTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcTransVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcTransAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcAngularVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcAngularAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcForce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcMoment); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcDispTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstTransAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstAngularVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstAngularAcc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstForce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstMoment); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstDispTransDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstDispOrientation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinType(SrcLinTypeData, DstLinTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinType), intent(in) :: SrcLinTypeData
   type(Glue_LinType), intent(inout) :: DstLinTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLinTypeData%x)) then
      LB(1:1) = lbound(SrcLinTypeData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x)) then
         allocate(DstLinTypeData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x = SrcLinTypeData%x
   end if
   if (allocated(SrcLinTypeData%dx)) then
      LB(1:1) = lbound(SrcLinTypeData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%dx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dx)) then
         allocate(DstLinTypeData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dx = SrcLinTypeData%dx
   end if
   if (allocated(SrcLinTypeData%xd)) then
      LB(1:1) = lbound(SrcLinTypeData%xd, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%xd, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%xd)) then
         allocate(DstLinTypeData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%xd = SrcLinTypeData%xd
   end if
   if (allocated(SrcLinTypeData%z)) then
      LB(1:1) = lbound(SrcLinTypeData%z, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%z, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%z)) then
         allocate(DstLinTypeData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%z = SrcLinTypeData%z
   end if
   if (allocated(SrcLinTypeData%u)) then
      LB(1:1) = lbound(SrcLinTypeData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%u, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%u)) then
         allocate(DstLinTypeData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%u = SrcLinTypeData%u
   end if
   if (allocated(SrcLinTypeData%y)) then
      LB(1:1) = lbound(SrcLinTypeData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y)) then
         allocate(DstLinTypeData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y = SrcLinTypeData%y
   end if
   if (allocated(SrcLinTypeData%u_perturb)) then
      LB(1:1) = lbound(SrcLinTypeData%u_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%u_perturb, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%u_perturb)) then
         allocate(DstLinTypeData%u_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%u_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%u_perturb = SrcLinTypeData%u_perturb
   end if
   if (allocated(SrcLinTypeData%x_perturb)) then
      LB(1:1) = lbound(SrcLinTypeData%x_perturb, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_perturb, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_perturb)) then
         allocate(DstLinTypeData%x_perturb(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_perturb.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_perturb = SrcLinTypeData%x_perturb
   end if
   if (allocated(SrcLinTypeData%x_pos)) then
      LB(1:1) = lbound(SrcLinTypeData%x_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_pos, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_pos)) then
         allocate(DstLinTypeData%x_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_pos = SrcLinTypeData%x_pos
   end if
   if (allocated(SrcLinTypeData%x_neg)) then
      LB(1:1) = lbound(SrcLinTypeData%x_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%x_neg, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%x_neg)) then
         allocate(DstLinTypeData%x_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%x_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%x_neg = SrcLinTypeData%x_neg
   end if
   if (allocated(SrcLinTypeData%y_pos)) then
      LB(1:1) = lbound(SrcLinTypeData%y_pos, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y_pos, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y_pos)) then
         allocate(DstLinTypeData%y_pos(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y_pos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y_pos = SrcLinTypeData%y_pos
   end if
   if (allocated(SrcLinTypeData%y_neg)) then
      LB(1:1) = lbound(SrcLinTypeData%y_neg, kind=B8Ki)
      UB(1:1) = ubound(SrcLinTypeData%y_neg, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%y_neg)) then
         allocate(DstLinTypeData%y_neg(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%y_neg.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%y_neg = SrcLinTypeData%y_neg
   end if
   if (allocated(SrcLinTypeData%dYdx)) then
      LB(1:2) = lbound(SrcLinTypeData%dYdx, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dYdx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dYdx)) then
         allocate(DstLinTypeData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dYdx = SrcLinTypeData%dYdx
   end if
   if (allocated(SrcLinTypeData%dXdx)) then
      LB(1:2) = lbound(SrcLinTypeData%dXdx, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dXdx, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dXdx)) then
         allocate(DstLinTypeData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dXdx = SrcLinTypeData%dXdx
   end if
   if (allocated(SrcLinTypeData%dYdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dYdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dYdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dYdu)) then
         allocate(DstLinTypeData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dYdu = SrcLinTypeData%dYdu
   end if
   if (allocated(SrcLinTypeData%dXdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dXdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dXdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dXdu)) then
         allocate(DstLinTypeData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dXdu = SrcLinTypeData%dXdu
   end if
   if (allocated(SrcLinTypeData%dUdu)) then
      LB(1:2) = lbound(SrcLinTypeData%dUdu, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dUdu, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dUdu)) then
         allocate(DstLinTypeData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dUdu = SrcLinTypeData%dUdu
   end if
   if (allocated(SrcLinTypeData%dUdy)) then
      LB(1:2) = lbound(SrcLinTypeData%dUdy, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%dUdy, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%dUdy)) then
         allocate(DstLinTypeData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%dUdy = SrcLinTypeData%dUdy
   end if
   if (allocated(SrcLinTypeData%StateRotation)) then
      LB(1:2) = lbound(SrcLinTypeData%StateRotation, kind=B8Ki)
      UB(1:2) = ubound(SrcLinTypeData%StateRotation, kind=B8Ki)
      if (.not. allocated(DstLinTypeData%StateRotation)) then
         allocate(DstLinTypeData%StateRotation(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%StateRotation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinTypeData%StateRotation = SrcLinTypeData%StateRotation
   end if
end subroutine

subroutine Glue_DestroyLinType(LinTypeData, ErrStat, ErrMsg)
   type(Glue_LinType), intent(inout) :: LinTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinTypeData%x)) then
      deallocate(LinTypeData%x)
   end if
   if (allocated(LinTypeData%dx)) then
      deallocate(LinTypeData%dx)
   end if
   if (allocated(LinTypeData%xd)) then
      deallocate(LinTypeData%xd)
   end if
   if (allocated(LinTypeData%z)) then
      deallocate(LinTypeData%z)
   end if
   if (allocated(LinTypeData%u)) then
      deallocate(LinTypeData%u)
   end if
   if (allocated(LinTypeData%y)) then
      deallocate(LinTypeData%y)
   end if
   if (allocated(LinTypeData%u_perturb)) then
      deallocate(LinTypeData%u_perturb)
   end if
   if (allocated(LinTypeData%x_perturb)) then
      deallocate(LinTypeData%x_perturb)
   end if
   if (allocated(LinTypeData%x_pos)) then
      deallocate(LinTypeData%x_pos)
   end if
   if (allocated(LinTypeData%x_neg)) then
      deallocate(LinTypeData%x_neg)
   end if
   if (allocated(LinTypeData%y_pos)) then
      deallocate(LinTypeData%y_pos)
   end if
   if (allocated(LinTypeData%y_neg)) then
      deallocate(LinTypeData%y_neg)
   end if
   if (allocated(LinTypeData%dYdx)) then
      deallocate(LinTypeData%dYdx)
   end if
   if (allocated(LinTypeData%dXdx)) then
      deallocate(LinTypeData%dXdx)
   end if
   if (allocated(LinTypeData%dYdu)) then
      deallocate(LinTypeData%dYdu)
   end if
   if (allocated(LinTypeData%dXdu)) then
      deallocate(LinTypeData%dXdu)
   end if
   if (allocated(LinTypeData%dUdu)) then
      deallocate(LinTypeData%dUdu)
   end if
   if (allocated(LinTypeData%dUdy)) then
      deallocate(LinTypeData%dUdy)
   end if
   if (allocated(LinTypeData%StateRotation)) then
      deallocate(LinTypeData%StateRotation)
   end if
end subroutine

subroutine Glue_PackLinType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%u_perturb)
   call RegPackAlloc(RF, InData%x_perturb)
   call RegPackAlloc(RF, InData%x_pos)
   call RegPackAlloc(RF, InData%x_neg)
   call RegPackAlloc(RF, InData%y_pos)
   call RegPackAlloc(RF, InData%y_neg)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%StateRotation)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_perturb); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_pos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_neg); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%StateRotation); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyModDataType(SrcModDataTypeData, DstModDataTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModDataType), intent(in) :: SrcModDataTypeData
   type(ModDataType), intent(inout) :: DstModDataTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModDataTypeData%Abbr = SrcModDataTypeData%Abbr
   DstModDataTypeData%ID = SrcModDataTypeData%ID
   DstModDataTypeData%Idx = SrcModDataTypeData%Idx
   DstModDataTypeData%Ins = SrcModDataTypeData%Ins
   DstModDataTypeData%DT = SrcModDataTypeData%DT
   DstModDataTypeData%SubSteps = SrcModDataTypeData%SubSteps
   DstModDataTypeData%Vars => SrcModDataTypeData%Vars
   call Glue_CopyLinType(SrcModDataTypeData%Lin, DstModDataTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcModDataTypeData%SrcMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%SrcMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%SrcMaps)) then
         allocate(DstModDataTypeData%SrcMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%SrcMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%SrcMaps = SrcModDataTypeData%SrcMaps
   end if
   if (allocated(SrcModDataTypeData%DstMaps)) then
      LB(1:1) = lbound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModDataTypeData%DstMaps, kind=B8Ki)
      if (.not. allocated(DstModDataTypeData%DstMaps)) then
         allocate(DstModDataTypeData%DstMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModDataTypeData%DstMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstModDataTypeData%DstMaps = SrcModDataTypeData%DstMaps
   end if
end subroutine

subroutine Glue_DestroyModDataType(ModDataTypeData, ErrStat, ErrMsg)
   type(ModDataType), intent(inout) :: ModDataTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyModDataType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   nullify(ModDataTypeData%Vars)
   call Glue_DestroyLinType(ModDataTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModDataTypeData%SrcMaps)) then
      deallocate(ModDataTypeData%SrcMaps)
   end if
   if (allocated(ModDataTypeData%DstMaps)) then
      deallocate(ModDataTypeData%DstMaps)
   end if
end subroutine

subroutine Glue_PackModDataType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackModDataType'
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Abbr)
   call RegPack(RF, InData%ID)
   call RegPack(RF, InData%Idx)
   call RegPack(RF, InData%Ins)
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%SubSteps)
   call RegPack(RF, associated(InData%Vars))
   if (associated(InData%Vars)) then
      call RegPackPointer(RF, c_loc(InData%Vars), PtrInIndex)
      if (.not. PtrInIndex) then
         call NWTC_Library_PackModVarsType(RF, InData%Vars) 
      end if
   end if
   call Glue_PackLinType(RF, InData%Lin) 
   call RegPackAlloc(RF, InData%SrcMaps)
   call RegPackAlloc(RF, InData%DstMaps)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackModDataType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackModDataType'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Abbr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Idx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ins); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SubSteps); if (RegCheckErr(RF, RoutineName)) return
   if (associated(OutData%Vars)) deallocate(OutData%Vars)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(RF, Ptr, PtrIdx); if (RegCheckErr(RF, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vars)
      else
         allocate(OutData%Vars,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vars.', RF%ErrStat, RF%ErrMsg, RoutineName)
            return
         end if
         RF%Pointers(PtrIdx) = c_loc(OutData%Vars)
         call NWTC_Library_UnpackModVarsType(RF, OutData%Vars) ! Vars 
      end if
   else
      OutData%Vars => null()
   end if
   call Glue_UnpackLinType(RF, OutData%Lin) ! Lin 
   call RegUnpackAlloc(RF, OutData%SrcMaps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DstMaps); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyVarIdxType(SrcVarIdxTypeData, DstVarIdxTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarIdxType), intent(in) :: SrcVarIdxTypeData
   type(VarIdxType), intent(inout) :: DstVarIdxTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyVarIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcVarIdxTypeData%ModVarStart)) then
      LB(1:1) = lbound(SrcVarIdxTypeData%ModVarStart, kind=B8Ki)
      UB(1:1) = ubound(SrcVarIdxTypeData%ModVarStart, kind=B8Ki)
      if (.not. allocated(DstVarIdxTypeData%ModVarStart)) then
         allocate(DstVarIdxTypeData%ModVarStart(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarIdxTypeData%ModVarStart.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarIdxTypeData%ModVarStart = SrcVarIdxTypeData%ModVarStart
   end if
   if (allocated(SrcVarIdxTypeData%ValLocGbl)) then
      LB(1:2) = lbound(SrcVarIdxTypeData%ValLocGbl, kind=B8Ki)
      UB(1:2) = ubound(SrcVarIdxTypeData%ValLocGbl, kind=B8Ki)
      if (.not. allocated(DstVarIdxTypeData%ValLocGbl)) then
         allocate(DstVarIdxTypeData%ValLocGbl(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVarIdxTypeData%ValLocGbl.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVarIdxTypeData%ValLocGbl = SrcVarIdxTypeData%ValLocGbl
   end if
end subroutine

subroutine Glue_DestroyVarIdxType(VarIdxTypeData, ErrStat, ErrMsg)
   type(VarIdxType), intent(inout) :: VarIdxTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyVarIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VarIdxTypeData%ModVarStart)) then
      deallocate(VarIdxTypeData%ModVarStart)
   end if
   if (allocated(VarIdxTypeData%ValLocGbl)) then
      deallocate(VarIdxTypeData%ValLocGbl)
   end if
end subroutine

subroutine Glue_PackVarIdxType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarIdxType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackVarIdxType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%ModVarStart)
   call RegPackAlloc(RF, InData%ValLocGbl)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackVarIdxType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarIdxType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackVarIdxType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%ModVarStart); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ValLocGbl); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyVarsIdxType(SrcVarsIdxTypeData, DstVarsIdxTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarsIdxType), intent(in) :: SrcVarsIdxTypeData
   type(VarsIdxType), intent(inout) :: DstVarsIdxTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyVarsIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVarsIdxTypeData%FlagFilter = SrcVarsIdxTypeData%FlagFilter
   DstVarsIdxTypeData%Nx = SrcVarsIdxTypeData%Nx
   DstVarsIdxTypeData%Nxd = SrcVarsIdxTypeData%Nxd
   DstVarsIdxTypeData%Nz = SrcVarsIdxTypeData%Nz
   DstVarsIdxTypeData%Nu = SrcVarsIdxTypeData%Nu
   DstVarsIdxTypeData%Ny = SrcVarsIdxTypeData%Ny
   call Glue_CopyVarIdxType(SrcVarsIdxTypeData%x, DstVarsIdxTypeData%x, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyVarIdxType(SrcVarsIdxTypeData%xd, DstVarsIdxTypeData%xd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyVarIdxType(SrcVarsIdxTypeData%z, DstVarsIdxTypeData%z, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyVarIdxType(SrcVarsIdxTypeData%u, DstVarsIdxTypeData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyVarIdxType(SrcVarsIdxTypeData%y, DstVarsIdxTypeData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyLinType(SrcVarsIdxTypeData%Lin, DstVarsIdxTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyVarsIdxType(VarsIdxTypeData, ErrStat, ErrMsg)
   type(VarsIdxType), intent(inout) :: VarsIdxTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyVarsIdxType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyVarIdxType(VarsIdxTypeData%x, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyVarIdxType(VarsIdxTypeData%xd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyVarIdxType(VarsIdxTypeData%z, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyVarIdxType(VarsIdxTypeData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyVarIdxType(VarsIdxTypeData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyLinType(VarsIdxTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackVarsIdxType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarsIdxType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackVarsIdxType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%FlagFilter)
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%Nxd)
   call RegPack(RF, InData%Nz)
   call RegPack(RF, InData%Nu)
   call RegPack(RF, InData%Ny)
   call Glue_PackVarIdxType(RF, InData%x) 
   call Glue_PackVarIdxType(RF, InData%xd) 
   call Glue_PackVarIdxType(RF, InData%z) 
   call Glue_PackVarIdxType(RF, InData%u) 
   call Glue_PackVarIdxType(RF, InData%y) 
   call Glue_PackLinType(RF, InData%Lin) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackVarsIdxType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarsIdxType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackVarsIdxType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%FlagFilter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nxd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ny); if (RegCheckErr(RF, RoutineName)) return
   call Glue_UnpackVarIdxType(RF, OutData%x) ! x 
   call Glue_UnpackVarIdxType(RF, OutData%xd) ! xd 
   call Glue_UnpackVarIdxType(RF, OutData%z) ! z 
   call Glue_UnpackVarIdxType(RF, OutData%u) ! u 
   call Glue_UnpackVarIdxType(RF, OutData%y) ! y 
   call Glue_UnpackLinType(RF, OutData%Lin) ! Lin 
end subroutine

subroutine Glue_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(in) :: SrcParamData
   type(Glue_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcParamData%iMod)) then
      LB(1:1) = lbound(SrcParamData%iMod, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iMod, kind=B8Ki)
      if (.not. allocated(DstParamData%iMod)) then
         allocate(DstParamData%iMod(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iMod.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iMod = SrcParamData%iMod
   end if
   call Glue_CopyVarsIdxType(SrcParamData%IdxLin, DstParamData%IdxLin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%DT = SrcParamData%DT
   DstParamData%ConvTol = SrcParamData%ConvTol
   DstParamData%NumCrctn = SrcParamData%NumCrctn
   DstParamData%MaxConvIter = SrcParamData%MaxConvIter
   DstParamData%NIter_UJac = SrcParamData%NIter_UJac
   DstParamData%NStep_UJac = SrcParamData%NStep_UJac
   DstParamData%Scale_UJac = SrcParamData%Scale_UJac
   DstParamData%AccBlend = SrcParamData%AccBlend
   DstParamData%RhoInf = SrcParamData%RhoInf
   DstParamData%AlphaM = SrcParamData%AlphaM
   DstParamData%AlphaF = SrcParamData%AlphaF
   DstParamData%Beta = SrcParamData%Beta
   DstParamData%Gamma = SrcParamData%Gamma
   DstParamData%C = SrcParamData%C
   DstParamData%iX1 = SrcParamData%iX1
   DstParamData%iX2 = SrcParamData%iX2
   DstParamData%iUT = SrcParamData%iUT
   DstParamData%iU1 = SrcParamData%iU1
   DstParamData%iyT = SrcParamData%iyT
   DstParamData%iy1 = SrcParamData%iy1
   DstParamData%iJX = SrcParamData%iJX
   DstParamData%iJU = SrcParamData%iJU
   DstParamData%iJUT = SrcParamData%iJUT
   if (allocated(SrcParamData%iJL)) then
      LB(1:1) = lbound(SrcParamData%iJL, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iJL, kind=B8Ki)
      if (.not. allocated(DstParamData%iJL)) then
         allocate(DstParamData%iJL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iJL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iJL = SrcParamData%iJL
   end if
   if (allocated(SrcParamData%ixqd)) then
      LB(1:2) = lbound(SrcParamData%ixqd, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%ixqd, kind=B8Ki)
      if (.not. allocated(DstParamData%ixqd)) then
         allocate(DstParamData%ixqd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ixqd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%ixqd = SrcParamData%ixqd
   end if
   if (allocated(SrcParamData%iModInit)) then
      LB(1:1) = lbound(SrcParamData%iModInit, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModInit, kind=B8Ki)
      if (.not. allocated(DstParamData%iModInit)) then
         allocate(DstParamData%iModInit(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModInit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModInit = SrcParamData%iModInit
   end if
   if (allocated(SrcParamData%iModTC)) then
      LB(1:1) = lbound(SrcParamData%iModTC, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModTC, kind=B8Ki)
      if (.not. allocated(DstParamData%iModTC)) then
         allocate(DstParamData%iModTC(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModTC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModTC = SrcParamData%iModTC
   end if
   if (allocated(SrcParamData%iModBD)) then
      LB(1:1) = lbound(SrcParamData%iModBD, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModBD, kind=B8Ki)
      if (.not. allocated(DstParamData%iModBD)) then
         allocate(DstParamData%iModBD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModBD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModBD = SrcParamData%iModBD
   end if
   if (allocated(SrcParamData%iModOpt1)) then
      LB(1:1) = lbound(SrcParamData%iModOpt1, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt1, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt1)) then
         allocate(DstParamData%iModOpt1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt1 = SrcParamData%iModOpt1
   end if
   if (allocated(SrcParamData%iModOpt1US)) then
      LB(1:1) = lbound(SrcParamData%iModOpt1US, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt1US, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt1US)) then
         allocate(DstParamData%iModOpt1US(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt1US.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt1US = SrcParamData%iModOpt1US
   end if
   if (allocated(SrcParamData%iModOpt2)) then
      LB(1:1) = lbound(SrcParamData%iModOpt2, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModOpt2, kind=B8Ki)
      if (.not. allocated(DstParamData%iModOpt2)) then
         allocate(DstParamData%iModOpt2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModOpt2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModOpt2 = SrcParamData%iModOpt2
   end if
   if (allocated(SrcParamData%iModPost)) then
      LB(1:1) = lbound(SrcParamData%iModPost, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%iModPost, kind=B8Ki)
      if (.not. allocated(DstParamData%iModPost)) then
         allocate(DstParamData%iModPost(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%iModPost.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%iModPost = SrcParamData%iModPost
   end if
end subroutine

subroutine Glue_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%iMod)) then
      deallocate(ParamData%iMod)
   end if
   call Glue_DestroyVarsIdxType(ParamData%IdxLin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ParamData%iJL)) then
      deallocate(ParamData%iJL)
   end if
   if (allocated(ParamData%ixqd)) then
      deallocate(ParamData%ixqd)
   end if
   if (allocated(ParamData%iModInit)) then
      deallocate(ParamData%iModInit)
   end if
   if (allocated(ParamData%iModTC)) then
      deallocate(ParamData%iModTC)
   end if
   if (allocated(ParamData%iModBD)) then
      deallocate(ParamData%iModBD)
   end if
   if (allocated(ParamData%iModOpt1)) then
      deallocate(ParamData%iModOpt1)
   end if
   if (allocated(ParamData%iModOpt1US)) then
      deallocate(ParamData%iModOpt1US)
   end if
   if (allocated(ParamData%iModOpt2)) then
      deallocate(ParamData%iModOpt2)
   end if
   if (allocated(ParamData%iModPost)) then
      deallocate(ParamData%iModPost)
   end if
end subroutine

subroutine Glue_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%iMod)
   call Glue_PackVarsIdxType(RF, InData%IdxLin) 
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%ConvTol)
   call RegPack(RF, InData%NumCrctn)
   call RegPack(RF, InData%MaxConvIter)
   call RegPack(RF, InData%NIter_UJac)
   call RegPack(RF, InData%NStep_UJac)
   call RegPack(RF, InData%Scale_UJac)
   call RegPack(RF, InData%AccBlend)
   call RegPack(RF, InData%RhoInf)
   call RegPack(RF, InData%AlphaM)
   call RegPack(RF, InData%AlphaF)
   call RegPack(RF, InData%Beta)
   call RegPack(RF, InData%Gamma)
   call RegPack(RF, InData%C)
   call RegPack(RF, InData%iX1)
   call RegPack(RF, InData%iX2)
   call RegPack(RF, InData%iUT)
   call RegPack(RF, InData%iU1)
   call RegPack(RF, InData%iyT)
   call RegPack(RF, InData%iy1)
   call RegPack(RF, InData%iJX)
   call RegPack(RF, InData%iJU)
   call RegPack(RF, InData%iJUT)
   call RegPackAlloc(RF, InData%iJL)
   call RegPackAlloc(RF, InData%ixqd)
   call RegPackAlloc(RF, InData%iModInit)
   call RegPackAlloc(RF, InData%iModTC)
   call RegPackAlloc(RF, InData%iModBD)
   call RegPackAlloc(RF, InData%iModOpt1)
   call RegPackAlloc(RF, InData%iModOpt1US)
   call RegPackAlloc(RF, InData%iModOpt2)
   call RegPackAlloc(RF, InData%iModPost)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackParam'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
   call Glue_UnpackVarsIdxType(RF, OutData%IdxLin) ! IdxLin 
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvTol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumCrctn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MaxConvIter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NIter_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NStep_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Scale_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AccBlend); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RhoInf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Beta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Gamma); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%C); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iU1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iyT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iy1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iJL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ixqd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModTC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModBD); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt1US); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModPost); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinSave(SrcLinSaveData, DstLinSaveData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(in) :: SrcLinSaveData
   type(Glue_LinSave), intent(inout) :: DstLinSaveData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLinSaveData%x)) then
      LB(1:2) = lbound(SrcLinSaveData%x, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%x, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%x)) then
         allocate(DstLinSaveData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%x = SrcLinSaveData%x
   end if
   if (allocated(SrcLinSaveData%xd)) then
      LB(1:2) = lbound(SrcLinSaveData%xd, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%xd, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%xd)) then
         allocate(DstLinSaveData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%xd = SrcLinSaveData%xd
   end if
   if (allocated(SrcLinSaveData%z)) then
      LB(1:2) = lbound(SrcLinSaveData%z, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%z, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%z)) then
         allocate(DstLinSaveData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%z = SrcLinSaveData%z
   end if
   if (allocated(SrcLinSaveData%OtherSt)) then
      LB(1:2) = lbound(SrcLinSaveData%OtherSt, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%OtherSt, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%OtherSt)) then
         allocate(DstLinSaveData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%OtherSt = SrcLinSaveData%OtherSt
   end if
   if (allocated(SrcLinSaveData%u)) then
      LB(1:2) = lbound(SrcLinSaveData%u, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%u, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%u)) then
         allocate(DstLinSaveData%u(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%u = SrcLinSaveData%u
   end if
end subroutine

subroutine Glue_DestroyLinSave(LinSaveData, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(inout) :: LinSaveData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinSaveData%x)) then
      deallocate(LinSaveData%x)
   end if
   if (allocated(LinSaveData%xd)) then
      deallocate(LinSaveData%xd)
   end if
   if (allocated(LinSaveData%z)) then
      deallocate(LinSaveData%z)
   end if
   if (allocated(LinSaveData%OtherSt)) then
      deallocate(LinSaveData%OtherSt)
   end if
   if (allocated(LinSaveData%u)) then
      deallocate(LinSaveData%u)
   end if
end subroutine

subroutine Glue_PackLinSave(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinSave), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinSave'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%OtherSt)
   call RegPackAlloc(RF, InData%u)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinSave(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinSave), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinSave'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OtherSt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyOutputFileType(SrcOutputFileTypeData, DstOutputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(in) :: SrcOutputFileTypeData
   type(Glue_OutputFileType), intent(inout) :: DstOutputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyModDataType(SrcOutputFileTypeData%ModGlue, DstOutputFileTypeData%ModGlue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyLinSave(SrcOutputFileTypeData%OP, DstOutputFileTypeData%OP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyOutputFileType(OutputFileTypeData, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(inout) :: OutputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyModDataType(OutputFileTypeData%ModGlue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyLinSave(OutputFileTypeData%OP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackOutputFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_OutputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackOutputFileType'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackModDataType(RF, InData%ModGlue) 
   call Glue_PackLinSave(RF, InData%OP) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackOutputFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_OutputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackOutputFileType'
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackModDataType(RF, OutData%ModGlue) ! ModGlue 
   call Glue_UnpackLinSave(RF, OutData%OP) ! OP 
end subroutine

subroutine Glue_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: SrcMiscData
   type(Glue_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%ModData)) then
      LB(1:1) = lbound(SrcMiscData%ModData, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%ModData, kind=B8Ki)
      if (.not. allocated(DstMiscData%ModData)) then
         allocate(DstMiscData%ModData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ModData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyModDataType(SrcMiscData%ModData(i1), DstMiscData%ModData(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%Mappings)) then
      LB(1:1) = lbound(SrcMiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%Mappings, kind=B8Ki)
      if (.not. allocated(DstMiscData%Mappings)) then
         allocate(DstMiscData%Mappings(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Mappings.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyMappingType(SrcMiscData%Mappings(i1), DstMiscData%Mappings(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%q)) then
      LB(1:2) = lbound(SrcMiscData%q, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%q, kind=B8Ki)
      if (.not. allocated(DstMiscData%q)) then
         allocate(DstMiscData%q(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%q.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%q = SrcMiscData%q
   end if
   if (allocated(SrcMiscData%qn)) then
      LB(1:2) = lbound(SrcMiscData%qn, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%qn, kind=B8Ki)
      if (.not. allocated(DstMiscData%qn)) then
         allocate(DstMiscData%qn(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%qn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%qn = SrcMiscData%qn
   end if
   if (allocated(SrcMiscData%x)) then
      LB(1:1) = lbound(SrcMiscData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%x, kind=B8Ki)
      if (.not. allocated(DstMiscData%x)) then
         allocate(DstMiscData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%x = SrcMiscData%x
   end if
   if (allocated(SrcMiscData%xn)) then
      LB(1:1) = lbound(SrcMiscData%xn, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%xn, kind=B8Ki)
      if (.not. allocated(DstMiscData%xn)) then
         allocate(DstMiscData%xn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%xn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%xn = SrcMiscData%xn
   end if
   if (allocated(SrcMiscData%dxdt)) then
      LB(1:1) = lbound(SrcMiscData%dxdt, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%dxdt, kind=B8Ki)
      if (.not. allocated(DstMiscData%dxdt)) then
         allocate(DstMiscData%dxdt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dxdt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dxdt = SrcMiscData%dxdt
   end if
   if (allocated(SrcMiscData%u)) then
      LB(1:1) = lbound(SrcMiscData%u, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%u, kind=B8Ki)
      if (.not. allocated(DstMiscData%u)) then
         allocate(DstMiscData%u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%u = SrcMiscData%u
   end if
   if (allocated(SrcMiscData%un)) then
      LB(1:1) = lbound(SrcMiscData%un, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%un, kind=B8Ki)
      if (.not. allocated(DstMiscData%un)) then
         allocate(DstMiscData%un(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%un.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%un = SrcMiscData%un
   end if
   if (allocated(SrcMiscData%u_tmp)) then
      LB(1:1) = lbound(SrcMiscData%u_tmp, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%u_tmp, kind=B8Ki)
      if (.not. allocated(DstMiscData%u_tmp)) then
         allocate(DstMiscData%u_tmp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_tmp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%u_tmp = SrcMiscData%u_tmp
   end if
   if (allocated(SrcMiscData%y)) then
      LB(1:1) = lbound(SrcMiscData%y, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%y, kind=B8Ki)
      if (.not. allocated(DstMiscData%y)) then
         allocate(DstMiscData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%y = SrcMiscData%y
   end if
   if (allocated(SrcMiscData%dYdx)) then
      LB(1:2) = lbound(SrcMiscData%dYdx, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dYdx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dYdx)) then
         allocate(DstMiscData%dYdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dYdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dYdx = SrcMiscData%dYdx
   end if
   if (allocated(SrcMiscData%dYdu)) then
      LB(1:2) = lbound(SrcMiscData%dYdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dYdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dYdu)) then
         allocate(DstMiscData%dYdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dYdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dYdu = SrcMiscData%dYdu
   end if
   if (allocated(SrcMiscData%dXdx)) then
      LB(1:2) = lbound(SrcMiscData%dXdx, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dXdx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dXdx)) then
         allocate(DstMiscData%dXdx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dXdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dXdx = SrcMiscData%dXdx
   end if
   if (allocated(SrcMiscData%dXdu)) then
      LB(1:2) = lbound(SrcMiscData%dXdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dXdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dXdu)) then
         allocate(DstMiscData%dXdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dXdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dXdu = SrcMiscData%dXdu
   end if
   if (allocated(SrcMiscData%dUdu)) then
      LB(1:2) = lbound(SrcMiscData%dUdu, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdu, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdu)) then
         allocate(DstMiscData%dUdu(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdu.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdu = SrcMiscData%dUdu
   end if
   if (allocated(SrcMiscData%dUdy)) then
      LB(1:2) = lbound(SrcMiscData%dUdy, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdy, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdy)) then
         allocate(DstMiscData%dUdy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdy = SrcMiscData%dUdy
   end if
   if (allocated(SrcMiscData%dUdyHat)) then
      LB(1:2) = lbound(SrcMiscData%dUdyHat, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dUdyHat, kind=B8Ki)
      if (.not. allocated(DstMiscData%dUdyHat)) then
         allocate(DstMiscData%dUdyHat(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dUdyHat.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dUdyHat = SrcMiscData%dUdyHat
   end if
   if (allocated(SrcMiscData%XB)) then
      LB(1:2) = lbound(SrcMiscData%XB, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%XB, kind=B8Ki)
      if (.not. allocated(DstMiscData%XB)) then
         allocate(DstMiscData%XB(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%XB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%XB = SrcMiscData%XB
   end if
   if (allocated(SrcMiscData%G)) then
      LB(1:2) = lbound(SrcMiscData%G, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%G, kind=B8Ki)
      if (.not. allocated(DstMiscData%G)) then
         allocate(DstMiscData%G(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%G.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%G = SrcMiscData%G
   end if
   if (allocated(SrcMiscData%Jac)) then
      LB(1:2) = lbound(SrcMiscData%Jac, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%Jac, kind=B8Ki)
      if (.not. allocated(DstMiscData%Jac)) then
         allocate(DstMiscData%Jac(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Jac.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%Jac = SrcMiscData%Jac
   end if
   if (allocated(SrcMiscData%IPIV)) then
      LB(1:1) = lbound(SrcMiscData%IPIV, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%IPIV, kind=B8Ki)
      if (.not. allocated(DstMiscData%IPIV)) then
         allocate(DstMiscData%IPIV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%IPIV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%IPIV = SrcMiscData%IPIV
   end if
   DstMiscData%IterTotal = SrcMiscData%IterTotal
   DstMiscData%IterUntilUJac = SrcMiscData%IterUntilUJac
   DstMiscData%StepsUntilUJac = SrcMiscData%StepsUntilUJac
   if (allocated(SrcMiscData%dq)) then
      LB(1:2) = lbound(SrcMiscData%dq, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%dq, kind=B8Ki)
      if (.not. allocated(DstMiscData%dq)) then
         allocate(DstMiscData%dq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dq = SrcMiscData%dq
   end if
   if (allocated(SrcMiscData%dx)) then
      LB(1:1) = lbound(SrcMiscData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%dx, kind=B8Ki)
      if (.not. allocated(DstMiscData%dx)) then
         allocate(DstMiscData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%dx = SrcMiscData%dx
   end if
   if (allocated(SrcMiscData%du)) then
      LB(1:1) = lbound(SrcMiscData%du, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%du, kind=B8Ki)
      if (.not. allocated(DstMiscData%du)) then
         allocate(DstMiscData%du(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%du.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%du = SrcMiscData%du
   end if
   if (allocated(SrcMiscData%UDiff)) then
      LB(1:1) = lbound(SrcMiscData%UDiff, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%UDiff, kind=B8Ki)
      if (.not. allocated(DstMiscData%UDiff)) then
         allocate(DstMiscData%UDiff(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UDiff.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%UDiff = SrcMiscData%UDiff
   end if
   DstMiscData%ConvWarn = SrcMiscData%ConvWarn
end subroutine

subroutine Glue_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%ModData)) then
      LB(1:1) = lbound(MiscData%ModData, kind=B8Ki)
      UB(1:1) = ubound(MiscData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyModDataType(MiscData%ModData(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%ModData)
   end if
   if (allocated(MiscData%Mappings)) then
      LB(1:1) = lbound(MiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(MiscData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyMappingType(MiscData%Mappings(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%Mappings)
   end if
   if (allocated(MiscData%q)) then
      deallocate(MiscData%q)
   end if
   if (allocated(MiscData%qn)) then
      deallocate(MiscData%qn)
   end if
   if (allocated(MiscData%x)) then
      deallocate(MiscData%x)
   end if
   if (allocated(MiscData%xn)) then
      deallocate(MiscData%xn)
   end if
   if (allocated(MiscData%dxdt)) then
      deallocate(MiscData%dxdt)
   end if
   if (allocated(MiscData%u)) then
      deallocate(MiscData%u)
   end if
   if (allocated(MiscData%un)) then
      deallocate(MiscData%un)
   end if
   if (allocated(MiscData%u_tmp)) then
      deallocate(MiscData%u_tmp)
   end if
   if (allocated(MiscData%y)) then
      deallocate(MiscData%y)
   end if
   if (allocated(MiscData%dYdx)) then
      deallocate(MiscData%dYdx)
   end if
   if (allocated(MiscData%dYdu)) then
      deallocate(MiscData%dYdu)
   end if
   if (allocated(MiscData%dXdx)) then
      deallocate(MiscData%dXdx)
   end if
   if (allocated(MiscData%dXdu)) then
      deallocate(MiscData%dXdu)
   end if
   if (allocated(MiscData%dUdu)) then
      deallocate(MiscData%dUdu)
   end if
   if (allocated(MiscData%dUdy)) then
      deallocate(MiscData%dUdy)
   end if
   if (allocated(MiscData%dUdyHat)) then
      deallocate(MiscData%dUdyHat)
   end if
   if (allocated(MiscData%XB)) then
      deallocate(MiscData%XB)
   end if
   if (allocated(MiscData%G)) then
      deallocate(MiscData%G)
   end if
   if (allocated(MiscData%Jac)) then
      deallocate(MiscData%Jac)
   end if
   if (allocated(MiscData%IPIV)) then
      deallocate(MiscData%IPIV)
   end if
   if (allocated(MiscData%dq)) then
      deallocate(MiscData%dq)
   end if
   if (allocated(MiscData%dx)) then
      deallocate(MiscData%dx)
   end if
   if (allocated(MiscData%du)) then
      deallocate(MiscData%du)
   end if
   if (allocated(MiscData%UDiff)) then
      deallocate(MiscData%UDiff)
   end if
end subroutine

subroutine Glue_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%ModData))
   if (allocated(InData%ModData)) then
      call RegPackBounds(RF, 1, lbound(InData%ModData, kind=B8Ki), ubound(InData%ModData, kind=B8Ki))
      LB(1:1) = lbound(InData%ModData, kind=B8Ki)
      UB(1:1) = ubound(InData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackModDataType(RF, InData%ModData(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Mappings))
   if (allocated(InData%Mappings)) then
      call RegPackBounds(RF, 1, lbound(InData%Mappings, kind=B8Ki), ubound(InData%Mappings, kind=B8Ki))
      LB(1:1) = lbound(InData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(InData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackMappingType(RF, InData%Mappings(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%q)
   call RegPackAlloc(RF, InData%qn)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%xn)
   call RegPackAlloc(RF, InData%dxdt)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%un)
   call RegPackAlloc(RF, InData%u_tmp)
   call RegPackAlloc(RF, InData%y)
   call RegPackAlloc(RF, InData%dYdx)
   call RegPackAlloc(RF, InData%dYdu)
   call RegPackAlloc(RF, InData%dXdx)
   call RegPackAlloc(RF, InData%dXdu)
   call RegPackAlloc(RF, InData%dUdu)
   call RegPackAlloc(RF, InData%dUdy)
   call RegPackAlloc(RF, InData%dUdyHat)
   call RegPackAlloc(RF, InData%XB)
   call RegPackAlloc(RF, InData%G)
   call RegPackAlloc(RF, InData%Jac)
   call RegPackAlloc(RF, InData%IPIV)
   call RegPack(RF, InData%IterTotal)
   call RegPack(RF, InData%IterUntilUJac)
   call RegPack(RF, InData%StepsUntilUJac)
   call RegPackAlloc(RF, InData%dq)
   call RegPackAlloc(RF, InData%dx)
   call RegPackAlloc(RF, InData%du)
   call RegPackAlloc(RF, InData%UDiff)
   call RegPack(RF, InData%ConvWarn)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%ModData)) deallocate(OutData%ModData)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%ModData(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ModData.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackModDataType(RF, OutData%ModData(i1)) ! ModData 
      end do
   end if
   if (allocated(OutData%Mappings)) deallocate(OutData%Mappings)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Mappings(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mappings.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackMappingType(RF, OutData%Mappings(i1)) ! Mappings 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%q); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%qn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dxdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%un); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u_tmp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dYdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dXdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdy); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dUdyHat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%XB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%G); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%IPIV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IterTotal); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IterUntilUJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%StepsUntilUJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%du); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%UDiff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvWarn); if (RegCheckErr(RF, RoutineName)) return
end subroutine
END MODULE Glue_Types
!ENDOFREGISTRYGENERATEDFILE
