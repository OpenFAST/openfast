!STARTOFREGISTRYGENERATEDFILE 'Glue_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Glue_Types
!.................................................................................................................................
! This file is part of Glue.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Glue. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Glue_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_LoadMesh                     = 1      ! Load mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_MotionMesh                   = 2      ! Motion mesh mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Variable                     = 3      ! Individual variable mapping type [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Map_Custom                       = 4      ! Custom mapping not used for linearization [-]
! =========  VarMapType  =======
  TYPE, PUBLIC :: VarMapType
    INTEGER(IntKi)  :: iMapping = 0      !< Mapping index [-]
    INTEGER(IntKi)  :: iModSrc = 0      !< Source module index in module array [-]
    INTEGER(IntKi)  :: iModDst = 0      !< Destination module index in module array [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: iVarSrc = 0      !< Source variable indices (Vars%y) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: iVarSrcDisp = 0      !< Source variable indices (Vars%u) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: iVarDst = 0      !< Destination variable indices (Vars%u) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: iVarDstDisp = 0      !< Destination variable indices (Vars%y) [-]
  END TYPE VarMapType
! =======================
! =========  ModGlueType  =======
  TYPE, PUBLIC :: ModGlueType
    character(ChanLen)  :: Name      !< Glue name [-]
    TYPE(ModDataType) , DIMENSION(:), ALLOCATABLE  :: ModData      !< Array of module info [-]
    TYPE(ModVarsType)  :: Vars      !< Combined module variables [-]
    TYPE(ModLinType)  :: Lin      !< Glue linearization data [-]
    TYPE(VarMapType) , DIMENSION(:), ALLOCATABLE  :: VarMaps      !< Var mapping [-]
  END TYPE ModGlueType
! =======================
! =========  MappingType  =======
  TYPE, PUBLIC :: MappingType
    character(128)  :: Desc      !< Description of mapping (used to lookup non-mesh maps) [-]
    INTEGER(IntKi)  :: iModSrc = 0      !< Source module index in ModData array [-]
    INTEGER(IntKi)  :: iModDst = 0      !< Destination module index in ModData array [-]
    INTEGER(IntKi)  :: SrcModID = 0      !< Source module ID [-]
    INTEGER(IntKi)  :: DstModID = 0      !< Destination module ID [-]
    INTEGER(IntKi)  :: SrcIns = 0      !< Source module Instance [-]
    INTEGER(IntKi)  :: DstIns = 0      !< Destination module Instance [-]
    TYPE(DatLoc)  :: SrcDL      !< Source mesh locator (number and indices) [-]
    TYPE(DatLoc)  :: DstDL      !< Destination mesh locator (number and indices) [-]
    TYPE(DatLoc)  :: SrcDispDL      !< Source displacement mesh locator (number and indices) [-]
    TYPE(DatLoc)  :: DstDispDL      !< Destination displacement mesh locator (number and indices) [-]
    INTEGER(IntKi)  :: MapType = 0      !< Integer denoting mapping type (1=Load Mesh, 2=Motion Mesh, 3=Variable, 4=Custom) [-]
    INTEGER(IntKi)  :: XfrType = 0      !< Integer denoting transfer type (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    INTEGER(IntKi)  :: XfrTypeAux = 0      !< Integer denoting transfer type to auxiliary mesh (1=P-to-P, 2=L-to-P, 3=P-to-L, 4=L-to-L) [-]
    LOGICAL  :: Ready = .false.      !< Flag indicating source data is ready to be transferred [-]
    LOGICAL  :: DstUsesSibling = .false.      !< Flag indicating the destination displacement mesh is a sibling of the source destination load mesh [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: TmpMatrix      !< Temporary matrix for performing transfer for destination load meshes without sibling motion meshes [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: VarData      !< Data array for variable mapping [-]
    TYPE(ModVarType)  :: SrcVar      !< Source variable for variable mapping [-]
    TYPE(ModVarType)  :: DstVar      !< Destination variable for variable mapping [-]
    TYPE(MeshMapType)  :: MeshMap      !< Mesh mapping from Source variable to Destination variable [-]
    TYPE(MeshMapType)  :: MeshMapAux      !< Auxiliary mesh mapping for destination load meshes without sibling motion mesh [-]
    TYPE(MeshType)  :: TmpLoadMesh      !< Temporary load mesh for intermediate transfers [-]
    TYPE(MeshType)  :: TmpMotionMesh      !< Temporary motion mesh for intermediate transfers [-]
  END TYPE MappingType
! =======================
! =========  Glue_LinParam  =======
  TYPE, PUBLIC :: Glue_LinParam
    INTEGER(IntKi)  :: NumTimes = 0_IntKi      !< Number of times to linearize [-]
    INTEGER(IntKi)  :: InterpOrder = 0_IntKi      !< Interpolation order [-]
    LOGICAL  :: SaveOPs = .false.      !< flag to save operating points during linearization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iMod      !< ModData index order for linearization [-]
  END TYPE Glue_LinParam
! =======================
! =========  Glue_TCParam  =======
  TYPE, PUBLIC :: Glue_TCParam
    REAL(R8Ki)  :: h = 0.0_R8Ki      !< solution time step [-]
    REAL(R8Ki)  :: ConvTol = 0.0_R8Ki      !< Solution convergence tolerance [-]
    INTEGER(IntKi)  :: NumCrctn = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: MaxConvIter = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: NIter_UJac = 0_IntKi      !< Number of solution iterations between updating the Jacobian [-]
    INTEGER(IntKi)  :: NStep_UJac = 0_IntKi      !< Number of global time steps between updating the Jacobian [-]
    REAL(R8Ki)  :: Scale_UJac = 0.0_R8Ki      !<  [-]
    REAL(R8Ki)  :: RhoInf = 0.0_R8Ki      !< Rho infinity used for calculating Generalized-alpha coefficients [-]
    REAL(R8Ki)  :: AlphaM = 0.0_R8Ki      !< Generalized-alpha alpha_m coefficient [-]
    REAL(R8Ki)  :: AlphaF = 0.0_R8Ki      !< Generalized-alpha alpha_f coefficient [-]
    REAL(R8Ki)  :: Beta = 0.0_R8Ki      !< Generalized-alpha beta coefficient [-]
    REAL(R8Ki)  :: Gamma = 0.0_R8Ki      !< Generalized-alpha gamma coefficient [-]
    REAL(R8Ki)  :: BetaPrime = 0.0_R8Ki      !< Generalized-alpha beta prime [-]
    REAL(R8Ki)  :: GammaPrime = 0.0_R8Ki      !< Generalized-alpha gamma prime [-]
    INTEGER(IntKi)  :: NumJ = 0_IntKi      !< Number of values in Jacobian [-]
    INTEGER(IntKi)  :: NumQ = 0_IntKi      !< Number of states in Jacobian [-]
    INTEGER(IntKi)  :: NumU = 0_IntKi      !< Number of total inputs in Jacobian [-]
    INTEGER(IntKi)  :: NumUT = 0_IntKi      !< Number of TC inputs in Jacobian [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iX2 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iUT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iU1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iUL = 0_IntKi      !< Input load indices [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iyT = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iy1 = 0_IntKi      !<  [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJX = 0_IntKi      !< Indices of Jacobian q variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJU = 0_IntKi      !< Indices of Jacobian input variables [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJUT = 0_IntKi      !< Indices of Jacobian input variables from tight coupling [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: iJL = 0_IntKi      !< Indices of Jacobian load variables [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModInit      !< ModData index order for step 0 initialization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModTC      !< ModData index order for tight coupling modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt1      !< ModData index order for option 1 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOpt2      !< ModData index order for option 2 modules [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModPost      !< ModData index order for post option 1 modules [-]
  END TYPE Glue_TCParam
! =======================
! =========  Glue_ParameterType  =======
  TYPE, PUBLIC :: Glue_ParameterType
    TYPE(Glue_LinParam)  :: Lin      !< Linearization parameters [-]
    TYPE(Glue_TCParam)  :: TC      !< Tight Coupling solver parameters [-]
  END TYPE Glue_ParameterType
! =======================
! =========  Glue_LinSave  =======
  TYPE, PUBLIC :: Glue_LinSave
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: Times      !< linearization times [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: u      !< linearization operating point input [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: x      !< linearization operating point continuous state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< linearization operating point discrete state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: z      !< linearization operating point constraint state [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< linearization operating point other state [-]
  END TYPE Glue_LinSave
! =======================
! =========  Glue_OutputFileType  =======
  TYPE, PUBLIC :: Glue_OutputFileType
    TYPE(Glue_LinSave)  :: Lin      !< Operating point data for linearization [-]
  END TYPE Glue_OutputFileType
! =======================
! =========  Glue_CalcSteady  =======
  TYPE, PUBLIC :: Glue_CalcSteady
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: AzimuthTarget      !< target azimuth positions where outputs are calculated [-]
    REAL(R8Ki)  :: AzimuthDelta = 0.0_R8Ki      !<  [-]
    LOGICAL  :: IsConverged = .false.      !< Steady State calculation is converged [-]
    LOGICAL  :: FoundSteady = .false.      !<  [-]
    LOGICAL  :: ForceLin = .false.      !<  [-]
    INTEGER(IntKi)  :: NumRotations = 0_IntKi      !< Number of rotor rotations [-]
    INTEGER(IntKi)  :: NumOutputs = 0_IntKi      !< Number of output values (ignoring write outputs) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: psi_buffer      !< azimuth buffer for interpolation [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: y_buffer      !< output buffer for interpolation [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: y_azimuth      !< output values at target azimuths [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_interp      !< output values interpolated to target azimuth [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_diff      !< difference between outputs from current and previous rotation [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: y_ref      !< reference output values for error calculation [-]
  END TYPE Glue_CalcSteady
! =======================
! =========  AeroMapCase  =======
  TYPE, PUBLIC :: AeroMapCase
    REAL(ReKi)  :: RotSpeed = 0.0_ReKi      !< Rotor speed for this case of the steady-state solve [>0] [rad/s]
    REAL(ReKi)  :: TSR = 0.0_ReKi      !< TSR for this case of the steady-state solve [>0] [-]
    REAL(ReKi)  :: WindSpeed = 0.0_ReKi      !< Windspeed for this case of the steady-state solve [>0] [m/s]
    REAL(ReKi)  :: Pitch = 0.0_ReKi      !< Pitch angle for this case of the steady-state solve [rad]
  END TYPE AeroMapCase
! =======================
! =========  Glue_AeroMap  =======
  TYPE, PUBLIC :: Glue_AeroMap
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: iModOrder      !< Module indices in global ModDataAry [-]
    TYPE(ModGlueType)  :: Mod      !< Module combining all active modules [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac11      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac12      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac21      !< Components of Jacobian matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac22      !< Components of Jacobian matrix [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: JacPivot      !< Jacobian matrix pivot array [-]
    REAL(R8Ki)  :: JacScale = 0.0_R8Ki      !< Jacobian scaling factor for loads [-]
    REAL(R8Ki)  :: SolveTolerance = 0.0_R8Ki      !< Allowable solution tolerance [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: HubOrientation      !< Hub orientation matrix for each blade [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u1      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: u2      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: Residual      !<  [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: SolveDelta      !<  [-]
    TYPE(AeroMapCase) , DIMENSION(:), ALLOCATABLE  :: Cases      !< cases to run for aero mapping [-]
    INTEGER(IntKi)  :: LinFileNum = 1      !< Linearization file number [-]
  END TYPE Glue_AeroMap
! =======================
! =========  TC_State  =======
  TYPE, PUBLIC :: TC_State
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: q_prev      !< Generalized alpha previous step displacement [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !< Generalized alpha change in displacement [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: q      !< Generalized alpha predicted displacement [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: v      !< Generalized alpha velocities [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: vd      !< Generalized alpha acceleration [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: a      !< Generalized alpha algorithmic acceleration [-]
  END TYPE TC_State
! =======================
! =========  Glue_TCMisc  =======
  TYPE, PUBLIC :: Glue_TCMisc
    TYPE(ModGlueType)  :: Mod      !< Glue module combining tight coupling modules [-]
    TYPE(TC_State)  :: StateCurr      !< Tight Coupling current state [-]
    TYPE(TC_State)  :: StatePred      !< Tight Coupling predicted state [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: UCalc      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: XB      !<  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IPIV      !<  [-]
    INTEGER(IntKi)  :: IterTotal = 0      !<  [-]
    INTEGER(IntKi)  :: UJacIterRemain = 0      !< Number of convergence iterations until Jacobian update [-]
    INTEGER(IntKi)  :: UJacStepsRemain = 0      !< Number of time steps until Jacobian update [-]
    LOGICAL  :: ConvWarn = .false.      !< Flag to warn about convergence failure [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: XB_IO      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: Jac_IO      !<  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J11      !< Jacobian upper left quadrant [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J12      !< Jacobian upper right quadrant [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J21      !< Jacobian lower left quadrant [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: J22      !< Jacobian lower right quadrant [-]
  END TYPE Glue_TCMisc
! =======================
! =========  Glue_LinMisc  =======
  TYPE, PUBLIC :: Glue_LinMisc
    INTEGER(IntKi)  :: TimeIndex = 0_IntKi      !<  [-]
    INTEGER(IntKi)  :: AzimuthIndex = 0_IntKi      !<  [-]
    LOGICAL  :: IsConverged = .false.      !<  [-]
  END TYPE Glue_LinMisc
! =======================
! =========  Glue_MiscVarType  =======
  TYPE, PUBLIC :: Glue_MiscVarType
    TYPE(ModDataType) , DIMENSION(:), ALLOCATABLE  :: ModData      !< Module variable and value data [-]
    TYPE(MappingType) , DIMENSION(:), ALLOCATABLE  :: Mappings      !< Module mapping [-]
    TYPE(ModGlueType)  :: ModGlue      !< Glue code module [-]
    TYPE(Glue_LinMisc)  :: Lin      !< Linearization misc vars [-]
    TYPE(Glue_CalcSteady)  :: CS      !< CalcSteady calculation data [-]
    TYPE(Glue_AeroMap)  :: AM      !< AeroMap data [-]
    TYPE(Glue_TCMisc)  :: TC      !< Tight Coupling Miscellaneous data [-]
  END TYPE Glue_MiscVarType
! =======================

contains

subroutine Glue_CopyVarMapType(SrcVarMapTypeData, DstVarMapTypeData, CtrlCode, ErrStat, ErrMsg)
   type(VarMapType), intent(in) :: SrcVarMapTypeData
   type(VarMapType), intent(inout) :: DstVarMapTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyVarMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVarMapTypeData%iMapping = SrcVarMapTypeData%iMapping
   DstVarMapTypeData%iModSrc = SrcVarMapTypeData%iModSrc
   DstVarMapTypeData%iModDst = SrcVarMapTypeData%iModDst
   DstVarMapTypeData%iVarSrc = SrcVarMapTypeData%iVarSrc
   DstVarMapTypeData%iVarSrcDisp = SrcVarMapTypeData%iVarSrcDisp
   DstVarMapTypeData%iVarDst = SrcVarMapTypeData%iVarDst
   DstVarMapTypeData%iVarDstDisp = SrcVarMapTypeData%iVarDstDisp
end subroutine

subroutine Glue_DestroyVarMapType(VarMapTypeData, ErrStat, ErrMsg)
   type(VarMapType), intent(inout) :: VarMapTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyVarMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackVarMapType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VarMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackVarMapType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%iMapping)
   call RegPack(RF, InData%iModSrc)
   call RegPack(RF, InData%iModDst)
   call RegPack(RF, InData%iVarSrc)
   call RegPack(RF, InData%iVarSrcDisp)
   call RegPack(RF, InData%iVarDst)
   call RegPack(RF, InData%iVarDstDisp)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackVarMapType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VarMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackVarMapType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%iMapping); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarSrcDisp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iVarDstDisp); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyModGlueType(SrcModGlueTypeData, DstModGlueTypeData, CtrlCode, ErrStat, ErrMsg)
   type(ModGlueType), intent(in) :: SrcModGlueTypeData
   type(ModGlueType), intent(inout) :: DstModGlueTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyModGlueType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstModGlueTypeData%Name = SrcModGlueTypeData%Name
   if (allocated(SrcModGlueTypeData%ModData)) then
      LB(1:1) = lbound(SrcModGlueTypeData%ModData, kind=B8Ki)
      UB(1:1) = ubound(SrcModGlueTypeData%ModData, kind=B8Ki)
      if (.not. allocated(DstModGlueTypeData%ModData)) then
         allocate(DstModGlueTypeData%ModData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModGlueTypeData%ModData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModDataType(SrcModGlueTypeData%ModData(i1), DstModGlueTypeData%ModData(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call NWTC_Library_CopyModVarsType(SrcModGlueTypeData%Vars, DstModGlueTypeData%Vars, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyModLinType(SrcModGlueTypeData%Lin, DstModGlueTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcModGlueTypeData%VarMaps)) then
      LB(1:1) = lbound(SrcModGlueTypeData%VarMaps, kind=B8Ki)
      UB(1:1) = ubound(SrcModGlueTypeData%VarMaps, kind=B8Ki)
      if (.not. allocated(DstModGlueTypeData%VarMaps)) then
         allocate(DstModGlueTypeData%VarMaps(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstModGlueTypeData%VarMaps.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyVarMapType(SrcModGlueTypeData%VarMaps(i1), DstModGlueTypeData%VarMaps(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine Glue_DestroyModGlueType(ModGlueTypeData, ErrStat, ErrMsg)
   type(ModGlueType), intent(inout) :: ModGlueTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyModGlueType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ModGlueTypeData%ModData)) then
      LB(1:1) = lbound(ModGlueTypeData%ModData, kind=B8Ki)
      UB(1:1) = ubound(ModGlueTypeData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModDataType(ModGlueTypeData%ModData(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModGlueTypeData%ModData)
   end if
   call NWTC_Library_DestroyModVarsType(ModGlueTypeData%Vars, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyModLinType(ModGlueTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ModGlueTypeData%VarMaps)) then
      LB(1:1) = lbound(ModGlueTypeData%VarMaps, kind=B8Ki)
      UB(1:1) = ubound(ModGlueTypeData%VarMaps, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyVarMapType(ModGlueTypeData%VarMaps(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ModGlueTypeData%VarMaps)
   end if
end subroutine

subroutine Glue_PackModGlueType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ModGlueType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackModGlueType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, allocated(InData%ModData))
   if (allocated(InData%ModData)) then
      call RegPackBounds(RF, 1, lbound(InData%ModData, kind=B8Ki), ubound(InData%ModData, kind=B8Ki))
      LB(1:1) = lbound(InData%ModData, kind=B8Ki)
      UB(1:1) = ubound(InData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModDataType(RF, InData%ModData(i1)) 
      end do
   end if
   call NWTC_Library_PackModVarsType(RF, InData%Vars) 
   call NWTC_Library_PackModLinType(RF, InData%Lin) 
   call RegPack(RF, allocated(InData%VarMaps))
   if (allocated(InData%VarMaps)) then
      call RegPackBounds(RF, 1, lbound(InData%VarMaps, kind=B8Ki), ubound(InData%VarMaps, kind=B8Ki))
      LB(1:1) = lbound(InData%VarMaps, kind=B8Ki)
      UB(1:1) = ubound(InData%VarMaps, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackVarMapType(RF, InData%VarMaps(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackModGlueType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ModGlueType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackModGlueType'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%ModData)) deallocate(OutData%ModData)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%ModData(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ModData.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModDataType(RF, OutData%ModData(i1)) ! ModData 
      end do
   end if
   call NWTC_Library_UnpackModVarsType(RF, OutData%Vars) ! Vars 
   call NWTC_Library_UnpackModLinType(RF, OutData%Lin) ! Lin 
   if (allocated(OutData%VarMaps)) deallocate(OutData%VarMaps)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VarMaps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VarMaps.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackVarMapType(RF, OutData%VarMaps(i1)) ! VarMaps 
      end do
   end if
end subroutine

subroutine Glue_CopyMappingType(SrcMappingTypeData, DstMappingTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: SrcMappingTypeData
   type(MappingType), intent(inout) :: DstMappingTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMappingTypeData%Desc = SrcMappingTypeData%Desc
   DstMappingTypeData%iModSrc = SrcMappingTypeData%iModSrc
   DstMappingTypeData%iModDst = SrcMappingTypeData%iModDst
   DstMappingTypeData%SrcModID = SrcMappingTypeData%SrcModID
   DstMappingTypeData%DstModID = SrcMappingTypeData%DstModID
   DstMappingTypeData%SrcIns = SrcMappingTypeData%SrcIns
   DstMappingTypeData%DstIns = SrcMappingTypeData%DstIns
   call NWTC_Library_CopyDatLoc(SrcMappingTypeData%SrcDL, DstMappingTypeData%SrcDL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyDatLoc(SrcMappingTypeData%DstDL, DstMappingTypeData%DstDL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyDatLoc(SrcMappingTypeData%SrcDispDL, DstMappingTypeData%SrcDispDL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyDatLoc(SrcMappingTypeData%DstDispDL, DstMappingTypeData%DstDispDL, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMappingTypeData%MapType = SrcMappingTypeData%MapType
   DstMappingTypeData%XfrType = SrcMappingTypeData%XfrType
   DstMappingTypeData%XfrTypeAux = SrcMappingTypeData%XfrTypeAux
   DstMappingTypeData%Ready = SrcMappingTypeData%Ready
   DstMappingTypeData%DstUsesSibling = SrcMappingTypeData%DstUsesSibling
   if (allocated(SrcMappingTypeData%TmpMatrix)) then
      LB(1:2) = lbound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      UB(1:2) = ubound(SrcMappingTypeData%TmpMatrix, kind=B8Ki)
      if (.not. allocated(DstMappingTypeData%TmpMatrix)) then
         allocate(DstMappingTypeData%TmpMatrix(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMappingTypeData%TmpMatrix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMappingTypeData%TmpMatrix = SrcMappingTypeData%TmpMatrix
   end if
   if (allocated(SrcMappingTypeData%VarData)) then
      LB(1:1) = lbound(SrcMappingTypeData%VarData, kind=B8Ki)
      UB(1:1) = ubound(SrcMappingTypeData%VarData, kind=B8Ki)
      if (.not. allocated(DstMappingTypeData%VarData)) then
         allocate(DstMappingTypeData%VarData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMappingTypeData%VarData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMappingTypeData%VarData = SrcMappingTypeData%VarData
   end if
   call NWTC_Library_CopyModVarType(SrcMappingTypeData%SrcVar, DstMappingTypeData%SrcVar, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyModVarType(SrcMappingTypeData%DstVar, DstMappingTypeData%DstVar, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMap, DstMappingTypeData%MeshMap, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call NWTC_Library_CopyMeshMapType(SrcMappingTypeData%MeshMapAux, DstMappingTypeData%MeshMapAux, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMappingTypeData%TmpLoadMesh, DstMappingTypeData%TmpLoadMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MeshCopy(SrcMappingTypeData%TmpMotionMesh, DstMappingTypeData%TmpMotionMesh, CtrlCode, ErrStat2, ErrMsg2 )
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyMappingType(MappingTypeData, ErrStat, ErrMsg)
   type(MappingType), intent(inout) :: MappingTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMappingType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyDatLoc(MappingTypeData%SrcDL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyDatLoc(MappingTypeData%DstDL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyDatLoc(MappingTypeData%SrcDispDL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyDatLoc(MappingTypeData%DstDispDL, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MappingTypeData%TmpMatrix)) then
      deallocate(MappingTypeData%TmpMatrix)
   end if
   if (allocated(MappingTypeData%VarData)) then
      deallocate(MappingTypeData%VarData)
   end if
   call NWTC_Library_DestroyModVarType(MappingTypeData%SrcVar, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyModVarType(MappingTypeData%DstVar, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMap, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call NWTC_Library_DestroyMeshMapType(MappingTypeData%MeshMapAux, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpLoadMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MeshDestroy( MappingTypeData%TmpMotionMesh, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackMappingType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MappingType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMappingType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Desc)
   call RegPack(RF, InData%iModSrc)
   call RegPack(RF, InData%iModDst)
   call RegPack(RF, InData%SrcModID)
   call RegPack(RF, InData%DstModID)
   call RegPack(RF, InData%SrcIns)
   call RegPack(RF, InData%DstIns)
   call NWTC_Library_PackDatLoc(RF, InData%SrcDL) 
   call NWTC_Library_PackDatLoc(RF, InData%DstDL) 
   call NWTC_Library_PackDatLoc(RF, InData%SrcDispDL) 
   call NWTC_Library_PackDatLoc(RF, InData%DstDispDL) 
   call RegPack(RF, InData%MapType)
   call RegPack(RF, InData%XfrType)
   call RegPack(RF, InData%XfrTypeAux)
   call RegPack(RF, InData%Ready)
   call RegPack(RF, InData%DstUsesSibling)
   call RegPackAlloc(RF, InData%TmpMatrix)
   call RegPackAlloc(RF, InData%VarData)
   call NWTC_Library_PackModVarType(RF, InData%SrcVar) 
   call NWTC_Library_PackModVarType(RF, InData%DstVar) 
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMap) 
   call NWTC_Library_PackMeshMapType(RF, InData%MeshMapAux) 
   call MeshPack(RF, InData%TmpLoadMesh) 
   call MeshPack(RF, InData%TmpMotionMesh) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMappingType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MappingType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMappingType'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Desc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModSrc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iModDst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstModID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SrcIns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstIns); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackDatLoc(RF, OutData%SrcDL) ! SrcDL 
   call NWTC_Library_UnpackDatLoc(RF, OutData%DstDL) ! DstDL 
   call NWTC_Library_UnpackDatLoc(RF, OutData%SrcDispDL) ! SrcDispDL 
   call NWTC_Library_UnpackDatLoc(RF, OutData%DstDispDL) ! DstDispDL 
   call RegUnpack(RF, OutData%MapType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%XfrTypeAux); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ready); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DstUsesSibling); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TmpMatrix); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%VarData); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackModVarType(RF, OutData%SrcVar) ! SrcVar 
   call NWTC_Library_UnpackModVarType(RF, OutData%DstVar) ! DstVar 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMap) ! MeshMap 
   call NWTC_Library_UnpackMeshMapType(RF, OutData%MeshMapAux) ! MeshMapAux 
   call MeshUnpack(RF, OutData%TmpLoadMesh) ! TmpLoadMesh 
   call MeshUnpack(RF, OutData%TmpMotionMesh) ! TmpMotionMesh 
end subroutine

subroutine Glue_CopyLinParam(SrcLinParamData, DstLinParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinParam), intent(in) :: SrcLinParamData
   type(Glue_LinParam), intent(inout) :: DstLinParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinParamData%NumTimes = SrcLinParamData%NumTimes
   DstLinParamData%InterpOrder = SrcLinParamData%InterpOrder
   DstLinParamData%SaveOPs = SrcLinParamData%SaveOPs
   if (allocated(SrcLinParamData%iMod)) then
      LB(1:1) = lbound(SrcLinParamData%iMod, kind=B8Ki)
      UB(1:1) = ubound(SrcLinParamData%iMod, kind=B8Ki)
      if (.not. allocated(DstLinParamData%iMod)) then
         allocate(DstLinParamData%iMod(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinParamData%iMod.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinParamData%iMod = SrcLinParamData%iMod
   end if
end subroutine

subroutine Glue_DestroyLinParam(LinParamData, ErrStat, ErrMsg)
   type(Glue_LinParam), intent(inout) :: LinParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinParamData%iMod)) then
      deallocate(LinParamData%iMod)
   end if
end subroutine

subroutine Glue_PackLinParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinParam), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumTimes)
   call RegPack(RF, InData%InterpOrder)
   call RegPack(RF, InData%SaveOPs)
   call RegPackAlloc(RF, InData%iMod)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinParam), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinParam'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumTimes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SaveOPs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iMod); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyTCParam(SrcTCParamData, DstTCParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_TCParam), intent(in) :: SrcTCParamData
   type(Glue_TCParam), intent(inout) :: DstTCParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyTCParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTCParamData%h = SrcTCParamData%h
   DstTCParamData%ConvTol = SrcTCParamData%ConvTol
   DstTCParamData%NumCrctn = SrcTCParamData%NumCrctn
   DstTCParamData%MaxConvIter = SrcTCParamData%MaxConvIter
   DstTCParamData%NIter_UJac = SrcTCParamData%NIter_UJac
   DstTCParamData%NStep_UJac = SrcTCParamData%NStep_UJac
   DstTCParamData%Scale_UJac = SrcTCParamData%Scale_UJac
   DstTCParamData%RhoInf = SrcTCParamData%RhoInf
   DstTCParamData%AlphaM = SrcTCParamData%AlphaM
   DstTCParamData%AlphaF = SrcTCParamData%AlphaF
   DstTCParamData%Beta = SrcTCParamData%Beta
   DstTCParamData%Gamma = SrcTCParamData%Gamma
   DstTCParamData%BetaPrime = SrcTCParamData%BetaPrime
   DstTCParamData%GammaPrime = SrcTCParamData%GammaPrime
   DstTCParamData%NumJ = SrcTCParamData%NumJ
   DstTCParamData%NumQ = SrcTCParamData%NumQ
   DstTCParamData%NumU = SrcTCParamData%NumU
   DstTCParamData%NumUT = SrcTCParamData%NumUT
   DstTCParamData%iX1 = SrcTCParamData%iX1
   DstTCParamData%iX2 = SrcTCParamData%iX2
   DstTCParamData%iUT = SrcTCParamData%iUT
   DstTCParamData%iU1 = SrcTCParamData%iU1
   DstTCParamData%iUL = SrcTCParamData%iUL
   DstTCParamData%iyT = SrcTCParamData%iyT
   DstTCParamData%iy1 = SrcTCParamData%iy1
   DstTCParamData%iJX = SrcTCParamData%iJX
   DstTCParamData%iJU = SrcTCParamData%iJU
   DstTCParamData%iJUT = SrcTCParamData%iJUT
   DstTCParamData%iJL = SrcTCParamData%iJL
   if (allocated(SrcTCParamData%iModInit)) then
      LB(1:1) = lbound(SrcTCParamData%iModInit, kind=B8Ki)
      UB(1:1) = ubound(SrcTCParamData%iModInit, kind=B8Ki)
      if (.not. allocated(DstTCParamData%iModInit)) then
         allocate(DstTCParamData%iModInit(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCParamData%iModInit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCParamData%iModInit = SrcTCParamData%iModInit
   end if
   if (allocated(SrcTCParamData%iModTC)) then
      LB(1:1) = lbound(SrcTCParamData%iModTC, kind=B8Ki)
      UB(1:1) = ubound(SrcTCParamData%iModTC, kind=B8Ki)
      if (.not. allocated(DstTCParamData%iModTC)) then
         allocate(DstTCParamData%iModTC(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCParamData%iModTC.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCParamData%iModTC = SrcTCParamData%iModTC
   end if
   if (allocated(SrcTCParamData%iModOpt1)) then
      LB(1:1) = lbound(SrcTCParamData%iModOpt1, kind=B8Ki)
      UB(1:1) = ubound(SrcTCParamData%iModOpt1, kind=B8Ki)
      if (.not. allocated(DstTCParamData%iModOpt1)) then
         allocate(DstTCParamData%iModOpt1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCParamData%iModOpt1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCParamData%iModOpt1 = SrcTCParamData%iModOpt1
   end if
   if (allocated(SrcTCParamData%iModOpt2)) then
      LB(1:1) = lbound(SrcTCParamData%iModOpt2, kind=B8Ki)
      UB(1:1) = ubound(SrcTCParamData%iModOpt2, kind=B8Ki)
      if (.not. allocated(DstTCParamData%iModOpt2)) then
         allocate(DstTCParamData%iModOpt2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCParamData%iModOpt2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCParamData%iModOpt2 = SrcTCParamData%iModOpt2
   end if
   if (allocated(SrcTCParamData%iModPost)) then
      LB(1:1) = lbound(SrcTCParamData%iModPost, kind=B8Ki)
      UB(1:1) = ubound(SrcTCParamData%iModPost, kind=B8Ki)
      if (.not. allocated(DstTCParamData%iModPost)) then
         allocate(DstTCParamData%iModPost(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCParamData%iModPost.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCParamData%iModPost = SrcTCParamData%iModPost
   end if
end subroutine

subroutine Glue_DestroyTCParam(TCParamData, ErrStat, ErrMsg)
   type(Glue_TCParam), intent(inout) :: TCParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyTCParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(TCParamData%iModInit)) then
      deallocate(TCParamData%iModInit)
   end if
   if (allocated(TCParamData%iModTC)) then
      deallocate(TCParamData%iModTC)
   end if
   if (allocated(TCParamData%iModOpt1)) then
      deallocate(TCParamData%iModOpt1)
   end if
   if (allocated(TCParamData%iModOpt2)) then
      deallocate(TCParamData%iModOpt2)
   end if
   if (allocated(TCParamData%iModPost)) then
      deallocate(TCParamData%iModPost)
   end if
end subroutine

subroutine Glue_PackTCParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_TCParam), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackTCParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%h)
   call RegPack(RF, InData%ConvTol)
   call RegPack(RF, InData%NumCrctn)
   call RegPack(RF, InData%MaxConvIter)
   call RegPack(RF, InData%NIter_UJac)
   call RegPack(RF, InData%NStep_UJac)
   call RegPack(RF, InData%Scale_UJac)
   call RegPack(RF, InData%RhoInf)
   call RegPack(RF, InData%AlphaM)
   call RegPack(RF, InData%AlphaF)
   call RegPack(RF, InData%Beta)
   call RegPack(RF, InData%Gamma)
   call RegPack(RF, InData%BetaPrime)
   call RegPack(RF, InData%GammaPrime)
   call RegPack(RF, InData%NumJ)
   call RegPack(RF, InData%NumQ)
   call RegPack(RF, InData%NumU)
   call RegPack(RF, InData%NumUT)
   call RegPack(RF, InData%iX1)
   call RegPack(RF, InData%iX2)
   call RegPack(RF, InData%iUT)
   call RegPack(RF, InData%iU1)
   call RegPack(RF, InData%iUL)
   call RegPack(RF, InData%iyT)
   call RegPack(RF, InData%iy1)
   call RegPack(RF, InData%iJX)
   call RegPack(RF, InData%iJU)
   call RegPack(RF, InData%iJUT)
   call RegPack(RF, InData%iJL)
   call RegPackAlloc(RF, InData%iModInit)
   call RegPackAlloc(RF, InData%iModTC)
   call RegPackAlloc(RF, InData%iModOpt1)
   call RegPackAlloc(RF, InData%iModOpt2)
   call RegPackAlloc(RF, InData%iModPost)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackTCParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_TCParam), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackTCParam'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%h); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvTol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumCrctn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MaxConvIter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NIter_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NStep_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Scale_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RhoInf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AlphaF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Beta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Gamma); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BetaPrime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%GammaPrime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumJ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumQ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iX2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iU1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iUL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iyT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iy1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJU); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJUT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%iJL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModTC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModOpt2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%iModPost); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(in) :: SrcParamData
   type(Glue_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyLinParam(SrcParamData%Lin, DstParamData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyTCParam(SrcParamData%TC, DstParamData%TC, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(Glue_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyLinParam(ParamData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyTCParam(ParamData%TC, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackLinParam(RF, InData%Lin) 
   call Glue_PackTCParam(RF, InData%TC) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackParam'
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackLinParam(RF, OutData%Lin) ! Lin 
   call Glue_UnpackTCParam(RF, OutData%TC) ! TC 
end subroutine

subroutine Glue_CopyLinSave(SrcLinSaveData, DstLinSaveData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(in) :: SrcLinSaveData
   type(Glue_LinSave), intent(inout) :: DstLinSaveData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLinSaveData%Times)) then
      LB(1:1) = lbound(SrcLinSaveData%Times, kind=B8Ki)
      UB(1:1) = ubound(SrcLinSaveData%Times, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%Times)) then
         allocate(DstLinSaveData%Times(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%Times.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%Times = SrcLinSaveData%Times
   end if
   if (allocated(SrcLinSaveData%u)) then
      LB(1:2) = lbound(SrcLinSaveData%u, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%u, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%u)) then
         allocate(DstLinSaveData%u(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%u = SrcLinSaveData%u
   end if
   if (allocated(SrcLinSaveData%x)) then
      LB(1:2) = lbound(SrcLinSaveData%x, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%x, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%x)) then
         allocate(DstLinSaveData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%x = SrcLinSaveData%x
   end if
   if (allocated(SrcLinSaveData%xd)) then
      LB(1:2) = lbound(SrcLinSaveData%xd, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%xd, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%xd)) then
         allocate(DstLinSaveData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%xd = SrcLinSaveData%xd
   end if
   if (allocated(SrcLinSaveData%z)) then
      LB(1:2) = lbound(SrcLinSaveData%z, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%z, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%z)) then
         allocate(DstLinSaveData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%z = SrcLinSaveData%z
   end if
   if (allocated(SrcLinSaveData%OtherSt)) then
      LB(1:2) = lbound(SrcLinSaveData%OtherSt, kind=B8Ki)
      UB(1:2) = ubound(SrcLinSaveData%OtherSt, kind=B8Ki)
      if (.not. allocated(DstLinSaveData%OtherSt)) then
         allocate(DstLinSaveData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLinSaveData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLinSaveData%OtherSt = SrcLinSaveData%OtherSt
   end if
end subroutine

subroutine Glue_DestroyLinSave(LinSaveData, ErrStat, ErrMsg)
   type(Glue_LinSave), intent(inout) :: LinSaveData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinSave'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LinSaveData%Times)) then
      deallocate(LinSaveData%Times)
   end if
   if (allocated(LinSaveData%u)) then
      deallocate(LinSaveData%u)
   end if
   if (allocated(LinSaveData%x)) then
      deallocate(LinSaveData%x)
   end if
   if (allocated(LinSaveData%xd)) then
      deallocate(LinSaveData%xd)
   end if
   if (allocated(LinSaveData%z)) then
      deallocate(LinSaveData%z)
   end if
   if (allocated(LinSaveData%OtherSt)) then
      deallocate(LinSaveData%OtherSt)
   end if
end subroutine

subroutine Glue_PackLinSave(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinSave), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinSave'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Times)
   call RegPackAlloc(RF, InData%u)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%xd)
   call RegPackAlloc(RF, InData%z)
   call RegPackAlloc(RF, InData%OtherSt)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinSave(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinSave), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinSave'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Times); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%xd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%z); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OtherSt); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyOutputFileType(SrcOutputFileTypeData, DstOutputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(in) :: SrcOutputFileTypeData
   type(Glue_OutputFileType), intent(inout) :: DstOutputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyLinSave(SrcOutputFileTypeData%Lin, DstOutputFileTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyOutputFileType(OutputFileTypeData, ErrStat, ErrMsg)
   type(Glue_OutputFileType), intent(inout) :: OutputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyLinSave(OutputFileTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackOutputFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_OutputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackOutputFileType'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackLinSave(RF, InData%Lin) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackOutputFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_OutputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackOutputFileType'
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackLinSave(RF, OutData%Lin) ! Lin 
end subroutine

subroutine Glue_CopyCalcSteady(SrcCalcSteadyData, DstCalcSteadyData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_CalcSteady), intent(in) :: SrcCalcSteadyData
   type(Glue_CalcSteady), intent(inout) :: DstCalcSteadyData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyCalcSteady'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcCalcSteadyData%AzimuthTarget)) then
      LB(1:1) = lbound(SrcCalcSteadyData%AzimuthTarget, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%AzimuthTarget, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%AzimuthTarget)) then
         allocate(DstCalcSteadyData%AzimuthTarget(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%AzimuthTarget.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%AzimuthTarget = SrcCalcSteadyData%AzimuthTarget
   end if
   DstCalcSteadyData%AzimuthDelta = SrcCalcSteadyData%AzimuthDelta
   DstCalcSteadyData%IsConverged = SrcCalcSteadyData%IsConverged
   DstCalcSteadyData%FoundSteady = SrcCalcSteadyData%FoundSteady
   DstCalcSteadyData%ForceLin = SrcCalcSteadyData%ForceLin
   DstCalcSteadyData%NumRotations = SrcCalcSteadyData%NumRotations
   DstCalcSteadyData%NumOutputs = SrcCalcSteadyData%NumOutputs
   if (allocated(SrcCalcSteadyData%psi_buffer)) then
      LB(1:1) = lbound(SrcCalcSteadyData%psi_buffer, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%psi_buffer, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%psi_buffer)) then
         allocate(DstCalcSteadyData%psi_buffer(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%psi_buffer.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%psi_buffer = SrcCalcSteadyData%psi_buffer
   end if
   if (allocated(SrcCalcSteadyData%y_buffer)) then
      LB(1:2) = lbound(SrcCalcSteadyData%y_buffer, kind=B8Ki)
      UB(1:2) = ubound(SrcCalcSteadyData%y_buffer, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_buffer)) then
         allocate(DstCalcSteadyData%y_buffer(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_buffer.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_buffer = SrcCalcSteadyData%y_buffer
   end if
   if (allocated(SrcCalcSteadyData%y_azimuth)) then
      LB(1:2) = lbound(SrcCalcSteadyData%y_azimuth, kind=B8Ki)
      UB(1:2) = ubound(SrcCalcSteadyData%y_azimuth, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_azimuth)) then
         allocate(DstCalcSteadyData%y_azimuth(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_azimuth.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_azimuth = SrcCalcSteadyData%y_azimuth
   end if
   if (allocated(SrcCalcSteadyData%y_interp)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_interp, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_interp, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_interp)) then
         allocate(DstCalcSteadyData%y_interp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_interp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_interp = SrcCalcSteadyData%y_interp
   end if
   if (allocated(SrcCalcSteadyData%y_diff)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_diff, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_diff, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_diff)) then
         allocate(DstCalcSteadyData%y_diff(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_diff.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_diff = SrcCalcSteadyData%y_diff
   end if
   if (allocated(SrcCalcSteadyData%y_ref)) then
      LB(1:1) = lbound(SrcCalcSteadyData%y_ref, kind=B8Ki)
      UB(1:1) = ubound(SrcCalcSteadyData%y_ref, kind=B8Ki)
      if (.not. allocated(DstCalcSteadyData%y_ref)) then
         allocate(DstCalcSteadyData%y_ref(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstCalcSteadyData%y_ref.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstCalcSteadyData%y_ref = SrcCalcSteadyData%y_ref
   end if
end subroutine

subroutine Glue_DestroyCalcSteady(CalcSteadyData, ErrStat, ErrMsg)
   type(Glue_CalcSteady), intent(inout) :: CalcSteadyData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyCalcSteady'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(CalcSteadyData%AzimuthTarget)) then
      deallocate(CalcSteadyData%AzimuthTarget)
   end if
   if (allocated(CalcSteadyData%psi_buffer)) then
      deallocate(CalcSteadyData%psi_buffer)
   end if
   if (allocated(CalcSteadyData%y_buffer)) then
      deallocate(CalcSteadyData%y_buffer)
   end if
   if (allocated(CalcSteadyData%y_azimuth)) then
      deallocate(CalcSteadyData%y_azimuth)
   end if
   if (allocated(CalcSteadyData%y_interp)) then
      deallocate(CalcSteadyData%y_interp)
   end if
   if (allocated(CalcSteadyData%y_diff)) then
      deallocate(CalcSteadyData%y_diff)
   end if
   if (allocated(CalcSteadyData%y_ref)) then
      deallocate(CalcSteadyData%y_ref)
   end if
end subroutine

subroutine Glue_PackCalcSteady(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_CalcSteady), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackCalcSteady'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%AzimuthTarget)
   call RegPack(RF, InData%AzimuthDelta)
   call RegPack(RF, InData%IsConverged)
   call RegPack(RF, InData%FoundSteady)
   call RegPack(RF, InData%ForceLin)
   call RegPack(RF, InData%NumRotations)
   call RegPack(RF, InData%NumOutputs)
   call RegPackAlloc(RF, InData%psi_buffer)
   call RegPackAlloc(RF, InData%y_buffer)
   call RegPackAlloc(RF, InData%y_azimuth)
   call RegPackAlloc(RF, InData%y_interp)
   call RegPackAlloc(RF, InData%y_diff)
   call RegPackAlloc(RF, InData%y_ref)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackCalcSteady(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_CalcSteady), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackCalcSteady'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%AzimuthTarget); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimuthDelta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsConverged); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FoundSteady); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ForceLin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumRotations); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumOutputs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%psi_buffer); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_buffer); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_azimuth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_interp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_diff); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_ref); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyAeroMapCase(SrcAeroMapCaseData, DstAeroMapCaseData, CtrlCode, ErrStat, ErrMsg)
   type(AeroMapCase), intent(in) :: SrcAeroMapCaseData
   type(AeroMapCase), intent(inout) :: DstAeroMapCaseData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyAeroMapCase'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstAeroMapCaseData%RotSpeed = SrcAeroMapCaseData%RotSpeed
   DstAeroMapCaseData%TSR = SrcAeroMapCaseData%TSR
   DstAeroMapCaseData%WindSpeed = SrcAeroMapCaseData%WindSpeed
   DstAeroMapCaseData%Pitch = SrcAeroMapCaseData%Pitch
end subroutine

subroutine Glue_DestroyAeroMapCase(AeroMapCaseData, ErrStat, ErrMsg)
   type(AeroMapCase), intent(inout) :: AeroMapCaseData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyAeroMapCase'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackAeroMapCase(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AeroMapCase), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackAeroMapCase'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%TSR)
   call RegPack(RF, InData%WindSpeed)
   call RegPack(RF, InData%Pitch)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackAeroMapCase(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AeroMapCase), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackAeroMapCase'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TSR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WindSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pitch); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyAeroMap(SrcAeroMapData, DstAeroMapData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_AeroMap), intent(in) :: SrcAeroMapData
   type(Glue_AeroMap), intent(inout) :: DstAeroMapData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyAeroMap'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAeroMapData%iModOrder)) then
      LB(1:1) = lbound(SrcAeroMapData%iModOrder, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%iModOrder, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%iModOrder)) then
         allocate(DstAeroMapData%iModOrder(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%iModOrder.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%iModOrder = SrcAeroMapData%iModOrder
   end if
   call Glue_CopyModGlueType(SrcAeroMapData%Mod, DstAeroMapData%Mod, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcAeroMapData%Jac11)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac11, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac11, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac11)) then
         allocate(DstAeroMapData%Jac11(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac11.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac11 = SrcAeroMapData%Jac11
   end if
   if (allocated(SrcAeroMapData%Jac12)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac12, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac12, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac12)) then
         allocate(DstAeroMapData%Jac12(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac12.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac12 = SrcAeroMapData%Jac12
   end if
   if (allocated(SrcAeroMapData%Jac21)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac21, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac21, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac21)) then
         allocate(DstAeroMapData%Jac21(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac21.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac21 = SrcAeroMapData%Jac21
   end if
   if (allocated(SrcAeroMapData%Jac22)) then
      LB(1:2) = lbound(SrcAeroMapData%Jac22, kind=B8Ki)
      UB(1:2) = ubound(SrcAeroMapData%Jac22, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Jac22)) then
         allocate(DstAeroMapData%Jac22(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Jac22.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Jac22 = SrcAeroMapData%Jac22
   end if
   if (allocated(SrcAeroMapData%JacPivot)) then
      LB(1:1) = lbound(SrcAeroMapData%JacPivot, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%JacPivot, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%JacPivot)) then
         allocate(DstAeroMapData%JacPivot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%JacPivot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%JacPivot = SrcAeroMapData%JacPivot
   end if
   DstAeroMapData%JacScale = SrcAeroMapData%JacScale
   DstAeroMapData%SolveTolerance = SrcAeroMapData%SolveTolerance
   if (allocated(SrcAeroMapData%HubOrientation)) then
      LB(1:3) = lbound(SrcAeroMapData%HubOrientation, kind=B8Ki)
      UB(1:3) = ubound(SrcAeroMapData%HubOrientation, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%HubOrientation)) then
         allocate(DstAeroMapData%HubOrientation(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%HubOrientation.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%HubOrientation = SrcAeroMapData%HubOrientation
   end if
   if (allocated(SrcAeroMapData%u1)) then
      LB(1:1) = lbound(SrcAeroMapData%u1, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%u1, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%u1)) then
         allocate(DstAeroMapData%u1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%u1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%u1 = SrcAeroMapData%u1
   end if
   if (allocated(SrcAeroMapData%u2)) then
      LB(1:1) = lbound(SrcAeroMapData%u2, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%u2, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%u2)) then
         allocate(DstAeroMapData%u2(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%u2.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%u2 = SrcAeroMapData%u2
   end if
   if (allocated(SrcAeroMapData%Residual)) then
      LB(1:1) = lbound(SrcAeroMapData%Residual, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%Residual, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Residual)) then
         allocate(DstAeroMapData%Residual(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Residual.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%Residual = SrcAeroMapData%Residual
   end if
   if (allocated(SrcAeroMapData%SolveDelta)) then
      LB(1:1) = lbound(SrcAeroMapData%SolveDelta, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%SolveDelta, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%SolveDelta)) then
         allocate(DstAeroMapData%SolveDelta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%SolveDelta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroMapData%SolveDelta = SrcAeroMapData%SolveDelta
   end if
   if (allocated(SrcAeroMapData%Cases)) then
      LB(1:1) = lbound(SrcAeroMapData%Cases, kind=B8Ki)
      UB(1:1) = ubound(SrcAeroMapData%Cases, kind=B8Ki)
      if (.not. allocated(DstAeroMapData%Cases)) then
         allocate(DstAeroMapData%Cases(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroMapData%Cases.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyAeroMapCase(SrcAeroMapData%Cases(i1), DstAeroMapData%Cases(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstAeroMapData%LinFileNum = SrcAeroMapData%LinFileNum
end subroutine

subroutine Glue_DestroyAeroMap(AeroMapData, ErrStat, ErrMsg)
   type(Glue_AeroMap), intent(inout) :: AeroMapData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyAeroMap'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AeroMapData%iModOrder)) then
      deallocate(AeroMapData%iModOrder)
   end if
   call Glue_DestroyModGlueType(AeroMapData%Mod, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(AeroMapData%Jac11)) then
      deallocate(AeroMapData%Jac11)
   end if
   if (allocated(AeroMapData%Jac12)) then
      deallocate(AeroMapData%Jac12)
   end if
   if (allocated(AeroMapData%Jac21)) then
      deallocate(AeroMapData%Jac21)
   end if
   if (allocated(AeroMapData%Jac22)) then
      deallocate(AeroMapData%Jac22)
   end if
   if (allocated(AeroMapData%JacPivot)) then
      deallocate(AeroMapData%JacPivot)
   end if
   if (allocated(AeroMapData%HubOrientation)) then
      deallocate(AeroMapData%HubOrientation)
   end if
   if (allocated(AeroMapData%u1)) then
      deallocate(AeroMapData%u1)
   end if
   if (allocated(AeroMapData%u2)) then
      deallocate(AeroMapData%u2)
   end if
   if (allocated(AeroMapData%Residual)) then
      deallocate(AeroMapData%Residual)
   end if
   if (allocated(AeroMapData%SolveDelta)) then
      deallocate(AeroMapData%SolveDelta)
   end if
   if (allocated(AeroMapData%Cases)) then
      LB(1:1) = lbound(AeroMapData%Cases, kind=B8Ki)
      UB(1:1) = ubound(AeroMapData%Cases, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyAeroMapCase(AeroMapData%Cases(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroMapData%Cases)
   end if
end subroutine

subroutine Glue_PackAeroMap(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_AeroMap), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackAeroMap'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%iModOrder)
   call Glue_PackModGlueType(RF, InData%Mod) 
   call RegPackAlloc(RF, InData%Jac11)
   call RegPackAlloc(RF, InData%Jac12)
   call RegPackAlloc(RF, InData%Jac21)
   call RegPackAlloc(RF, InData%Jac22)
   call RegPackAlloc(RF, InData%JacPivot)
   call RegPack(RF, InData%JacScale)
   call RegPack(RF, InData%SolveTolerance)
   call RegPackAlloc(RF, InData%HubOrientation)
   call RegPackAlloc(RF, InData%u1)
   call RegPackAlloc(RF, InData%u2)
   call RegPackAlloc(RF, InData%Residual)
   call RegPackAlloc(RF, InData%SolveDelta)
   call RegPack(RF, allocated(InData%Cases))
   if (allocated(InData%Cases)) then
      call RegPackBounds(RF, 1, lbound(InData%Cases, kind=B8Ki), ubound(InData%Cases, kind=B8Ki))
      LB(1:1) = lbound(InData%Cases, kind=B8Ki)
      UB(1:1) = ubound(InData%Cases, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackAeroMapCase(RF, InData%Cases(i1)) 
      end do
   end if
   call RegPack(RF, InData%LinFileNum)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackAeroMap(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_AeroMap), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackAeroMap'
   integer(B8Ki)   :: i1, i2, i3
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%iModOrder); if (RegCheckErr(RF, RoutineName)) return
   call Glue_UnpackModGlueType(RF, OutData%Mod) ! Mod 
   call RegUnpackAlloc(RF, OutData%Jac11); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac12); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac21); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac22); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%JacPivot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%JacScale); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SolveTolerance); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%HubOrientation); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%u2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Residual); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%SolveDelta); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%Cases)) deallocate(OutData%Cases)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Cases(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cases.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackAeroMapCase(RF, OutData%Cases(i1)) ! Cases 
      end do
   end if
   call RegUnpack(RF, OutData%LinFileNum); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyTC_State(SrcTC_StateData, DstTC_StateData, CtrlCode, ErrStat, ErrMsg)
   type(TC_State), intent(in) :: SrcTC_StateData
   type(TC_State), intent(inout) :: DstTC_StateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'Glue_CopyTC_State'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcTC_StateData%q_prev)) then
      LB(1:1) = lbound(SrcTC_StateData%q_prev, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%q_prev, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%q_prev)) then
         allocate(DstTC_StateData%q_prev(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%q_prev.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%q_prev = SrcTC_StateData%q_prev
   end if
   if (allocated(SrcTC_StateData%x)) then
      LB(1:1) = lbound(SrcTC_StateData%x, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%x, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%x)) then
         allocate(DstTC_StateData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%x = SrcTC_StateData%x
   end if
   if (allocated(SrcTC_StateData%q)) then
      LB(1:1) = lbound(SrcTC_StateData%q, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%q, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%q)) then
         allocate(DstTC_StateData%q(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%q.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%q = SrcTC_StateData%q
   end if
   if (allocated(SrcTC_StateData%v)) then
      LB(1:1) = lbound(SrcTC_StateData%v, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%v, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%v)) then
         allocate(DstTC_StateData%v(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%v.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%v = SrcTC_StateData%v
   end if
   if (allocated(SrcTC_StateData%vd)) then
      LB(1:1) = lbound(SrcTC_StateData%vd, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%vd, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%vd)) then
         allocate(DstTC_StateData%vd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%vd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%vd = SrcTC_StateData%vd
   end if
   if (allocated(SrcTC_StateData%a)) then
      LB(1:1) = lbound(SrcTC_StateData%a, kind=B8Ki)
      UB(1:1) = ubound(SrcTC_StateData%a, kind=B8Ki)
      if (.not. allocated(DstTC_StateData%a)) then
         allocate(DstTC_StateData%a(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTC_StateData%a.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTC_StateData%a = SrcTC_StateData%a
   end if
end subroutine

subroutine Glue_DestroyTC_State(TC_StateData, ErrStat, ErrMsg)
   type(TC_State), intent(inout) :: TC_StateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyTC_State'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(TC_StateData%q_prev)) then
      deallocate(TC_StateData%q_prev)
   end if
   if (allocated(TC_StateData%x)) then
      deallocate(TC_StateData%x)
   end if
   if (allocated(TC_StateData%q)) then
      deallocate(TC_StateData%q)
   end if
   if (allocated(TC_StateData%v)) then
      deallocate(TC_StateData%v)
   end if
   if (allocated(TC_StateData%vd)) then
      deallocate(TC_StateData%vd)
   end if
   if (allocated(TC_StateData%a)) then
      deallocate(TC_StateData%a)
   end if
end subroutine

subroutine Glue_PackTC_State(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(TC_State), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackTC_State'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%q_prev)
   call RegPackAlloc(RF, InData%x)
   call RegPackAlloc(RF, InData%q)
   call RegPackAlloc(RF, InData%v)
   call RegPackAlloc(RF, InData%vd)
   call RegPackAlloc(RF, InData%a)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackTC_State(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(TC_State), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackTC_State'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%q_prev); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%q); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%v); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%vd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%a); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyTCMisc(SrcTCMiscData, DstTCMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_TCMisc), intent(in) :: SrcTCMiscData
   type(Glue_TCMisc), intent(inout) :: DstTCMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyTCMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_CopyModGlueType(SrcTCMiscData%Mod, DstTCMiscData%Mod, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyTC_State(SrcTCMiscData%StateCurr, DstTCMiscData%StateCurr, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyTC_State(SrcTCMiscData%StatePred, DstTCMiscData%StatePred, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcTCMiscData%UCalc)) then
      LB(1:1) = lbound(SrcTCMiscData%UCalc, kind=B8Ki)
      UB(1:1) = ubound(SrcTCMiscData%UCalc, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%UCalc)) then
         allocate(DstTCMiscData%UCalc(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%UCalc.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%UCalc = SrcTCMiscData%UCalc
   end if
   if (allocated(SrcTCMiscData%XB)) then
      LB(1:2) = lbound(SrcTCMiscData%XB, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%XB, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%XB)) then
         allocate(DstTCMiscData%XB(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%XB.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%XB = SrcTCMiscData%XB
   end if
   if (allocated(SrcTCMiscData%IPIV)) then
      LB(1:1) = lbound(SrcTCMiscData%IPIV, kind=B8Ki)
      UB(1:1) = ubound(SrcTCMiscData%IPIV, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%IPIV)) then
         allocate(DstTCMiscData%IPIV(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%IPIV.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%IPIV = SrcTCMiscData%IPIV
   end if
   DstTCMiscData%IterTotal = SrcTCMiscData%IterTotal
   DstTCMiscData%UJacIterRemain = SrcTCMiscData%UJacIterRemain
   DstTCMiscData%UJacStepsRemain = SrcTCMiscData%UJacStepsRemain
   DstTCMiscData%ConvWarn = SrcTCMiscData%ConvWarn
   if (allocated(SrcTCMiscData%XB_IO)) then
      LB(1:2) = lbound(SrcTCMiscData%XB_IO, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%XB_IO, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%XB_IO)) then
         allocate(DstTCMiscData%XB_IO(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%XB_IO.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%XB_IO = SrcTCMiscData%XB_IO
   end if
   if (allocated(SrcTCMiscData%Jac_IO)) then
      LB(1:2) = lbound(SrcTCMiscData%Jac_IO, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%Jac_IO, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%Jac_IO)) then
         allocate(DstTCMiscData%Jac_IO(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%Jac_IO.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%Jac_IO = SrcTCMiscData%Jac_IO
   end if
   if (allocated(SrcTCMiscData%J11)) then
      LB(1:2) = lbound(SrcTCMiscData%J11, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%J11, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%J11)) then
         allocate(DstTCMiscData%J11(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%J11.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%J11 = SrcTCMiscData%J11
   end if
   if (allocated(SrcTCMiscData%J12)) then
      LB(1:2) = lbound(SrcTCMiscData%J12, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%J12, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%J12)) then
         allocate(DstTCMiscData%J12(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%J12.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%J12 = SrcTCMiscData%J12
   end if
   if (allocated(SrcTCMiscData%J21)) then
      LB(1:2) = lbound(SrcTCMiscData%J21, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%J21, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%J21)) then
         allocate(DstTCMiscData%J21(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%J21.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%J21 = SrcTCMiscData%J21
   end if
   if (allocated(SrcTCMiscData%J22)) then
      LB(1:2) = lbound(SrcTCMiscData%J22, kind=B8Ki)
      UB(1:2) = ubound(SrcTCMiscData%J22, kind=B8Ki)
      if (.not. allocated(DstTCMiscData%J22)) then
         allocate(DstTCMiscData%J22(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstTCMiscData%J22.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstTCMiscData%J22 = SrcTCMiscData%J22
   end if
end subroutine

subroutine Glue_DestroyTCMisc(TCMiscData, ErrStat, ErrMsg)
   type(Glue_TCMisc), intent(inout) :: TCMiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyTCMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call Glue_DestroyModGlueType(TCMiscData%Mod, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyTC_State(TCMiscData%StateCurr, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyTC_State(TCMiscData%StatePred, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(TCMiscData%UCalc)) then
      deallocate(TCMiscData%UCalc)
   end if
   if (allocated(TCMiscData%XB)) then
      deallocate(TCMiscData%XB)
   end if
   if (allocated(TCMiscData%IPIV)) then
      deallocate(TCMiscData%IPIV)
   end if
   if (allocated(TCMiscData%XB_IO)) then
      deallocate(TCMiscData%XB_IO)
   end if
   if (allocated(TCMiscData%Jac_IO)) then
      deallocate(TCMiscData%Jac_IO)
   end if
   if (allocated(TCMiscData%J11)) then
      deallocate(TCMiscData%J11)
   end if
   if (allocated(TCMiscData%J12)) then
      deallocate(TCMiscData%J12)
   end if
   if (allocated(TCMiscData%J21)) then
      deallocate(TCMiscData%J21)
   end if
   if (allocated(TCMiscData%J22)) then
      deallocate(TCMiscData%J22)
   end if
end subroutine

subroutine Glue_PackTCMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_TCMisc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackTCMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call Glue_PackModGlueType(RF, InData%Mod) 
   call Glue_PackTC_State(RF, InData%StateCurr) 
   call Glue_PackTC_State(RF, InData%StatePred) 
   call RegPackAlloc(RF, InData%UCalc)
   call RegPackAlloc(RF, InData%XB)
   call RegPackAlloc(RF, InData%IPIV)
   call RegPack(RF, InData%IterTotal)
   call RegPack(RF, InData%UJacIterRemain)
   call RegPack(RF, InData%UJacStepsRemain)
   call RegPack(RF, InData%ConvWarn)
   call RegPackAlloc(RF, InData%XB_IO)
   call RegPackAlloc(RF, InData%Jac_IO)
   call RegPackAlloc(RF, InData%J11)
   call RegPackAlloc(RF, InData%J12)
   call RegPackAlloc(RF, InData%J21)
   call RegPackAlloc(RF, InData%J22)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackTCMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_TCMisc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackTCMisc'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call Glue_UnpackModGlueType(RF, OutData%Mod) ! Mod 
   call Glue_UnpackTC_State(RF, OutData%StateCurr) ! StateCurr 
   call Glue_UnpackTC_State(RF, OutData%StatePred) ! StatePred 
   call RegUnpackAlloc(RF, OutData%UCalc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%XB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%IPIV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IterTotal); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UJacIterRemain); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UJacStepsRemain); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvWarn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%XB_IO); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac_IO); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J11); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J12); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J21); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%J22); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyLinMisc(SrcLinMiscData, DstLinMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_LinMisc), intent(in) :: SrcLinMiscData
   type(Glue_LinMisc), intent(inout) :: DstLinMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_CopyLinMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinMiscData%TimeIndex = SrcLinMiscData%TimeIndex
   DstLinMiscData%AzimuthIndex = SrcLinMiscData%AzimuthIndex
   DstLinMiscData%IsConverged = SrcLinMiscData%IsConverged
end subroutine

subroutine Glue_DestroyLinMisc(LinMiscData, ErrStat, ErrMsg)
   type(Glue_LinMisc), intent(inout) :: LinMiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'Glue_DestroyLinMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine Glue_PackLinMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_LinMisc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackLinMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%TimeIndex)
   call RegPack(RF, InData%AzimuthIndex)
   call RegPack(RF, InData%IsConverged)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackLinMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_LinMisc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackLinMisc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%TimeIndex); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimuthIndex); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsConverged); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: SrcMiscData
   type(Glue_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%ModData)) then
      LB(1:1) = lbound(SrcMiscData%ModData, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%ModData, kind=B8Ki)
      if (.not. allocated(DstMiscData%ModData)) then
         allocate(DstMiscData%ModData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ModData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_CopyModDataType(SrcMiscData%ModData(i1), DstMiscData%ModData(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%Mappings)) then
      LB(1:1) = lbound(SrcMiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%Mappings, kind=B8Ki)
      if (.not. allocated(DstMiscData%Mappings)) then
         allocate(DstMiscData%Mappings(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Mappings.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Glue_CopyMappingType(SrcMiscData%Mappings(i1), DstMiscData%Mappings(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call Glue_CopyModGlueType(SrcMiscData%ModGlue, DstMiscData%ModGlue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyLinMisc(SrcMiscData%Lin, DstMiscData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyCalcSteady(SrcMiscData%CS, DstMiscData%CS, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyAeroMap(SrcMiscData%AM, DstMiscData%AM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyTCMisc(SrcMiscData%TC, DstMiscData%TC, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine Glue_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(Glue_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'Glue_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%ModData)) then
      LB(1:1) = lbound(MiscData%ModData, kind=B8Ki)
      UB(1:1) = ubound(MiscData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_DestroyModDataType(MiscData%ModData(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%ModData)
   end if
   if (allocated(MiscData%Mappings)) then
      LB(1:1) = lbound(MiscData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(MiscData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_DestroyMappingType(MiscData%Mappings(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%Mappings)
   end if
   call Glue_DestroyModGlueType(MiscData%ModGlue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyLinMisc(MiscData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyCalcSteady(MiscData%CS, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyAeroMap(MiscData%AM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyTCMisc(MiscData%TC, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine Glue_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(Glue_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Glue_PackMisc'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%ModData))
   if (allocated(InData%ModData)) then
      call RegPackBounds(RF, 1, lbound(InData%ModData, kind=B8Ki), ubound(InData%ModData, kind=B8Ki))
      LB(1:1) = lbound(InData%ModData, kind=B8Ki)
      UB(1:1) = ubound(InData%ModData, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackModDataType(RF, InData%ModData(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Mappings))
   if (allocated(InData%Mappings)) then
      call RegPackBounds(RF, 1, lbound(InData%Mappings, kind=B8Ki), ubound(InData%Mappings, kind=B8Ki))
      LB(1:1) = lbound(InData%Mappings, kind=B8Ki)
      UB(1:1) = ubound(InData%Mappings, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call Glue_PackMappingType(RF, InData%Mappings(i1)) 
      end do
   end if
   call Glue_PackModGlueType(RF, InData%ModGlue) 
   call Glue_PackLinMisc(RF, InData%Lin) 
   call Glue_PackCalcSteady(RF, InData%CS) 
   call Glue_PackAeroMap(RF, InData%AM) 
   call Glue_PackTCMisc(RF, InData%TC) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine Glue_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(Glue_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Glue_UnPackMisc'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%ModData)) deallocate(OutData%ModData)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%ModData(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ModData.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackModDataType(RF, OutData%ModData(i1)) ! ModData 
      end do
   end if
   if (allocated(OutData%Mappings)) deallocate(OutData%Mappings)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Mappings(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mappings.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Glue_UnpackMappingType(RF, OutData%Mappings(i1)) ! Mappings 
      end do
   end if
   call Glue_UnpackModGlueType(RF, OutData%ModGlue) ! ModGlue 
   call Glue_UnpackLinMisc(RF, OutData%Lin) ! Lin 
   call Glue_UnpackCalcSteady(RF, OutData%CS) ! CS 
   call Glue_UnpackAeroMap(RF, OutData%AM) ! AM 
   call Glue_UnpackTCMisc(RF, OutData%TC) ! TC 
end subroutine

END MODULE Glue_Types

!ENDOFREGISTRYGENERATEDFILE
