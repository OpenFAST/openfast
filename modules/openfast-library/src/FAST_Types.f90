!STARTOFREGISTRYGENERATEDFILE 'FAST_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FAST_Types
!.................................................................................................................................
! This file is part of FAST.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FAST. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FAST_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE Glue_Types
USE ElastoDyn_Types
USE SED_Types
USE BeamDyn_Types
USE ServoDyn_Types
USE AeroDyn_Types
USE AeroDisk_Types
USE ExtLoads_Types
USE SubDyn_Types
USE SeaState_Types
USE HydroDyn_Types
USE IceFloe_Types
USE ExternalInflow_Types
USE IceDyn_Types
USE FEAMooring_Types
USE MAP_Types
USE MoorDyn_Types
USE OrcaFlexInterface_Types
USE ExtPtfm_MCKF_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Unknown                   = -1      ! Unknown [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_None                      = 0      ! No module selected [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Glue                      = 1      ! Glue code [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IfW                       = 2      ! InflowWind [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ExtInfw                   = 3      ! ExternalInflow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ED                        = 4      ! ElastoDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_BD                        = 5      ! BeamDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_AD                        = 7      ! AeroDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ExtLd                     = 8      ! ExternalLoads [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SrvD                      = 9      ! ServoDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SeaSt                     = 10      ! SeaState [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_HD                        = 11      ! HydroDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SD                        = 12      ! SubDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ExtPtfm                   = 13      ! External Platform Loading MCKF [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_MAP                       = 14      ! MAP (Mooring Analysis Program) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_FEAM                      = 15      ! FEAMooring [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_MD                        = 16      ! MoorDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Orca                      = 17      ! OrcaFlex integration (HD/Mooring) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IceF                      = 18      ! IceFloe [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IceD                      = 19      ! IceDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ADsk                      = 20      ! AeroDisk [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SED                       = 21      ! Simplified-ElastoDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: NumModules                       = 21      ! The number of modules available in FAST [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxNBlades                       = 3      ! Maximum number of blades allowed on a turbine [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: IceD_MaxLegs                     = 4      ! because I don't know how many legs there are before calling IceD_Init and I don't want to copy the data because of sibling mesh issues, I'm going to allocate IceD based on this number [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_Pitch                    = 1      ! pitch [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_TSR                      = 2      ! TSR [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_WS                       = 3      ! wind speed [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_RotSpeed                 = 4      ! rotor speed [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_Err                      = 5      ! err in the ss solve [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SS_Indx_Iter                     = 6      ! number of iterations [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: NumStateTimes                    = 4      ! size of arrays of state derived types (Continuous state type etc). (STATE_CURR, STATE_PRED, STATE_SAVED_CURR, STATE_SAVED_PRED) [-]
! =========  FAST_VTK_BLSurfaceType  =======
  TYPE, PUBLIC :: FAST_VTK_BLSurfaceType
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x,y coordinates for airfoil around each blade node on a blade (relative to reference) [-]
  END TYPE FAST_VTK_BLSurfaceType
! =======================
! =========  FAST_VTK_SurfaceType  =======
  TYPE, PUBLIC :: FAST_VTK_SurfaceType
    INTEGER(IntKi)  :: NumSectors = 0_IntKi      !< number of sectors in which to split circles (higher number gives smoother surface) [-]
    REAL(SiKi)  :: HubRad = 0.0_R4Ki      !< Preconed hub radius (distance from the rotor apex to the blade root) [m]
    REAL(SiKi)  :: GroundRad = 0.0_R4Ki      !< radius for plotting circle on ground [m]
    REAL(SiKi) , DIMENSION(1:3,1:8)  :: NacelleBox = 0.0_R4Ki      !< X-Y-Z locations of 8 points that define the nacelle box, relative to the nacelle position [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: TowerRad      !< radius of each ED tower node [m]
    INTEGER(IntKi) , DIMENSION(1:2)  :: NWaveElevPts = 0_IntKi      !< number of points for wave elevation visualization [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevVisX      !< X locations for WaveElev output (for visualization). [m,-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevVisY      !< Y locations for WaveElev output (for visualization). [m,-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveElevVisGrid      !< wave elevation at WaveElevVis{XY}; first dimension is time step; second/third dimensions are grid of elevations [m,-]
    TYPE(FAST_VTK_BLSurfaceType) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< AirfoilCoords for each blade [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: MorisonVisRad      !< radius of each Morison node [m]
  END TYPE FAST_VTK_SurfaceType
! =======================
! =========  FAST_VTK_ModeShapeType  =======
  TYPE, PUBLIC :: FAST_VTK_ModeShapeType
    CHARACTER(1024)  :: CheckpointRoot      !< name of the checkpoint file written by FAST when linearization data was produced [-]
    CHARACTER(1024)  :: MatlabFileName      !< name of the file with eigenvectors written by Matlab [-]
    INTEGER(IntKi)  :: VTKLinModes = 0_IntKi      !< Number of modes to visualize [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: VTKModes      !< Which modes to visualize [-]
    INTEGER(IntKi)  :: VTKLinTim = 0_IntKi      !< Switch to make one animation for all LinTimes together (1) or separate animations for each LinTimes(2) [-]
    INTEGER(IntKi)  :: VTKNLinTimes = 0_IntKi      !< number of linearization times to use when VTKLinTim==2 [-]
    REAL(ReKi)  :: VTKLinScale = 0.0_ReKi      !< Mode shape visualization scaling factor [-]
    REAL(ReKi)  :: VTKLinPhase = 0.0_ReKi      !< Phase when making one animation for all LinTimes together (used only when VTKLinTim=1) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: DampingRatio      !< damping ratios from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: NaturalFreq_Hz      !< natural frequency from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: DampedFreq_Hz      !< damped frequency from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: x_eig_magnitude      !< magnitude of eigenvector (dimension 1=state, dim 2= azimuth, dim 3 = mode) [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: x_eig_phase      !< phase of eigenvector (dimension 1=state, dim 2= azimuth, dim 3 = mode) [-]
  END TYPE FAST_VTK_ModeShapeType
! =======================
! =========  FAST_ParameterType  =======
  TYPE, PUBLIC :: FAST_ParameterType
    REAL(DbKi)  :: DT = 0.0_R8Ki      !< Integration time step [global time] [s]
    REAL(DbKi) , DIMENSION(1:NumModules)  :: DT_module = 0.0_R8Ki      !< Integration time step [global time] [s]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: n_substeps = 0_IntKi      !< The number of module substeps for advancing states from t_global to t_global_next [-]
    INTEGER(IntKi)  :: n_TMax_m1 = 0_IntKi      !< The time step of TMax - dt (the end time of the simulation) [(-)]
    REAL(DbKi)  :: TMax = 0.0_R8Ki      !< Total run time [s]
    INTEGER(IntKi)  :: InterpOrder = 0_IntKi      !< Interpolation order {0,1,2} [-]
    INTEGER(IntKi)  :: NumCrctn = 0_IntKi      !< Number of correction iterations [-]
    INTEGER(IntKi)  :: KMax = 0_IntKi      !< Maximum number of input-output-solve or nonlinear solve residual equation iterations (KMax >= 1) [>0] [-]
    INTEGER(IntKi)  :: numIceLegs = 0_IntKi      !< number of suport-structure legs in contact with ice (IceDyn coupling) [-]
    INTEGER(IntKi)  :: nBeams = 0_IntKi      !< number of BeamDyn instances [-]
    LOGICAL  :: BD_OutputSibling = .false.      !< flag to determine if BD input is sibling of output mesh [-]
    REAL(DbKi)  :: RhoInf = 0.0_R8Ki      !< Numerical damping parameter for tight coupling generalized-alpha integrator (-) [0.0 to 1.0] [-]
    REAL(DbKi)  :: ConvTol = 0.0_R8Ki      !< Convergence iteration error tolerance for tight coupling generalized alpha integrator (-) [-]
    INTEGER(IntKi)  :: MaxConvIter = 0_IntKi      !< Maximum number of convergence iterations for tight coupling generalized alpha integrator (-) [-]
    REAL(DbKi)  :: DT_Ujac = 0.0_R8Ki      !< Time between when we need to re-calculate these Jacobians [s]
    REAL(ReKi)  :: UJacSclFact = 0.0_ReKi      !< Scaling factor used to get similar magnitudes between accelerations, forces, and moments in Jacobians [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: SizeJac_Opt1 = 0_IntKi      !< (1)=size of matrix; (2)=size of ED portion; (3)=size of SD portion [2 meshes]; (4)=size of HD portion; (5)=size of BD portion blade 1; (6)=size of BD portion blade 2; (7)=size of BD portion blade 3; (8)=size of Orca portion; (9)=size of ExtPtfm portion; [-]
    INTEGER(IntKi)  :: SolveOption = 0_IntKi      !< Switch to determine which solve option we are going to use (see Solve_FullOpt1, etc) [-]
    INTEGER(IntKi)  :: CompElast = 0_IntKi      !< Compute blade loads (switch) {Module_ED; Module_BD; Module_SED} [-]
    INTEGER(IntKi)  :: CompInflow = 0_IntKi      !< Compute inflow wind conditions (switch) {Module_None; Module_IfW; Module_ExtInfw} [-]
    INTEGER(IntKi)  :: CompAero = 0_IntKi      !< Compute aerodynamic loads (switch) {Module_None; Module_ADsk; Module_AD} [-]
    INTEGER(IntKi)  :: CompServo = 0_IntKi      !< Compute control and electrical-drive dynamics (switch) {Module_None; Module_SrvD} [-]
    INTEGER(IntKi)  :: CompSeaSt = 0_IntKi      !< Compute sea states; wave kinematics (switch) {Module_None; Module_SeaSt} [-]
    INTEGER(IntKi)  :: CompHydro = 0_IntKi      !< Compute hydrodynamic loads (switch) {Module_None; Module_HD} [-]
    INTEGER(IntKi)  :: CompSub = 0_IntKi      !< Compute sub-structural dynamics (switch) {Module_None; Module_SD, Module_ExtPtfm} [-]
    INTEGER(IntKi)  :: CompMooring = 0_IntKi      !< Compute mooring system (switch) {Module_None; Module_MAP; Module_FEAM; Module_MD; Module_Orca} [-]
    INTEGER(IntKi)  :: CompIce = 0_IntKi      !< Compute ice loading (switch) {Module_None; Module_IceF, Module_IceD} [-]
    INTEGER(IntKi)  :: MHK = 0_IntKi      !< MHK turbine type (switch) {0=Not an MHK turbine; 1=Fixed MHK turbine; 2=Floating MHK turbine} [-]
    LOGICAL  :: UseDWM = .false.      !< Use the DWM module in AeroDyn [-]
    LOGICAL  :: Linearize = .false.      !< Linearization analysis (flag) [-]
    INTEGER(IntKi)  :: WaveFieldMod = 0_IntKi      !< Wave field handling (-) (switch) 0: use individual HydroDyn inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    LOGICAL  :: FarmIntegration = .false.      !< whether this is called from FAST.Farm (or another program that doesn't want FAST to call all of the init stuff first) [-]
    REAL(SiKi) , DIMENSION(1:3)  :: TurbinePos = 0.0_R4Ki      !< Initial position of turbine base (origin used for graphics) [m]
    REAL(ReKi)  :: Gravity = 0.0_ReKi      !< Gravitational acceleration [m/s^2]
    REAL(ReKi)  :: AirDens = 0.0_ReKi      !< Air density [kg/m^3]
    REAL(ReKi)  :: WtrDens = 0.0_ReKi      !< Water density [kg/m^3]
    REAL(ReKi)  :: KinVisc = 0.0_ReKi      !< Kinematic viscosity of working fluid [m^2/s]
    REAL(ReKi)  :: SpdSound = 0.0_ReKi      !< Speed of sound in working fluid [m/s]
    REAL(ReKi)  :: Patm = 0.0_ReKi      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap = 0.0_ReKi      !< Vapour pressure of working fluid [Pa]
    REAL(ReKi)  :: WtrDpth = 0.0_ReKi      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL = 0.0_ReKi      !< Offset between still-water level and mean sea level [m]
    CHARACTER(1024)  :: EDFile      !< The name of the ElastoDyn/Simplified-ElastoDyn input file [-]
    CHARACTER(1024) , DIMENSION(1:MaxNBlades)  :: BDBldFile      !< Name of files containing BeamDyn inputs for each blade [-]
    CHARACTER(1024)  :: InflowFile      !< Name of file containing inflow wind input parameters [-]
    CHARACTER(1024)  :: AeroFile      !< Name of file containing aerodynamic input parameters [-]
    CHARACTER(1024)  :: ServoFile      !< Name of file containing control and electrical-drive input parameters [-]
    CHARACTER(1024)  :: SeaStFile      !< Name of file containing sea state input parameters [-]
    CHARACTER(1024)  :: HydroFile      !< Name of file containing hydrodynamic input parameters [-]
    CHARACTER(1024)  :: SubFile      !< Name of file containing sub-structural input parameters [-]
    CHARACTER(1024)  :: MooringFile      !< Name of file containing mooring system input parameters [-]
    CHARACTER(1024)  :: IceFile      !< Name of file containing ice loading input parameters [-]
    REAL(DbKi)  :: TStart = 0.0_R8Ki      !< Time to begin tabular output [s]
    REAL(DbKi)  :: DT_Out = 0.0_R8Ki      !< Time step for tabular output [s]
    LOGICAL  :: WrSttsTime = .false.      !< Whether we should write the status times to the screen [-]
    INTEGER(IntKi)  :: n_SttsTime = 0_IntKi      !< Number of time steps between screen status messages [-]
    INTEGER(IntKi)  :: n_ChkptTime = 0_IntKi      !< Number of time steps between writing checkpoint files [-]
    INTEGER(IntKi)  :: n_DT_Out = 0_IntKi      !< Number of time steps between writing a line in the time-marching output files [-]
    INTEGER(IntKi)  :: n_VTKTime = 0_IntKi      !< Number of time steps between writing VTK files [-]
    LOGICAL  :: WrBinOutFile = .false.      !< Write a binary output file? (.outb) [-]
    LOGICAL  :: WrTxtOutFile = .false.      !< Write a text (formatted) output file? (.out) [-]
    INTEGER(IntKi)  :: WrBinMod = 0_IntKi      !< If writing binary, which file format is to be written [1, 2, or 3] [-]
    LOGICAL  :: SumPrint = .false.      !< Print summary data to file? (.sum) [-]
    INTEGER(IntKi)  :: WrVTK = 0      !< VTK Visualization data output: (switch) {0=none; 1=initialization data only; 2=animation} [-]
    INTEGER(IntKi)  :: VTK_Type = 0_IntKi      !< Type of  VTK visualization data: (switch) {1=surfaces; 2=basic meshes (lines/points); 3=all meshes (debug)} [-]
    LOGICAL  :: VTK_fields = .false.      !< Write mesh fields to VTK data files? (flag) {true/false} [-]
    CHARACTER(1)  :: Delim      !< Delimiter between columns of text output file (.out): space or tab [-]
    CHARACTER(20)  :: OutFmt      !< Format used for text tabular output (except time); resulting field should be 10 characters [-]
    CHARACTER(20)  :: OutFmt_t      !< Format used for time channel in text tabular output; resulting field should be 10 characters [-]
    INTEGER(IntKi)  :: FmtWidth = 0_IntKi      !< width of the time OutFmt specifier [-]
    INTEGER(IntKi)  :: TChanLen = 0_IntKi      !< width of the time channel [-]
    CHARACTER(1024)  :: OutFileRoot      !< The rootname of the output files [-]
    CHARACTER(1024)  :: FTitle      !< The description line from the FAST (glue-code) input file [-]
    CHARACTER(1024)  :: VTK_OutFileRoot = ''      !< The rootname of the VTK output files [-]
    INTEGER(IntKi)  :: VTK_tWidth = 0_IntKi      !< Width of number of files for leading zeros in file name format [-]
    REAL(DbKi)  :: VTK_fps = 0.0_R8Ki      !< number of frames per second to output VTK data [-]
    TYPE(FAST_VTK_SurfaceType)  :: VTK_surface      !< Data for VTK surface visualization [-]
    CHARACTER(4)  :: Tdesc      !< description of turbine ID (for FAST.Farm) screen printing [-]
    REAL(DbKi) , DIMENSION(1:6)  :: PlatformPosInit = 0.0_R8Ki      !< Platform inital 6 DOF position from ED (this is different from TurbinePos) [-]
    LOGICAL  :: CalcSteady = .false.      !< Calculate a steady-state periodic operating point before linearization [unused if Linearize=False] [-]
    INTEGER(IntKi)  :: TrimCase = 0_IntKi      !< Controller parameter to be trimmed {1:yaw; 2:torque; 3:pitch} [unused if Linearize=False; used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimTol = 0.0_ReKi      !< Tolerance for the rotational speed convergence (>0) [unused if Linearize=False; used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimGain = 0.0_ReKi      !< Proportional gain for the rotational speed error (>0) [unused if Linearize=False; used only if CalcSteady=True] [rad/(rad/s) for yaw or pitch; Nm/(rad/s) for torque]
    REAL(ReKi)  :: Twr_Kdmp = 0.0_ReKi      !< Damping factor for the tower [unused if Linearize=False; used only if CalcSteady=True] [N/(m/s)]
    REAL(ReKi)  :: Bld_Kdmp = 0.0_ReKi      !< Damping factor for the blades [unused if Linearize=False; used only if CalcSteady=True] [N/(m/s)]
    INTEGER(IntKi)  :: NLinTimes = 0_IntKi      !< Number of LinTimes, or equally-spaced azimuth steps in periodic linearized model (>0)[unused if Linearize=False] [-]
    REAL(DbKi)  :: AzimDelta = 0.0_R8Ki      !< difference between two consecutive azimuth positions in CalcSteady algorithm [rad]
    INTEGER(IntKi)  :: LinInputs = 0_IntKi      !< Inputs included in linearization (switch) {0=none; 1=standard; 2=all module inputs (debug)} [unused if Linearize=False] [-]
    INTEGER(IntKi)  :: LinOutputs = 0_IntKi      !< Outputs included in linearization (switch) {0=none; 1=from OutList(s); 2=all module outputs (debug)} [unused if Linearize=False] [-]
    LOGICAL  :: LinOutJac = .false.      !< Include full Jacabians in linearization output (for debug) (flag) [unused if Linearize=False; used only if LinInputs=LinOutputs=2] [-]
    LOGICAL  :: LinOutMod = .false.      !< Write module-level linearization output files in addition to output for full system? (flag) [unused if Linearize=False] [-]
    TYPE(FAST_VTK_ModeShapeType)  :: VTK_modes      !< Data for VTK mode-shape visualization [-]
    INTEGER(IntKi)  :: Lin_NumMods = 0_IntKi      !< number of modules in the linearization [-]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: Lin_ModOrder = 0_IntKi      !< indices that determine which order the modules are in the glue-code linearization matrix [-]
    INTEGER(IntKi)  :: LinInterpOrder = 0_IntKi      !< Interpolation order for CalcSteady solution [-]
    LOGICAL  :: CompAeroMaps = .false.      !< Flag to determine if we are calculating aero maps [-]
    INTEGER(IntKi)  :: N_UJac = 0_IntKi      !< Number of iterations between re-calculating Jacobian [(-)]
    INTEGER(IntKi)  :: NumBl_Lin = 0_IntKi      !< number of blades in the jacobian [-]
    REAL(R8Ki)  :: tolerSquared = 0.0_R8Ki      !< Convergence tolerance for nonlinear solve residual equation [>0] squared [(-)]
    INTEGER(IntKi)  :: NumSSCases = 0_IntKi      !< Number of cases for steady-state solver generation [>0] [(-)]
    INTEGER(IntKi)  :: WindSpeedOrTSR = 0_IntKi      !< Choice of swept parameter (switch) { 1:wind speed; 2: TSR } [(-)]
    REAL(ReKi)  :: RotSpeedInit = 0.0_ReKi      !< Initial rotor speed for steady-state solve [>0] [(rad/s)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RotSpeed      !< List of rotor speeds for steady-state solve [>0] [(rad/s)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WS_TSR      !< List of WindSpeed or TSRs (depending on WindSpeedOrTSR setting) for aeromap generation [(m/s or -)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Pitch      !< List of pitch angles for aeromap generation [(rad)]
    INTEGER(IntKi)  :: GearBox_index = 0_IntKi      !< Index to gearbox rotation in state array (for steady-state calculations) [-]
  END TYPE FAST_ParameterType
! =======================
! =========  FAST_LinFileType  =======
  TYPE, PUBLIC :: FAST_LinFileType
    REAL(ReKi)  :: RotSpeed = 0.0_ReKi      !< Rotor azimuth angular speed [rad/s]
    REAL(ReKi)  :: Azimuth = 0.0_ReKi      !< Rotor azimuth position [rad]
    REAL(ReKi)  :: WindSpeed = 0.0_ReKi      !< Wind speed at reference height [m/s]
  END TYPE FAST_LinFileType
! =======================
! =========  FAST_MiscLinType  =======
  TYPE, PUBLIC :: FAST_MiscLinType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: LinTimes      !< List of times at which to linearize [s]
    INTEGER(IntKi)  :: CopyOP_CtrlCode = 0_IntKi      !< mesh control code for copy type (new on first call; update otherwise) [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: AzimTarget      !< target azimuth positions in CalcSteady algorithm [rad]
    LOGICAL  :: IsConverged = .false.      !< whether the error calculation in the CalcSteady algorithm is converged [-]
    LOGICAL  :: FoundSteady = .false.      !< whether the CalcSteady algorithm found a steady-state solution [-]
    LOGICAL  :: ForceLin = .false.      !< whether the CalcSteady algorithm found a steady-state solution [-]
    INTEGER(IntKi)  :: n_rot = 0_IntKi      !< number of rotations completed in CalcSteady algorithm [-]
    INTEGER(IntKi)  :: AzimIndx = 0_IntKi      !< index into target azimuth array in CalcSteady algorithm [-]
    INTEGER(IntKi)  :: NextLinTimeIndx = 0_IntKi      !< index for next time in LinTimes where linearization should occur [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Psi      !< Azimuth angle at the current and previous time steps (uses LinInterpOrder); DbKi so that we can use registry-generated extrap/interp routines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y_interp      !< Interpolated outputs packed into an array [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y_ref      !< Reference output range for CalcSteady error calculation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Y_prevRot      !< Linearization outputs from previous rotor revolution at each target azimuth  [-]
  END TYPE FAST_MiscLinType
! =======================
! =========  FAST_OutputFileType  =======
  TYPE, PUBLIC :: FAST_OutputFileType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TimeData      !< Array to contain the time output data for the binary file (first output time and a time [fixed] increment) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AllOutData      !< Array to contain all the output data (time history of all outputs); Index 1 is NumOuts, Index 2 is Time step [-]
    INTEGER(IntKi)  :: n_Out = 0_IntKi      !< Time index into the AllOutData array [-]
    INTEGER(IntKi)  :: NOutSteps = 0_IntKi      !< Maximum number of output steps [-]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: numOuts = 0_IntKi      !< number of outputs to print from each module [-]
    INTEGER(IntKi)  :: UnOu = -1      !< I/O unit number for the tabular output file [-]
    INTEGER(IntKi)  :: UnSum = -1      !< I/O unit number for the summary file [-]
    INTEGER(IntKi)  :: UnGra = -1      !< I/O unit number for mesh graphics [-]
    CHARACTER(1024) , DIMENSION(1:3)  :: FileDescLines      !< Description lines to include in output files (header, time run, plus module names/versions) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChannelNames      !< Names of the output channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChannelUnits      !< Units for the output channels [-]
    TYPE(ProgDesc) , DIMENSION(1:NumModules)  :: Module_Ver      !< version information from all modules [-]
    CHARACTER(ChanLen) , DIMENSION(1:NumModules)  :: Module_Abrev      !< abbreviation for module (used in file output naming conventions) [-]
    LOGICAL  :: WriteThisStep = .false.      !< Whether this step will be written in the FAST output files [-]
    INTEGER(IntKi)  :: VTK_count = 0_IntKi      !< Number of VTK files written (for naming output files) [-]
    INTEGER(IntKi)  :: VTK_LastWaveIndx = 0_IntKi      !< last index into wave array [-]
    TYPE(FAST_LinFileType)  :: Lin      !< linearization data for output [-]
    INTEGER(IntKi)  :: ActualChanLen = 0_IntKi      !< width of the column headers output in the text and/or binary file [-]
    REAL(ReKi) , DIMENSION(1:6)  :: DriverWriteOutput = 0.0_ReKi      !< pitch and tsr for current aero map case, plus error, number of iterations, wind speed, rotor speed [-]
  END TYPE FAST_OutputFileType
! =======================
! =========  IceDyn_Data  =======
  TYPE, PUBLIC :: IceDyn_Data
    TYPE(IceD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(IceD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(IceD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(IceD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(IceD_ParameterType) , DIMENSION(:), ALLOCATABLE  :: p      !< Parameters [-]
    TYPE(IceD_OutputType) , DIMENSION(:), ALLOCATABLE  :: y      !< System outputs [-]
    TYPE(IceD_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: m      !< Misc/optimization variables [-]
    TYPE(IceD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE IceDyn_Data
! =======================
! =========  BeamDyn_Data  =======
  TYPE, PUBLIC :: BeamDyn_Data
    TYPE(BD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(BD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(BD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(BD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(BD_ParameterType) , DIMENSION(:), ALLOCATABLE  :: p      !< Parameters [-]
    TYPE(BD_OutputType) , DIMENSION(:), ALLOCATABLE  :: y      !< System outputs [-]
    TYPE(BD_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: m      !< Misc/optimization variables [-]
    TYPE(BD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE BeamDyn_Data
! =======================
! =========  ElastoDyn_Data  =======
  TYPE, PUBLIC :: ElastoDyn_Data
    TYPE(ED_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(ED_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(ED_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(ED_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(ED_ParameterType) , DIMENSION(:), ALLOCATABLE  :: p      !< Parameters [-]
    TYPE(ED_OutputType) , DIMENSION(:), ALLOCATABLE  :: y      !< System outputs [-]
    TYPE(ED_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: m      !< Misc (optimization) variables not associated with time [-]
    TYPE(ED_InputType) , DIMENSION(:,:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ElastoDyn_Data
! =======================
! =========  SED_Data  =======
  TYPE, PUBLIC :: SED_Data
    TYPE(SED_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(SED_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(SED_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(SED_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(SED_ParameterType)  :: p      !< Parameters [-]
    TYPE(SED_OutputType)  :: y      !< System outputs [-]
    TYPE(SED_MiscVarType)  :: m      !< Misc (optimization) variables not associated with time [-]
    TYPE(SED_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE SED_Data
! =======================
! =========  ServoDyn_Data  =======
  TYPE, PUBLIC :: ServoDyn_Data
    TYPE(SrvD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(SrvD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(SrvD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(SrvD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(SrvD_ParameterType)  :: p      !< Parameters [-]
    TYPE(SrvD_OutputType)  :: y      !< System outputs [-]
    TYPE(SrvD_MiscVarType)  :: m      !< Misc (optimization) variables not associated with time [-]
    TYPE(SrvD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ServoDyn_Data
! =======================
! =========  AeroDyn_Data  =======
  TYPE, PUBLIC :: AeroDyn_Data
    TYPE(AD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(AD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(AD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(AD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(AD_ParameterType)  :: p      !< Parameters [-]
    TYPE(AD_OutputType)  :: y      !< System outputs [-]
    TYPE(AD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(AD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE AeroDyn_Data
! =======================
! =========  ExtLoads_Data  =======
  TYPE, PUBLIC :: ExtLoads_Data
    TYPE(ExtLd_ContinuousStateType) , DIMENSION(1:NumStateTimes)  :: x      !< Continuous states [-]
    TYPE(ExtLd_DiscreteStateType) , DIMENSION(1:NumStateTimes)  :: xd      !< Discrete states [-]
    TYPE(ExtLd_ConstraintStateType) , DIMENSION(1:NumStateTimes)  :: z      !< Constraint states [-]
    TYPE(ExtLd_OtherStateType) , DIMENSION(1:NumStateTimes)  :: OtherSt      !< Other states [-]
    TYPE(ExtLd_ParameterType)  :: p      !< Parameters [-]
    TYPE(ExtLd_InputType)  :: u      !< System inputs [-]
    TYPE(ExtLd_OutputType)  :: y      !< System outputs [-]
    TYPE(ExtLd_MiscVarType)  :: m      !< Misc/optimization variables [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ExtLoads_Data
! =======================
! =========  AeroDisk_Data  =======
  TYPE, PUBLIC :: AeroDisk_Data
    TYPE(ADsk_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(ADsk_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(ADsk_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(ADsk_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(ADsk_ParameterType)  :: p      !< Parameters [-]
    TYPE(ADsk_OutputType)  :: y      !< System outputs [-]
    TYPE(ADsk_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(ADsk_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE AeroDisk_Data
! =======================
! =========  InflowWind_Data  =======
  TYPE, PUBLIC :: InflowWind_Data
    TYPE(InflowWind_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(InflowWind_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(InflowWind_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(InflowWind_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(InflowWind_ParameterType)  :: p      !< Parameters [-]
    TYPE(InflowWind_OutputType)  :: y      !< System outputs [-]
    TYPE(InflowWind_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(InflowWind_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE InflowWind_Data
! =======================
! =========  ExternalInflow_Data  =======
  TYPE, PUBLIC :: ExternalInflow_Data
    TYPE(ExtInfw_InputType)  :: u      !< System inputs [-]
    TYPE(ExtInfw_OutputType)  :: y      !< System outputs [-]
    TYPE(ExtInfw_ParameterType)  :: p      !< Parameters [-]
    TYPE(ExtInfw_MiscVarType)  :: m      !< Parameters [-]
  END TYPE ExternalInflow_Data
! =======================
! =========  SubDyn_Data  =======
  TYPE, PUBLIC :: SubDyn_Data
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(SD_ContinuousStateType)  :: dxdt      !< Continuous state derivatives [-]
    TYPE(SD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(SD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(SD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(SD_ParameterType)  :: p      !< Parameters [-]
    TYPE(SD_OutputType)  :: y      !< System outputs [-]
    TYPE(SD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(SD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE SubDyn_Data
! =======================
! =========  ExtPtfm_Data  =======
  TYPE, PUBLIC :: ExtPtfm_Data
    TYPE(ExtPtfm_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(ExtPtfm_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(ExtPtfm_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(ExtPtfm_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(ExtPtfm_ParameterType)  :: p      !< Parameters [-]
    TYPE(ExtPtfm_OutputType)  :: y      !< System outputs [-]
    TYPE(ExtPtfm_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(ExtPtfm_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ExtPtfm_Data
! =======================
! =========  SeaState_Data  =======
  TYPE, PUBLIC :: SeaState_Data
    TYPE(SeaSt_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(SeaSt_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(SeaSt_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(SeaSt_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(SeaSt_ParameterType)  :: p      !< Parameters [-]
    TYPE(SeaSt_OutputType)  :: y      !< System outputs [-]
    TYPE(SeaSt_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(SeaSt_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE SeaState_Data
! =======================
! =========  HydroDyn_Data  =======
  TYPE, PUBLIC :: HydroDyn_Data
    TYPE(HydroDyn_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(HydroDyn_ContinuousStateType)  :: dxdt      !< Continuous state derivatives [-]
    TYPE(HydroDyn_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(HydroDyn_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(HydroDyn_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(HydroDyn_ParameterType)  :: p      !< Parameters [-]
    TYPE(HydroDyn_OutputType)  :: y      !< System outputs [-]
    TYPE(HydroDyn_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(HydroDyn_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE HydroDyn_Data
! =======================
! =========  IceFloe_Data  =======
  TYPE, PUBLIC :: IceFloe_Data
    TYPE(IceFloe_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(IceFloe_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(IceFloe_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(IceFloe_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(IceFloe_ParameterType)  :: p      !< Parameters [-]
    TYPE(IceFloe_OutputType)  :: y      !< System outputs [-]
    TYPE(IceFloe_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(IceFloe_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE IceFloe_Data
! =======================
! =========  MAP_Data  =======
  TYPE, PUBLIC :: MAP_Data
    TYPE(MAP_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(MAP_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(MAP_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(MAP_OtherStateType)  :: OtherSt      !< Other/optimization states [-]
    TYPE(MAP_ParameterType)  :: p      !< Parameters [-]
    TYPE(MAP_OutputType)  :: y      !< System outputs [-]
    TYPE(MAP_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(MAP_OtherStateType)  :: OtherSt_old      !< Other/optimization states (copied for the case of subcycling) [-]
    TYPE(MAP_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE MAP_Data
! =======================
! =========  FEAMooring_Data  =======
  TYPE, PUBLIC :: FEAMooring_Data
    TYPE(FEAM_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(FEAM_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(FEAM_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(FEAM_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(FEAM_ParameterType)  :: p      !< Parameters [-]
    TYPE(FEAM_OutputType)  :: y      !< System outputs [-]
    TYPE(FEAM_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(FEAM_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE FEAMooring_Data
! =======================
! =========  MoorDyn_Data  =======
  TYPE, PUBLIC :: MoorDyn_Data
    TYPE(MD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(MD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(MD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(MD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(MD_ParameterType)  :: p      !< Parameters [-]
    TYPE(MD_OutputType)  :: y      !< System outputs [-]
    TYPE(MD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(MD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE MoorDyn_Data
! =======================
! =========  OrcaFlex_Data  =======
  TYPE, PUBLIC :: OrcaFlex_Data
    TYPE(Orca_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(Orca_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(Orca_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(Orca_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(Orca_ParameterType)  :: p      !< Parameters [-]
    TYPE(Orca_OutputType)  :: y      !< System outputs [-]
    TYPE(Orca_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(Orca_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE OrcaFlex_Data
! =======================
! =========  FAST_ExternInputType  =======
  TYPE, PUBLIC :: FAST_ExternInputType
    REAL(ReKi)  :: GenTrq = 0.0_ReKi      !< generator torque input from Simulink/Labview [-]
    REAL(ReKi)  :: ElecPwr = 0.0_ReKi      !< electric power input from Simulink/Labview [-]
    REAL(ReKi)  :: YawPosCom = 0.0_ReKi      !< yaw position command from Simulink/Labview [-]
    REAL(ReKi)  :: YawRateCom = 0.0_ReKi      !< yaw rate command from Simulink/Labview [-]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchCom = 0.0_ReKi      !< blade pitch commands from Simulink/Labview [rad]
    REAL(ReKi) , DIMENSION(1:3)  :: BlAirfoilCom = 0.0_ReKi      !< blade airfoil commands from Simulink/Labview [-]
    REAL(ReKi)  :: HSSBrFrac = 0.0_ReKi      !< Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full) from Simulink or LabVIEW [-]
    REAL(ReKi) , DIMENSION(1:3)  :: LidarFocus = 0.0_ReKi      !< lidar focus (relative to lidar location) [m]
    REAL(ReKi) , DIMENSION(1:20)  :: CableDeltaL = 0.0_ReKi      !< Cable control DeltaL [m]
    REAL(ReKi) , DIMENSION(1:20)  :: CableDeltaLdot = 0.0_ReKi      !< Cable control DeltaLdot [m/s]
  END TYPE FAST_ExternInputType
! =======================
! =========  FAST_MiscVarType  =======
  TYPE, PUBLIC :: FAST_MiscVarType
    REAL(DbKi)  :: TiLstPrn = 0.0_R8Ki      !< The simulation time of the last print (to file) [(s)]
    REAL(DbKi)  :: t_global = 0.0_R8Ki      !< Current simulation time (for global/FAST simulation) [(s)]
    REAL(DbKi)  :: NextJacCalcTime = 0.0_R8Ki      !< Time between calculating Jacobians in the HD-ED and SD-ED simulations [(s)]
    REAL(ReKi)  :: PrevClockTime = 0.0_ReKi      !< Clock time at start of simulation in seconds [(s)]
    REAL(ReKi)  :: UsrTime1 = 0.0_ReKi      !< User CPU time for simulation initialization [(s)]
    REAL(ReKi)  :: UsrTime2 = 0.0_ReKi      !< User CPU time for simulation (without intialization) [(s)]
    INTEGER(IntKi) , DIMENSION(1:8)  :: StrtTime = 0_IntKi      !< Start time of simulation (including intialization) [-]
    INTEGER(IntKi) , DIMENSION(1:8)  :: SimStrtTime = 0_IntKi      !< Start time of simulation (after initialization) [-]
    LOGICAL  :: calcJacobian = .false.      !< Should we calculate Jacobians in Option 1? [(flag)]
    TYPE(FAST_ExternInputType)  :: ExternInput      !< external input values [-]
    TYPE(FAST_MiscLinType)  :: Lin      !< misc data for linearization analysis [-]
  END TYPE FAST_MiscVarType
! =======================
! =========  FAST_InitData  =======
  TYPE, PUBLIC :: FAST_InitData
    TYPE(ED_InitInputType)  :: InData_ED      !< ED Initialization input data [-]
    TYPE(ED_InitOutputType) , DIMENSION(:), ALLOCATABLE  :: OutData_ED      !< ED Initialization output data [-]
    TYPE(SED_InitInputType)  :: InData_SED      !< SED Initialization input data [-]
    TYPE(SED_InitOutputType)  :: OutData_SED      !< SED Initialization output data [-]
    TYPE(BD_InitInputType)  :: InData_BD      !< BD Initialization input data [-]
    TYPE(BD_InitOutputType) , DIMENSION(:), ALLOCATABLE  :: OutData_BD      !< BD Initialization output data [-]
    TYPE(SrvD_InitInputType)  :: InData_SrvD      !< SrvD Initialization input data [-]
    TYPE(SrvD_InitOutputType)  :: OutData_SrvD      !< SrvD Initialization output data [-]
    TYPE(AD_InitInputType)  :: InData_AD      !< AD Initialization input data [-]
    TYPE(AD_InitOutputType)  :: OutData_AD      !< AD Initialization output data [-]
    TYPE(ADsk_InitInputType)  :: InData_ADsk      !< ADsk Initialization input data [-]
    TYPE(ADsk_InitOutputType)  :: OutData_ADsk      !< ADsk Initialization output data [-]
    TYPE(ExtLd_InitInputType)  :: InData_ExtLd      !< ExtLd Initialization input data [-]
    TYPE(ExtLd_InitOutputType)  :: OutData_ExtLd      !< ExtLd Initialization output data [-]
    TYPE(InflowWind_InitInputType)  :: InData_IfW      !< IfW Initialization input data [-]
    TYPE(InflowWind_InitOutputType)  :: OutData_IfW      !< IfW Initialization output data [-]
    TYPE(ExtInfw_InitInputType)  :: InData_ExtInfw      !< ExtInfw Initialization input data [-]
    TYPE(ExtInfw_InitOutputType)  :: OutData_ExtInfw      !< ExtInfw Initialization output data [-]
    TYPE(SeaSt_InitInputType)  :: InData_SeaSt      !< SeaSt Initialization input data [-]
    TYPE(SeaSt_InitOutputType)  :: OutData_SeaSt      !< SeaSt Initialization output data [-]
    TYPE(HydroDyn_InitInputType)  :: InData_HD      !< HD Initialization input data [-]
    TYPE(HydroDyn_InitOutputType)  :: OutData_HD      !< HD Initialization output data [-]
    TYPE(SD_InitInputType)  :: InData_SD      !< SD Initialization input data [-]
    TYPE(SD_InitOutputType)  :: OutData_SD      !< SD Initialization output data [-]
    TYPE(ExtPtfm_InitInputType)  :: InData_ExtPtfm      !< ExtPtfm Initialization input data [-]
    TYPE(ExtPtfm_InitOutputType)  :: OutData_ExtPtfm      !< ExtPtfm Initialization output data [-]
    TYPE(MAP_InitInputType)  :: InData_MAP      !< MAP Initialization input data [-]
    TYPE(MAP_InitOutputType)  :: OutData_MAP      !< MAP Initialization output data [-]
    TYPE(FEAM_InitInputType)  :: InData_FEAM      !< FEAM Initialization input data [-]
    TYPE(FEAM_InitOutputType)  :: OutData_FEAM      !< FEAM Initialization output data [-]
    TYPE(MD_InitInputType)  :: InData_MD      !< MD Initialization input data [-]
    TYPE(MD_InitOutputType)  :: OutData_MD      !< MD Initialization output data [-]
    TYPE(Orca_InitInputType)  :: InData_Orca      !< Orca Initialization input data [-]
    TYPE(Orca_InitOutputType)  :: OutData_Orca      !< Orca Initialization output data [-]
    TYPE(IceFloe_InitInputType)  :: InData_IceF      !< IceF Initialization input data [-]
    TYPE(IceFloe_InitOutputType)  :: OutData_IceF      !< IceF Initialization output data [-]
    TYPE(IceD_InitInputType)  :: InData_IceD      !< IceD Initialization input data [-]
    TYPE(IceD_InitOutputType)  :: OutData_IceD      !< IceD Initialization output data (each instance will have the same output channels) [-]
  END TYPE FAST_InitData
! =======================
! =========  FAST_ExternInitType  =======
  TYPE, PUBLIC :: FAST_ExternInitType
    REAL(DbKi)  :: Tmax = -1      !< External code specified Tmax [s]
    INTEGER(IntKi)  :: TurbIDforName = -1      !< ID number for turbine (used to create output file naming convention) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TurbinePos = 0.0_ReKi      !< Initial position of turbine base (origin used for graphics or in FAST.Farm) [m]
    INTEGER(IntKi)  :: WaveFieldMod = 0_IntKi      !< Wave field handling (-) (switch) 0: use individual HydroDyn inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    LOGICAL  :: FarmIntegration = .false.      !< whether this is called from FAST.Farm (or another program that doesn't want FAST to call all of the init stuff first) [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: windGrid_n = 0_IntKi      !< number of grid points in the x, y, z, and t directions for IfW [-]
    REAL(ReKi) , DIMENSION(1:4)  :: windGrid_delta = 0.0_ReKi      !< size between 2 consecutive grid points in each grid direction for IfW [m,m,m,s]
    REAL(ReKi) , DIMENSION(1:3)  :: windGrid_pZero = 0.0_ReKi      !< fixed position of the XYZ grid (i.e., XYZ coordinates of IfW m%V(:,1,1,1,:)) [m]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: windGrid_data => NULL()      !< Pointers to Wind velocity of disturbed wind (ambient + wakes) across each high-resolution domain around a turbine for each high-resolution step within a low-resolution step [m/s]
    CHARACTER(1024)  :: RootName      !< Root name of FAST output files (overrides normal operation) [-]
    INTEGER(IntKi)  :: NumActForcePtsBlade = 0_IntKi      !< number of actuator line force points in blade [-]
    INTEGER(IntKi)  :: NumActForcePtsTower = 0_IntKi      !< number of actuator line force points in tower [-]
    INTEGER(IntKi)  :: NodeClusterType = 0_IntKi      !< Node clustering for actuator line (0 - Uniform, 1 - Non-uniform clustered towards tip) [-]
    REAL(DbKi)  :: DTdriver = -1      !< External driver time step [s]
    LOGICAL  :: TwrAero = .false.      !< Is Tower aerodynamics enabled for ExtLoads module? [-]
    REAL(ReKi)  :: az_blend_mean = 0.0_ReKi      !< Mean azimuth at which to blend the external and aerodyn loads [-]
    REAL(ReKi)  :: az_blend_delta = 0.0_ReKi      !< Mean azimuth at which to blend the external and aerodyn loads [-]
  END TYPE FAST_ExternInitType
! =======================
! =========  FAST_TurbineType  =======
  TYPE, PUBLIC :: FAST_TurbineType
    INTEGER(IntKi)  :: TurbID = 1      !< Turbine ID Number [-]
    TYPE(FAST_ParameterType)  :: p_FAST      !< Parameters for the glue code [-]
    TYPE(FAST_OutputFileType)  :: y_FAST      !< Output variables for the glue code [-]
    TYPE(FAST_MiscVarType)  :: m_FAST      !< Miscellaneous variables [-]
    TYPE(Glue_ParameterType)  :: p_Glue      !< Parameters for the glue code [-]
    TYPE(Glue_OutputFileType)  :: y_Glue      !< Output variables for the glue code [-]
    TYPE(Glue_MiscVarType)  :: m_Glue      !< Miscellaneous variables [-]
    TYPE(ElastoDyn_Data)  :: ED      !< Data for the ElastoDyn module [-]
    TYPE(SED_Data)  :: SED      !< Data for the Simplified-ElastoDyn module [-]
    TYPE(BeamDyn_Data)  :: BD      !< Data for the BeamDyn module [-]
    TYPE(ServoDyn_Data)  :: SrvD      !< Data for the ServoDyn module [-]
    TYPE(AeroDyn_Data)  :: AD      !< Data for the AeroDyn module [-]
    TYPE(AeroDisk_Data)  :: ADsk      !< Data for the AeroDisk module [-]
    TYPE(ExtLoads_Data)  :: ExtLd      !< Data for the External loads module [-]
    TYPE(InflowWind_Data)  :: IfW      !< Data for InflowWind module [-]
    TYPE(ExternalInflow_Data)  :: ExtInfw      !< Data for ExternalInflow integration module [-]
    TYPE(SeaState_Data)  :: SeaSt      !< Data for the SeaState module [-]
    TYPE(HydroDyn_Data)  :: HD      !< Data for the HydroDyn module [-]
    TYPE(SubDyn_Data)  :: SD      !< Data for the SubDyn module [-]
    TYPE(MAP_Data)  :: MAP      !< Data for the MAP (Mooring Analysis Program) module [-]
    TYPE(FEAMooring_Data)  :: FEAM      !< Data for the FEAMooring module [-]
    TYPE(MoorDyn_Data)  :: MD      !< Data for the MoorDyn module [-]
    TYPE(OrcaFlex_Data)  :: Orca      !< Data for the OrcaFlex interface module [-]
    TYPE(IceFloe_Data)  :: IceF      !< Data for the IceFloe module [-]
    TYPE(IceDyn_Data)  :: IceD      !< Data for the IceDyn module [-]
    TYPE(ExtPtfm_Data)  :: ExtPtfm      !< Data for the ExtPtfm (external platform loading) module [-]
  END TYPE FAST_TurbineType
! =======================

contains

subroutine FAST_CopyVTK_BLSurfaceType(SrcVTK_BLSurfaceTypeData, DstVTK_BLSurfaceTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_VTK_BLSurfaceType), intent(in) :: SrcVTK_BLSurfaceTypeData
   type(FAST_VTK_BLSurfaceType), intent(inout) :: DstVTK_BLSurfaceTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'FAST_CopyVTK_BLSurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcVTK_BLSurfaceTypeData%AirfoilCoords)) then
      LB(1:3) = lbound(SrcVTK_BLSurfaceTypeData%AirfoilCoords)
      UB(1:3) = ubound(SrcVTK_BLSurfaceTypeData%AirfoilCoords)
      if (.not. allocated(DstVTK_BLSurfaceTypeData%AirfoilCoords)) then
         allocate(DstVTK_BLSurfaceTypeData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_BLSurfaceTypeData%AirfoilCoords.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_BLSurfaceTypeData%AirfoilCoords = SrcVTK_BLSurfaceTypeData%AirfoilCoords
   end if
end subroutine

subroutine FAST_DestroyVTK_BLSurfaceType(VTK_BLSurfaceTypeData, ErrStat, ErrMsg)
   type(FAST_VTK_BLSurfaceType), intent(inout) :: VTK_BLSurfaceTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyVTK_BLSurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VTK_BLSurfaceTypeData%AirfoilCoords)) then
      deallocate(VTK_BLSurfaceTypeData%AirfoilCoords)
   end if
end subroutine

subroutine FAST_PackVTK_BLSurfaceType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_VTK_BLSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_BLSurfaceType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%AirfoilCoords)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_BLSurfaceType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_VTK_BLSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_BLSurfaceType'
   integer(B4Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%AirfoilCoords); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyVTK_SurfaceType(SrcVTK_SurfaceTypeData, DstVTK_SurfaceTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_VTK_SurfaceType), intent(in) :: SrcVTK_SurfaceTypeData
   type(FAST_VTK_SurfaceType), intent(inout) :: DstVTK_SurfaceTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2, i3
   integer(B4Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyVTK_SurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVTK_SurfaceTypeData%NumSectors = SrcVTK_SurfaceTypeData%NumSectors
   DstVTK_SurfaceTypeData%HubRad = SrcVTK_SurfaceTypeData%HubRad
   DstVTK_SurfaceTypeData%GroundRad = SrcVTK_SurfaceTypeData%GroundRad
   DstVTK_SurfaceTypeData%NacelleBox = SrcVTK_SurfaceTypeData%NacelleBox
   if (allocated(SrcVTK_SurfaceTypeData%TowerRad)) then
      LB(1:1) = lbound(SrcVTK_SurfaceTypeData%TowerRad)
      UB(1:1) = ubound(SrcVTK_SurfaceTypeData%TowerRad)
      if (.not. allocated(DstVTK_SurfaceTypeData%TowerRad)) then
         allocate(DstVTK_SurfaceTypeData%TowerRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%TowerRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_SurfaceTypeData%TowerRad = SrcVTK_SurfaceTypeData%TowerRad
   end if
   DstVTK_SurfaceTypeData%NWaveElevPts = SrcVTK_SurfaceTypeData%NWaveElevPts
   if (allocated(SrcVTK_SurfaceTypeData%WaveElevVisX)) then
      LB(1:1) = lbound(SrcVTK_SurfaceTypeData%WaveElevVisX)
      UB(1:1) = ubound(SrcVTK_SurfaceTypeData%WaveElevVisX)
      if (.not. allocated(DstVTK_SurfaceTypeData%WaveElevVisX)) then
         allocate(DstVTK_SurfaceTypeData%WaveElevVisX(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%WaveElevVisX.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_SurfaceTypeData%WaveElevVisX = SrcVTK_SurfaceTypeData%WaveElevVisX
   end if
   if (allocated(SrcVTK_SurfaceTypeData%WaveElevVisY)) then
      LB(1:1) = lbound(SrcVTK_SurfaceTypeData%WaveElevVisY)
      UB(1:1) = ubound(SrcVTK_SurfaceTypeData%WaveElevVisY)
      if (.not. allocated(DstVTK_SurfaceTypeData%WaveElevVisY)) then
         allocate(DstVTK_SurfaceTypeData%WaveElevVisY(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%WaveElevVisY.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_SurfaceTypeData%WaveElevVisY = SrcVTK_SurfaceTypeData%WaveElevVisY
   end if
   if (allocated(SrcVTK_SurfaceTypeData%WaveElevVisGrid)) then
      LB(1:3) = lbound(SrcVTK_SurfaceTypeData%WaveElevVisGrid)
      UB(1:3) = ubound(SrcVTK_SurfaceTypeData%WaveElevVisGrid)
      if (.not. allocated(DstVTK_SurfaceTypeData%WaveElevVisGrid)) then
         allocate(DstVTK_SurfaceTypeData%WaveElevVisGrid(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%WaveElevVisGrid.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_SurfaceTypeData%WaveElevVisGrid = SrcVTK_SurfaceTypeData%WaveElevVisGrid
   end if
   if (allocated(SrcVTK_SurfaceTypeData%BladeShape)) then
      LB(1:1) = lbound(SrcVTK_SurfaceTypeData%BladeShape)
      UB(1:1) = ubound(SrcVTK_SurfaceTypeData%BladeShape)
      if (.not. allocated(DstVTK_SurfaceTypeData%BladeShape)) then
         allocate(DstVTK_SurfaceTypeData%BladeShape(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%BladeShape.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FAST_CopyVTK_BLSurfaceType(SrcVTK_SurfaceTypeData%BladeShape(i1), DstVTK_SurfaceTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcVTK_SurfaceTypeData%MorisonVisRad)) then
      LB(1:1) = lbound(SrcVTK_SurfaceTypeData%MorisonVisRad)
      UB(1:1) = ubound(SrcVTK_SurfaceTypeData%MorisonVisRad)
      if (.not. allocated(DstVTK_SurfaceTypeData%MorisonVisRad)) then
         allocate(DstVTK_SurfaceTypeData%MorisonVisRad(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%MorisonVisRad.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_SurfaceTypeData%MorisonVisRad = SrcVTK_SurfaceTypeData%MorisonVisRad
   end if
end subroutine

subroutine FAST_DestroyVTK_SurfaceType(VTK_SurfaceTypeData, ErrStat, ErrMsg)
   type(FAST_VTK_SurfaceType), intent(inout) :: VTK_SurfaceTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2, i3
   integer(B4Ki)   :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyVTK_SurfaceType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VTK_SurfaceTypeData%TowerRad)) then
      deallocate(VTK_SurfaceTypeData%TowerRad)
   end if
   if (allocated(VTK_SurfaceTypeData%WaveElevVisX)) then
      deallocate(VTK_SurfaceTypeData%WaveElevVisX)
   end if
   if (allocated(VTK_SurfaceTypeData%WaveElevVisY)) then
      deallocate(VTK_SurfaceTypeData%WaveElevVisY)
   end if
   if (allocated(VTK_SurfaceTypeData%WaveElevVisGrid)) then
      deallocate(VTK_SurfaceTypeData%WaveElevVisGrid)
   end if
   if (allocated(VTK_SurfaceTypeData%BladeShape)) then
      LB(1:1) = lbound(VTK_SurfaceTypeData%BladeShape)
      UB(1:1) = ubound(VTK_SurfaceTypeData%BladeShape)
      do i1 = LB(1), UB(1)
         call FAST_DestroyVTK_BLSurfaceType(VTK_SurfaceTypeData%BladeShape(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(VTK_SurfaceTypeData%BladeShape)
   end if
   if (allocated(VTK_SurfaceTypeData%MorisonVisRad)) then
      deallocate(VTK_SurfaceTypeData%MorisonVisRad)
   end if
end subroutine

subroutine FAST_PackVTK_SurfaceType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_VTK_SurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_SurfaceType'
   integer(B4Ki)   :: i1, i2, i3
   integer(B4Ki)   :: LB(3), UB(3)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumSectors)
   call RegPack(RF, InData%HubRad)
   call RegPack(RF, InData%GroundRad)
   call RegPack(RF, InData%NacelleBox)
   call RegPackAlloc(RF, InData%TowerRad)
   call RegPack(RF, InData%NWaveElevPts)
   call RegPackAlloc(RF, InData%WaveElevVisX)
   call RegPackAlloc(RF, InData%WaveElevVisY)
   call RegPackAlloc(RF, InData%WaveElevVisGrid)
   call RegPack(RF, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call FAST_PackVTK_BLSurfaceType(RF, InData%BladeShape(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%MorisonVisRad)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_SurfaceType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_VTK_SurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_SurfaceType'
   integer(B4Ki)   :: i1, i2, i3
   integer(B4Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumSectors); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HubRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%GroundRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NacelleBox); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TowerRad); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NWaveElevPts); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElevVisX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElevVisY); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WaveElevVisGrid); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FAST_UnpackVTK_BLSurfaceType(RF, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%MorisonVisRad); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyVTK_ModeShapeType(SrcVTK_ModeShapeTypeData, DstVTK_ModeShapeTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_VTK_ModeShapeType), intent(in) :: SrcVTK_ModeShapeTypeData
   type(FAST_VTK_ModeShapeType), intent(inout) :: DstVTK_ModeShapeTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'FAST_CopyVTK_ModeShapeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstVTK_ModeShapeTypeData%CheckpointRoot = SrcVTK_ModeShapeTypeData%CheckpointRoot
   DstVTK_ModeShapeTypeData%MatlabFileName = SrcVTK_ModeShapeTypeData%MatlabFileName
   DstVTK_ModeShapeTypeData%VTKLinModes = SrcVTK_ModeShapeTypeData%VTKLinModes
   if (allocated(SrcVTK_ModeShapeTypeData%VTKModes)) then
      LB(1:1) = lbound(SrcVTK_ModeShapeTypeData%VTKModes)
      UB(1:1) = ubound(SrcVTK_ModeShapeTypeData%VTKModes)
      if (.not. allocated(DstVTK_ModeShapeTypeData%VTKModes)) then
         allocate(DstVTK_ModeShapeTypeData%VTKModes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%VTKModes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%VTKModes = SrcVTK_ModeShapeTypeData%VTKModes
   end if
   DstVTK_ModeShapeTypeData%VTKLinTim = SrcVTK_ModeShapeTypeData%VTKLinTim
   DstVTK_ModeShapeTypeData%VTKNLinTimes = SrcVTK_ModeShapeTypeData%VTKNLinTimes
   DstVTK_ModeShapeTypeData%VTKLinScale = SrcVTK_ModeShapeTypeData%VTKLinScale
   DstVTK_ModeShapeTypeData%VTKLinPhase = SrcVTK_ModeShapeTypeData%VTKLinPhase
   if (allocated(SrcVTK_ModeShapeTypeData%DampingRatio)) then
      LB(1:1) = lbound(SrcVTK_ModeShapeTypeData%DampingRatio)
      UB(1:1) = ubound(SrcVTK_ModeShapeTypeData%DampingRatio)
      if (.not. allocated(DstVTK_ModeShapeTypeData%DampingRatio)) then
         allocate(DstVTK_ModeShapeTypeData%DampingRatio(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%DampingRatio.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%DampingRatio = SrcVTK_ModeShapeTypeData%DampingRatio
   end if
   if (allocated(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz)) then
      LB(1:1) = lbound(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz)
      UB(1:1) = ubound(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz)
      if (.not. allocated(DstVTK_ModeShapeTypeData%NaturalFreq_Hz)) then
         allocate(DstVTK_ModeShapeTypeData%NaturalFreq_Hz(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%NaturalFreq_Hz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%NaturalFreq_Hz = SrcVTK_ModeShapeTypeData%NaturalFreq_Hz
   end if
   if (allocated(SrcVTK_ModeShapeTypeData%DampedFreq_Hz)) then
      LB(1:1) = lbound(SrcVTK_ModeShapeTypeData%DampedFreq_Hz)
      UB(1:1) = ubound(SrcVTK_ModeShapeTypeData%DampedFreq_Hz)
      if (.not. allocated(DstVTK_ModeShapeTypeData%DampedFreq_Hz)) then
         allocate(DstVTK_ModeShapeTypeData%DampedFreq_Hz(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%DampedFreq_Hz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%DampedFreq_Hz = SrcVTK_ModeShapeTypeData%DampedFreq_Hz
   end if
   if (allocated(SrcVTK_ModeShapeTypeData%x_eig_magnitude)) then
      LB(1:3) = lbound(SrcVTK_ModeShapeTypeData%x_eig_magnitude)
      UB(1:3) = ubound(SrcVTK_ModeShapeTypeData%x_eig_magnitude)
      if (.not. allocated(DstVTK_ModeShapeTypeData%x_eig_magnitude)) then
         allocate(DstVTK_ModeShapeTypeData%x_eig_magnitude(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%x_eig_magnitude.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%x_eig_magnitude = SrcVTK_ModeShapeTypeData%x_eig_magnitude
   end if
   if (allocated(SrcVTK_ModeShapeTypeData%x_eig_phase)) then
      LB(1:3) = lbound(SrcVTK_ModeShapeTypeData%x_eig_phase)
      UB(1:3) = ubound(SrcVTK_ModeShapeTypeData%x_eig_phase)
      if (.not. allocated(DstVTK_ModeShapeTypeData%x_eig_phase)) then
         allocate(DstVTK_ModeShapeTypeData%x_eig_phase(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%x_eig_phase.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVTK_ModeShapeTypeData%x_eig_phase = SrcVTK_ModeShapeTypeData%x_eig_phase
   end if
end subroutine

subroutine FAST_DestroyVTK_ModeShapeType(VTK_ModeShapeTypeData, ErrStat, ErrMsg)
   type(FAST_VTK_ModeShapeType), intent(inout) :: VTK_ModeShapeTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyVTK_ModeShapeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VTK_ModeShapeTypeData%VTKModes)) then
      deallocate(VTK_ModeShapeTypeData%VTKModes)
   end if
   if (allocated(VTK_ModeShapeTypeData%DampingRatio)) then
      deallocate(VTK_ModeShapeTypeData%DampingRatio)
   end if
   if (allocated(VTK_ModeShapeTypeData%NaturalFreq_Hz)) then
      deallocate(VTK_ModeShapeTypeData%NaturalFreq_Hz)
   end if
   if (allocated(VTK_ModeShapeTypeData%DampedFreq_Hz)) then
      deallocate(VTK_ModeShapeTypeData%DampedFreq_Hz)
   end if
   if (allocated(VTK_ModeShapeTypeData%x_eig_magnitude)) then
      deallocate(VTK_ModeShapeTypeData%x_eig_magnitude)
   end if
   if (allocated(VTK_ModeShapeTypeData%x_eig_phase)) then
      deallocate(VTK_ModeShapeTypeData%x_eig_phase)
   end if
end subroutine

subroutine FAST_PackVTK_ModeShapeType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_VTK_ModeShapeType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_ModeShapeType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%CheckpointRoot)
   call RegPack(RF, InData%MatlabFileName)
   call RegPack(RF, InData%VTKLinModes)
   call RegPackAlloc(RF, InData%VTKModes)
   call RegPack(RF, InData%VTKLinTim)
   call RegPack(RF, InData%VTKNLinTimes)
   call RegPack(RF, InData%VTKLinScale)
   call RegPack(RF, InData%VTKLinPhase)
   call RegPackAlloc(RF, InData%DampingRatio)
   call RegPackAlloc(RF, InData%NaturalFreq_Hz)
   call RegPackAlloc(RF, InData%DampedFreq_Hz)
   call RegPackAlloc(RF, InData%x_eig_magnitude)
   call RegPackAlloc(RF, InData%x_eig_phase)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_ModeShapeType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_VTK_ModeShapeType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_ModeShapeType'
   integer(B4Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%CheckpointRoot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MatlabFileName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKLinModes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%VTKModes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKLinTim); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKNLinTimes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKLinScale); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTKLinPhase); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DampingRatio); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NaturalFreq_Hz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DampedFreq_Hz); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_eig_magnitude); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%x_eig_phase); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_ParameterType), intent(in) :: SrcParamData
   type(FAST_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT = SrcParamData%DT
   DstParamData%DT_module = SrcParamData%DT_module
   DstParamData%n_substeps = SrcParamData%n_substeps
   DstParamData%n_TMax_m1 = SrcParamData%n_TMax_m1
   DstParamData%TMax = SrcParamData%TMax
   DstParamData%InterpOrder = SrcParamData%InterpOrder
   DstParamData%NumCrctn = SrcParamData%NumCrctn
   DstParamData%KMax = SrcParamData%KMax
   DstParamData%numIceLegs = SrcParamData%numIceLegs
   DstParamData%nBeams = SrcParamData%nBeams
   DstParamData%BD_OutputSibling = SrcParamData%BD_OutputSibling
   DstParamData%RhoInf = SrcParamData%RhoInf
   DstParamData%ConvTol = SrcParamData%ConvTol
   DstParamData%MaxConvIter = SrcParamData%MaxConvIter
   DstParamData%DT_Ujac = SrcParamData%DT_Ujac
   DstParamData%UJacSclFact = SrcParamData%UJacSclFact
   DstParamData%SizeJac_Opt1 = SrcParamData%SizeJac_Opt1
   DstParamData%SolveOption = SrcParamData%SolveOption
   DstParamData%CompElast = SrcParamData%CompElast
   DstParamData%CompInflow = SrcParamData%CompInflow
   DstParamData%CompAero = SrcParamData%CompAero
   DstParamData%CompServo = SrcParamData%CompServo
   DstParamData%CompSeaSt = SrcParamData%CompSeaSt
   DstParamData%CompHydro = SrcParamData%CompHydro
   DstParamData%CompSub = SrcParamData%CompSub
   DstParamData%CompMooring = SrcParamData%CompMooring
   DstParamData%CompIce = SrcParamData%CompIce
   DstParamData%MHK = SrcParamData%MHK
   DstParamData%UseDWM = SrcParamData%UseDWM
   DstParamData%Linearize = SrcParamData%Linearize
   DstParamData%WaveFieldMod = SrcParamData%WaveFieldMod
   DstParamData%FarmIntegration = SrcParamData%FarmIntegration
   DstParamData%TurbinePos = SrcParamData%TurbinePos
   DstParamData%Gravity = SrcParamData%Gravity
   DstParamData%AirDens = SrcParamData%AirDens
   DstParamData%WtrDens = SrcParamData%WtrDens
   DstParamData%KinVisc = SrcParamData%KinVisc
   DstParamData%SpdSound = SrcParamData%SpdSound
   DstParamData%Patm = SrcParamData%Patm
   DstParamData%Pvap = SrcParamData%Pvap
   DstParamData%WtrDpth = SrcParamData%WtrDpth
   DstParamData%MSL2SWL = SrcParamData%MSL2SWL
   DstParamData%EDFile = SrcParamData%EDFile
   DstParamData%BDBldFile = SrcParamData%BDBldFile
   DstParamData%InflowFile = SrcParamData%InflowFile
   DstParamData%AeroFile = SrcParamData%AeroFile
   DstParamData%ServoFile = SrcParamData%ServoFile
   DstParamData%SeaStFile = SrcParamData%SeaStFile
   DstParamData%HydroFile = SrcParamData%HydroFile
   DstParamData%SubFile = SrcParamData%SubFile
   DstParamData%MooringFile = SrcParamData%MooringFile
   DstParamData%IceFile = SrcParamData%IceFile
   DstParamData%TStart = SrcParamData%TStart
   DstParamData%DT_Out = SrcParamData%DT_Out
   DstParamData%WrSttsTime = SrcParamData%WrSttsTime
   DstParamData%n_SttsTime = SrcParamData%n_SttsTime
   DstParamData%n_ChkptTime = SrcParamData%n_ChkptTime
   DstParamData%n_DT_Out = SrcParamData%n_DT_Out
   DstParamData%n_VTKTime = SrcParamData%n_VTKTime
   DstParamData%WrBinOutFile = SrcParamData%WrBinOutFile
   DstParamData%WrTxtOutFile = SrcParamData%WrTxtOutFile
   DstParamData%WrBinMod = SrcParamData%WrBinMod
   DstParamData%SumPrint = SrcParamData%SumPrint
   DstParamData%WrVTK = SrcParamData%WrVTK
   DstParamData%VTK_Type = SrcParamData%VTK_Type
   DstParamData%VTK_fields = SrcParamData%VTK_fields
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutFmt_t = SrcParamData%OutFmt_t
   DstParamData%FmtWidth = SrcParamData%FmtWidth
   DstParamData%TChanLen = SrcParamData%TChanLen
   DstParamData%OutFileRoot = SrcParamData%OutFileRoot
   DstParamData%FTitle = SrcParamData%FTitle
   DstParamData%VTK_OutFileRoot = SrcParamData%VTK_OutFileRoot
   DstParamData%VTK_tWidth = SrcParamData%VTK_tWidth
   DstParamData%VTK_fps = SrcParamData%VTK_fps
   call FAST_CopyVTK_SurfaceType(SrcParamData%VTK_surface, DstParamData%VTK_surface, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%Tdesc = SrcParamData%Tdesc
   DstParamData%PlatformPosInit = SrcParamData%PlatformPosInit
   DstParamData%CalcSteady = SrcParamData%CalcSteady
   DstParamData%TrimCase = SrcParamData%TrimCase
   DstParamData%TrimTol = SrcParamData%TrimTol
   DstParamData%TrimGain = SrcParamData%TrimGain
   DstParamData%Twr_Kdmp = SrcParamData%Twr_Kdmp
   DstParamData%Bld_Kdmp = SrcParamData%Bld_Kdmp
   DstParamData%NLinTimes = SrcParamData%NLinTimes
   DstParamData%AzimDelta = SrcParamData%AzimDelta
   DstParamData%LinInputs = SrcParamData%LinInputs
   DstParamData%LinOutputs = SrcParamData%LinOutputs
   DstParamData%LinOutJac = SrcParamData%LinOutJac
   DstParamData%LinOutMod = SrcParamData%LinOutMod
   call FAST_CopyVTK_ModeShapeType(SrcParamData%VTK_modes, DstParamData%VTK_modes, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%Lin_NumMods = SrcParamData%Lin_NumMods
   DstParamData%Lin_ModOrder = SrcParamData%Lin_ModOrder
   DstParamData%LinInterpOrder = SrcParamData%LinInterpOrder
   DstParamData%CompAeroMaps = SrcParamData%CompAeroMaps
   DstParamData%N_UJac = SrcParamData%N_UJac
   DstParamData%NumBl_Lin = SrcParamData%NumBl_Lin
   DstParamData%tolerSquared = SrcParamData%tolerSquared
   DstParamData%NumSSCases = SrcParamData%NumSSCases
   DstParamData%WindSpeedOrTSR = SrcParamData%WindSpeedOrTSR
   DstParamData%RotSpeedInit = SrcParamData%RotSpeedInit
   if (allocated(SrcParamData%RotSpeed)) then
      LB(1:1) = lbound(SrcParamData%RotSpeed)
      UB(1:1) = ubound(SrcParamData%RotSpeed)
      if (.not. allocated(DstParamData%RotSpeed)) then
         allocate(DstParamData%RotSpeed(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%RotSpeed.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%RotSpeed = SrcParamData%RotSpeed
   end if
   if (allocated(SrcParamData%WS_TSR)) then
      LB(1:1) = lbound(SrcParamData%WS_TSR)
      UB(1:1) = ubound(SrcParamData%WS_TSR)
      if (.not. allocated(DstParamData%WS_TSR)) then
         allocate(DstParamData%WS_TSR(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WS_TSR.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%WS_TSR = SrcParamData%WS_TSR
   end if
   if (allocated(SrcParamData%Pitch)) then
      LB(1:1) = lbound(SrcParamData%Pitch)
      UB(1:1) = ubound(SrcParamData%Pitch)
      if (.not. allocated(DstParamData%Pitch)) then
         allocate(DstParamData%Pitch(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Pitch.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%Pitch = SrcParamData%Pitch
   end if
   DstParamData%GearBox_index = SrcParamData%GearBox_index
end subroutine

subroutine FAST_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(FAST_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call FAST_DestroyVTK_SurfaceType(ParamData%VTK_surface, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyVTK_ModeShapeType(ParamData%VTK_modes, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ParamData%RotSpeed)) then
      deallocate(ParamData%RotSpeed)
   end if
   if (allocated(ParamData%WS_TSR)) then
      deallocate(ParamData%WS_TSR)
   end if
   if (allocated(ParamData%Pitch)) then
      deallocate(ParamData%Pitch)
   end if
end subroutine

subroutine FAST_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackParam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DT)
   call RegPack(RF, InData%DT_module)
   call RegPack(RF, InData%n_substeps)
   call RegPack(RF, InData%n_TMax_m1)
   call RegPack(RF, InData%TMax)
   call RegPack(RF, InData%InterpOrder)
   call RegPack(RF, InData%NumCrctn)
   call RegPack(RF, InData%KMax)
   call RegPack(RF, InData%numIceLegs)
   call RegPack(RF, InData%nBeams)
   call RegPack(RF, InData%BD_OutputSibling)
   call RegPack(RF, InData%RhoInf)
   call RegPack(RF, InData%ConvTol)
   call RegPack(RF, InData%MaxConvIter)
   call RegPack(RF, InData%DT_Ujac)
   call RegPack(RF, InData%UJacSclFact)
   call RegPack(RF, InData%SizeJac_Opt1)
   call RegPack(RF, InData%SolveOption)
   call RegPack(RF, InData%CompElast)
   call RegPack(RF, InData%CompInflow)
   call RegPack(RF, InData%CompAero)
   call RegPack(RF, InData%CompServo)
   call RegPack(RF, InData%CompSeaSt)
   call RegPack(RF, InData%CompHydro)
   call RegPack(RF, InData%CompSub)
   call RegPack(RF, InData%CompMooring)
   call RegPack(RF, InData%CompIce)
   call RegPack(RF, InData%MHK)
   call RegPack(RF, InData%UseDWM)
   call RegPack(RF, InData%Linearize)
   call RegPack(RF, InData%WaveFieldMod)
   call RegPack(RF, InData%FarmIntegration)
   call RegPack(RF, InData%TurbinePos)
   call RegPack(RF, InData%Gravity)
   call RegPack(RF, InData%AirDens)
   call RegPack(RF, InData%WtrDens)
   call RegPack(RF, InData%KinVisc)
   call RegPack(RF, InData%SpdSound)
   call RegPack(RF, InData%Patm)
   call RegPack(RF, InData%Pvap)
   call RegPack(RF, InData%WtrDpth)
   call RegPack(RF, InData%MSL2SWL)
   call RegPack(RF, InData%EDFile)
   call RegPack(RF, InData%BDBldFile)
   call RegPack(RF, InData%InflowFile)
   call RegPack(RF, InData%AeroFile)
   call RegPack(RF, InData%ServoFile)
   call RegPack(RF, InData%SeaStFile)
   call RegPack(RF, InData%HydroFile)
   call RegPack(RF, InData%SubFile)
   call RegPack(RF, InData%MooringFile)
   call RegPack(RF, InData%IceFile)
   call RegPack(RF, InData%TStart)
   call RegPack(RF, InData%DT_Out)
   call RegPack(RF, InData%WrSttsTime)
   call RegPack(RF, InData%n_SttsTime)
   call RegPack(RF, InData%n_ChkptTime)
   call RegPack(RF, InData%n_DT_Out)
   call RegPack(RF, InData%n_VTKTime)
   call RegPack(RF, InData%WrBinOutFile)
   call RegPack(RF, InData%WrTxtOutFile)
   call RegPack(RF, InData%WrBinMod)
   call RegPack(RF, InData%SumPrint)
   call RegPack(RF, InData%WrVTK)
   call RegPack(RF, InData%VTK_Type)
   call RegPack(RF, InData%VTK_fields)
   call RegPack(RF, InData%Delim)
   call RegPack(RF, InData%OutFmt)
   call RegPack(RF, InData%OutFmt_t)
   call RegPack(RF, InData%FmtWidth)
   call RegPack(RF, InData%TChanLen)
   call RegPack(RF, InData%OutFileRoot)
   call RegPack(RF, InData%FTitle)
   call RegPack(RF, InData%VTK_OutFileRoot)
   call RegPack(RF, InData%VTK_tWidth)
   call RegPack(RF, InData%VTK_fps)
   call FAST_PackVTK_SurfaceType(RF, InData%VTK_surface) 
   call RegPack(RF, InData%Tdesc)
   call RegPack(RF, InData%PlatformPosInit)
   call RegPack(RF, InData%CalcSteady)
   call RegPack(RF, InData%TrimCase)
   call RegPack(RF, InData%TrimTol)
   call RegPack(RF, InData%TrimGain)
   call RegPack(RF, InData%Twr_Kdmp)
   call RegPack(RF, InData%Bld_Kdmp)
   call RegPack(RF, InData%NLinTimes)
   call RegPack(RF, InData%AzimDelta)
   call RegPack(RF, InData%LinInputs)
   call RegPack(RF, InData%LinOutputs)
   call RegPack(RF, InData%LinOutJac)
   call RegPack(RF, InData%LinOutMod)
   call FAST_PackVTK_ModeShapeType(RF, InData%VTK_modes) 
   call RegPack(RF, InData%Lin_NumMods)
   call RegPack(RF, InData%Lin_ModOrder)
   call RegPack(RF, InData%LinInterpOrder)
   call RegPack(RF, InData%CompAeroMaps)
   call RegPack(RF, InData%N_UJac)
   call RegPack(RF, InData%NumBl_Lin)
   call RegPack(RF, InData%tolerSquared)
   call RegPack(RF, InData%NumSSCases)
   call RegPack(RF, InData%WindSpeedOrTSR)
   call RegPack(RF, InData%RotSpeedInit)
   call RegPackAlloc(RF, InData%RotSpeed)
   call RegPackAlloc(RF, InData%WS_TSR)
   call RegPackAlloc(RF, InData%Pitch)
   call RegPack(RF, InData%GearBox_index)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackParam'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT_module); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_substeps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_TMax_m1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TMax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InterpOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumCrctn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%KMax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numIceLegs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nBeams); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BD_OutputSibling); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RhoInf); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ConvTol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MaxConvIter); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT_Ujac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UJacSclFact); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SizeJac_Opt1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SolveOption); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompElast); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompInflow); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompAero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompServo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompSeaSt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompHydro); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompSub); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompMooring); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompIce); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MHK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UseDWM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Linearize); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveFieldMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FarmIntegration); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TurbinePos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Gravity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AirDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDens); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%KinVisc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SpdSound); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Patm); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Pvap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MSL2SWL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EDFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BDBldFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%InflowFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AeroFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ServoFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SeaStFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HydroFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SubFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MooringFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IceFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TStart); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DT_Out); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrSttsTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_SttsTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_ChkptTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_DT_Out); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_VTKTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrBinOutFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrTxtOutFile); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrBinMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SumPrint); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WrVTK); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_Type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_fields); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Delim); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFmt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFmt_t); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FmtWidth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TChanLen); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFileRoot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FTitle); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_OutFileRoot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_tWidth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_fps); if (RegCheckErr(RF, RoutineName)) return
   call FAST_UnpackVTK_SurfaceType(RF, OutData%VTK_surface) ! VTK_surface 
   call RegUnpack(RF, OutData%Tdesc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PlatformPosInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CalcSteady); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TrimCase); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TrimTol); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TrimGain); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Twr_Kdmp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Bld_Kdmp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NLinTimes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimDelta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinInputs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinOutputs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinOutJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinOutMod); if (RegCheckErr(RF, RoutineName)) return
   call FAST_UnpackVTK_ModeShapeType(RF, OutData%VTK_modes) ! VTK_modes 
   call RegUnpack(RF, OutData%Lin_NumMods); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Lin_ModOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LinInterpOrder); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CompAeroMaps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%N_UJac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumBl_Lin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%tolerSquared); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumSSCases); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WindSpeedOrTSR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RotSpeedInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%WS_TSR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Pitch); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%GearBox_index); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyLinFileType(SrcLinFileTypeData, DstLinFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_LinFileType), intent(in) :: SrcLinFileTypeData
   type(FAST_LinFileType), intent(inout) :: DstLinFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_CopyLinFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinFileTypeData%RotSpeed = SrcLinFileTypeData%RotSpeed
   DstLinFileTypeData%Azimuth = SrcLinFileTypeData%Azimuth
   DstLinFileTypeData%WindSpeed = SrcLinFileTypeData%WindSpeed
end subroutine

subroutine FAST_DestroyLinFileType(LinFileTypeData, ErrStat, ErrMsg)
   type(FAST_LinFileType), intent(inout) :: LinFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyLinFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine FAST_PackLinFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_LinFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackLinFileType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%RotSpeed)
   call RegPack(RF, InData%Azimuth)
   call RegPack(RF, InData%WindSpeed)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackLinFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_LinFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackLinFileType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%RotSpeed); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Azimuth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WindSpeed); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyMiscLinType(SrcMiscLinTypeData, DstMiscLinTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_MiscLinType), intent(in) :: SrcMiscLinTypeData
   type(FAST_MiscLinType), intent(inout) :: DstMiscLinTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'FAST_CopyMiscLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscLinTypeData%LinTimes)) then
      LB(1:1) = lbound(SrcMiscLinTypeData%LinTimes)
      UB(1:1) = ubound(SrcMiscLinTypeData%LinTimes)
      if (.not. allocated(DstMiscLinTypeData%LinTimes)) then
         allocate(DstMiscLinTypeData%LinTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%LinTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%LinTimes = SrcMiscLinTypeData%LinTimes
   end if
   DstMiscLinTypeData%CopyOP_CtrlCode = SrcMiscLinTypeData%CopyOP_CtrlCode
   if (allocated(SrcMiscLinTypeData%AzimTarget)) then
      LB(1:1) = lbound(SrcMiscLinTypeData%AzimTarget)
      UB(1:1) = ubound(SrcMiscLinTypeData%AzimTarget)
      if (.not. allocated(DstMiscLinTypeData%AzimTarget)) then
         allocate(DstMiscLinTypeData%AzimTarget(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%AzimTarget.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%AzimTarget = SrcMiscLinTypeData%AzimTarget
   end if
   DstMiscLinTypeData%IsConverged = SrcMiscLinTypeData%IsConverged
   DstMiscLinTypeData%FoundSteady = SrcMiscLinTypeData%FoundSteady
   DstMiscLinTypeData%ForceLin = SrcMiscLinTypeData%ForceLin
   DstMiscLinTypeData%n_rot = SrcMiscLinTypeData%n_rot
   DstMiscLinTypeData%AzimIndx = SrcMiscLinTypeData%AzimIndx
   DstMiscLinTypeData%NextLinTimeIndx = SrcMiscLinTypeData%NextLinTimeIndx
   if (allocated(SrcMiscLinTypeData%Psi)) then
      LB(1:1) = lbound(SrcMiscLinTypeData%Psi)
      UB(1:1) = ubound(SrcMiscLinTypeData%Psi)
      if (.not. allocated(DstMiscLinTypeData%Psi)) then
         allocate(DstMiscLinTypeData%Psi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%Psi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%Psi = SrcMiscLinTypeData%Psi
   end if
   if (allocated(SrcMiscLinTypeData%y_interp)) then
      LB(1:1) = lbound(SrcMiscLinTypeData%y_interp)
      UB(1:1) = ubound(SrcMiscLinTypeData%y_interp)
      if (.not. allocated(DstMiscLinTypeData%y_interp)) then
         allocate(DstMiscLinTypeData%y_interp(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%y_interp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%y_interp = SrcMiscLinTypeData%y_interp
   end if
   if (allocated(SrcMiscLinTypeData%y_ref)) then
      LB(1:1) = lbound(SrcMiscLinTypeData%y_ref)
      UB(1:1) = ubound(SrcMiscLinTypeData%y_ref)
      if (.not. allocated(DstMiscLinTypeData%y_ref)) then
         allocate(DstMiscLinTypeData%y_ref(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%y_ref.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%y_ref = SrcMiscLinTypeData%y_ref
   end if
   if (allocated(SrcMiscLinTypeData%Y_prevRot)) then
      LB(1:2) = lbound(SrcMiscLinTypeData%Y_prevRot)
      UB(1:2) = ubound(SrcMiscLinTypeData%Y_prevRot)
      if (.not. allocated(DstMiscLinTypeData%Y_prevRot)) then
         allocate(DstMiscLinTypeData%Y_prevRot(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%Y_prevRot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscLinTypeData%Y_prevRot = SrcMiscLinTypeData%Y_prevRot
   end if
end subroutine

subroutine FAST_DestroyMiscLinType(MiscLinTypeData, ErrStat, ErrMsg)
   type(FAST_MiscLinType), intent(inout) :: MiscLinTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyMiscLinType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscLinTypeData%LinTimes)) then
      deallocate(MiscLinTypeData%LinTimes)
   end if
   if (allocated(MiscLinTypeData%AzimTarget)) then
      deallocate(MiscLinTypeData%AzimTarget)
   end if
   if (allocated(MiscLinTypeData%Psi)) then
      deallocate(MiscLinTypeData%Psi)
   end if
   if (allocated(MiscLinTypeData%y_interp)) then
      deallocate(MiscLinTypeData%y_interp)
   end if
   if (allocated(MiscLinTypeData%y_ref)) then
      deallocate(MiscLinTypeData%y_ref)
   end if
   if (allocated(MiscLinTypeData%Y_prevRot)) then
      deallocate(MiscLinTypeData%Y_prevRot)
   end if
end subroutine

subroutine FAST_PackMiscLinType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_MiscLinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMiscLinType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%LinTimes)
   call RegPack(RF, InData%CopyOP_CtrlCode)
   call RegPackAlloc(RF, InData%AzimTarget)
   call RegPack(RF, InData%IsConverged)
   call RegPack(RF, InData%FoundSteady)
   call RegPack(RF, InData%ForceLin)
   call RegPack(RF, InData%n_rot)
   call RegPack(RF, InData%AzimIndx)
   call RegPack(RF, InData%NextLinTimeIndx)
   call RegPackAlloc(RF, InData%Psi)
   call RegPackAlloc(RF, InData%y_interp)
   call RegPackAlloc(RF, InData%y_ref)
   call RegPackAlloc(RF, InData%Y_prevRot)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackMiscLinType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_MiscLinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMiscLinType'
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%LinTimes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CopyOP_CtrlCode); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AzimTarget); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%IsConverged); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FoundSteady); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ForceLin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_rot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AzimIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NextLinTimeIndx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Psi); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_interp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%y_ref); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Y_prevRot); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyOutputFileType(SrcOutputFileTypeData, DstOutputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_OutputFileType), intent(in) :: SrcOutputFileTypeData
   type(FAST_OutputFileType), intent(inout) :: DstOutputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputFileTypeData%TimeData)) then
      LB(1:1) = lbound(SrcOutputFileTypeData%TimeData)
      UB(1:1) = ubound(SrcOutputFileTypeData%TimeData)
      if (.not. allocated(DstOutputFileTypeData%TimeData)) then
         allocate(DstOutputFileTypeData%TimeData(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%TimeData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputFileTypeData%TimeData = SrcOutputFileTypeData%TimeData
   end if
   if (allocated(SrcOutputFileTypeData%AllOutData)) then
      LB(1:2) = lbound(SrcOutputFileTypeData%AllOutData)
      UB(1:2) = ubound(SrcOutputFileTypeData%AllOutData)
      if (.not. allocated(DstOutputFileTypeData%AllOutData)) then
         allocate(DstOutputFileTypeData%AllOutData(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%AllOutData.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputFileTypeData%AllOutData = SrcOutputFileTypeData%AllOutData
   end if
   DstOutputFileTypeData%n_Out = SrcOutputFileTypeData%n_Out
   DstOutputFileTypeData%NOutSteps = SrcOutputFileTypeData%NOutSteps
   DstOutputFileTypeData%numOuts = SrcOutputFileTypeData%numOuts
   DstOutputFileTypeData%UnOu = SrcOutputFileTypeData%UnOu
   DstOutputFileTypeData%UnSum = SrcOutputFileTypeData%UnSum
   DstOutputFileTypeData%UnGra = SrcOutputFileTypeData%UnGra
   DstOutputFileTypeData%FileDescLines = SrcOutputFileTypeData%FileDescLines
   if (allocated(SrcOutputFileTypeData%ChannelNames)) then
      LB(1:1) = lbound(SrcOutputFileTypeData%ChannelNames)
      UB(1:1) = ubound(SrcOutputFileTypeData%ChannelNames)
      if (.not. allocated(DstOutputFileTypeData%ChannelNames)) then
         allocate(DstOutputFileTypeData%ChannelNames(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%ChannelNames.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputFileTypeData%ChannelNames = SrcOutputFileTypeData%ChannelNames
   end if
   if (allocated(SrcOutputFileTypeData%ChannelUnits)) then
      LB(1:1) = lbound(SrcOutputFileTypeData%ChannelUnits)
      UB(1:1) = ubound(SrcOutputFileTypeData%ChannelUnits)
      if (.not. allocated(DstOutputFileTypeData%ChannelUnits)) then
         allocate(DstOutputFileTypeData%ChannelUnits(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%ChannelUnits.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputFileTypeData%ChannelUnits = SrcOutputFileTypeData%ChannelUnits
   end if
   LB(1:1) = lbound(SrcOutputFileTypeData%Module_Ver)
   UB(1:1) = ubound(SrcOutputFileTypeData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_CopyProgDesc(SrcOutputFileTypeData%Module_Ver(i1), DstOutputFileTypeData%Module_Ver(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   DstOutputFileTypeData%Module_Abrev = SrcOutputFileTypeData%Module_Abrev
   DstOutputFileTypeData%WriteThisStep = SrcOutputFileTypeData%WriteThisStep
   DstOutputFileTypeData%VTK_count = SrcOutputFileTypeData%VTK_count
   DstOutputFileTypeData%VTK_LastWaveIndx = SrcOutputFileTypeData%VTK_LastWaveIndx
   call FAST_CopyLinFileType(SrcOutputFileTypeData%Lin, DstOutputFileTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstOutputFileTypeData%ActualChanLen = SrcOutputFileTypeData%ActualChanLen
   DstOutputFileTypeData%DriverWriteOutput = SrcOutputFileTypeData%DriverWriteOutput
end subroutine

subroutine FAST_DestroyOutputFileType(OutputFileTypeData, ErrStat, ErrMsg)
   type(FAST_OutputFileType), intent(inout) :: OutputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyOutputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputFileTypeData%TimeData)) then
      deallocate(OutputFileTypeData%TimeData)
   end if
   if (allocated(OutputFileTypeData%AllOutData)) then
      deallocate(OutputFileTypeData%AllOutData)
   end if
   if (allocated(OutputFileTypeData%ChannelNames)) then
      deallocate(OutputFileTypeData%ChannelNames)
   end if
   if (allocated(OutputFileTypeData%ChannelUnits)) then
      deallocate(OutputFileTypeData%ChannelUnits)
   end if
   LB(1:1) = lbound(OutputFileTypeData%Module_Ver)
   UB(1:1) = ubound(OutputFileTypeData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_DestroyProgDesc(OutputFileTypeData%Module_Ver(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   call FAST_DestroyLinFileType(OutputFileTypeData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine FAST_PackOutputFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_OutputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackOutputFileType'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%TimeData)
   call RegPackAlloc(RF, InData%AllOutData)
   call RegPack(RF, InData%n_Out)
   call RegPack(RF, InData%NOutSteps)
   call RegPack(RF, InData%numOuts)
   call RegPack(RF, InData%UnOu)
   call RegPack(RF, InData%UnSum)
   call RegPack(RF, InData%UnGra)
   call RegPack(RF, InData%FileDescLines)
   call RegPackAlloc(RF, InData%ChannelNames)
   call RegPackAlloc(RF, InData%ChannelUnits)
   LB(1:1) = lbound(InData%Module_Ver)
   UB(1:1) = ubound(InData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_PackProgDesc(RF, InData%Module_Ver(i1)) 
   end do
   call RegPack(RF, InData%Module_Abrev)
   call RegPack(RF, InData%WriteThisStep)
   call RegPack(RF, InData%VTK_count)
   call RegPack(RF, InData%VTK_LastWaveIndx)
   call FAST_PackLinFileType(RF, InData%Lin) 
   call RegPack(RF, InData%ActualChanLen)
   call RegPack(RF, InData%DriverWriteOutput)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackOutputFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_OutputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackOutputFileType'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%TimeData); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%AllOutData); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%n_Out); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NOutSteps); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%numOuts); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnOu); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnSum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnGra); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FileDescLines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChannelNames); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ChannelUnits); if (RegCheckErr(RF, RoutineName)) return
   LB(1:1) = lbound(OutData%Module_Ver)
   UB(1:1) = ubound(OutData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_UnpackProgDesc(RF, OutData%Module_Ver(i1)) ! Module_Ver 
   end do
   call RegUnpack(RF, OutData%Module_Abrev); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WriteThisStep); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_count); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VTK_LastWaveIndx); if (RegCheckErr(RF, RoutineName)) return
   call FAST_UnpackLinFileType(RF, OutData%Lin) ! Lin 
   call RegUnpack(RF, OutData%ActualChanLen); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DriverWriteOutput); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyIceDyn_Data(SrcIceDyn_DataData, DstIceDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(IceDyn_Data), intent(inout) :: SrcIceDyn_DataData
   type(IceDyn_Data), intent(inout) :: DstIceDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyIceDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcIceDyn_DataData%x)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%x)
      UB(1:2) = ubound(SrcIceDyn_DataData%x)
      if (.not. allocated(DstIceDyn_DataData%x)) then
         allocate(DstIceDyn_DataData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_CopyContState(SrcIceDyn_DataData%x(i1,i2), DstIceDyn_DataData%x(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcIceDyn_DataData%xd)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%xd)
      UB(1:2) = ubound(SrcIceDyn_DataData%xd)
      if (.not. allocated(DstIceDyn_DataData%xd)) then
         allocate(DstIceDyn_DataData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_CopyDiscState(SrcIceDyn_DataData%xd(i1,i2), DstIceDyn_DataData%xd(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcIceDyn_DataData%z)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%z)
      UB(1:2) = ubound(SrcIceDyn_DataData%z)
      if (.not. allocated(DstIceDyn_DataData%z)) then
         allocate(DstIceDyn_DataData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_CopyConstrState(SrcIceDyn_DataData%z(i1,i2), DstIceDyn_DataData%z(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcIceDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%OtherSt)
      UB(1:2) = ubound(SrcIceDyn_DataData%OtherSt)
      if (.not. allocated(DstIceDyn_DataData%OtherSt)) then
         allocate(DstIceDyn_DataData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_CopyOtherState(SrcIceDyn_DataData%OtherSt(i1,i2), DstIceDyn_DataData%OtherSt(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcIceDyn_DataData%p)) then
      LB(1:1) = lbound(SrcIceDyn_DataData%p)
      UB(1:1) = ubound(SrcIceDyn_DataData%p)
      if (.not. allocated(DstIceDyn_DataData%p)) then
         allocate(DstIceDyn_DataData%p(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%p.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceD_CopyParam(SrcIceDyn_DataData%p(i1), DstIceDyn_DataData%p(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceDyn_DataData%y)) then
      LB(1:1) = lbound(SrcIceDyn_DataData%y)
      UB(1:1) = ubound(SrcIceDyn_DataData%y)
      if (.not. allocated(DstIceDyn_DataData%y)) then
         allocate(DstIceDyn_DataData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceD_CopyOutput(SrcIceDyn_DataData%y(i1), DstIceDyn_DataData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceDyn_DataData%m)) then
      LB(1:1) = lbound(SrcIceDyn_DataData%m)
      UB(1:1) = ubound(SrcIceDyn_DataData%m)
      if (.not. allocated(DstIceDyn_DataData%m)) then
         allocate(DstIceDyn_DataData%m(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%m.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceD_CopyMisc(SrcIceDyn_DataData%m(i1), DstIceDyn_DataData%m(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceDyn_DataData%Input)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%Input)
      UB(1:2) = ubound(SrcIceDyn_DataData%Input)
      if (.not. allocated(DstIceDyn_DataData%Input)) then
         allocate(DstIceDyn_DataData%Input(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_CopyInput(SrcIceDyn_DataData%Input(i1,i2), DstIceDyn_DataData%Input(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcIceDyn_DataData%InputTimes)) then
      LB(1:2) = lbound(SrcIceDyn_DataData%InputTimes)
      UB(1:2) = ubound(SrcIceDyn_DataData%InputTimes)
      if (.not. allocated(DstIceDyn_DataData%InputTimes)) then
         allocate(DstIceDyn_DataData%InputTimes(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstIceDyn_DataData%InputTimes = SrcIceDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyIceDyn_Data(IceDyn_DataData, ErrStat, ErrMsg)
   type(IceDyn_Data), intent(inout) :: IceDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyIceDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(IceDyn_DataData%x)) then
      LB(1:2) = lbound(IceDyn_DataData%x)
      UB(1:2) = ubound(IceDyn_DataData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_DestroyContState(IceDyn_DataData%x(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(IceDyn_DataData%x)
   end if
   if (allocated(IceDyn_DataData%xd)) then
      LB(1:2) = lbound(IceDyn_DataData%xd)
      UB(1:2) = ubound(IceDyn_DataData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_DestroyDiscState(IceDyn_DataData%xd(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(IceDyn_DataData%xd)
   end if
   if (allocated(IceDyn_DataData%z)) then
      LB(1:2) = lbound(IceDyn_DataData%z)
      UB(1:2) = ubound(IceDyn_DataData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_DestroyConstrState(IceDyn_DataData%z(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(IceDyn_DataData%z)
   end if
   if (allocated(IceDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(IceDyn_DataData%OtherSt)
      UB(1:2) = ubound(IceDyn_DataData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_DestroyOtherState(IceDyn_DataData%OtherSt(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(IceDyn_DataData%OtherSt)
   end if
   if (allocated(IceDyn_DataData%p)) then
      LB(1:1) = lbound(IceDyn_DataData%p)
      UB(1:1) = ubound(IceDyn_DataData%p)
      do i1 = LB(1), UB(1)
         call IceD_DestroyParam(IceDyn_DataData%p(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceDyn_DataData%p)
   end if
   if (allocated(IceDyn_DataData%y)) then
      LB(1:1) = lbound(IceDyn_DataData%y)
      UB(1:1) = ubound(IceDyn_DataData%y)
      do i1 = LB(1), UB(1)
         call IceD_DestroyOutput(IceDyn_DataData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceDyn_DataData%y)
   end if
   if (allocated(IceDyn_DataData%m)) then
      LB(1:1) = lbound(IceDyn_DataData%m)
      UB(1:1) = ubound(IceDyn_DataData%m)
      do i1 = LB(1), UB(1)
         call IceD_DestroyMisc(IceDyn_DataData%m(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceDyn_DataData%m)
   end if
   if (allocated(IceDyn_DataData%Input)) then
      LB(1:2) = lbound(IceDyn_DataData%Input)
      UB(1:2) = ubound(IceDyn_DataData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_DestroyInput(IceDyn_DataData%Input(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(IceDyn_DataData%Input)
   end if
   if (allocated(IceDyn_DataData%InputTimes)) then
      deallocate(IceDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackIceDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(IceDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackIceDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 2, lbound(InData%x), ubound(InData%x))
      LB(1:2) = lbound(InData%x)
      UB(1:2) = ubound(InData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackContState(RF, InData%x(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 2, lbound(InData%xd), ubound(InData%xd))
      LB(1:2) = lbound(InData%xd)
      UB(1:2) = ubound(InData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackDiscState(RF, InData%xd(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 2, lbound(InData%z), ubound(InData%z))
      LB(1:2) = lbound(InData%z)
      UB(1:2) = ubound(InData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackConstrState(RF, InData%z(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 2, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:2) = lbound(InData%OtherSt)
      UB(1:2) = ubound(InData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackOtherState(RF, InData%OtherSt(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%p))
   if (allocated(InData%p)) then
      call RegPackBounds(RF, 1, lbound(InData%p), ubound(InData%p))
      LB(1:1) = lbound(InData%p)
      UB(1:1) = ubound(InData%p)
      do i1 = LB(1), UB(1)
         call IceD_PackParam(RF, InData%p(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call IceD_PackOutput(RF, InData%y(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%m))
   if (allocated(InData%m)) then
      call RegPackBounds(RF, 1, lbound(InData%m), ubound(InData%m))
      LB(1:1) = lbound(InData%m)
      UB(1:1) = ubound(InData%m)
      do i1 = LB(1), UB(1)
         call IceD_PackMisc(RF, InData%m(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 2, lbound(InData%Input), ubound(InData%Input))
      LB(1:2) = lbound(InData%Input)
      UB(1:2) = ubound(InData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackInput(RF, InData%Input(i1,i2)) 
         end do
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackIceDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(IceDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackIceDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackContState(RF, OutData%x(i1,i2)) ! x 
         end do
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackDiscState(RF, OutData%xd(i1,i2)) ! xd 
         end do
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackConstrState(RF, OutData%z(i1,i2)) ! z 
         end do
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackOtherState(RF, OutData%OtherSt(i1,i2)) ! OtherSt 
         end do
      end do
   end if
   if (allocated(OutData%p)) deallocate(OutData%p)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%p(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackParam(RF, OutData%p(i1)) ! p 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackOutput(RF, OutData%y(i1)) ! y 
      end do
   end if
   if (allocated(OutData%m)) deallocate(OutData%m)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%m.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackMisc(RF, OutData%m(i1)) ! m 
      end do
   end if
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackInput(RF, OutData%Input(i1,i2)) ! Input 
         end do
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyBeamDyn_Data(SrcBeamDyn_DataData, DstBeamDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(BeamDyn_Data), intent(inout) :: SrcBeamDyn_DataData
   type(BeamDyn_Data), intent(inout) :: DstBeamDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyBeamDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBeamDyn_DataData%x)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%x)
      UB(1:2) = ubound(SrcBeamDyn_DataData%x)
      if (.not. allocated(DstBeamDyn_DataData%x)) then
         allocate(DstBeamDyn_DataData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_CopyContState(SrcBeamDyn_DataData%x(i1,i2), DstBeamDyn_DataData%x(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%xd)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%xd)
      UB(1:2) = ubound(SrcBeamDyn_DataData%xd)
      if (.not. allocated(DstBeamDyn_DataData%xd)) then
         allocate(DstBeamDyn_DataData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_CopyDiscState(SrcBeamDyn_DataData%xd(i1,i2), DstBeamDyn_DataData%xd(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%z)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%z)
      UB(1:2) = ubound(SrcBeamDyn_DataData%z)
      if (.not. allocated(DstBeamDyn_DataData%z)) then
         allocate(DstBeamDyn_DataData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_CopyConstrState(SrcBeamDyn_DataData%z(i1,i2), DstBeamDyn_DataData%z(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%OtherSt)
      UB(1:2) = ubound(SrcBeamDyn_DataData%OtherSt)
      if (.not. allocated(DstBeamDyn_DataData%OtherSt)) then
         allocate(DstBeamDyn_DataData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_CopyOtherState(SrcBeamDyn_DataData%OtherSt(i1,i2), DstBeamDyn_DataData%OtherSt(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%p)) then
      LB(1:1) = lbound(SrcBeamDyn_DataData%p)
      UB(1:1) = ubound(SrcBeamDyn_DataData%p)
      if (.not. allocated(DstBeamDyn_DataData%p)) then
         allocate(DstBeamDyn_DataData%p(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%p.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call BD_CopyParam(SrcBeamDyn_DataData%p(i1), DstBeamDyn_DataData%p(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%y)) then
      LB(1:1) = lbound(SrcBeamDyn_DataData%y)
      UB(1:1) = ubound(SrcBeamDyn_DataData%y)
      if (.not. allocated(DstBeamDyn_DataData%y)) then
         allocate(DstBeamDyn_DataData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call BD_CopyOutput(SrcBeamDyn_DataData%y(i1), DstBeamDyn_DataData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%m)) then
      LB(1:1) = lbound(SrcBeamDyn_DataData%m)
      UB(1:1) = ubound(SrcBeamDyn_DataData%m)
      if (.not. allocated(DstBeamDyn_DataData%m)) then
         allocate(DstBeamDyn_DataData%m(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%m.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call BD_CopyMisc(SrcBeamDyn_DataData%m(i1), DstBeamDyn_DataData%m(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%Input)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%Input)
      UB(1:2) = ubound(SrcBeamDyn_DataData%Input)
      if (.not. allocated(DstBeamDyn_DataData%Input)) then
         allocate(DstBeamDyn_DataData%Input(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_CopyInput(SrcBeamDyn_DataData%Input(i1,i2), DstBeamDyn_DataData%Input(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcBeamDyn_DataData%InputTimes)) then
      LB(1:2) = lbound(SrcBeamDyn_DataData%InputTimes)
      UB(1:2) = ubound(SrcBeamDyn_DataData%InputTimes)
      if (.not. allocated(DstBeamDyn_DataData%InputTimes)) then
         allocate(DstBeamDyn_DataData%InputTimes(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBeamDyn_DataData%InputTimes = SrcBeamDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyBeamDyn_Data(BeamDyn_DataData, ErrStat, ErrMsg)
   type(BeamDyn_Data), intent(inout) :: BeamDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyBeamDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BeamDyn_DataData%x)) then
      LB(1:2) = lbound(BeamDyn_DataData%x)
      UB(1:2) = ubound(BeamDyn_DataData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_DestroyContState(BeamDyn_DataData%x(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(BeamDyn_DataData%x)
   end if
   if (allocated(BeamDyn_DataData%xd)) then
      LB(1:2) = lbound(BeamDyn_DataData%xd)
      UB(1:2) = ubound(BeamDyn_DataData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_DestroyDiscState(BeamDyn_DataData%xd(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(BeamDyn_DataData%xd)
   end if
   if (allocated(BeamDyn_DataData%z)) then
      LB(1:2) = lbound(BeamDyn_DataData%z)
      UB(1:2) = ubound(BeamDyn_DataData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_DestroyConstrState(BeamDyn_DataData%z(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(BeamDyn_DataData%z)
   end if
   if (allocated(BeamDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(BeamDyn_DataData%OtherSt)
      UB(1:2) = ubound(BeamDyn_DataData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_DestroyOtherState(BeamDyn_DataData%OtherSt(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(BeamDyn_DataData%OtherSt)
   end if
   if (allocated(BeamDyn_DataData%p)) then
      LB(1:1) = lbound(BeamDyn_DataData%p)
      UB(1:1) = ubound(BeamDyn_DataData%p)
      do i1 = LB(1), UB(1)
         call BD_DestroyParam(BeamDyn_DataData%p(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(BeamDyn_DataData%p)
   end if
   if (allocated(BeamDyn_DataData%y)) then
      LB(1:1) = lbound(BeamDyn_DataData%y)
      UB(1:1) = ubound(BeamDyn_DataData%y)
      do i1 = LB(1), UB(1)
         call BD_DestroyOutput(BeamDyn_DataData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(BeamDyn_DataData%y)
   end if
   if (allocated(BeamDyn_DataData%m)) then
      LB(1:1) = lbound(BeamDyn_DataData%m)
      UB(1:1) = ubound(BeamDyn_DataData%m)
      do i1 = LB(1), UB(1)
         call BD_DestroyMisc(BeamDyn_DataData%m(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(BeamDyn_DataData%m)
   end if
   if (allocated(BeamDyn_DataData%Input)) then
      LB(1:2) = lbound(BeamDyn_DataData%Input)
      UB(1:2) = ubound(BeamDyn_DataData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_DestroyInput(BeamDyn_DataData%Input(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(BeamDyn_DataData%Input)
   end if
   if (allocated(BeamDyn_DataData%InputTimes)) then
      deallocate(BeamDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackBeamDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(BeamDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackBeamDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 2, lbound(InData%x), ubound(InData%x))
      LB(1:2) = lbound(InData%x)
      UB(1:2) = ubound(InData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackContState(RF, InData%x(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 2, lbound(InData%xd), ubound(InData%xd))
      LB(1:2) = lbound(InData%xd)
      UB(1:2) = ubound(InData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackDiscState(RF, InData%xd(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 2, lbound(InData%z), ubound(InData%z))
      LB(1:2) = lbound(InData%z)
      UB(1:2) = ubound(InData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackConstrState(RF, InData%z(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 2, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:2) = lbound(InData%OtherSt)
      UB(1:2) = ubound(InData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackOtherState(RF, InData%OtherSt(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%p))
   if (allocated(InData%p)) then
      call RegPackBounds(RF, 1, lbound(InData%p), ubound(InData%p))
      LB(1:1) = lbound(InData%p)
      UB(1:1) = ubound(InData%p)
      do i1 = LB(1), UB(1)
         call BD_PackParam(RF, InData%p(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call BD_PackOutput(RF, InData%y(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%m))
   if (allocated(InData%m)) then
      call RegPackBounds(RF, 1, lbound(InData%m), ubound(InData%m))
      LB(1:1) = lbound(InData%m)
      UB(1:1) = ubound(InData%m)
      do i1 = LB(1), UB(1)
         call BD_PackMisc(RF, InData%m(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 2, lbound(InData%Input), ubound(InData%Input))
      LB(1:2) = lbound(InData%Input)
      UB(1:2) = ubound(InData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackInput(RF, InData%Input(i1,i2)) 
         end do
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackBeamDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(BeamDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackBeamDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackContState(RF, OutData%x(i1,i2)) ! x 
         end do
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackDiscState(RF, OutData%xd(i1,i2)) ! xd 
         end do
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackConstrState(RF, OutData%z(i1,i2)) ! z 
         end do
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackOtherState(RF, OutData%OtherSt(i1,i2)) ! OtherSt 
         end do
      end do
   end if
   if (allocated(OutData%p)) deallocate(OutData%p)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%p(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackParam(RF, OutData%p(i1)) ! p 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackOutput(RF, OutData%y(i1)) ! y 
      end do
   end if
   if (allocated(OutData%m)) deallocate(OutData%m)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%m.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackMisc(RF, OutData%m(i1)) ! m 
      end do
   end if
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackInput(RF, OutData%Input(i1,i2)) ! Input 
         end do
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyElastoDyn_Data(SrcElastoDyn_DataData, DstElastoDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(ElastoDyn_Data), intent(inout) :: SrcElastoDyn_DataData
   type(ElastoDyn_Data), intent(inout) :: DstElastoDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyElastoDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcElastoDyn_DataData%x)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%x)
      UB(1:2) = ubound(SrcElastoDyn_DataData%x)
      if (.not. allocated(DstElastoDyn_DataData%x)) then
         allocate(DstElastoDyn_DataData%x(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_CopyContState(SrcElastoDyn_DataData%x(i1,i2), DstElastoDyn_DataData%x(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%xd)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%xd)
      UB(1:2) = ubound(SrcElastoDyn_DataData%xd)
      if (.not. allocated(DstElastoDyn_DataData%xd)) then
         allocate(DstElastoDyn_DataData%xd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_CopyDiscState(SrcElastoDyn_DataData%xd(i1,i2), DstElastoDyn_DataData%xd(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%z)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%z)
      UB(1:2) = ubound(SrcElastoDyn_DataData%z)
      if (.not. allocated(DstElastoDyn_DataData%z)) then
         allocate(DstElastoDyn_DataData%z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_CopyConstrState(SrcElastoDyn_DataData%z(i1,i2), DstElastoDyn_DataData%z(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%OtherSt)
      UB(1:2) = ubound(SrcElastoDyn_DataData%OtherSt)
      if (.not. allocated(DstElastoDyn_DataData%OtherSt)) then
         allocate(DstElastoDyn_DataData%OtherSt(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_CopyOtherState(SrcElastoDyn_DataData%OtherSt(i1,i2), DstElastoDyn_DataData%OtherSt(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%p)) then
      LB(1:1) = lbound(SrcElastoDyn_DataData%p)
      UB(1:1) = ubound(SrcElastoDyn_DataData%p)
      if (.not. allocated(DstElastoDyn_DataData%p)) then
         allocate(DstElastoDyn_DataData%p(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%p.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ED_CopyParam(SrcElastoDyn_DataData%p(i1), DstElastoDyn_DataData%p(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%y)) then
      LB(1:1) = lbound(SrcElastoDyn_DataData%y)
      UB(1:1) = ubound(SrcElastoDyn_DataData%y)
      if (.not. allocated(DstElastoDyn_DataData%y)) then
         allocate(DstElastoDyn_DataData%y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ED_CopyOutput(SrcElastoDyn_DataData%y(i1), DstElastoDyn_DataData%y(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%m)) then
      LB(1:1) = lbound(SrcElastoDyn_DataData%m)
      UB(1:1) = ubound(SrcElastoDyn_DataData%m)
      if (.not. allocated(DstElastoDyn_DataData%m)) then
         allocate(DstElastoDyn_DataData%m(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%m.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ED_CopyMisc(SrcElastoDyn_DataData%m(i1), DstElastoDyn_DataData%m(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%Input)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%Input)
      UB(1:2) = ubound(SrcElastoDyn_DataData%Input)
      if (.not. allocated(DstElastoDyn_DataData%Input)) then
         allocate(DstElastoDyn_DataData%Input(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_CopyInput(SrcElastoDyn_DataData%Input(i1,i2), DstElastoDyn_DataData%Input(i1,i2), CtrlCode, ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            if (ErrStat >= AbortErrLev) return
         end do
      end do
   end if
   if (allocated(SrcElastoDyn_DataData%InputTimes)) then
      LB(1:2) = lbound(SrcElastoDyn_DataData%InputTimes)
      UB(1:2) = ubound(SrcElastoDyn_DataData%InputTimes)
      if (.not. allocated(DstElastoDyn_DataData%InputTimes)) then
         allocate(DstElastoDyn_DataData%InputTimes(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstElastoDyn_DataData%InputTimes = SrcElastoDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyElastoDyn_Data(ElastoDyn_DataData, ErrStat, ErrMsg)
   type(ElastoDyn_Data), intent(inout) :: ElastoDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyElastoDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ElastoDyn_DataData%x)) then
      LB(1:2) = lbound(ElastoDyn_DataData%x)
      UB(1:2) = ubound(ElastoDyn_DataData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_DestroyContState(ElastoDyn_DataData%x(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(ElastoDyn_DataData%x)
   end if
   if (allocated(ElastoDyn_DataData%xd)) then
      LB(1:2) = lbound(ElastoDyn_DataData%xd)
      UB(1:2) = ubound(ElastoDyn_DataData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_DestroyDiscState(ElastoDyn_DataData%xd(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(ElastoDyn_DataData%xd)
   end if
   if (allocated(ElastoDyn_DataData%z)) then
      LB(1:2) = lbound(ElastoDyn_DataData%z)
      UB(1:2) = ubound(ElastoDyn_DataData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_DestroyConstrState(ElastoDyn_DataData%z(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(ElastoDyn_DataData%z)
   end if
   if (allocated(ElastoDyn_DataData%OtherSt)) then
      LB(1:2) = lbound(ElastoDyn_DataData%OtherSt)
      UB(1:2) = ubound(ElastoDyn_DataData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_DestroyOtherState(ElastoDyn_DataData%OtherSt(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(ElastoDyn_DataData%OtherSt)
   end if
   if (allocated(ElastoDyn_DataData%p)) then
      LB(1:1) = lbound(ElastoDyn_DataData%p)
      UB(1:1) = ubound(ElastoDyn_DataData%p)
      do i1 = LB(1), UB(1)
         call ED_DestroyParam(ElastoDyn_DataData%p(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ElastoDyn_DataData%p)
   end if
   if (allocated(ElastoDyn_DataData%y)) then
      LB(1:1) = lbound(ElastoDyn_DataData%y)
      UB(1:1) = ubound(ElastoDyn_DataData%y)
      do i1 = LB(1), UB(1)
         call ED_DestroyOutput(ElastoDyn_DataData%y(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ElastoDyn_DataData%y)
   end if
   if (allocated(ElastoDyn_DataData%m)) then
      LB(1:1) = lbound(ElastoDyn_DataData%m)
      UB(1:1) = ubound(ElastoDyn_DataData%m)
      do i1 = LB(1), UB(1)
         call ED_DestroyMisc(ElastoDyn_DataData%m(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ElastoDyn_DataData%m)
   end if
   if (allocated(ElastoDyn_DataData%Input)) then
      LB(1:2) = lbound(ElastoDyn_DataData%Input)
      UB(1:2) = ubound(ElastoDyn_DataData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_DestroyInput(ElastoDyn_DataData%Input(i1,i2), ErrStat2, ErrMsg2)
            call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         end do
      end do
      deallocate(ElastoDyn_DataData%Input)
   end if
   if (allocated(ElastoDyn_DataData%InputTimes)) then
      deallocate(ElastoDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackElastoDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ElastoDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackElastoDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 2, lbound(InData%x), ubound(InData%x))
      LB(1:2) = lbound(InData%x)
      UB(1:2) = ubound(InData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_PackContState(RF, InData%x(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 2, lbound(InData%xd), ubound(InData%xd))
      LB(1:2) = lbound(InData%xd)
      UB(1:2) = ubound(InData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_PackDiscState(RF, InData%xd(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 2, lbound(InData%z), ubound(InData%z))
      LB(1:2) = lbound(InData%z)
      UB(1:2) = ubound(InData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_PackConstrState(RF, InData%z(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 2, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:2) = lbound(InData%OtherSt)
      UB(1:2) = ubound(InData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_PackOtherState(RF, InData%OtherSt(i1,i2)) 
         end do
      end do
   end if
   call RegPack(RF, allocated(InData%p))
   if (allocated(InData%p)) then
      call RegPackBounds(RF, 1, lbound(InData%p), ubound(InData%p))
      LB(1:1) = lbound(InData%p)
      UB(1:1) = ubound(InData%p)
      do i1 = LB(1), UB(1)
         call ED_PackParam(RF, InData%p(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(RF, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call ED_PackOutput(RF, InData%y(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%m))
   if (allocated(InData%m)) then
      call RegPackBounds(RF, 1, lbound(InData%m), ubound(InData%m))
      LB(1:1) = lbound(InData%m)
      UB(1:1) = ubound(InData%m)
      do i1 = LB(1), UB(1)
         call ED_PackMisc(RF, InData%m(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 2, lbound(InData%Input), ubound(InData%Input))
      LB(1:2) = lbound(InData%Input)
      UB(1:2) = ubound(InData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_PackInput(RF, InData%Input(i1,i2)) 
         end do
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackElastoDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ElastoDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackElastoDyn_Data'
   integer(B4Ki)   :: i1, i2
   integer(B4Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_UnpackContState(RF, OutData%x(i1,i2)) ! x 
         end do
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_UnpackDiscState(RF, OutData%xd(i1,i2)) ! xd 
         end do
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_UnpackConstrState(RF, OutData%z(i1,i2)) ! z 
         end do
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_UnpackOtherState(RF, OutData%OtherSt(i1,i2)) ! OtherSt 
         end do
      end do
   end if
   if (allocated(OutData%p)) deallocate(OutData%p)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%p(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackParam(RF, OutData%p(i1)) ! p 
      end do
   end if
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackOutput(RF, OutData%y(i1)) ! y 
      end do
   end if
   if (allocated(OutData%m)) deallocate(OutData%m)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%m.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackMisc(RF, OutData%m(i1)) ! m 
      end do
   end if
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 2, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call ED_UnpackInput(RF, OutData%Input(i1,i2)) ! Input 
         end do
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopySED_Data(SrcSED_DataData, DstSED_DataData, CtrlCode, ErrStat, ErrMsg)
   type(SED_Data), intent(inout) :: SrcSED_DataData
   type(SED_Data), intent(inout) :: DstSED_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopySED_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcSED_DataData%x)) then
      LB(1:1) = lbound(SrcSED_DataData%x)
      UB(1:1) = ubound(SrcSED_DataData%x)
      if (.not. allocated(DstSED_DataData%x)) then
         allocate(DstSED_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SED_CopyContState(SrcSED_DataData%x(i1), DstSED_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSED_DataData%xd)) then
      LB(1:1) = lbound(SrcSED_DataData%xd)
      UB(1:1) = ubound(SrcSED_DataData%xd)
      if (.not. allocated(DstSED_DataData%xd)) then
         allocate(DstSED_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SED_CopyDiscState(SrcSED_DataData%xd(i1), DstSED_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSED_DataData%z)) then
      LB(1:1) = lbound(SrcSED_DataData%z)
      UB(1:1) = ubound(SrcSED_DataData%z)
      if (.not. allocated(DstSED_DataData%z)) then
         allocate(DstSED_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SED_CopyConstrState(SrcSED_DataData%z(i1), DstSED_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSED_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcSED_DataData%OtherSt)
      UB(1:1) = ubound(SrcSED_DataData%OtherSt)
      if (.not. allocated(DstSED_DataData%OtherSt)) then
         allocate(DstSED_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SED_CopyOtherState(SrcSED_DataData%OtherSt(i1), DstSED_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SED_CopyParam(SrcSED_DataData%p, DstSED_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SED_CopyOutput(SrcSED_DataData%y, DstSED_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SED_CopyMisc(SrcSED_DataData%m, DstSED_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcSED_DataData%Input)) then
      LB(1:1) = lbound(SrcSED_DataData%Input)
      UB(1:1) = ubound(SrcSED_DataData%Input)
      if (.not. allocated(DstSED_DataData%Input)) then
         allocate(DstSED_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SED_CopyInput(SrcSED_DataData%Input(i1), DstSED_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSED_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcSED_DataData%InputTimes)
      UB(1:1) = ubound(SrcSED_DataData%InputTimes)
      if (.not. allocated(DstSED_DataData%InputTimes)) then
         allocate(DstSED_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSED_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstSED_DataData%InputTimes = SrcSED_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroySED_Data(SED_DataData, ErrStat, ErrMsg)
   type(SED_Data), intent(inout) :: SED_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroySED_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SED_DataData%x)) then
      LB(1:1) = lbound(SED_DataData%x)
      UB(1:1) = ubound(SED_DataData%x)
      do i1 = LB(1), UB(1)
         call SED_DestroyContState(SED_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SED_DataData%x)
   end if
   if (allocated(SED_DataData%xd)) then
      LB(1:1) = lbound(SED_DataData%xd)
      UB(1:1) = ubound(SED_DataData%xd)
      do i1 = LB(1), UB(1)
         call SED_DestroyDiscState(SED_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SED_DataData%xd)
   end if
   if (allocated(SED_DataData%z)) then
      LB(1:1) = lbound(SED_DataData%z)
      UB(1:1) = ubound(SED_DataData%z)
      do i1 = LB(1), UB(1)
         call SED_DestroyConstrState(SED_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SED_DataData%z)
   end if
   if (allocated(SED_DataData%OtherSt)) then
      LB(1:1) = lbound(SED_DataData%OtherSt)
      UB(1:1) = ubound(SED_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call SED_DestroyOtherState(SED_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SED_DataData%OtherSt)
   end if
   call SED_DestroyParam(SED_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SED_DestroyOutput(SED_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SED_DestroyMisc(SED_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(SED_DataData%Input)) then
      LB(1:1) = lbound(SED_DataData%Input)
      UB(1:1) = ubound(SED_DataData%Input)
      do i1 = LB(1), UB(1)
         call SED_DestroyInput(SED_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SED_DataData%Input)
   end if
   if (allocated(SED_DataData%InputTimes)) then
      deallocate(SED_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackSED_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SED_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSED_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call SED_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call SED_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call SED_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call SED_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call SED_PackParam(RF, InData%p) 
   call SED_PackOutput(RF, InData%y) 
   call SED_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SED_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackSED_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SED_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSED_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SED_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SED_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SED_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SED_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call SED_UnpackParam(RF, OutData%p) ! p 
   call SED_UnpackOutput(RF, OutData%y) ! y 
   call SED_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SED_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyServoDyn_Data(SrcServoDyn_DataData, DstServoDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(ServoDyn_Data), intent(inout) :: SrcServoDyn_DataData
   type(ServoDyn_Data), intent(inout) :: DstServoDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyServoDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcServoDyn_DataData%x)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%x)
      UB(1:1) = ubound(SrcServoDyn_DataData%x)
      if (.not. allocated(DstServoDyn_DataData%x)) then
         allocate(DstServoDyn_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SrvD_CopyContState(SrcServoDyn_DataData%x(i1), DstServoDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcServoDyn_DataData%xd)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%xd)
      UB(1:1) = ubound(SrcServoDyn_DataData%xd)
      if (.not. allocated(DstServoDyn_DataData%xd)) then
         allocate(DstServoDyn_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SrvD_CopyDiscState(SrcServoDyn_DataData%xd(i1), DstServoDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcServoDyn_DataData%z)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%z)
      UB(1:1) = ubound(SrcServoDyn_DataData%z)
      if (.not. allocated(DstServoDyn_DataData%z)) then
         allocate(DstServoDyn_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SrvD_CopyConstrState(SrcServoDyn_DataData%z(i1), DstServoDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcServoDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%OtherSt)
      UB(1:1) = ubound(SrcServoDyn_DataData%OtherSt)
      if (.not. allocated(DstServoDyn_DataData%OtherSt)) then
         allocate(DstServoDyn_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SrvD_CopyOtherState(SrcServoDyn_DataData%OtherSt(i1), DstServoDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SrvD_CopyParam(SrcServoDyn_DataData%p, DstServoDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SrvD_CopyOutput(SrcServoDyn_DataData%y, DstServoDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SrvD_CopyMisc(SrcServoDyn_DataData%m, DstServoDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcServoDyn_DataData%Input)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%Input)
      UB(1:1) = ubound(SrcServoDyn_DataData%Input)
      if (.not. allocated(DstServoDyn_DataData%Input)) then
         allocate(DstServoDyn_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SrvD_CopyInput(SrcServoDyn_DataData%Input(i1), DstServoDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcServoDyn_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcServoDyn_DataData%InputTimes)
      UB(1:1) = ubound(SrcServoDyn_DataData%InputTimes)
      if (.not. allocated(DstServoDyn_DataData%InputTimes)) then
         allocate(DstServoDyn_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstServoDyn_DataData%InputTimes = SrcServoDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyServoDyn_Data(ServoDyn_DataData, ErrStat, ErrMsg)
   type(ServoDyn_Data), intent(inout) :: ServoDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyServoDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ServoDyn_DataData%x)) then
      LB(1:1) = lbound(ServoDyn_DataData%x)
      UB(1:1) = ubound(ServoDyn_DataData%x)
      do i1 = LB(1), UB(1)
         call SrvD_DestroyContState(ServoDyn_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ServoDyn_DataData%x)
   end if
   if (allocated(ServoDyn_DataData%xd)) then
      LB(1:1) = lbound(ServoDyn_DataData%xd)
      UB(1:1) = ubound(ServoDyn_DataData%xd)
      do i1 = LB(1), UB(1)
         call SrvD_DestroyDiscState(ServoDyn_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ServoDyn_DataData%xd)
   end if
   if (allocated(ServoDyn_DataData%z)) then
      LB(1:1) = lbound(ServoDyn_DataData%z)
      UB(1:1) = ubound(ServoDyn_DataData%z)
      do i1 = LB(1), UB(1)
         call SrvD_DestroyConstrState(ServoDyn_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ServoDyn_DataData%z)
   end if
   if (allocated(ServoDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(ServoDyn_DataData%OtherSt)
      UB(1:1) = ubound(ServoDyn_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call SrvD_DestroyOtherState(ServoDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ServoDyn_DataData%OtherSt)
   end if
   call SrvD_DestroyParam(ServoDyn_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SrvD_DestroyOutput(ServoDyn_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SrvD_DestroyMisc(ServoDyn_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ServoDyn_DataData%Input)) then
      LB(1:1) = lbound(ServoDyn_DataData%Input)
      UB(1:1) = ubound(ServoDyn_DataData%Input)
      do i1 = LB(1), UB(1)
         call SrvD_DestroyInput(ServoDyn_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ServoDyn_DataData%Input)
   end if
   if (allocated(ServoDyn_DataData%InputTimes)) then
      deallocate(ServoDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackServoDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ServoDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackServoDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call SrvD_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call SrvD_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call SrvD_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call SrvD_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call SrvD_PackParam(RF, InData%p) 
   call SrvD_PackOutput(RF, InData%y) 
   call SrvD_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SrvD_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackServoDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ServoDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackServoDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call SrvD_UnpackParam(RF, OutData%p) ! p 
   call SrvD_UnpackOutput(RF, OutData%y) ! y 
   call SrvD_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyAeroDyn_Data(SrcAeroDyn_DataData, DstAeroDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(AeroDyn_Data), intent(inout) :: SrcAeroDyn_DataData
   type(AeroDyn_Data), intent(inout) :: DstAeroDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyAeroDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAeroDyn_DataData%x)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%x)
      UB(1:1) = ubound(SrcAeroDyn_DataData%x)
      if (.not. allocated(DstAeroDyn_DataData%x)) then
         allocate(DstAeroDyn_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyContState(SrcAeroDyn_DataData%x(i1), DstAeroDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDyn_DataData%xd)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%xd)
      UB(1:1) = ubound(SrcAeroDyn_DataData%xd)
      if (.not. allocated(DstAeroDyn_DataData%xd)) then
         allocate(DstAeroDyn_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyDiscState(SrcAeroDyn_DataData%xd(i1), DstAeroDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDyn_DataData%z)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%z)
      UB(1:1) = ubound(SrcAeroDyn_DataData%z)
      if (.not. allocated(DstAeroDyn_DataData%z)) then
         allocate(DstAeroDyn_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyConstrState(SrcAeroDyn_DataData%z(i1), DstAeroDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%OtherSt)
      UB(1:1) = ubound(SrcAeroDyn_DataData%OtherSt)
      if (.not. allocated(DstAeroDyn_DataData%OtherSt)) then
         allocate(DstAeroDyn_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyOtherState(SrcAeroDyn_DataData%OtherSt(i1), DstAeroDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call AD_CopyParam(SrcAeroDyn_DataData%p, DstAeroDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD_CopyOutput(SrcAeroDyn_DataData%y, DstAeroDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD_CopyMisc(SrcAeroDyn_DataData%m, DstAeroDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcAeroDyn_DataData%Input)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%Input)
      UB(1:1) = ubound(SrcAeroDyn_DataData%Input)
      if (.not. allocated(DstAeroDyn_DataData%Input)) then
         allocate(DstAeroDyn_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call AD_CopyInput(SrcAeroDyn_DataData%Input(i1), DstAeroDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDyn_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcAeroDyn_DataData%InputTimes)
      UB(1:1) = ubound(SrcAeroDyn_DataData%InputTimes)
      if (.not. allocated(DstAeroDyn_DataData%InputTimes)) then
         allocate(DstAeroDyn_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroDyn_DataData%InputTimes = SrcAeroDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyAeroDyn_Data(AeroDyn_DataData, ErrStat, ErrMsg)
   type(AeroDyn_Data), intent(inout) :: AeroDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyAeroDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AeroDyn_DataData%x)) then
      LB(1:1) = lbound(AeroDyn_DataData%x)
      UB(1:1) = ubound(AeroDyn_DataData%x)
      do i1 = LB(1), UB(1)
         call AD_DestroyContState(AeroDyn_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDyn_DataData%x)
   end if
   if (allocated(AeroDyn_DataData%xd)) then
      LB(1:1) = lbound(AeroDyn_DataData%xd)
      UB(1:1) = ubound(AeroDyn_DataData%xd)
      do i1 = LB(1), UB(1)
         call AD_DestroyDiscState(AeroDyn_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDyn_DataData%xd)
   end if
   if (allocated(AeroDyn_DataData%z)) then
      LB(1:1) = lbound(AeroDyn_DataData%z)
      UB(1:1) = ubound(AeroDyn_DataData%z)
      do i1 = LB(1), UB(1)
         call AD_DestroyConstrState(AeroDyn_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDyn_DataData%z)
   end if
   if (allocated(AeroDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(AeroDyn_DataData%OtherSt)
      UB(1:1) = ubound(AeroDyn_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call AD_DestroyOtherState(AeroDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDyn_DataData%OtherSt)
   end if
   call AD_DestroyParam(AeroDyn_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD_DestroyOutput(AeroDyn_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD_DestroyMisc(AeroDyn_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(AeroDyn_DataData%Input)) then
      LB(1:1) = lbound(AeroDyn_DataData%Input)
      UB(1:1) = ubound(AeroDyn_DataData%Input)
      do i1 = LB(1), UB(1)
         call AD_DestroyInput(AeroDyn_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDyn_DataData%Input)
   end if
   if (allocated(AeroDyn_DataData%InputTimes)) then
      deallocate(AeroDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackAeroDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AeroDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackAeroDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call AD_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call AD_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call AD_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call AD_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call AD_PackParam(RF, InData%p) 
   call AD_PackOutput(RF, InData%y) 
   call AD_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call AD_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackAeroDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AeroDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackAeroDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call AD_UnpackParam(RF, OutData%p) ! p 
   call AD_UnpackOutput(RF, OutData%y) ! y 
   call AD_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyExtLoads_Data(SrcExtLoads_DataData, DstExtLoads_DataData, CtrlCode, ErrStat, ErrMsg)
   type(ExtLoads_Data), intent(inout) :: SrcExtLoads_DataData
   type(ExtLoads_Data), intent(inout) :: DstExtLoads_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyExtLoads_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   LB(1:1) = lbound(SrcExtLoads_DataData%x)
   UB(1:1) = ubound(SrcExtLoads_DataData%x)
   do i1 = LB(1), UB(1)
      call ExtLd_CopyContState(SrcExtLoads_DataData%x(i1), DstExtLoads_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   LB(1:1) = lbound(SrcExtLoads_DataData%xd)
   UB(1:1) = ubound(SrcExtLoads_DataData%xd)
   do i1 = LB(1), UB(1)
      call ExtLd_CopyDiscState(SrcExtLoads_DataData%xd(i1), DstExtLoads_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   LB(1:1) = lbound(SrcExtLoads_DataData%z)
   UB(1:1) = ubound(SrcExtLoads_DataData%z)
   do i1 = LB(1), UB(1)
      call ExtLd_CopyConstrState(SrcExtLoads_DataData%z(i1), DstExtLoads_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   LB(1:1) = lbound(SrcExtLoads_DataData%OtherSt)
   UB(1:1) = ubound(SrcExtLoads_DataData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtLd_CopyOtherState(SrcExtLoads_DataData%OtherSt(i1), DstExtLoads_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   call ExtLd_CopyParam(SrcExtLoads_DataData%p, DstExtLoads_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtLd_CopyInput(SrcExtLoads_DataData%u, DstExtLoads_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtLd_CopyOutput(SrcExtLoads_DataData%y, DstExtLoads_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtLd_CopyMisc(SrcExtLoads_DataData%m, DstExtLoads_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcExtLoads_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcExtLoads_DataData%InputTimes)
      UB(1:1) = ubound(SrcExtLoads_DataData%InputTimes)
      if (.not. allocated(DstExtLoads_DataData%InputTimes)) then
         allocate(DstExtLoads_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtLoads_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstExtLoads_DataData%InputTimes = SrcExtLoads_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyExtLoads_Data(ExtLoads_DataData, ErrStat, ErrMsg)
   type(ExtLoads_Data), intent(inout) :: ExtLoads_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyExtLoads_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   LB(1:1) = lbound(ExtLoads_DataData%x)
   UB(1:1) = ubound(ExtLoads_DataData%x)
   do i1 = LB(1), UB(1)
      call ExtLd_DestroyContState(ExtLoads_DataData%x(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   LB(1:1) = lbound(ExtLoads_DataData%xd)
   UB(1:1) = ubound(ExtLoads_DataData%xd)
   do i1 = LB(1), UB(1)
      call ExtLd_DestroyDiscState(ExtLoads_DataData%xd(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   LB(1:1) = lbound(ExtLoads_DataData%z)
   UB(1:1) = ubound(ExtLoads_DataData%z)
   do i1 = LB(1), UB(1)
      call ExtLd_DestroyConstrState(ExtLoads_DataData%z(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   LB(1:1) = lbound(ExtLoads_DataData%OtherSt)
   UB(1:1) = ubound(ExtLoads_DataData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtLd_DestroyOtherState(ExtLoads_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   call ExtLd_DestroyParam(ExtLoads_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtLd_DestroyInput(ExtLoads_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtLd_DestroyOutput(ExtLoads_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtLd_DestroyMisc(ExtLoads_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ExtLoads_DataData%InputTimes)) then
      deallocate(ExtLoads_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackExtLoads_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ExtLoads_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExtLoads_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call ExtLd_PackContState(RF, InData%x(i1)) 
   end do
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call ExtLd_PackDiscState(RF, InData%xd(i1)) 
   end do
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call ExtLd_PackConstrState(RF, InData%z(i1)) 
   end do
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtLd_PackOtherState(RF, InData%OtherSt(i1)) 
   end do
   call ExtLd_PackParam(RF, InData%p) 
   call ExtLd_PackInput(RF, InData%u) 
   call ExtLd_PackOutput(RF, InData%y) 
   call ExtLd_PackMisc(RF, InData%m) 
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackExtLoads_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ExtLoads_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExtLoads_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call ExtLd_UnpackContState(RF, OutData%x(i1)) ! x 
   end do
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call ExtLd_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
   end do
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call ExtLd_UnpackConstrState(RF, OutData%z(i1)) ! z 
   end do
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtLd_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
   end do
   call ExtLd_UnpackParam(RF, OutData%p) ! p 
   call ExtLd_UnpackInput(RF, OutData%u) ! u 
   call ExtLd_UnpackOutput(RF, OutData%y) ! y 
   call ExtLd_UnpackMisc(RF, OutData%m) ! m 
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyAeroDisk_Data(SrcAeroDisk_DataData, DstAeroDisk_DataData, CtrlCode, ErrStat, ErrMsg)
   type(AeroDisk_Data), intent(inout) :: SrcAeroDisk_DataData
   type(AeroDisk_Data), intent(inout) :: DstAeroDisk_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyAeroDisk_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcAeroDisk_DataData%x)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%x)
      UB(1:1) = ubound(SrcAeroDisk_DataData%x)
      if (.not. allocated(DstAeroDisk_DataData%x)) then
         allocate(DstAeroDisk_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADsk_CopyContState(SrcAeroDisk_DataData%x(i1), DstAeroDisk_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDisk_DataData%xd)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%xd)
      UB(1:1) = ubound(SrcAeroDisk_DataData%xd)
      if (.not. allocated(DstAeroDisk_DataData%xd)) then
         allocate(DstAeroDisk_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADsk_CopyDiscState(SrcAeroDisk_DataData%xd(i1), DstAeroDisk_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDisk_DataData%z)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%z)
      UB(1:1) = ubound(SrcAeroDisk_DataData%z)
      if (.not. allocated(DstAeroDisk_DataData%z)) then
         allocate(DstAeroDisk_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADsk_CopyConstrState(SrcAeroDisk_DataData%z(i1), DstAeroDisk_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDisk_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%OtherSt)
      UB(1:1) = ubound(SrcAeroDisk_DataData%OtherSt)
      if (.not. allocated(DstAeroDisk_DataData%OtherSt)) then
         allocate(DstAeroDisk_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADsk_CopyOtherState(SrcAeroDisk_DataData%OtherSt(i1), DstAeroDisk_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call ADsk_CopyParam(SrcAeroDisk_DataData%p, DstAeroDisk_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ADsk_CopyOutput(SrcAeroDisk_DataData%y, DstAeroDisk_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ADsk_CopyMisc(SrcAeroDisk_DataData%m, DstAeroDisk_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcAeroDisk_DataData%Input)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%Input)
      UB(1:1) = ubound(SrcAeroDisk_DataData%Input)
      if (.not. allocated(DstAeroDisk_DataData%Input)) then
         allocate(DstAeroDisk_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADsk_CopyInput(SrcAeroDisk_DataData%Input(i1), DstAeroDisk_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcAeroDisk_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcAeroDisk_DataData%InputTimes)
      UB(1:1) = ubound(SrcAeroDisk_DataData%InputTimes)
      if (.not. allocated(DstAeroDisk_DataData%InputTimes)) then
         allocate(DstAeroDisk_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDisk_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstAeroDisk_DataData%InputTimes = SrcAeroDisk_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyAeroDisk_Data(AeroDisk_DataData, ErrStat, ErrMsg)
   type(AeroDisk_Data), intent(inout) :: AeroDisk_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyAeroDisk_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(AeroDisk_DataData%x)) then
      LB(1:1) = lbound(AeroDisk_DataData%x)
      UB(1:1) = ubound(AeroDisk_DataData%x)
      do i1 = LB(1), UB(1)
         call ADsk_DestroyContState(AeroDisk_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDisk_DataData%x)
   end if
   if (allocated(AeroDisk_DataData%xd)) then
      LB(1:1) = lbound(AeroDisk_DataData%xd)
      UB(1:1) = ubound(AeroDisk_DataData%xd)
      do i1 = LB(1), UB(1)
         call ADsk_DestroyDiscState(AeroDisk_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDisk_DataData%xd)
   end if
   if (allocated(AeroDisk_DataData%z)) then
      LB(1:1) = lbound(AeroDisk_DataData%z)
      UB(1:1) = ubound(AeroDisk_DataData%z)
      do i1 = LB(1), UB(1)
         call ADsk_DestroyConstrState(AeroDisk_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDisk_DataData%z)
   end if
   if (allocated(AeroDisk_DataData%OtherSt)) then
      LB(1:1) = lbound(AeroDisk_DataData%OtherSt)
      UB(1:1) = ubound(AeroDisk_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call ADsk_DestroyOtherState(AeroDisk_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDisk_DataData%OtherSt)
   end if
   call ADsk_DestroyParam(AeroDisk_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ADsk_DestroyOutput(AeroDisk_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ADsk_DestroyMisc(AeroDisk_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(AeroDisk_DataData%Input)) then
      LB(1:1) = lbound(AeroDisk_DataData%Input)
      UB(1:1) = ubound(AeroDisk_DataData%Input)
      do i1 = LB(1), UB(1)
         call ADsk_DestroyInput(AeroDisk_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(AeroDisk_DataData%Input)
   end if
   if (allocated(AeroDisk_DataData%InputTimes)) then
      deallocate(AeroDisk_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackAeroDisk_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(AeroDisk_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackAeroDisk_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call ADsk_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call ADsk_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call ADsk_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call ADsk_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call ADsk_PackParam(RF, InData%p) 
   call ADsk_PackOutput(RF, InData%y) 
   call ADsk_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call ADsk_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackAeroDisk_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(AeroDisk_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackAeroDisk_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADsk_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADsk_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADsk_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADsk_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call ADsk_UnpackParam(RF, OutData%p) ! p 
   call ADsk_UnpackOutput(RF, OutData%y) ! y 
   call ADsk_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADsk_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyInflowWind_Data(SrcInflowWind_DataData, DstInflowWind_DataData, CtrlCode, ErrStat, ErrMsg)
   type(InflowWind_Data), intent(in) :: SrcInflowWind_DataData
   type(InflowWind_Data), intent(inout) :: DstInflowWind_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyInflowWind_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInflowWind_DataData%x)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%x)
      UB(1:1) = ubound(SrcInflowWind_DataData%x)
      if (.not. allocated(DstInflowWind_DataData%x)) then
         allocate(DstInflowWind_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_CopyContState(SrcInflowWind_DataData%x(i1), DstInflowWind_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInflowWind_DataData%xd)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%xd)
      UB(1:1) = ubound(SrcInflowWind_DataData%xd)
      if (.not. allocated(DstInflowWind_DataData%xd)) then
         allocate(DstInflowWind_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_CopyDiscState(SrcInflowWind_DataData%xd(i1), DstInflowWind_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInflowWind_DataData%z)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%z)
      UB(1:1) = ubound(SrcInflowWind_DataData%z)
      if (.not. allocated(DstInflowWind_DataData%z)) then
         allocate(DstInflowWind_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_CopyConstrState(SrcInflowWind_DataData%z(i1), DstInflowWind_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInflowWind_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%OtherSt)
      UB(1:1) = ubound(SrcInflowWind_DataData%OtherSt)
      if (.not. allocated(DstInflowWind_DataData%OtherSt)) then
         allocate(DstInflowWind_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_CopyOtherState(SrcInflowWind_DataData%OtherSt(i1), DstInflowWind_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call InflowWind_CopyParam(SrcInflowWind_DataData%p, DstInflowWind_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyOutput(SrcInflowWind_DataData%y, DstInflowWind_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyMisc(SrcInflowWind_DataData%m, DstInflowWind_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInflowWind_DataData%Input)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%Input)
      UB(1:1) = ubound(SrcInflowWind_DataData%Input)
      if (.not. allocated(DstInflowWind_DataData%Input)) then
         allocate(DstInflowWind_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_CopyInput(SrcInflowWind_DataData%Input(i1), DstInflowWind_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInflowWind_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcInflowWind_DataData%InputTimes)
      UB(1:1) = ubound(SrcInflowWind_DataData%InputTimes)
      if (.not. allocated(DstInflowWind_DataData%InputTimes)) then
         allocate(DstInflowWind_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInflowWind_DataData%InputTimes = SrcInflowWind_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyInflowWind_Data(InflowWind_DataData, ErrStat, ErrMsg)
   type(InflowWind_Data), intent(inout) :: InflowWind_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyInflowWind_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InflowWind_DataData%x)) then
      LB(1:1) = lbound(InflowWind_DataData%x)
      UB(1:1) = ubound(InflowWind_DataData%x)
      do i1 = LB(1), UB(1)
         call InflowWind_DestroyContState(InflowWind_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InflowWind_DataData%x)
   end if
   if (allocated(InflowWind_DataData%xd)) then
      LB(1:1) = lbound(InflowWind_DataData%xd)
      UB(1:1) = ubound(InflowWind_DataData%xd)
      do i1 = LB(1), UB(1)
         call InflowWind_DestroyDiscState(InflowWind_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InflowWind_DataData%xd)
   end if
   if (allocated(InflowWind_DataData%z)) then
      LB(1:1) = lbound(InflowWind_DataData%z)
      UB(1:1) = ubound(InflowWind_DataData%z)
      do i1 = LB(1), UB(1)
         call InflowWind_DestroyConstrState(InflowWind_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InflowWind_DataData%z)
   end if
   if (allocated(InflowWind_DataData%OtherSt)) then
      LB(1:1) = lbound(InflowWind_DataData%OtherSt)
      UB(1:1) = ubound(InflowWind_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call InflowWind_DestroyOtherState(InflowWind_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InflowWind_DataData%OtherSt)
   end if
   call InflowWind_DestroyParam(InflowWind_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyOutput(InflowWind_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyMisc(InflowWind_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InflowWind_DataData%Input)) then
      LB(1:1) = lbound(InflowWind_DataData%Input)
      UB(1:1) = ubound(InflowWind_DataData%Input)
      do i1 = LB(1), UB(1)
         call InflowWind_DestroyInput(InflowWind_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InflowWind_DataData%Input)
   end if
   if (allocated(InflowWind_DataData%InputTimes)) then
      deallocate(InflowWind_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackInflowWind_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(InflowWind_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackInflowWind_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call InflowWind_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call InflowWind_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call InflowWind_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call InflowWind_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call InflowWind_PackParam(RF, InData%p) 
   call InflowWind_PackOutput(RF, InData%y) 
   call InflowWind_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call InflowWind_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackInflowWind_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(InflowWind_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackInflowWind_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call InflowWind_UnpackParam(RF, OutData%p) ! p 
   call InflowWind_UnpackOutput(RF, OutData%y) ! y 
   call InflowWind_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyExternalInflow_Data(SrcExternalInflow_DataData, DstExternalInflow_DataData, CtrlCode, ErrStat, ErrMsg)
   type(ExternalInflow_Data), intent(inout) :: SrcExternalInflow_DataData
   type(ExternalInflow_Data), intent(inout) :: DstExternalInflow_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyExternalInflow_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call ExtInfw_CopyInput(SrcExternalInflow_DataData%u, DstExternalInflow_DataData%u, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtInfw_CopyOutput(SrcExternalInflow_DataData%y, DstExternalInflow_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtInfw_CopyParam(SrcExternalInflow_DataData%p, DstExternalInflow_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtInfw_CopyMisc(SrcExternalInflow_DataData%m, DstExternalInflow_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine FAST_DestroyExternalInflow_Data(ExternalInflow_DataData, ErrStat, ErrMsg)
   type(ExternalInflow_Data), intent(inout) :: ExternalInflow_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyExternalInflow_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call ExtInfw_DestroyInput(ExternalInflow_DataData%u, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtInfw_DestroyOutput(ExternalInflow_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtInfw_DestroyParam(ExternalInflow_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtInfw_DestroyMisc(ExternalInflow_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine FAST_PackExternalInflow_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ExternalInflow_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExternalInflow_Data'
   if (RF%ErrStat >= AbortErrLev) return
   call ExtInfw_PackInput(RF, InData%u) 
   call ExtInfw_PackOutput(RF, InData%y) 
   call ExtInfw_PackParam(RF, InData%p) 
   call ExtInfw_PackMisc(RF, InData%m) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackExternalInflow_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ExternalInflow_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExternalInflow_Data'
   if (RF%ErrStat /= ErrID_None) return
   call ExtInfw_UnpackInput(RF, OutData%u) ! u 
   call ExtInfw_UnpackOutput(RF, OutData%y) ! y 
   call ExtInfw_UnpackParam(RF, OutData%p) ! p 
   call ExtInfw_UnpackMisc(RF, OutData%m) ! m 
end subroutine

subroutine FAST_CopySubDyn_Data(SrcSubDyn_DataData, DstSubDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(SubDyn_Data), intent(inout) :: SrcSubDyn_DataData
   type(SubDyn_Data), intent(inout) :: DstSubDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopySubDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcSubDyn_DataData%x)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%x)
      UB(1:1) = ubound(SrcSubDyn_DataData%x)
      if (.not. allocated(DstSubDyn_DataData%x)) then
         allocate(DstSubDyn_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SD_CopyContState(SrcSubDyn_DataData%x(i1), DstSubDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SD_CopyContState(SrcSubDyn_DataData%dxdt, DstSubDyn_DataData%dxdt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcSubDyn_DataData%xd)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%xd)
      UB(1:1) = ubound(SrcSubDyn_DataData%xd)
      if (.not. allocated(DstSubDyn_DataData%xd)) then
         allocate(DstSubDyn_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SD_CopyDiscState(SrcSubDyn_DataData%xd(i1), DstSubDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSubDyn_DataData%z)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%z)
      UB(1:1) = ubound(SrcSubDyn_DataData%z)
      if (.not. allocated(DstSubDyn_DataData%z)) then
         allocate(DstSubDyn_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SD_CopyConstrState(SrcSubDyn_DataData%z(i1), DstSubDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSubDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%OtherSt)
      UB(1:1) = ubound(SrcSubDyn_DataData%OtherSt)
      if (.not. allocated(DstSubDyn_DataData%OtherSt)) then
         allocate(DstSubDyn_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SD_CopyOtherState(SrcSubDyn_DataData%OtherSt(i1), DstSubDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SD_CopyParam(SrcSubDyn_DataData%p, DstSubDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SD_CopyOutput(SrcSubDyn_DataData%y, DstSubDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SD_CopyMisc(SrcSubDyn_DataData%m, DstSubDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcSubDyn_DataData%Input)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%Input)
      UB(1:1) = ubound(SrcSubDyn_DataData%Input)
      if (.not. allocated(DstSubDyn_DataData%Input)) then
         allocate(DstSubDyn_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SD_CopyInput(SrcSubDyn_DataData%Input(i1), DstSubDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSubDyn_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcSubDyn_DataData%InputTimes)
      UB(1:1) = ubound(SrcSubDyn_DataData%InputTimes)
      if (.not. allocated(DstSubDyn_DataData%InputTimes)) then
         allocate(DstSubDyn_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstSubDyn_DataData%InputTimes = SrcSubDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroySubDyn_Data(SubDyn_DataData, ErrStat, ErrMsg)
   type(SubDyn_Data), intent(inout) :: SubDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroySubDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SubDyn_DataData%x)) then
      LB(1:1) = lbound(SubDyn_DataData%x)
      UB(1:1) = ubound(SubDyn_DataData%x)
      do i1 = LB(1), UB(1)
         call SD_DestroyContState(SubDyn_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SubDyn_DataData%x)
   end if
   call SD_DestroyContState(SubDyn_DataData%dxdt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(SubDyn_DataData%xd)) then
      LB(1:1) = lbound(SubDyn_DataData%xd)
      UB(1:1) = ubound(SubDyn_DataData%xd)
      do i1 = LB(1), UB(1)
         call SD_DestroyDiscState(SubDyn_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SubDyn_DataData%xd)
   end if
   if (allocated(SubDyn_DataData%z)) then
      LB(1:1) = lbound(SubDyn_DataData%z)
      UB(1:1) = ubound(SubDyn_DataData%z)
      do i1 = LB(1), UB(1)
         call SD_DestroyConstrState(SubDyn_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SubDyn_DataData%z)
   end if
   if (allocated(SubDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SubDyn_DataData%OtherSt)
      UB(1:1) = ubound(SubDyn_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call SD_DestroyOtherState(SubDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SubDyn_DataData%OtherSt)
   end if
   call SD_DestroyParam(SubDyn_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SD_DestroyOutput(SubDyn_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SD_DestroyMisc(SubDyn_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(SubDyn_DataData%Input)) then
      LB(1:1) = lbound(SubDyn_DataData%Input)
      UB(1:1) = ubound(SubDyn_DataData%Input)
      do i1 = LB(1), UB(1)
         call SD_DestroyInput(SubDyn_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SubDyn_DataData%Input)
   end if
   if (allocated(SubDyn_DataData%InputTimes)) then
      deallocate(SubDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackSubDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SubDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSubDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call SD_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call SD_PackContState(RF, InData%dxdt) 
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call SD_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call SD_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call SD_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call SD_PackParam(RF, InData%p) 
   call SD_PackOutput(RF, InData%y) 
   call SD_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SD_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackSubDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SubDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSubDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   call SD_UnpackContState(RF, OutData%dxdt) ! dxdt 
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call SD_UnpackParam(RF, OutData%p) ! p 
   call SD_UnpackOutput(RF, OutData%y) ! y 
   call SD_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyExtPtfm_Data(SrcExtPtfm_DataData, DstExtPtfm_DataData, CtrlCode, ErrStat, ErrMsg)
   type(ExtPtfm_Data), intent(inout) :: SrcExtPtfm_DataData
   type(ExtPtfm_Data), intent(inout) :: DstExtPtfm_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyExtPtfm_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcExtPtfm_DataData%x)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%x)
      UB(1:1) = ubound(SrcExtPtfm_DataData%x)
      if (.not. allocated(DstExtPtfm_DataData%x)) then
         allocate(DstExtPtfm_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_CopyContState(SrcExtPtfm_DataData%x(i1), DstExtPtfm_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcExtPtfm_DataData%xd)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%xd)
      UB(1:1) = ubound(SrcExtPtfm_DataData%xd)
      if (.not. allocated(DstExtPtfm_DataData%xd)) then
         allocate(DstExtPtfm_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_CopyDiscState(SrcExtPtfm_DataData%xd(i1), DstExtPtfm_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcExtPtfm_DataData%z)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%z)
      UB(1:1) = ubound(SrcExtPtfm_DataData%z)
      if (.not. allocated(DstExtPtfm_DataData%z)) then
         allocate(DstExtPtfm_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_CopyConstrState(SrcExtPtfm_DataData%z(i1), DstExtPtfm_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcExtPtfm_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%OtherSt)
      UB(1:1) = ubound(SrcExtPtfm_DataData%OtherSt)
      if (.not. allocated(DstExtPtfm_DataData%OtherSt)) then
         allocate(DstExtPtfm_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_CopyOtherState(SrcExtPtfm_DataData%OtherSt(i1), DstExtPtfm_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call ExtPtfm_CopyParam(SrcExtPtfm_DataData%p, DstExtPtfm_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtPtfm_CopyOutput(SrcExtPtfm_DataData%y, DstExtPtfm_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtPtfm_CopyMisc(SrcExtPtfm_DataData%m, DstExtPtfm_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcExtPtfm_DataData%Input)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%Input)
      UB(1:1) = ubound(SrcExtPtfm_DataData%Input)
      if (.not. allocated(DstExtPtfm_DataData%Input)) then
         allocate(DstExtPtfm_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_CopyInput(SrcExtPtfm_DataData%Input(i1), DstExtPtfm_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcExtPtfm_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcExtPtfm_DataData%InputTimes)
      UB(1:1) = ubound(SrcExtPtfm_DataData%InputTimes)
      if (.not. allocated(DstExtPtfm_DataData%InputTimes)) then
         allocate(DstExtPtfm_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstExtPtfm_DataData%InputTimes = SrcExtPtfm_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyExtPtfm_Data(ExtPtfm_DataData, ErrStat, ErrMsg)
   type(ExtPtfm_Data), intent(inout) :: ExtPtfm_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyExtPtfm_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ExtPtfm_DataData%x)) then
      LB(1:1) = lbound(ExtPtfm_DataData%x)
      UB(1:1) = ubound(ExtPtfm_DataData%x)
      do i1 = LB(1), UB(1)
         call ExtPtfm_DestroyContState(ExtPtfm_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ExtPtfm_DataData%x)
   end if
   if (allocated(ExtPtfm_DataData%xd)) then
      LB(1:1) = lbound(ExtPtfm_DataData%xd)
      UB(1:1) = ubound(ExtPtfm_DataData%xd)
      do i1 = LB(1), UB(1)
         call ExtPtfm_DestroyDiscState(ExtPtfm_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ExtPtfm_DataData%xd)
   end if
   if (allocated(ExtPtfm_DataData%z)) then
      LB(1:1) = lbound(ExtPtfm_DataData%z)
      UB(1:1) = ubound(ExtPtfm_DataData%z)
      do i1 = LB(1), UB(1)
         call ExtPtfm_DestroyConstrState(ExtPtfm_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ExtPtfm_DataData%z)
   end if
   if (allocated(ExtPtfm_DataData%OtherSt)) then
      LB(1:1) = lbound(ExtPtfm_DataData%OtherSt)
      UB(1:1) = ubound(ExtPtfm_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call ExtPtfm_DestroyOtherState(ExtPtfm_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ExtPtfm_DataData%OtherSt)
   end if
   call ExtPtfm_DestroyParam(ExtPtfm_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtPtfm_DestroyOutput(ExtPtfm_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtPtfm_DestroyMisc(ExtPtfm_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ExtPtfm_DataData%Input)) then
      LB(1:1) = lbound(ExtPtfm_DataData%Input)
      UB(1:1) = ubound(ExtPtfm_DataData%Input)
      do i1 = LB(1), UB(1)
         call ExtPtfm_DestroyInput(ExtPtfm_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ExtPtfm_DataData%Input)
   end if
   if (allocated(ExtPtfm_DataData%InputTimes)) then
      deallocate(ExtPtfm_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackExtPtfm_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(ExtPtfm_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExtPtfm_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call ExtPtfm_PackParam(RF, InData%p) 
   call ExtPtfm_PackOutput(RF, InData%y) 
   call ExtPtfm_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackExtPtfm_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(ExtPtfm_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExtPtfm_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call ExtPtfm_UnpackParam(RF, OutData%p) ! p 
   call ExtPtfm_UnpackOutput(RF, OutData%y) ! y 
   call ExtPtfm_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopySeaState_Data(SrcSeaState_DataData, DstSeaState_DataData, CtrlCode, ErrStat, ErrMsg)
   type(SeaState_Data), intent(in) :: SrcSeaState_DataData
   type(SeaState_Data), intent(inout) :: DstSeaState_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopySeaState_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcSeaState_DataData%x)) then
      LB(1:1) = lbound(SrcSeaState_DataData%x)
      UB(1:1) = ubound(SrcSeaState_DataData%x)
      if (.not. allocated(DstSeaState_DataData%x)) then
         allocate(DstSeaState_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_CopyContState(SrcSeaState_DataData%x(i1), DstSeaState_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSeaState_DataData%xd)) then
      LB(1:1) = lbound(SrcSeaState_DataData%xd)
      UB(1:1) = ubound(SrcSeaState_DataData%xd)
      if (.not. allocated(DstSeaState_DataData%xd)) then
         allocate(DstSeaState_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_CopyDiscState(SrcSeaState_DataData%xd(i1), DstSeaState_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSeaState_DataData%z)) then
      LB(1:1) = lbound(SrcSeaState_DataData%z)
      UB(1:1) = ubound(SrcSeaState_DataData%z)
      if (.not. allocated(DstSeaState_DataData%z)) then
         allocate(DstSeaState_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_CopyConstrState(SrcSeaState_DataData%z(i1), DstSeaState_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSeaState_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcSeaState_DataData%OtherSt)
      UB(1:1) = ubound(SrcSeaState_DataData%OtherSt)
      if (.not. allocated(DstSeaState_DataData%OtherSt)) then
         allocate(DstSeaState_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_CopyOtherState(SrcSeaState_DataData%OtherSt(i1), DstSeaState_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SeaSt_CopyParam(SrcSeaState_DataData%p, DstSeaState_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SeaSt_CopyOutput(SrcSeaState_DataData%y, DstSeaState_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SeaSt_CopyMisc(SrcSeaState_DataData%m, DstSeaState_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcSeaState_DataData%Input)) then
      LB(1:1) = lbound(SrcSeaState_DataData%Input)
      UB(1:1) = ubound(SrcSeaState_DataData%Input)
      if (.not. allocated(DstSeaState_DataData%Input)) then
         allocate(DstSeaState_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_CopyInput(SrcSeaState_DataData%Input(i1), DstSeaState_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcSeaState_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcSeaState_DataData%InputTimes)
      UB(1:1) = ubound(SrcSeaState_DataData%InputTimes)
      if (.not. allocated(DstSeaState_DataData%InputTimes)) then
         allocate(DstSeaState_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstSeaState_DataData%InputTimes = SrcSeaState_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroySeaState_Data(SeaState_DataData, ErrStat, ErrMsg)
   type(SeaState_Data), intent(inout) :: SeaState_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroySeaState_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SeaState_DataData%x)) then
      LB(1:1) = lbound(SeaState_DataData%x)
      UB(1:1) = ubound(SeaState_DataData%x)
      do i1 = LB(1), UB(1)
         call SeaSt_DestroyContState(SeaState_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SeaState_DataData%x)
   end if
   if (allocated(SeaState_DataData%xd)) then
      LB(1:1) = lbound(SeaState_DataData%xd)
      UB(1:1) = ubound(SeaState_DataData%xd)
      do i1 = LB(1), UB(1)
         call SeaSt_DestroyDiscState(SeaState_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SeaState_DataData%xd)
   end if
   if (allocated(SeaState_DataData%z)) then
      LB(1:1) = lbound(SeaState_DataData%z)
      UB(1:1) = ubound(SeaState_DataData%z)
      do i1 = LB(1), UB(1)
         call SeaSt_DestroyConstrState(SeaState_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SeaState_DataData%z)
   end if
   if (allocated(SeaState_DataData%OtherSt)) then
      LB(1:1) = lbound(SeaState_DataData%OtherSt)
      UB(1:1) = ubound(SeaState_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call SeaSt_DestroyOtherState(SeaState_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SeaState_DataData%OtherSt)
   end if
   call SeaSt_DestroyParam(SeaState_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SeaSt_DestroyOutput(SeaState_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SeaSt_DestroyMisc(SeaState_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(SeaState_DataData%Input)) then
      LB(1:1) = lbound(SeaState_DataData%Input)
      UB(1:1) = ubound(SeaState_DataData%Input)
      do i1 = LB(1), UB(1)
         call SeaSt_DestroyInput(SeaState_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(SeaState_DataData%Input)
   end if
   if (allocated(SeaState_DataData%InputTimes)) then
      deallocate(SeaState_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackSeaState_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(SeaState_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSeaState_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call SeaSt_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call SeaSt_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call SeaSt_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call SeaSt_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call SeaSt_PackParam(RF, InData%p) 
   call SeaSt_PackOutput(RF, InData%y) 
   call SeaSt_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SeaSt_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackSeaState_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(SeaState_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSeaState_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call SeaSt_UnpackParam(RF, OutData%p) ! p 
   call SeaSt_UnpackOutput(RF, OutData%y) ! y 
   call SeaSt_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyHydroDyn_Data(SrcHydroDyn_DataData, DstHydroDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(HydroDyn_Data), intent(inout) :: SrcHydroDyn_DataData
   type(HydroDyn_Data), intent(inout) :: DstHydroDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyHydroDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcHydroDyn_DataData%x)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%x)
      UB(1:1) = ubound(SrcHydroDyn_DataData%x)
      if (.not. allocated(DstHydroDyn_DataData%x)) then
         allocate(DstHydroDyn_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_CopyContState(SrcHydroDyn_DataData%x(i1), DstHydroDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call HydroDyn_CopyContState(SrcHydroDyn_DataData%dxdt, DstHydroDyn_DataData%dxdt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcHydroDyn_DataData%xd)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%xd)
      UB(1:1) = ubound(SrcHydroDyn_DataData%xd)
      if (.not. allocated(DstHydroDyn_DataData%xd)) then
         allocate(DstHydroDyn_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_CopyDiscState(SrcHydroDyn_DataData%xd(i1), DstHydroDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcHydroDyn_DataData%z)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%z)
      UB(1:1) = ubound(SrcHydroDyn_DataData%z)
      if (.not. allocated(DstHydroDyn_DataData%z)) then
         allocate(DstHydroDyn_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_CopyConstrState(SrcHydroDyn_DataData%z(i1), DstHydroDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcHydroDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%OtherSt)
      UB(1:1) = ubound(SrcHydroDyn_DataData%OtherSt)
      if (.not. allocated(DstHydroDyn_DataData%OtherSt)) then
         allocate(DstHydroDyn_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_CopyOtherState(SrcHydroDyn_DataData%OtherSt(i1), DstHydroDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call HydroDyn_CopyParam(SrcHydroDyn_DataData%p, DstHydroDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call HydroDyn_CopyOutput(SrcHydroDyn_DataData%y, DstHydroDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call HydroDyn_CopyMisc(SrcHydroDyn_DataData%m, DstHydroDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcHydroDyn_DataData%Input)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%Input)
      UB(1:1) = ubound(SrcHydroDyn_DataData%Input)
      if (.not. allocated(DstHydroDyn_DataData%Input)) then
         allocate(DstHydroDyn_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_CopyInput(SrcHydroDyn_DataData%Input(i1), DstHydroDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcHydroDyn_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcHydroDyn_DataData%InputTimes)
      UB(1:1) = ubound(SrcHydroDyn_DataData%InputTimes)
      if (.not. allocated(DstHydroDyn_DataData%InputTimes)) then
         allocate(DstHydroDyn_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstHydroDyn_DataData%InputTimes = SrcHydroDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyHydroDyn_Data(HydroDyn_DataData, ErrStat, ErrMsg)
   type(HydroDyn_Data), intent(inout) :: HydroDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyHydroDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(HydroDyn_DataData%x)) then
      LB(1:1) = lbound(HydroDyn_DataData%x)
      UB(1:1) = ubound(HydroDyn_DataData%x)
      do i1 = LB(1), UB(1)
         call HydroDyn_DestroyContState(HydroDyn_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(HydroDyn_DataData%x)
   end if
   call HydroDyn_DestroyContState(HydroDyn_DataData%dxdt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(HydroDyn_DataData%xd)) then
      LB(1:1) = lbound(HydroDyn_DataData%xd)
      UB(1:1) = ubound(HydroDyn_DataData%xd)
      do i1 = LB(1), UB(1)
         call HydroDyn_DestroyDiscState(HydroDyn_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(HydroDyn_DataData%xd)
   end if
   if (allocated(HydroDyn_DataData%z)) then
      LB(1:1) = lbound(HydroDyn_DataData%z)
      UB(1:1) = ubound(HydroDyn_DataData%z)
      do i1 = LB(1), UB(1)
         call HydroDyn_DestroyConstrState(HydroDyn_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(HydroDyn_DataData%z)
   end if
   if (allocated(HydroDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(HydroDyn_DataData%OtherSt)
      UB(1:1) = ubound(HydroDyn_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call HydroDyn_DestroyOtherState(HydroDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(HydroDyn_DataData%OtherSt)
   end if
   call HydroDyn_DestroyParam(HydroDyn_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call HydroDyn_DestroyOutput(HydroDyn_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call HydroDyn_DestroyMisc(HydroDyn_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(HydroDyn_DataData%Input)) then
      LB(1:1) = lbound(HydroDyn_DataData%Input)
      UB(1:1) = ubound(HydroDyn_DataData%Input)
      do i1 = LB(1), UB(1)
         call HydroDyn_DestroyInput(HydroDyn_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(HydroDyn_DataData%Input)
   end if
   if (allocated(HydroDyn_DataData%InputTimes)) then
      deallocate(HydroDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackHydroDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(HydroDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackHydroDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call HydroDyn_PackContState(RF, InData%dxdt) 
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call HydroDyn_PackParam(RF, InData%p) 
   call HydroDyn_PackOutput(RF, InData%y) 
   call HydroDyn_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackHydroDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(HydroDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackHydroDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   call HydroDyn_UnpackContState(RF, OutData%dxdt) ! dxdt 
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call HydroDyn_UnpackParam(RF, OutData%p) ! p 
   call HydroDyn_UnpackOutput(RF, OutData%y) ! y 
   call HydroDyn_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyIceFloe_Data(SrcIceFloe_DataData, DstIceFloe_DataData, CtrlCode, ErrStat, ErrMsg)
   type(IceFloe_Data), intent(inout) :: SrcIceFloe_DataData
   type(IceFloe_Data), intent(inout) :: DstIceFloe_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyIceFloe_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcIceFloe_DataData%x)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%x)
      UB(1:1) = ubound(SrcIceFloe_DataData%x)
      if (.not. allocated(DstIceFloe_DataData%x)) then
         allocate(DstIceFloe_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_CopyContState(SrcIceFloe_DataData%x(i1), DstIceFloe_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceFloe_DataData%xd)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%xd)
      UB(1:1) = ubound(SrcIceFloe_DataData%xd)
      if (.not. allocated(DstIceFloe_DataData%xd)) then
         allocate(DstIceFloe_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_CopyDiscState(SrcIceFloe_DataData%xd(i1), DstIceFloe_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceFloe_DataData%z)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%z)
      UB(1:1) = ubound(SrcIceFloe_DataData%z)
      if (.not. allocated(DstIceFloe_DataData%z)) then
         allocate(DstIceFloe_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_CopyConstrState(SrcIceFloe_DataData%z(i1), DstIceFloe_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceFloe_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%OtherSt)
      UB(1:1) = ubound(SrcIceFloe_DataData%OtherSt)
      if (.not. allocated(DstIceFloe_DataData%OtherSt)) then
         allocate(DstIceFloe_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_CopyOtherState(SrcIceFloe_DataData%OtherSt(i1), DstIceFloe_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call IceFloe_CopyParam(SrcIceFloe_DataData%p, DstIceFloe_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceFloe_CopyOutput(SrcIceFloe_DataData%y, DstIceFloe_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceFloe_CopyMisc(SrcIceFloe_DataData%m, DstIceFloe_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcIceFloe_DataData%Input)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%Input)
      UB(1:1) = ubound(SrcIceFloe_DataData%Input)
      if (.not. allocated(DstIceFloe_DataData%Input)) then
         allocate(DstIceFloe_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_CopyInput(SrcIceFloe_DataData%Input(i1), DstIceFloe_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcIceFloe_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcIceFloe_DataData%InputTimes)
      UB(1:1) = ubound(SrcIceFloe_DataData%InputTimes)
      if (.not. allocated(DstIceFloe_DataData%InputTimes)) then
         allocate(DstIceFloe_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstIceFloe_DataData%InputTimes = SrcIceFloe_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyIceFloe_Data(IceFloe_DataData, ErrStat, ErrMsg)
   type(IceFloe_Data), intent(inout) :: IceFloe_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyIceFloe_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(IceFloe_DataData%x)) then
      LB(1:1) = lbound(IceFloe_DataData%x)
      UB(1:1) = ubound(IceFloe_DataData%x)
      do i1 = LB(1), UB(1)
         call IceFloe_DestroyContState(IceFloe_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceFloe_DataData%x)
   end if
   if (allocated(IceFloe_DataData%xd)) then
      LB(1:1) = lbound(IceFloe_DataData%xd)
      UB(1:1) = ubound(IceFloe_DataData%xd)
      do i1 = LB(1), UB(1)
         call IceFloe_DestroyDiscState(IceFloe_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceFloe_DataData%xd)
   end if
   if (allocated(IceFloe_DataData%z)) then
      LB(1:1) = lbound(IceFloe_DataData%z)
      UB(1:1) = ubound(IceFloe_DataData%z)
      do i1 = LB(1), UB(1)
         call IceFloe_DestroyConstrState(IceFloe_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceFloe_DataData%z)
   end if
   if (allocated(IceFloe_DataData%OtherSt)) then
      LB(1:1) = lbound(IceFloe_DataData%OtherSt)
      UB(1:1) = ubound(IceFloe_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call IceFloe_DestroyOtherState(IceFloe_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceFloe_DataData%OtherSt)
   end if
   call IceFloe_DestroyParam(IceFloe_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceFloe_DestroyOutput(IceFloe_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceFloe_DestroyMisc(IceFloe_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(IceFloe_DataData%Input)) then
      LB(1:1) = lbound(IceFloe_DataData%Input)
      UB(1:1) = ubound(IceFloe_DataData%Input)
      do i1 = LB(1), UB(1)
         call IceFloe_DestroyInput(IceFloe_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(IceFloe_DataData%Input)
   end if
   if (allocated(IceFloe_DataData%InputTimes)) then
      deallocate(IceFloe_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackIceFloe_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(IceFloe_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackIceFloe_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call IceFloe_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call IceFloe_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call IceFloe_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call IceFloe_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call IceFloe_PackParam(RF, InData%p) 
   call IceFloe_PackOutput(RF, InData%y) 
   call IceFloe_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call IceFloe_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackIceFloe_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(IceFloe_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackIceFloe_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call IceFloe_UnpackParam(RF, OutData%p) ! p 
   call IceFloe_UnpackOutput(RF, OutData%y) ! y 
   call IceFloe_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyMAP_Data(SrcMAP_DataData, DstMAP_DataData, CtrlCode, ErrStat, ErrMsg)
   type(MAP_Data), intent(inout) :: SrcMAP_DataData
   type(MAP_Data), intent(inout) :: DstMAP_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyMAP_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMAP_DataData%x)) then
      LB(1:1) = lbound(SrcMAP_DataData%x)
      UB(1:1) = ubound(SrcMAP_DataData%x)
      if (.not. allocated(DstMAP_DataData%x)) then
         allocate(DstMAP_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MAP_CopyContState(SrcMAP_DataData%x(i1), DstMAP_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMAP_DataData%xd)) then
      LB(1:1) = lbound(SrcMAP_DataData%xd)
      UB(1:1) = ubound(SrcMAP_DataData%xd)
      if (.not. allocated(DstMAP_DataData%xd)) then
         allocate(DstMAP_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MAP_CopyDiscState(SrcMAP_DataData%xd(i1), DstMAP_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMAP_DataData%z)) then
      LB(1:1) = lbound(SrcMAP_DataData%z)
      UB(1:1) = ubound(SrcMAP_DataData%z)
      if (.not. allocated(DstMAP_DataData%z)) then
         allocate(DstMAP_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MAP_CopyConstrState(SrcMAP_DataData%z(i1), DstMAP_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MAP_CopyOtherState(SrcMAP_DataData%OtherSt, DstMAP_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyParam(SrcMAP_DataData%p, DstMAP_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyOutput(SrcMAP_DataData%y, DstMAP_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyMisc(SrcMAP_DataData%m, DstMAP_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyOtherState(SrcMAP_DataData%OtherSt_old, DstMAP_DataData%OtherSt_old, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMAP_DataData%Input)) then
      LB(1:1) = lbound(SrcMAP_DataData%Input)
      UB(1:1) = ubound(SrcMAP_DataData%Input)
      if (.not. allocated(DstMAP_DataData%Input)) then
         allocate(DstMAP_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MAP_CopyInput(SrcMAP_DataData%Input(i1), DstMAP_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMAP_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcMAP_DataData%InputTimes)
      UB(1:1) = ubound(SrcMAP_DataData%InputTimes)
      if (.not. allocated(DstMAP_DataData%InputTimes)) then
         allocate(DstMAP_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMAP_DataData%InputTimes = SrcMAP_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyMAP_Data(MAP_DataData, ErrStat, ErrMsg)
   type(MAP_Data), intent(inout) :: MAP_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyMAP_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MAP_DataData%x)) then
      LB(1:1) = lbound(MAP_DataData%x)
      UB(1:1) = ubound(MAP_DataData%x)
      do i1 = LB(1), UB(1)
         call MAP_DestroyContState(MAP_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MAP_DataData%x)
   end if
   if (allocated(MAP_DataData%xd)) then
      LB(1:1) = lbound(MAP_DataData%xd)
      UB(1:1) = ubound(MAP_DataData%xd)
      do i1 = LB(1), UB(1)
         call MAP_DestroyDiscState(MAP_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MAP_DataData%xd)
   end if
   if (allocated(MAP_DataData%z)) then
      LB(1:1) = lbound(MAP_DataData%z)
      UB(1:1) = ubound(MAP_DataData%z)
      do i1 = LB(1), UB(1)
         call MAP_DestroyConstrState(MAP_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MAP_DataData%z)
   end if
   call MAP_DestroyOtherState(MAP_DataData%OtherSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyParam(MAP_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyOutput(MAP_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyMisc(MAP_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyOtherState(MAP_DataData%OtherSt_old, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MAP_DataData%Input)) then
      LB(1:1) = lbound(MAP_DataData%Input)
      UB(1:1) = ubound(MAP_DataData%Input)
      do i1 = LB(1), UB(1)
         call MAP_DestroyInput(MAP_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MAP_DataData%Input)
   end if
   if (allocated(MAP_DataData%InputTimes)) then
      deallocate(MAP_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackMAP_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MAP_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMAP_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call MAP_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call MAP_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call MAP_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call MAP_PackOtherState(RF, InData%OtherSt) 
   call MAP_PackParam(RF, InData%p) 
   call MAP_PackOutput(RF, InData%y) 
   call MAP_PackMisc(RF, InData%m) 
   call MAP_PackOtherState(RF, InData%OtherSt_old) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call MAP_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackMAP_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MAP_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMAP_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   call MAP_UnpackOtherState(RF, OutData%OtherSt) ! OtherSt 
   call MAP_UnpackParam(RF, OutData%p) ! p 
   call MAP_UnpackOutput(RF, OutData%y) ! y 
   call MAP_UnpackMisc(RF, OutData%m) ! m 
   call MAP_UnpackOtherState(RF, OutData%OtherSt_old) ! OtherSt_old 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyFEAMooring_Data(SrcFEAMooring_DataData, DstFEAMooring_DataData, CtrlCode, ErrStat, ErrMsg)
   type(FEAMooring_Data), intent(inout) :: SrcFEAMooring_DataData
   type(FEAMooring_Data), intent(inout) :: DstFEAMooring_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyFEAMooring_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcFEAMooring_DataData%x)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%x)
      UB(1:1) = ubound(SrcFEAMooring_DataData%x)
      if (.not. allocated(DstFEAMooring_DataData%x)) then
         allocate(DstFEAMooring_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FEAM_CopyContState(SrcFEAMooring_DataData%x(i1), DstFEAMooring_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcFEAMooring_DataData%xd)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%xd)
      UB(1:1) = ubound(SrcFEAMooring_DataData%xd)
      if (.not. allocated(DstFEAMooring_DataData%xd)) then
         allocate(DstFEAMooring_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FEAM_CopyDiscState(SrcFEAMooring_DataData%xd(i1), DstFEAMooring_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcFEAMooring_DataData%z)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%z)
      UB(1:1) = ubound(SrcFEAMooring_DataData%z)
      if (.not. allocated(DstFEAMooring_DataData%z)) then
         allocate(DstFEAMooring_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FEAM_CopyConstrState(SrcFEAMooring_DataData%z(i1), DstFEAMooring_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcFEAMooring_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%OtherSt)
      UB(1:1) = ubound(SrcFEAMooring_DataData%OtherSt)
      if (.not. allocated(DstFEAMooring_DataData%OtherSt)) then
         allocate(DstFEAMooring_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FEAM_CopyOtherState(SrcFEAMooring_DataData%OtherSt(i1), DstFEAMooring_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call FEAM_CopyParam(SrcFEAMooring_DataData%p, DstFEAMooring_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FEAM_CopyOutput(SrcFEAMooring_DataData%y, DstFEAMooring_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FEAM_CopyMisc(SrcFEAMooring_DataData%m, DstFEAMooring_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcFEAMooring_DataData%Input)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%Input)
      UB(1:1) = ubound(SrcFEAMooring_DataData%Input)
      if (.not. allocated(DstFEAMooring_DataData%Input)) then
         allocate(DstFEAMooring_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call FEAM_CopyInput(SrcFEAMooring_DataData%Input(i1), DstFEAMooring_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcFEAMooring_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcFEAMooring_DataData%InputTimes)
      UB(1:1) = ubound(SrcFEAMooring_DataData%InputTimes)
      if (.not. allocated(DstFEAMooring_DataData%InputTimes)) then
         allocate(DstFEAMooring_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstFEAMooring_DataData%InputTimes = SrcFEAMooring_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyFEAMooring_Data(FEAMooring_DataData, ErrStat, ErrMsg)
   type(FEAMooring_Data), intent(inout) :: FEAMooring_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyFEAMooring_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(FEAMooring_DataData%x)) then
      LB(1:1) = lbound(FEAMooring_DataData%x)
      UB(1:1) = ubound(FEAMooring_DataData%x)
      do i1 = LB(1), UB(1)
         call FEAM_DestroyContState(FEAMooring_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(FEAMooring_DataData%x)
   end if
   if (allocated(FEAMooring_DataData%xd)) then
      LB(1:1) = lbound(FEAMooring_DataData%xd)
      UB(1:1) = ubound(FEAMooring_DataData%xd)
      do i1 = LB(1), UB(1)
         call FEAM_DestroyDiscState(FEAMooring_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(FEAMooring_DataData%xd)
   end if
   if (allocated(FEAMooring_DataData%z)) then
      LB(1:1) = lbound(FEAMooring_DataData%z)
      UB(1:1) = ubound(FEAMooring_DataData%z)
      do i1 = LB(1), UB(1)
         call FEAM_DestroyConstrState(FEAMooring_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(FEAMooring_DataData%z)
   end if
   if (allocated(FEAMooring_DataData%OtherSt)) then
      LB(1:1) = lbound(FEAMooring_DataData%OtherSt)
      UB(1:1) = ubound(FEAMooring_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call FEAM_DestroyOtherState(FEAMooring_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(FEAMooring_DataData%OtherSt)
   end if
   call FEAM_DestroyParam(FEAMooring_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FEAM_DestroyOutput(FEAMooring_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FEAM_DestroyMisc(FEAMooring_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(FEAMooring_DataData%Input)) then
      LB(1:1) = lbound(FEAMooring_DataData%Input)
      UB(1:1) = ubound(FEAMooring_DataData%Input)
      do i1 = LB(1), UB(1)
         call FEAM_DestroyInput(FEAMooring_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(FEAMooring_DataData%Input)
   end if
   if (allocated(FEAMooring_DataData%InputTimes)) then
      deallocate(FEAMooring_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackFEAMooring_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FEAMooring_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackFEAMooring_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call FEAM_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call FEAM_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call FEAM_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call FEAM_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call FEAM_PackParam(RF, InData%p) 
   call FEAM_PackOutput(RF, InData%y) 
   call FEAM_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call FEAM_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackFEAMooring_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FEAMooring_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackFEAMooring_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call FEAM_UnpackParam(RF, OutData%p) ! p 
   call FEAM_UnpackOutput(RF, OutData%y) ! y 
   call FEAM_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyMoorDyn_Data(SrcMoorDyn_DataData, DstMoorDyn_DataData, CtrlCode, ErrStat, ErrMsg)
   type(MoorDyn_Data), intent(inout) :: SrcMoorDyn_DataData
   type(MoorDyn_Data), intent(inout) :: DstMoorDyn_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyMoorDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMoorDyn_DataData%x)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%x)
      UB(1:1) = ubound(SrcMoorDyn_DataData%x)
      if (.not. allocated(DstMoorDyn_DataData%x)) then
         allocate(DstMoorDyn_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyContState(SrcMoorDyn_DataData%x(i1), DstMoorDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMoorDyn_DataData%xd)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%xd)
      UB(1:1) = ubound(SrcMoorDyn_DataData%xd)
      if (.not. allocated(DstMoorDyn_DataData%xd)) then
         allocate(DstMoorDyn_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyDiscState(SrcMoorDyn_DataData%xd(i1), DstMoorDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMoorDyn_DataData%z)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%z)
      UB(1:1) = ubound(SrcMoorDyn_DataData%z)
      if (.not. allocated(DstMoorDyn_DataData%z)) then
         allocate(DstMoorDyn_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyConstrState(SrcMoorDyn_DataData%z(i1), DstMoorDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMoorDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%OtherSt)
      UB(1:1) = ubound(SrcMoorDyn_DataData%OtherSt)
      if (.not. allocated(DstMoorDyn_DataData%OtherSt)) then
         allocate(DstMoorDyn_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyOtherState(SrcMoorDyn_DataData%OtherSt(i1), DstMoorDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MD_CopyParam(SrcMoorDyn_DataData%p, DstMoorDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyOutput(SrcMoorDyn_DataData%y, DstMoorDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyMisc(SrcMoorDyn_DataData%m, DstMoorDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMoorDyn_DataData%Input)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%Input)
      UB(1:1) = ubound(SrcMoorDyn_DataData%Input)
      if (.not. allocated(DstMoorDyn_DataData%Input)) then
         allocate(DstMoorDyn_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyInput(SrcMoorDyn_DataData%Input(i1), DstMoorDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMoorDyn_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcMoorDyn_DataData%InputTimes)
      UB(1:1) = ubound(SrcMoorDyn_DataData%InputTimes)
      if (.not. allocated(DstMoorDyn_DataData%InputTimes)) then
         allocate(DstMoorDyn_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMoorDyn_DataData%InputTimes = SrcMoorDyn_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyMoorDyn_Data(MoorDyn_DataData, ErrStat, ErrMsg)
   type(MoorDyn_Data), intent(inout) :: MoorDyn_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyMoorDyn_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MoorDyn_DataData%x)) then
      LB(1:1) = lbound(MoorDyn_DataData%x)
      UB(1:1) = ubound(MoorDyn_DataData%x)
      do i1 = LB(1), UB(1)
         call MD_DestroyContState(MoorDyn_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MoorDyn_DataData%x)
   end if
   if (allocated(MoorDyn_DataData%xd)) then
      LB(1:1) = lbound(MoorDyn_DataData%xd)
      UB(1:1) = ubound(MoorDyn_DataData%xd)
      do i1 = LB(1), UB(1)
         call MD_DestroyDiscState(MoorDyn_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MoorDyn_DataData%xd)
   end if
   if (allocated(MoorDyn_DataData%z)) then
      LB(1:1) = lbound(MoorDyn_DataData%z)
      UB(1:1) = ubound(MoorDyn_DataData%z)
      do i1 = LB(1), UB(1)
         call MD_DestroyConstrState(MoorDyn_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MoorDyn_DataData%z)
   end if
   if (allocated(MoorDyn_DataData%OtherSt)) then
      LB(1:1) = lbound(MoorDyn_DataData%OtherSt)
      UB(1:1) = ubound(MoorDyn_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call MD_DestroyOtherState(MoorDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MoorDyn_DataData%OtherSt)
   end if
   call MD_DestroyParam(MoorDyn_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyOutput(MoorDyn_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyMisc(MoorDyn_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MoorDyn_DataData%Input)) then
      LB(1:1) = lbound(MoorDyn_DataData%Input)
      UB(1:1) = ubound(MoorDyn_DataData%Input)
      do i1 = LB(1), UB(1)
         call MD_DestroyInput(MoorDyn_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MoorDyn_DataData%Input)
   end if
   if (allocated(MoorDyn_DataData%InputTimes)) then
      deallocate(MoorDyn_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackMoorDyn_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MoorDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMoorDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call MD_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call MD_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call MD_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call MD_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call MD_PackParam(RF, InData%p) 
   call MD_PackOutput(RF, InData%y) 
   call MD_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call MD_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackMoorDyn_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MoorDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMoorDyn_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call MD_UnpackParam(RF, OutData%p) ! p 
   call MD_UnpackOutput(RF, OutData%y) ! y 
   call MD_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyOrcaFlex_Data(SrcOrcaFlex_DataData, DstOrcaFlex_DataData, CtrlCode, ErrStat, ErrMsg)
   type(OrcaFlex_Data), intent(inout) :: SrcOrcaFlex_DataData
   type(OrcaFlex_Data), intent(inout) :: DstOrcaFlex_DataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyOrcaFlex_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOrcaFlex_DataData%x)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%x)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%x)
      if (.not. allocated(DstOrcaFlex_DataData%x)) then
         allocate(DstOrcaFlex_DataData%x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Orca_CopyContState(SrcOrcaFlex_DataData%x(i1), DstOrcaFlex_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOrcaFlex_DataData%xd)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%xd)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%xd)
      if (.not. allocated(DstOrcaFlex_DataData%xd)) then
         allocate(DstOrcaFlex_DataData%xd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%xd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Orca_CopyDiscState(SrcOrcaFlex_DataData%xd(i1), DstOrcaFlex_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOrcaFlex_DataData%z)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%z)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%z)
      if (.not. allocated(DstOrcaFlex_DataData%z)) then
         allocate(DstOrcaFlex_DataData%z(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Orca_CopyConstrState(SrcOrcaFlex_DataData%z(i1), DstOrcaFlex_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOrcaFlex_DataData%OtherSt)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%OtherSt)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%OtherSt)
      if (.not. allocated(DstOrcaFlex_DataData%OtherSt)) then
         allocate(DstOrcaFlex_DataData%OtherSt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%OtherSt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Orca_CopyOtherState(SrcOrcaFlex_DataData%OtherSt(i1), DstOrcaFlex_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call Orca_CopyParam(SrcOrcaFlex_DataData%p, DstOrcaFlex_DataData%p, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Orca_CopyOutput(SrcOrcaFlex_DataData%y, DstOrcaFlex_DataData%y, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Orca_CopyMisc(SrcOrcaFlex_DataData%m, DstOrcaFlex_DataData%m, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcOrcaFlex_DataData%Input)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%Input)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%Input)
      if (.not. allocated(DstOrcaFlex_DataData%Input)) then
         allocate(DstOrcaFlex_DataData%Input(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%Input.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call Orca_CopyInput(SrcOrcaFlex_DataData%Input(i1), DstOrcaFlex_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOrcaFlex_DataData%InputTimes)) then
      LB(1:1) = lbound(SrcOrcaFlex_DataData%InputTimes)
      UB(1:1) = ubound(SrcOrcaFlex_DataData%InputTimes)
      if (.not. allocated(DstOrcaFlex_DataData%InputTimes)) then
         allocate(DstOrcaFlex_DataData%InputTimes(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%InputTimes.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOrcaFlex_DataData%InputTimes = SrcOrcaFlex_DataData%InputTimes
   end if
end subroutine

subroutine FAST_DestroyOrcaFlex_Data(OrcaFlex_DataData, ErrStat, ErrMsg)
   type(OrcaFlex_Data), intent(inout) :: OrcaFlex_DataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyOrcaFlex_Data'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OrcaFlex_DataData%x)) then
      LB(1:1) = lbound(OrcaFlex_DataData%x)
      UB(1:1) = ubound(OrcaFlex_DataData%x)
      do i1 = LB(1), UB(1)
         call Orca_DestroyContState(OrcaFlex_DataData%x(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OrcaFlex_DataData%x)
   end if
   if (allocated(OrcaFlex_DataData%xd)) then
      LB(1:1) = lbound(OrcaFlex_DataData%xd)
      UB(1:1) = ubound(OrcaFlex_DataData%xd)
      do i1 = LB(1), UB(1)
         call Orca_DestroyDiscState(OrcaFlex_DataData%xd(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OrcaFlex_DataData%xd)
   end if
   if (allocated(OrcaFlex_DataData%z)) then
      LB(1:1) = lbound(OrcaFlex_DataData%z)
      UB(1:1) = ubound(OrcaFlex_DataData%z)
      do i1 = LB(1), UB(1)
         call Orca_DestroyConstrState(OrcaFlex_DataData%z(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OrcaFlex_DataData%z)
   end if
   if (allocated(OrcaFlex_DataData%OtherSt)) then
      LB(1:1) = lbound(OrcaFlex_DataData%OtherSt)
      UB(1:1) = ubound(OrcaFlex_DataData%OtherSt)
      do i1 = LB(1), UB(1)
         call Orca_DestroyOtherState(OrcaFlex_DataData%OtherSt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OrcaFlex_DataData%OtherSt)
   end if
   call Orca_DestroyParam(OrcaFlex_DataData%p, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Orca_DestroyOutput(OrcaFlex_DataData%y, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Orca_DestroyMisc(OrcaFlex_DataData%m, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(OrcaFlex_DataData%Input)) then
      LB(1:1) = lbound(OrcaFlex_DataData%Input)
      UB(1:1) = ubound(OrcaFlex_DataData%Input)
      do i1 = LB(1), UB(1)
         call Orca_DestroyInput(OrcaFlex_DataData%Input(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OrcaFlex_DataData%Input)
   end if
   if (allocated(OrcaFlex_DataData%InputTimes)) then
      deallocate(OrcaFlex_DataData%InputTimes)
   end if
end subroutine

subroutine FAST_PackOrcaFlex_Data(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(OrcaFlex_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackOrcaFlex_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(RF, 1, lbound(InData%x), ubound(InData%x))
      LB(1:1) = lbound(InData%x)
      UB(1:1) = ubound(InData%x)
      do i1 = LB(1), UB(1)
         call Orca_PackContState(RF, InData%x(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(RF, 1, lbound(InData%xd), ubound(InData%xd))
      LB(1:1) = lbound(InData%xd)
      UB(1:1) = ubound(InData%xd)
      do i1 = LB(1), UB(1)
         call Orca_PackDiscState(RF, InData%xd(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(RF, 1, lbound(InData%z), ubound(InData%z))
      LB(1:1) = lbound(InData%z)
      UB(1:1) = ubound(InData%z)
      do i1 = LB(1), UB(1)
         call Orca_PackConstrState(RF, InData%z(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(RF, 1, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:1) = lbound(InData%OtherSt)
      UB(1:1) = ubound(InData%OtherSt)
      do i1 = LB(1), UB(1)
         call Orca_PackOtherState(RF, InData%OtherSt(i1)) 
      end do
   end if
   call Orca_PackParam(RF, InData%p) 
   call Orca_PackOutput(RF, InData%y) 
   call Orca_PackMisc(RF, InData%m) 
   call RegPack(RF, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(RF, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call Orca_PackInput(RF, InData%Input(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%InputTimes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackOrcaFlex_Data(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(OrcaFlex_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackOrcaFlex_Data'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackContState(RF, OutData%x(i1)) ! x 
      end do
   end if
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackDiscState(RF, OutData%xd(i1)) ! xd 
      end do
   end if
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackConstrState(RF, OutData%z(i1)) ! z 
      end do
   end if
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackOtherState(RF, OutData%OtherSt(i1)) ! OtherSt 
      end do
   end if
   call Orca_UnpackParam(RF, OutData%p) ! p 
   call Orca_UnpackOutput(RF, OutData%y) ! y 
   call Orca_UnpackMisc(RF, OutData%m) ! m 
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackInput(RF, OutData%Input(i1)) ! Input 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%InputTimes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyExternInputType(SrcExternInputTypeData, DstExternInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_ExternInputType), intent(in) :: SrcExternInputTypeData
   type(FAST_ExternInputType), intent(inout) :: DstExternInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_CopyExternInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstExternInputTypeData%GenTrq = SrcExternInputTypeData%GenTrq
   DstExternInputTypeData%ElecPwr = SrcExternInputTypeData%ElecPwr
   DstExternInputTypeData%YawPosCom = SrcExternInputTypeData%YawPosCom
   DstExternInputTypeData%YawRateCom = SrcExternInputTypeData%YawRateCom
   DstExternInputTypeData%BlPitchCom = SrcExternInputTypeData%BlPitchCom
   DstExternInputTypeData%BlAirfoilCom = SrcExternInputTypeData%BlAirfoilCom
   DstExternInputTypeData%HSSBrFrac = SrcExternInputTypeData%HSSBrFrac
   DstExternInputTypeData%LidarFocus = SrcExternInputTypeData%LidarFocus
   DstExternInputTypeData%CableDeltaL = SrcExternInputTypeData%CableDeltaL
   DstExternInputTypeData%CableDeltaLdot = SrcExternInputTypeData%CableDeltaLdot
end subroutine

subroutine FAST_DestroyExternInputType(ExternInputTypeData, ErrStat, ErrMsg)
   type(FAST_ExternInputType), intent(inout) :: ExternInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyExternInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine FAST_PackExternInputType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_ExternInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExternInputType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%GenTrq)
   call RegPack(RF, InData%ElecPwr)
   call RegPack(RF, InData%YawPosCom)
   call RegPack(RF, InData%YawRateCom)
   call RegPack(RF, InData%BlPitchCom)
   call RegPack(RF, InData%BlAirfoilCom)
   call RegPack(RF, InData%HSSBrFrac)
   call RegPack(RF, InData%LidarFocus)
   call RegPack(RF, InData%CableDeltaL)
   call RegPack(RF, InData%CableDeltaLdot)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackExternInputType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_ExternInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExternInputType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%GenTrq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ElecPwr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%YawPosCom); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%YawRateCom); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BlPitchCom); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BlAirfoilCom); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%HSSBrFrac); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LidarFocus); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CableDeltaL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CableDeltaLdot); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_MiscVarType), intent(in) :: SrcMiscData
   type(FAST_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMiscData%TiLstPrn = SrcMiscData%TiLstPrn
   DstMiscData%t_global = SrcMiscData%t_global
   DstMiscData%NextJacCalcTime = SrcMiscData%NextJacCalcTime
   DstMiscData%PrevClockTime = SrcMiscData%PrevClockTime
   DstMiscData%UsrTime1 = SrcMiscData%UsrTime1
   DstMiscData%UsrTime2 = SrcMiscData%UsrTime2
   DstMiscData%StrtTime = SrcMiscData%StrtTime
   DstMiscData%SimStrtTime = SrcMiscData%SimStrtTime
   DstMiscData%calcJacobian = SrcMiscData%calcJacobian
   call FAST_CopyExternInputType(SrcMiscData%ExternInput, DstMiscData%ExternInput, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyMiscLinType(SrcMiscData%Lin, DstMiscData%Lin, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine FAST_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(FAST_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call FAST_DestroyExternInputType(MiscData%ExternInput, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyMiscLinType(MiscData%Lin, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine FAST_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMisc'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%TiLstPrn)
   call RegPack(RF, InData%t_global)
   call RegPack(RF, InData%NextJacCalcTime)
   call RegPack(RF, InData%PrevClockTime)
   call RegPack(RF, InData%UsrTime1)
   call RegPack(RF, InData%UsrTime2)
   call RegPack(RF, InData%StrtTime)
   call RegPack(RF, InData%SimStrtTime)
   call RegPack(RF, InData%calcJacobian)
   call FAST_PackExternInputType(RF, InData%ExternInput) 
   call FAST_PackMiscLinType(RF, InData%Lin) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMisc'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%TiLstPrn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%t_global); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NextJacCalcTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PrevClockTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UsrTime1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UsrTime2); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%StrtTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%SimStrtTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%calcJacobian); if (RegCheckErr(RF, RoutineName)) return
   call FAST_UnpackExternInputType(RF, OutData%ExternInput) ! ExternInput 
   call FAST_UnpackMiscLinType(RF, OutData%Lin) ! Lin 
end subroutine

subroutine FAST_CopyInitData(SrcInitDataData, DstInitDataData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_InitData), intent(inout) :: SrcInitDataData
   type(FAST_InitData), intent(inout) :: DstInitDataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyInitData'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call ED_CopyInitInput(SrcInitDataData%InData_ED, DstInitDataData%InData_ED, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInitDataData%OutData_ED)) then
      LB(1:1) = lbound(SrcInitDataData%OutData_ED)
      UB(1:1) = ubound(SrcInitDataData%OutData_ED)
      if (.not. allocated(DstInitDataData%OutData_ED)) then
         allocate(DstInitDataData%OutData_ED(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%OutData_ED.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ED_CopyInitOutput(SrcInitDataData%OutData_ED(i1), DstInitDataData%OutData_ED(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SED_CopyInitInput(SrcInitDataData%InData_SED, DstInitDataData%InData_SED, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SED_CopyInitOutput(SrcInitDataData%OutData_SED, DstInitDataData%OutData_SED, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call BD_CopyInitInput(SrcInitDataData%InData_BD, DstInitDataData%InData_BD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInitDataData%OutData_BD)) then
      LB(1:1) = lbound(SrcInitDataData%OutData_BD)
      UB(1:1) = ubound(SrcInitDataData%OutData_BD)
      if (.not. allocated(DstInitDataData%OutData_BD)) then
         allocate(DstInitDataData%OutData_BD(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%OutData_BD.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call BD_CopyInitOutput(SrcInitDataData%OutData_BD(i1), DstInitDataData%OutData_BD(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call SrvD_CopyInitInput(SrcInitDataData%InData_SrvD, DstInitDataData%InData_SrvD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SrvD_CopyInitOutput(SrcInitDataData%OutData_SrvD, DstInitDataData%OutData_SrvD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD_CopyInitInput(SrcInitDataData%InData_AD, DstInitDataData%InData_AD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call AD_CopyInitOutput(SrcInitDataData%OutData_AD, DstInitDataData%OutData_AD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ADsk_CopyInitInput(SrcInitDataData%InData_ADsk, DstInitDataData%InData_ADsk, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ADsk_CopyInitOutput(SrcInitDataData%OutData_ADsk, DstInitDataData%OutData_ADsk, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtLd_CopyInitInput(SrcInitDataData%InData_ExtLd, DstInitDataData%InData_ExtLd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtLd_CopyInitOutput(SrcInitDataData%OutData_ExtLd, DstInitDataData%OutData_ExtLd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyInitInput(SrcInitDataData%InData_IfW, DstInitDataData%InData_IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call InflowWind_CopyInitOutput(SrcInitDataData%OutData_IfW, DstInitDataData%OutData_IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtInfw_CopyInitInput(SrcInitDataData%InData_ExtInfw, DstInitDataData%InData_ExtInfw, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtInfw_CopyInitOutput(SrcInitDataData%OutData_ExtInfw, DstInitDataData%OutData_ExtInfw, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SeaSt_CopyInitInput(SrcInitDataData%InData_SeaSt, DstInitDataData%InData_SeaSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SeaSt_CopyInitOutput(SrcInitDataData%OutData_SeaSt, DstInitDataData%OutData_SeaSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call HydroDyn_CopyInitInput(SrcInitDataData%InData_HD, DstInitDataData%InData_HD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call HydroDyn_CopyInitOutput(SrcInitDataData%OutData_HD, DstInitDataData%OutData_HD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SD_CopyInitInput(SrcInitDataData%InData_SD, DstInitDataData%InData_SD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call SD_CopyInitOutput(SrcInitDataData%OutData_SD, DstInitDataData%OutData_SD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtPtfm_CopyInitInput(SrcInitDataData%InData_ExtPtfm, DstInitDataData%InData_ExtPtfm, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call ExtPtfm_CopyInitOutput(SrcInitDataData%OutData_ExtPtfm, DstInitDataData%OutData_ExtPtfm, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyInitInput(SrcInitDataData%InData_MAP, DstInitDataData%InData_MAP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MAP_CopyInitOutput(SrcInitDataData%OutData_MAP, DstInitDataData%OutData_MAP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FEAM_CopyInitInput(SrcInitDataData%InData_FEAM, DstInitDataData%InData_FEAM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FEAM_CopyInitOutput(SrcInitDataData%OutData_FEAM, DstInitDataData%OutData_FEAM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyInitInput(SrcInitDataData%InData_MD, DstInitDataData%InData_MD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyInitOutput(SrcInitDataData%OutData_MD, DstInitDataData%OutData_MD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Orca_CopyInitInput(SrcInitDataData%InData_Orca, DstInitDataData%InData_Orca, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Orca_CopyInitOutput(SrcInitDataData%OutData_Orca, DstInitDataData%OutData_Orca, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceFloe_CopyInitInput(SrcInitDataData%InData_IceF, DstInitDataData%InData_IceF, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceFloe_CopyInitOutput(SrcInitDataData%OutData_IceF, DstInitDataData%OutData_IceF, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceD_CopyInitInput(SrcInitDataData%InData_IceD, DstInitDataData%InData_IceD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call IceD_CopyInitOutput(SrcInitDataData%OutData_IceD, DstInitDataData%OutData_IceD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine FAST_DestroyInitData(InitDataData, ErrStat, ErrMsg)
   type(FAST_InitData), intent(inout) :: InitDataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyInitData'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call ED_DestroyInitInput(InitDataData%InData_ED, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitDataData%OutData_ED)) then
      LB(1:1) = lbound(InitDataData%OutData_ED)
      UB(1:1) = ubound(InitDataData%OutData_ED)
      do i1 = LB(1), UB(1)
         call ED_DestroyInitOutput(InitDataData%OutData_ED(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitDataData%OutData_ED)
   end if
   call SED_DestroyInitInput(InitDataData%InData_SED, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SED_DestroyInitOutput(InitDataData%OutData_SED, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call BD_DestroyInitInput(InitDataData%InData_BD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitDataData%OutData_BD)) then
      LB(1:1) = lbound(InitDataData%OutData_BD)
      UB(1:1) = ubound(InitDataData%OutData_BD)
      do i1 = LB(1), UB(1)
         call BD_DestroyInitOutput(InitDataData%OutData_BD(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InitDataData%OutData_BD)
   end if
   call SrvD_DestroyInitInput(InitDataData%InData_SrvD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SrvD_DestroyInitOutput(InitDataData%OutData_SrvD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD_DestroyInitInput(InitDataData%InData_AD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call AD_DestroyInitOutput(InitDataData%OutData_AD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ADsk_DestroyInitInput(InitDataData%InData_ADsk, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ADsk_DestroyInitOutput(InitDataData%OutData_ADsk, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtLd_DestroyInitInput(InitDataData%InData_ExtLd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtLd_DestroyInitOutput(InitDataData%OutData_ExtLd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyInitInput(InitDataData%InData_IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call InflowWind_DestroyInitOutput(InitDataData%OutData_IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtInfw_DestroyInitInput(InitDataData%InData_ExtInfw, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtInfw_DestroyInitOutput(InitDataData%OutData_ExtInfw, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SeaSt_DestroyInitInput(InitDataData%InData_SeaSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SeaSt_DestroyInitOutput(InitDataData%OutData_SeaSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call HydroDyn_DestroyInitInput(InitDataData%InData_HD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call HydroDyn_DestroyInitOutput(InitDataData%OutData_HD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SD_DestroyInitInput(InitDataData%InData_SD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call SD_DestroyInitOutput(InitDataData%OutData_SD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtPtfm_DestroyInitInput(InitDataData%InData_ExtPtfm, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call ExtPtfm_DestroyInitOutput(InitDataData%OutData_ExtPtfm, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyInitInput(InitDataData%InData_MAP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MAP_DestroyInitOutput(InitDataData%OutData_MAP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FEAM_DestroyInitInput(InitDataData%InData_FEAM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FEAM_DestroyInitOutput(InitDataData%OutData_FEAM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyInitInput(InitDataData%InData_MD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyInitOutput(InitDataData%OutData_MD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Orca_DestroyInitInput(InitDataData%InData_Orca, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Orca_DestroyInitOutput(InitDataData%OutData_Orca, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceFloe_DestroyInitInput(InitDataData%InData_IceF, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceFloe_DestroyInitOutput(InitDataData%OutData_IceF, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceD_DestroyInitInput(InitDataData%InData_IceD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call IceD_DestroyInitOutput(InitDataData%OutData_IceD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine FAST_PackInitData(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_InitData), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackInitData'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call ED_PackInitInput(RF, InData%InData_ED) 
   call RegPack(RF, allocated(InData%OutData_ED))
   if (allocated(InData%OutData_ED)) then
      call RegPackBounds(RF, 1, lbound(InData%OutData_ED), ubound(InData%OutData_ED))
      LB(1:1) = lbound(InData%OutData_ED)
      UB(1:1) = ubound(InData%OutData_ED)
      do i1 = LB(1), UB(1)
         call ED_PackInitOutput(RF, InData%OutData_ED(i1)) 
      end do
   end if
   call SED_PackInitInput(RF, InData%InData_SED) 
   call SED_PackInitOutput(RF, InData%OutData_SED) 
   call BD_PackInitInput(RF, InData%InData_BD) 
   call RegPack(RF, allocated(InData%OutData_BD))
   if (allocated(InData%OutData_BD)) then
      call RegPackBounds(RF, 1, lbound(InData%OutData_BD), ubound(InData%OutData_BD))
      LB(1:1) = lbound(InData%OutData_BD)
      UB(1:1) = ubound(InData%OutData_BD)
      do i1 = LB(1), UB(1)
         call BD_PackInitOutput(RF, InData%OutData_BD(i1)) 
      end do
   end if
   call SrvD_PackInitInput(RF, InData%InData_SrvD) 
   call SrvD_PackInitOutput(RF, InData%OutData_SrvD) 
   call AD_PackInitInput(RF, InData%InData_AD) 
   call AD_PackInitOutput(RF, InData%OutData_AD) 
   call ADsk_PackInitInput(RF, InData%InData_ADsk) 
   call ADsk_PackInitOutput(RF, InData%OutData_ADsk) 
   call ExtLd_PackInitInput(RF, InData%InData_ExtLd) 
   call ExtLd_PackInitOutput(RF, InData%OutData_ExtLd) 
   call InflowWind_PackInitInput(RF, InData%InData_IfW) 
   call InflowWind_PackInitOutput(RF, InData%OutData_IfW) 
   call ExtInfw_PackInitInput(RF, InData%InData_ExtInfw) 
   call ExtInfw_PackInitOutput(RF, InData%OutData_ExtInfw) 
   call SeaSt_PackInitInput(RF, InData%InData_SeaSt) 
   call SeaSt_PackInitOutput(RF, InData%OutData_SeaSt) 
   call HydroDyn_PackInitInput(RF, InData%InData_HD) 
   call HydroDyn_PackInitOutput(RF, InData%OutData_HD) 
   call SD_PackInitInput(RF, InData%InData_SD) 
   call SD_PackInitOutput(RF, InData%OutData_SD) 
   call ExtPtfm_PackInitInput(RF, InData%InData_ExtPtfm) 
   call ExtPtfm_PackInitOutput(RF, InData%OutData_ExtPtfm) 
   call MAP_PackInitInput(RF, InData%InData_MAP) 
   call MAP_PackInitOutput(RF, InData%OutData_MAP) 
   call FEAM_PackInitInput(RF, InData%InData_FEAM) 
   call FEAM_PackInitOutput(RF, InData%OutData_FEAM) 
   call MD_PackInitInput(RF, InData%InData_MD) 
   call MD_PackInitOutput(RF, InData%OutData_MD) 
   call Orca_PackInitInput(RF, InData%InData_Orca) 
   call Orca_PackInitOutput(RF, InData%OutData_Orca) 
   call IceFloe_PackInitInput(RF, InData%InData_IceF) 
   call IceFloe_PackInitOutput(RF, InData%OutData_IceF) 
   call IceD_PackInitInput(RF, InData%InData_IceD) 
   call IceD_PackInitOutput(RF, InData%OutData_IceD) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackInitData(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_InitData), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackInitData'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call ED_UnpackInitInput(RF, OutData%InData_ED) ! InData_ED 
   if (allocated(OutData%OutData_ED)) deallocate(OutData%OutData_ED)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OutData_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutData_ED.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackInitOutput(RF, OutData%OutData_ED(i1)) ! OutData_ED 
      end do
   end if
   call SED_UnpackInitInput(RF, OutData%InData_SED) ! InData_SED 
   call SED_UnpackInitOutput(RF, OutData%OutData_SED) ! OutData_SED 
   call BD_UnpackInitInput(RF, OutData%InData_BD) ! InData_BD 
   if (allocated(OutData%OutData_BD)) deallocate(OutData%OutData_BD)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OutData_BD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutData_BD.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackInitOutput(RF, OutData%OutData_BD(i1)) ! OutData_BD 
      end do
   end if
   call SrvD_UnpackInitInput(RF, OutData%InData_SrvD) ! InData_SrvD 
   call SrvD_UnpackInitOutput(RF, OutData%OutData_SrvD) ! OutData_SrvD 
   call AD_UnpackInitInput(RF, OutData%InData_AD) ! InData_AD 
   call AD_UnpackInitOutput(RF, OutData%OutData_AD) ! OutData_AD 
   call ADsk_UnpackInitInput(RF, OutData%InData_ADsk) ! InData_ADsk 
   call ADsk_UnpackInitOutput(RF, OutData%OutData_ADsk) ! OutData_ADsk 
   call ExtLd_UnpackInitInput(RF, OutData%InData_ExtLd) ! InData_ExtLd 
   call ExtLd_UnpackInitOutput(RF, OutData%OutData_ExtLd) ! OutData_ExtLd 
   call InflowWind_UnpackInitInput(RF, OutData%InData_IfW) ! InData_IfW 
   call InflowWind_UnpackInitOutput(RF, OutData%OutData_IfW) ! OutData_IfW 
   call ExtInfw_UnpackInitInput(RF, OutData%InData_ExtInfw) ! InData_ExtInfw 
   call ExtInfw_UnpackInitOutput(RF, OutData%OutData_ExtInfw) ! OutData_ExtInfw 
   call SeaSt_UnpackInitInput(RF, OutData%InData_SeaSt) ! InData_SeaSt 
   call SeaSt_UnpackInitOutput(RF, OutData%OutData_SeaSt) ! OutData_SeaSt 
   call HydroDyn_UnpackInitInput(RF, OutData%InData_HD) ! InData_HD 
   call HydroDyn_UnpackInitOutput(RF, OutData%OutData_HD) ! OutData_HD 
   call SD_UnpackInitInput(RF, OutData%InData_SD) ! InData_SD 
   call SD_UnpackInitOutput(RF, OutData%OutData_SD) ! OutData_SD 
   call ExtPtfm_UnpackInitInput(RF, OutData%InData_ExtPtfm) ! InData_ExtPtfm 
   call ExtPtfm_UnpackInitOutput(RF, OutData%OutData_ExtPtfm) ! OutData_ExtPtfm 
   call MAP_UnpackInitInput(RF, OutData%InData_MAP) ! InData_MAP 
   call MAP_UnpackInitOutput(RF, OutData%OutData_MAP) ! OutData_MAP 
   call FEAM_UnpackInitInput(RF, OutData%InData_FEAM) ! InData_FEAM 
   call FEAM_UnpackInitOutput(RF, OutData%OutData_FEAM) ! OutData_FEAM 
   call MD_UnpackInitInput(RF, OutData%InData_MD) ! InData_MD 
   call MD_UnpackInitOutput(RF, OutData%OutData_MD) ! OutData_MD 
   call Orca_UnpackInitInput(RF, OutData%InData_Orca) ! InData_Orca 
   call Orca_UnpackInitOutput(RF, OutData%OutData_Orca) ! OutData_Orca 
   call IceFloe_UnpackInitInput(RF, OutData%InData_IceF) ! InData_IceF 
   call IceFloe_UnpackInitOutput(RF, OutData%OutData_IceF) ! OutData_IceF 
   call IceD_UnpackInitInput(RF, OutData%InData_IceD) ! InData_IceD 
   call IceD_UnpackInitOutput(RF, OutData%OutData_IceD) ! OutData_IceD 
end subroutine

subroutine FAST_CopyExternInitType(SrcExternInitTypeData, DstExternInitTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_ExternInitType), intent(in) :: SrcExternInitTypeData
   type(FAST_ExternInitType), intent(inout) :: DstExternInitTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(5), UB(5)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'FAST_CopyExternInitType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstExternInitTypeData%Tmax = SrcExternInitTypeData%Tmax
   DstExternInitTypeData%TurbIDforName = SrcExternInitTypeData%TurbIDforName
   DstExternInitTypeData%TurbinePos = SrcExternInitTypeData%TurbinePos
   DstExternInitTypeData%WaveFieldMod = SrcExternInitTypeData%WaveFieldMod
   DstExternInitTypeData%FarmIntegration = SrcExternInitTypeData%FarmIntegration
   DstExternInitTypeData%windGrid_n = SrcExternInitTypeData%windGrid_n
   DstExternInitTypeData%windGrid_delta = SrcExternInitTypeData%windGrid_delta
   DstExternInitTypeData%windGrid_pZero = SrcExternInitTypeData%windGrid_pZero
   DstExternInitTypeData%windGrid_data => SrcExternInitTypeData%windGrid_data
   DstExternInitTypeData%RootName = SrcExternInitTypeData%RootName
   DstExternInitTypeData%NumActForcePtsBlade = SrcExternInitTypeData%NumActForcePtsBlade
   DstExternInitTypeData%NumActForcePtsTower = SrcExternInitTypeData%NumActForcePtsTower
   DstExternInitTypeData%NodeClusterType = SrcExternInitTypeData%NodeClusterType
   DstExternInitTypeData%DTdriver = SrcExternInitTypeData%DTdriver
   DstExternInitTypeData%TwrAero = SrcExternInitTypeData%TwrAero
   DstExternInitTypeData%az_blend_mean = SrcExternInitTypeData%az_blend_mean
   DstExternInitTypeData%az_blend_delta = SrcExternInitTypeData%az_blend_delta
end subroutine

subroutine FAST_DestroyExternInitType(ExternInitTypeData, ErrStat, ErrMsg)
   type(FAST_ExternInitType), intent(inout) :: ExternInitTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'FAST_DestroyExternInitType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   nullify(ExternInitTypeData%windGrid_data)
end subroutine

subroutine FAST_PackExternInitType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_ExternInitType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExternInitType'
   logical         :: PtrInIndex
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Tmax)
   call RegPack(RF, InData%TurbIDforName)
   call RegPack(RF, InData%TurbinePos)
   call RegPack(RF, InData%WaveFieldMod)
   call RegPack(RF, InData%FarmIntegration)
   call RegPack(RF, InData%windGrid_n)
   call RegPack(RF, InData%windGrid_delta)
   call RegPack(RF, InData%windGrid_pZero)
   call RegPackPtr(RF, InData%windGrid_data)
   call RegPack(RF, InData%RootName)
   call RegPack(RF, InData%NumActForcePtsBlade)
   call RegPack(RF, InData%NumActForcePtsTower)
   call RegPack(RF, InData%NodeClusterType)
   call RegPack(RF, InData%DTdriver)
   call RegPack(RF, InData%TwrAero)
   call RegPack(RF, InData%az_blend_mean)
   call RegPack(RF, InData%az_blend_delta)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackExternInitType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_ExternInitType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExternInitType'
   integer(B4Ki)   :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(B8Ki)   :: PtrIdx
   type(c_ptr)     :: Ptr
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Tmax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TurbIDforName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TurbinePos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveFieldMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FarmIntegration); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%windGrid_n); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%windGrid_delta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%windGrid_pZero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackPtr(RF, OutData%windGrid_data, LB, UB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RootName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumActForcePtsBlade); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumActForcePtsTower); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NodeClusterType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DTdriver); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TwrAero); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%az_blend_mean); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%az_blend_delta); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_CopyTurbineType(SrcTurbineTypeData, DstTurbineTypeData, CtrlCode, ErrStat, ErrMsg)
   type(FAST_TurbineType), intent(inout) :: SrcTurbineTypeData
   type(FAST_TurbineType), intent(inout) :: DstTurbineTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_CopyTurbineType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstTurbineTypeData%TurbID = SrcTurbineTypeData%TurbID
   call FAST_CopyParam(SrcTurbineTypeData%p_FAST, DstTurbineTypeData%p_FAST, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyOutputFileType(SrcTurbineTypeData%y_FAST, DstTurbineTypeData%y_FAST, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyMisc(SrcTurbineTypeData%m_FAST, DstTurbineTypeData%m_FAST, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyParam(SrcTurbineTypeData%p_Glue, DstTurbineTypeData%p_Glue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyOutputFileType(SrcTurbineTypeData%y_Glue, DstTurbineTypeData%y_Glue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call Glue_CopyMisc(SrcTurbineTypeData%m_Glue, DstTurbineTypeData%m_Glue, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyElastoDyn_Data(SrcTurbineTypeData%ED, DstTurbineTypeData%ED, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopySED_Data(SrcTurbineTypeData%SED, DstTurbineTypeData%SED, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyBeamDyn_Data(SrcTurbineTypeData%BD, DstTurbineTypeData%BD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyServoDyn_Data(SrcTurbineTypeData%SrvD, DstTurbineTypeData%SrvD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyAeroDyn_Data(SrcTurbineTypeData%AD, DstTurbineTypeData%AD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyAeroDisk_Data(SrcTurbineTypeData%ADsk, DstTurbineTypeData%ADsk, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyExtLoads_Data(SrcTurbineTypeData%ExtLd, DstTurbineTypeData%ExtLd, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyInflowWind_Data(SrcTurbineTypeData%IfW, DstTurbineTypeData%IfW, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyExternalInflow_Data(SrcTurbineTypeData%ExtInfw, DstTurbineTypeData%ExtInfw, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopySeaState_Data(SrcTurbineTypeData%SeaSt, DstTurbineTypeData%SeaSt, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyHydroDyn_Data(SrcTurbineTypeData%HD, DstTurbineTypeData%HD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopySubDyn_Data(SrcTurbineTypeData%SD, DstTurbineTypeData%SD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyMAP_Data(SrcTurbineTypeData%MAP, DstTurbineTypeData%MAP, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyFEAMooring_Data(SrcTurbineTypeData%FEAM, DstTurbineTypeData%FEAM, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyMoorDyn_Data(SrcTurbineTypeData%MD, DstTurbineTypeData%MD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyOrcaFlex_Data(SrcTurbineTypeData%Orca, DstTurbineTypeData%Orca, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyIceFloe_Data(SrcTurbineTypeData%IceF, DstTurbineTypeData%IceF, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyIceDyn_Data(SrcTurbineTypeData%IceD, DstTurbineTypeData%IceD, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call FAST_CopyExtPtfm_Data(SrcTurbineTypeData%ExtPtfm, DstTurbineTypeData%ExtPtfm, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine FAST_DestroyTurbineType(TurbineTypeData, ErrStat, ErrMsg)
   type(FAST_TurbineType), intent(inout) :: TurbineTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'FAST_DestroyTurbineType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call FAST_DestroyParam(TurbineTypeData%p_FAST, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyOutputFileType(TurbineTypeData%y_FAST, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyMisc(TurbineTypeData%m_FAST, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyParam(TurbineTypeData%p_Glue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyOutputFileType(TurbineTypeData%y_Glue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call Glue_DestroyMisc(TurbineTypeData%m_Glue, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyElastoDyn_Data(TurbineTypeData%ED, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroySED_Data(TurbineTypeData%SED, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyBeamDyn_Data(TurbineTypeData%BD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyServoDyn_Data(TurbineTypeData%SrvD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyAeroDyn_Data(TurbineTypeData%AD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyAeroDisk_Data(TurbineTypeData%ADsk, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyExtLoads_Data(TurbineTypeData%ExtLd, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyInflowWind_Data(TurbineTypeData%IfW, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyExternalInflow_Data(TurbineTypeData%ExtInfw, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroySeaState_Data(TurbineTypeData%SeaSt, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyHydroDyn_Data(TurbineTypeData%HD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroySubDyn_Data(TurbineTypeData%SD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyMAP_Data(TurbineTypeData%MAP, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyFEAMooring_Data(TurbineTypeData%FEAM, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyMoorDyn_Data(TurbineTypeData%MD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyOrcaFlex_Data(TurbineTypeData%Orca, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyIceFloe_Data(TurbineTypeData%IceF, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyIceDyn_Data(TurbineTypeData%IceD, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call FAST_DestroyExtPtfm_Data(TurbineTypeData%ExtPtfm, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine FAST_PackTurbineType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(FAST_TurbineType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackTurbineType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%TurbID)
   call FAST_PackParam(RF, InData%p_FAST) 
   call FAST_PackOutputFileType(RF, InData%y_FAST) 
   call FAST_PackMisc(RF, InData%m_FAST) 
   call Glue_PackParam(RF, InData%p_Glue) 
   call Glue_PackOutputFileType(RF, InData%y_Glue) 
   call Glue_PackMisc(RF, InData%m_Glue) 
   call FAST_PackElastoDyn_Data(RF, InData%ED) 
   call FAST_PackSED_Data(RF, InData%SED) 
   call FAST_PackBeamDyn_Data(RF, InData%BD) 
   call FAST_PackServoDyn_Data(RF, InData%SrvD) 
   call FAST_PackAeroDyn_Data(RF, InData%AD) 
   call FAST_PackAeroDisk_Data(RF, InData%ADsk) 
   call FAST_PackExtLoads_Data(RF, InData%ExtLd) 
   call FAST_PackInflowWind_Data(RF, InData%IfW) 
   call FAST_PackExternalInflow_Data(RF, InData%ExtInfw) 
   call FAST_PackSeaState_Data(RF, InData%SeaSt) 
   call FAST_PackHydroDyn_Data(RF, InData%HD) 
   call FAST_PackSubDyn_Data(RF, InData%SD) 
   call FAST_PackMAP_Data(RF, InData%MAP) 
   call FAST_PackFEAMooring_Data(RF, InData%FEAM) 
   call FAST_PackMoorDyn_Data(RF, InData%MD) 
   call FAST_PackOrcaFlex_Data(RF, InData%Orca) 
   call FAST_PackIceFloe_Data(RF, InData%IceF) 
   call FAST_PackIceDyn_Data(RF, InData%IceD) 
   call FAST_PackExtPtfm_Data(RF, InData%ExtPtfm) 
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine FAST_UnPackTurbineType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(FAST_TurbineType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackTurbineType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%TurbID); if (RegCheckErr(RF, RoutineName)) return
   call FAST_UnpackParam(RF, OutData%p_FAST) ! p_FAST 
   call FAST_UnpackOutputFileType(RF, OutData%y_FAST) ! y_FAST 
   call FAST_UnpackMisc(RF, OutData%m_FAST) ! m_FAST 
   call Glue_UnpackParam(RF, OutData%p_Glue) ! p_Glue 
   call Glue_UnpackOutputFileType(RF, OutData%y_Glue) ! y_Glue 
   call Glue_UnpackMisc(RF, OutData%m_Glue) ! m_Glue 
   call FAST_UnpackElastoDyn_Data(RF, OutData%ED) ! ED 
   call FAST_UnpackSED_Data(RF, OutData%SED) ! SED 
   call FAST_UnpackBeamDyn_Data(RF, OutData%BD) ! BD 
   call FAST_UnpackServoDyn_Data(RF, OutData%SrvD) ! SrvD 
   call FAST_UnpackAeroDyn_Data(RF, OutData%AD) ! AD 
   call FAST_UnpackAeroDisk_Data(RF, OutData%ADsk) ! ADsk 
   call FAST_UnpackExtLoads_Data(RF, OutData%ExtLd) ! ExtLd 
   call FAST_UnpackInflowWind_Data(RF, OutData%IfW) ! IfW 
   call FAST_UnpackExternalInflow_Data(RF, OutData%ExtInfw) ! ExtInfw 
   call FAST_UnpackSeaState_Data(RF, OutData%SeaSt) ! SeaSt 
   call FAST_UnpackHydroDyn_Data(RF, OutData%HD) ! HD 
   call FAST_UnpackSubDyn_Data(RF, OutData%SD) ! SD 
   call FAST_UnpackMAP_Data(RF, OutData%MAP) ! MAP 
   call FAST_UnpackFEAMooring_Data(RF, OutData%FEAM) ! FEAM 
   call FAST_UnpackMoorDyn_Data(RF, OutData%MD) ! MD 
   call FAST_UnpackOrcaFlex_Data(RF, OutData%Orca) ! Orca 
   call FAST_UnpackIceFloe_Data(RF, OutData%IceF) ! IceF 
   call FAST_UnpackIceDyn_Data(RF, OutData%IceD) ! IceD 
   call FAST_UnpackExtPtfm_Data(RF, OutData%ExtPtfm) ! ExtPtfm 
end subroutine

END MODULE FAST_Types

!ENDOFREGISTRYGENERATEDFILE
