!STARTOFREGISTRYGENERATEDFILE 'MAP_Fortran_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! MAP_Fortran_Types
!.................................................................................................................................
! This file is part of MAP_Fortran.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in MAP_Fortran. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE MAP_Fortran_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Lin_InitInputType  =======
  TYPE, PUBLIC :: Lin_InitInputType
    LOGICAL  :: linearize = .false.      !< Flag that tells this module if the glue code wants to linearize.  (fortran-only) [-]
  END TYPE Lin_InitInputType
! =======================
! =========  Lin_InitOutputType  =======
  TYPE, PUBLIC :: Lin_InitOutputType
    CHARACTER(200) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< second line of output file contents: units (fortran-only) [-]
    CHARACTER(200) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization (fortran-only) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) (fortran-only) [-]
  END TYPE Lin_InitOutputType
! =======================
! =========  Lin_ParamType  =======
  TYPE, PUBLIC :: Lin_ParamType
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian (fortran-only) [-]
    REAL(R8Ki)  :: du = 0.0_R8Ki      !< determines size of the translational displacement perturbation for u (inputs) (fortran-only) [-]
    INTEGER(IntKi)  :: Jac_ny = 0_IntKi      !< number of outputs in jacobian matrix (fortran-only) [-]
  END TYPE Lin_ParamType
! =======================
CONTAINS

subroutine MAP_Fortran_CopyLin_InitInputType(SrcLin_InitInputTypeData, DstLin_InitInputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Lin_InitInputType), intent(in) :: SrcLin_InitInputTypeData
   type(Lin_InitInputType), intent(inout) :: DstLin_InitInputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MAP_Fortran_CopyLin_InitInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLin_InitInputTypeData%linearize = SrcLin_InitInputTypeData%linearize
end subroutine

subroutine MAP_Fortran_DestroyLin_InitInputType(Lin_InitInputTypeData, ErrStat, ErrMsg)
   type(Lin_InitInputType), intent(inout) :: Lin_InitInputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MAP_Fortran_DestroyLin_InitInputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MAP_Fortran_PackLin_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lin_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MAP_Fortran_PackLin_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MAP_Fortran_UnPackLin_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lin_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MAP_Fortran_UnPackLin_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MAP_Fortran_CopyLin_InitOutputType(SrcLin_InitOutputTypeData, DstLin_InitOutputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Lin_InitOutputType), intent(in) :: SrcLin_InitOutputTypeData
   type(Lin_InitOutputType), intent(inout) :: DstLin_InitOutputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MAP_Fortran_CopyLin_InitOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLin_InitOutputTypeData%LinNames_y)) then
      LB(1:1) = lbound(SrcLin_InitOutputTypeData%LinNames_y)
      UB(1:1) = ubound(SrcLin_InitOutputTypeData%LinNames_y)
      if (.not. allocated(DstLin_InitOutputTypeData%LinNames_y)) then
         allocate(DstLin_InitOutputTypeData%LinNames_y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLin_InitOutputTypeData%LinNames_y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLin_InitOutputTypeData%LinNames_y = SrcLin_InitOutputTypeData%LinNames_y
   end if
   if (allocated(SrcLin_InitOutputTypeData%LinNames_u)) then
      LB(1:1) = lbound(SrcLin_InitOutputTypeData%LinNames_u)
      UB(1:1) = ubound(SrcLin_InitOutputTypeData%LinNames_u)
      if (.not. allocated(DstLin_InitOutputTypeData%LinNames_u)) then
         allocate(DstLin_InitOutputTypeData%LinNames_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLin_InitOutputTypeData%LinNames_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLin_InitOutputTypeData%LinNames_u = SrcLin_InitOutputTypeData%LinNames_u
   end if
   if (allocated(SrcLin_InitOutputTypeData%IsLoad_u)) then
      LB(1:1) = lbound(SrcLin_InitOutputTypeData%IsLoad_u)
      UB(1:1) = ubound(SrcLin_InitOutputTypeData%IsLoad_u)
      if (.not. allocated(DstLin_InitOutputTypeData%IsLoad_u)) then
         allocate(DstLin_InitOutputTypeData%IsLoad_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLin_InitOutputTypeData%IsLoad_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLin_InitOutputTypeData%IsLoad_u = SrcLin_InitOutputTypeData%IsLoad_u
   end if
end subroutine

subroutine MAP_Fortran_DestroyLin_InitOutputType(Lin_InitOutputTypeData, ErrStat, ErrMsg)
   type(Lin_InitOutputType), intent(inout) :: Lin_InitOutputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MAP_Fortran_DestroyLin_InitOutputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Lin_InitOutputTypeData%LinNames_y)) then
      deallocate(Lin_InitOutputTypeData%LinNames_y)
   end if
   if (allocated(Lin_InitOutputTypeData%LinNames_u)) then
      deallocate(Lin_InitOutputTypeData%LinNames_u)
   end if
   if (allocated(Lin_InitOutputTypeData%IsLoad_u)) then
      deallocate(Lin_InitOutputTypeData%IsLoad_u)
   end if
end subroutine

subroutine MAP_Fortran_PackLin_InitOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lin_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MAP_Fortran_PackLin_InitOutputType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MAP_Fortran_UnPackLin_InitOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lin_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MAP_Fortran_UnPackLin_InitOutputType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine MAP_Fortran_CopyLin_ParamType(SrcLin_ParamTypeData, DstLin_ParamTypeData, CtrlCode, ErrStat, ErrMsg)
   type(Lin_ParamType), intent(in) :: SrcLin_ParamTypeData
   type(Lin_ParamType), intent(inout) :: DstLin_ParamTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MAP_Fortran_CopyLin_ParamType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcLin_ParamTypeData%Jac_u_indx)) then
      LB(1:2) = lbound(SrcLin_ParamTypeData%Jac_u_indx)
      UB(1:2) = ubound(SrcLin_ParamTypeData%Jac_u_indx)
      if (.not. allocated(DstLin_ParamTypeData%Jac_u_indx)) then
         allocate(DstLin_ParamTypeData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLin_ParamTypeData%Jac_u_indx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLin_ParamTypeData%Jac_u_indx = SrcLin_ParamTypeData%Jac_u_indx
   end if
   DstLin_ParamTypeData%du = SrcLin_ParamTypeData%du
   DstLin_ParamTypeData%Jac_ny = SrcLin_ParamTypeData%Jac_ny
end subroutine

subroutine MAP_Fortran_DestroyLin_ParamType(Lin_ParamTypeData, ErrStat, ErrMsg)
   type(Lin_ParamType), intent(inout) :: Lin_ParamTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MAP_Fortran_DestroyLin_ParamType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(Lin_ParamTypeData%Jac_u_indx)) then
      deallocate(Lin_ParamTypeData%Jac_u_indx)
   end if
end subroutine

subroutine MAP_Fortran_PackLin_ParamType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lin_ParamType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MAP_Fortran_PackLin_ParamType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   call RegPack(Buf, InData%du)
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MAP_Fortran_UnPackLin_ParamType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lin_ParamType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MAP_Fortran_UnPackLin_ParamType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%du)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE MAP_Fortran_Types
!ENDOFREGISTRYGENERATEDFILE
