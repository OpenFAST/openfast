!**********************************************************************************************************************************
!> ## ExtPtfm_MCKF
!! The ExtPtfm_MCKF and ExtPtfm_MCKF_Types modules make up a template for creating user-defined calculations in the FAST Modularization
!! Framework. ExtPtfm_MCKF_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! ExtPtfm_MCKF_Registry.txt file.
!!
!! This template file contains comments in the style required for Doxygen, and it contains methods for handling errors.
!!
!! "ExtPtfm_MCKF" should be replaced with the name of your module. Example: ElastoDyn \n
!! "ExtPtfm" (in ExtPtfm_*) should be replaced with the module name or an abbreviation of it. Example: ED
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2012-2013, 2015-2016  National Renewable Energy Laboratory
!!
!!    This file is part of ExtPtfm_MCKF.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE ExtPtfm_MCKF

   USE ExtPtfm_MCKF_Types
   USE NWTC_Library

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER :: ExtPtfm_Ver = ProgDesc( 'ExtPtfm_MCKF', '', '' ) !< module date/version information


      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: ExtPtfm_Init                           !  Initialization routine
   PUBLIC :: ExtPtfm_End                            !  Ending routine (includes clean up)

   PUBLIC :: ExtPtfm_UpdateStates                   !  Loose coupling routine for solving for constraint states, integrating
                                                    !    continuous states, and updating discrete states
   PUBLIC :: ExtPtfm_CalcOutput                     !  Routine for computing outputs

   PUBLIC :: ExtPtfm_CalcConstrStateResidual        !  Tight coupling routine for returning the constraint state residual
   PUBLIC :: ExtPtfm_CalcContStateDeriv             !  Tight coupling routine for computing derivatives of continuous states
   PUBLIC :: ExtPtfm_UpdateDiscState                !  Tight coupling routine for updating discrete states

   PUBLIC :: ExtPtfm_JacobianPInput                 !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the inputs (u)
   PUBLIC :: ExtPtfm_JacobianPContState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the continuous
                                                    !    states (x)
   PUBLIC :: ExtPtfm_JacobianPDiscState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the discrete
                                                    !    states (xd)
   PUBLIC :: ExtPtfm_JacobianPConstrState           !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the constraint
                                                    !    states (z)
   
   PUBLIC :: ExtPtfm_GetOP                          !  Routine to get the operating-point values for linearization (from data structures to arrays)

CONTAINS
   
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
SUBROUTINE ExtPtfm_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(ExtPtfm_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(ExtPtfm_InputType),           INTENT(  OUT)  :: u           !< An initial guess for the input; input mesh must be defined
   TYPE(ExtPtfm_ParameterType),       INTENT(  OUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: x           !< Initial continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(  OUT)  :: xd          !< Initial discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: z           !< Initial guess of the constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(  OUT)  :: OtherState  !< Initial other states (logical, etc)
   TYPE(ExtPtfm_OutputType),          INTENT(  OUT)  :: y           !< Initial system outputs (outputs are not calculated;
                                                                    !!   only the output mesh is initialized)
   TYPE(ExtPtfm_MiscVarType),         INTENT(  OUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   REAL(DbKi),                        INTENT(INOUT)  :: Interval    !< Coupling interval in seconds: the rate that
                                                                    !!   (1) ExtPtfm_UpdateStates() is called in loose coupling &
                                                                    !!   (2) ExtPtfm_UpdateDiscState() is called in tight coupling.
                                                                    !!   Input is the suggested time from the glue code;
                                                                    !!   Output is the actual coupling interval that will be used
                                                                    !!   by the glue code.
   TYPE(ExtPtfm_InitOutputType),      INTENT(  OUT)  :: InitOut     !< Output for initialization routine
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables

   INTEGER(IntKi)                                    :: NumOuts     ! number of outputs; would probably be in the parameter type
   INTEGER(IntKi)                                    :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_Init'

      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Initialize the NWTC Subroutine Library
   call NWTC_Init( )

      ! Display the module information
   call DispNVD( ExtPtfm_Ver )

      ! set parameters
   p%NumOuts = 0   
   call ReadPrimaryFile( InitInp%InputFile, p, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) 
      if (errStat >= AbortErrLev) return
   
      ! Define initial system states here:
   x%DummyContState           = 0.0_ReKi
   xd%DummyDiscState          = 0.0_ReKi
   z%DummyConstrState         = 0.0_ReKi
   OtherState%DummyOtherState = 0.0_ReKi

      ! initialize optimization variables:
   m%Indx = 1
   
      ! Define initial guess (set up mesh first) for the system inputs here:
   call Init_meshes(u, y, ErrStat, ErrMsg)
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) 

      ! Define system output initializations (set up mesh) here:
   call AllocAry( y%WriteOutput,        p%NumOuts,'WriteOutput',  ErrStat2, ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) ! set return error status based on local (concatenate errors)
   call AllocAry(InitOut%WriteOutputHdr,p%NumOuts,'WriteOutputHdr',ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call AllocAry(InitOut%WriteOutputUnt,p%NumOuts,'WriteOutputUnt',ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if (ErrStat >= AbortErrLev) return        ! if there are local variables that need to be deallocated, do so before early return

   InitOut%Ver = ExtPtfm_Ver
      
   if (InitInp%Linearize) then
      
      ! If the module does not implement the four Jacobian routines at the end of this template, or the module cannot
      ! linearize with the features that are enabled, stop the simulation if InitInp%Linearize is true.
      
      CALL SetErrStat( ErrID_Fatal, 'ExtPtfm_MCKF cannot perform linearization analysis.', ErrStat, ErrMsg, RoutineName)
      
      ! Otherwise, if the module does allow linearization, return the appropriate Jacobian row/column names and rotating-frame flags here:   
      ! Allocate and set these variables: InitOut%LinNames_y, InitOut%LinNames_x, InitOut%LinNames_xd, InitOut%LinNames_z, InitOut%LinNames_u 
      ! Allocate and set these variables: InitOut%RotFrame_y, InitOut%RotFrame_x, InitOut%RotFrame_xd, InitOut%RotFrame_z, InitOut%RotFrame_u 
      
   end if
   
      
END SUBROUTINE ExtPtfm_Init
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadPrimaryFile( InputFile, p, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables
   CHARACTER(*),                INTENT(IN)    :: InputFile                           !< Name of the file containing the primary input data
   TYPE(ExtPtfm_ParameterType), INTENT(INOUT) :: p                                   !< All the parameter matrices stored in this input file
   INTEGER(IntKi),              INTENT(OUT)   :: ErrStat                             !< Error status                              
   CHARACTER(*),                INTENT(OUT)   :: ErrMsg                              !< Error message

   
      ! Local variables:
   REAL(ReKi)                    :: TmpAry(7)                                 ! temporary array for reading row from file
   INTEGER(IntKi)                :: I                                         ! loop counter
   INTEGER(IntKi)                :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                :: UnEc                                      !< I/O unit for echo file. If > 0, file is open for writing.
   
   INTEGER(IntKi)                :: ErrStat2                                  ! Temporary Error status
   LOGICAL                       :: Echo                                      ! Determines if an echo file should be written
   CHARACTER(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(1024)               :: FTitle                                    ! "File Title": the 1st line of the input file, which contains a description of its contents
   CHARACTER(200)                :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(*), PARAMETER       :: RoutineName = 'ReadPrimaryFile'
   
   
   
   
      ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
      
   UnEc = -1
   Echo = .FALSE.   
   !CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.
   
   
      ! Get an available unit number for the file.
   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) RETURN


      ! Open the Primary input file.
   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) RETURN
                  
      
   !-------------------------- HEADER ---------------------------------------------
   CALL ReadStr( UnIn, InputFile, FTitle, 'FTitle', 'File Header: External Platform MCKF Matrices (line 1)', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
      
   !---------------------- MASS MATRIX --------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Mass Matrix', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
      !Read Mass
   DO I =1,6
      CALL ReadAry( UnIn, InputFile, p%PtfmAM(I,:), 6, 'PtfmAM', 'Mass Matrix Terms', ErrStat2, ErrMsg2, UnEc  )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   ENDDO
   if ( ErrStat >= AbortErrLev ) then
      call cleanup()
      return
   end if
   
   
   !---------------------- DAMPING MATRIX --------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Damping Matrix', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
      !Read Damping
   DO I =1,6
      CALL ReadAry( UnIn, InputFile, p%Damp(I,:), 6, 'Damp', 'Damping Matrix Terms', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   ENDDO
   if ( ErrStat >= AbortErrLev ) then
      call cleanup()
      return
   end if

   
   !---------------------- STIFFNESS MATRIX --------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Stiffness Matrix', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
      !Read Stiffness
   DO I =1,6
      CALL ReadAry( UnIn, InputFile, p%Stff(I,:), 6, 'Stff', 'Stiffness Matrix Terms', ErrStat2, ErrMsg2, UnEc  )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   ENDDO
   if ( ErrStat >= AbortErrLev ) then
      call cleanup()
      return
   end if
   
   
   !---------------------- LOAD time-history --------------------------------------
   p%nPtfmFt = 0
   CALL ReadCom( UnIn, InputFile, 'Section Header: Loads time-history', ErrStat2, ErrMsg2, UnEc )
   CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel names', ErrStat2, ErrMsg2, UnEc )
   CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel units', ErrStat2, ErrMsg2, UnEc )
   if (ErrStat2 < AbortErrLev) then
      ! let's figure out how many rows of data are in the time-history table:
         read( UnIn, *, IOSTAT=ErrStat2 ) TmpAry
      do while (ErrStat2==0)
         p%nPtfmFt = p%nPtfmFt + 1
         read( UnIn, *, IOSTAT=ErrStat2 ) TmpAry
      end do
   end if

   call allocAry( p%PtfmFt,   max(1,p%nPtfmFt), 6, 'p%PtfmFt',   ErrStat2, ErrMsg2); CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   call allocAry( p%PtfmFt_t, max(1,p%nPtfmFt),    'p%PtfmFt_t', ErrStat2, ErrMsg2); CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   if (ErrStat >= AbortErrLev) then
      call cleanup()
      return
   end if
      
   if (p%nPtfmFt == 0) then
      p%PtfmFt = 0.0_ReKi
      p%PtfmFt_t = 0.0_ReKi
      p%nPtfmFt = 1
   else
      rewind(UnIn)
      
      do i=1,25 ! skip the first 25 rows of the file until we get to the data for the time-history table
         read(UnIn,*,IOSTAT=ErrStat2) line
      end do
      
      do i=1,p%nPtfmFt
      
         call ReadAry( UnIn, InputFile, TmpAry, 7, 'PtfmFt', 'PtfmFt time-history', ErrStat2, ErrMsg2, UnEc  )
         
         p%PtfmFt_t(i) = TmpAry(1)
         p%PtfmFt(i,:) = TmpAry(2:7)
            
      end do
      
   end if
      
   
   !---------------------- END OF FILE -----------------------------------------
      
   call cleanup()
   RETURN


CONTAINS
   !...............................................................................................................................
   SUBROUTINE cleanup()

         CLOSE( UnIn )

   END SUBROUTINE cleanup
   !...............................................................................................................................
END SUBROUTINE ReadPrimaryFile      
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Init_meshes(u, y, ErrStat, ErrMsg)

   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   INTEGER(IntKi)                                    :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'Init_meshes'

   
   ErrStat = ErrID_None
   ErrMSg = ""
   
      ! Create the input and output meshes associated with platform loads
   CALL MeshCreate(  BlankMesh         = u%PtfmMesh       , &
                     IOS               = COMPONENT_INPUT  , &
                     Nnodes            = 1                , &
                     ErrStat           = ErrStat2         , &
                     ErrMess           = ErrMsg2          , &
                     TranslationDisp   = .TRUE.           , &
                     Orientation       = .TRUE.           , &
                     TranslationVel    = .TRUE.           , &
                     RotationVel       = .TRUE.           , &
                     TranslationAcc    = .TRUE.           , &
                     RotationAcc       = .TRUE.)

      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) return
      
      ! Create the node on the mesh
   CALL MeshPositionNode (u%PtfmMesh, 1, (/0.0_ReKi, 0.0_ReKi, 0.0_ReKi/), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

      ! Create the mesh element
   CALL MeshConstructElement (  u%PtfmMesh, ELEMENT_POINT, ErrStat2, ErrMsg2, 1 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL MeshCommit ( u%PtfmMesh, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) return

      
      ! the output mesh is a sibling of the input:
   CALL MeshCopy( SrcMesh=u%PtfmMesh, DestMesh=y%PtfmMesh, CtrlCode=MESH_SIBLING, IOS=COMPONENT_OUTPUT, &
                  ErrStat=ErrStat2, ErrMess=ErrMsg2, Force=.TRUE., Moment=.TRUE. )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

END SUBROUTINE Init_meshes
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE ExtPtfm_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(INOUT)  :: z           !< Constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   INTEGER(IntKi)                                    :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_End'

      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Place any last minute operations or calculations here:


      ! Close files here (but because of checkpoint-restart capability, it is not recommended to have files open during the simulation):


      ! Destroy the input data:

   call ExtPtfm_DestroyInput( u, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


      ! Destroy the parameter data:

   call ExtPtfm_DestroyParam( p, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      ! Destroy the state data:

   call ExtPtfm_DestroyContState(   x,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyDiscState(   xd,         ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyConstrState( z,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyOtherState(  OtherState, ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


      ! Destroy the output data:

   call ExtPtfm_DestroyOutput( y, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


      ! Destroy the misc data:

   call ExtPtfm_DestroyMisc( m, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


END SUBROUTINE ExtPtfm_End
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE ExtPtfm_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                         INTENT(IN   ) :: t               !< Current simulation time in seconds
   INTEGER(IntKi),                     INTENT(IN   ) :: n               !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),            INTENT(INOUT) :: Inputs(:)       !< Inputs at InputTimes (output from this routine only
                                                                        !!  because of record keeping in routines that copy meshes)
   REAL(DbKi),                         INTENT(IN   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p               !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(INOUT) :: x               !< Input: Continuous states at t;
                                                                        !!   Output: Continuous states at t + Interval
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(INOUT) :: xd              !< Input: Discrete states at t;
                                                                        !!   Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(INOUT) :: z               !< Input: Constraint states at t;
                                                                        !!   Output: Constraint states at t + Interval
   TYPE(ExtPtfm_OtherStateType),       INTENT(INOUT) :: OtherState      !< Other states: Other states at t;
                                                                        !!   Output: Other states at t + Interval
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m               !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat         !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg          !< Error message if ErrStat /= ErrID_None

      ! Local variables
   !INTEGER(IntKi)                                    :: ErrStat2        ! local error status
   !CHARACTER(ErrMsgLen)                              :: ErrMsg2         ! local error message
   !CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_UpdateStates'


      ! Initialize variables

   ErrStat   = ErrID_None           ! no error has occurred
   ErrMsg    = ""



END SUBROUTINE ExtPtfm_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a routine for computing outputs, used in both loose and tight coupling.
SUBROUTINE ExtPtfm_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                     !!   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Local variables
   INTEGER(IntKi)                                  :: I,J               !< Generic counters
   INTEGER(IntKi)                                  :: ErrStat2          !< Temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsg2           !< Temporary Error message if ErrStat /= ErrID_None
   CHARACTER(*),     PARAMETER                     :: RoutineName='ExtPtfm_CalcOutput'
   
   
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""

   
      ! translate inputs on mesh to arrays for computations:
   m%q(1:3) = u%PtfmMesh%TranslationDisp(:,1)
   m%q(4:6) = GetSmllRotAngs ( u%PtfmMesh%Orientation(:,:,1), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   m%qdot(1:3) = u%PtfmMesh%TranslationVel(:,1)
   m%qdot(4:6) = u%PtfmMesh%RotationVel(:,1)   

   m%qdotdot(1:3) = u%PtfmMesh%TranslationAcc(:,1)
   m%qdotdot(4:6) = u%PtfmMesh%RotationAcc(:,1)

      ! compute the platform force (without added mass):
   ! get interpolated (in time) loads, m%PtfmFt
   call InterpStpMat( REAL(t,ReKi), p%PtfmFt_t, p%PtfmFt, m%Indx, p%nPtfmFt, m%PtfmFt ) ! interpolate this based on the time history read in
   
   ! add the loads from damping and stiffness
   DO J = 1,6
      DO I = 1,6
         m%PtfmFt(I) = m%PtfmFt(I) - p%Damp(I,J) * m%qdot(J) - p%Stff(I,J) * m%q(J)
      ENDDO
   ENDDO      
   
      ! Now calculate the loads from the added mass matrix
   m%F_PtfmAM     =  -matmul(p%PtfmAM, m%qdotdot)


      ! Update the Mesh with sum of these loads
   DO I=1,3
      y%PtfmMesh%Force(I,1)  =  m%F_PtfmAM(I)   +  m%PtfmFt(I)
      y%PtfmMesh%Moment(I,1) =  m%F_PtfmAM(I+3) +  m%PtfmFt(I+3)
   ENDDO
  
   

   !y%WriteOutput(1) = y%PtfmMesh%Force(1,1)
   !y%WriteOutput(2) = y%PtfmMesh%Moment(1,1)
   !

END SUBROUTINE ExtPtfm_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------


!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This is a tight coupling routine for computing derivatives of continuous states.
SUBROUTINE ExtPtfm_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, m, dxdt, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: dxdt        !< Continuous state derivatives at t
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Compute the first time derivatives of the continuous states here:

   dxdt%DummyContState = 0.0_ReKi

END SUBROUTINE ExtPtfm_CalcContStateDeriv
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for updating discrete states.
SUBROUTINE ExtPtfm_UpdateDiscState( t, n, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                    INTENT(IN   )  :: n           !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Input: Discrete states at t;
                                                                     !!   Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Update discrete states here:

   xd%DummyDiscState = 0.0_Reki

END SUBROUTINE ExtPtfm_UpdateDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for solving for the residual of the constraint state functions.
SUBROUTINE ExtPtfm_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, m, Z_residual, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: Z_residual  !< Residual of the constraint state functions using
                                                                    !!     the input values described above
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Solve for the residual of the constraint state functions here:

   Z_residual%DummyConstrState = 0.0_ReKi

END SUBROUTINE ExtPtfm_CalcConstrStateResidual
!----------------------------------------------------------------------------------------------------------------------------------


!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! ###### The following four routines are Jacobian routines for linearization capabilities #######
! If the module does not implement them, set ErrStat = ErrID_Fatal in ExtPtfm_Init() when InitInp%Linearize is .true.
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the inputs (u). The partial derivatives dY/du, dX/du, dXd/du, and DZ/du are returned.
SUBROUTINE ExtPtfm_JacobianPInput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdu, dXdu, dXddu, dZdu)
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdu.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdu(:,:)  !< Partial derivatives of output functions (Y) with respect 
                                                                                    !!   to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdu(:,:)  !< Partial derivatives of continuous state functions (X) with 
                                                                                    !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddu(:,:) !< Partial derivatives of discrete state functions (Xd) with 
                                                                                    !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdu(:,:)  !< Partial derivatives of constraint state functions (Z) with 
                                                                                    !!   respect to the inputs (u) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''


   IF ( PRESENT( dYdu ) ) THEN

      ! Calculate the partial derivative of the output functions (Y) with respect to the inputs (u) here:

      ! allocate and set dYdu

   END IF

   IF ( PRESENT( dXdu ) ) THEN

      ! Calculate the partial derivative of the continuous state functions (X) with respect to the inputs (u) here:

      ! allocate and set dXdu

   END IF

   IF ( PRESENT( dXddu ) ) THEN

      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the inputs (u) here:

      ! allocate and set dXddu

   END IF

   IF ( PRESENT( dZdu ) ) THEN

      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the inputs (u) here:

      ! allocate and set dZdu

   END IF


END SUBROUTINE ExtPtfm_JacobianPInput
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the continuous states (x). The partial derivatives dY/dx, dX/dx, dXd/dx, and DZ/dx are returned.
SUBROUTINE ExtPtfm_JacobianPContState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdx, dXdx, dXddx, dZdx )
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdx.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdx(:,:)  !< Partial derivatives of output functions
                                                                                    !!   (Y) with respect to the continuous
                                                                                    !!   states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdx(:,:)  !< Partial derivatives of continuous state
                                                                                    !!   functions (X) with respect to
                                                                                    !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddx(:,:) !< Partial derivatives of discrete state
                                                                                    !!   functions (Xd) with respect to
                                                                                    !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdx(:,:)  !< Partial derivatives of constraint state
                                                                                    !!   functions (Z) with respect to
                                                                                    !!   the continuous states (x) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''



   IF ( PRESENT( dYdx ) ) THEN

      ! Calculate the partial derivative of the output functions (Y) with respect to the continuous states (x) here:

      ! allocate and set dYdx

   END IF

   IF ( PRESENT( dXdx ) ) THEN

      ! Calculate the partial derivative of the continuous state functions (X) with respect to the continuous states (x) here:

      ! allocate and set dXdx

   END IF

   IF ( PRESENT( dXddx ) ) THEN

      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the continuous states (x) here:

      ! allocate and set dXddx

   END IF

   IF ( PRESENT( dZdx ) ) THEN


      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the continuous states (x) here:

      ! allocate and set dZdx

   END IF


END SUBROUTINE ExtPtfm_JacobianPContState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the discrete states (xd). The partial derivatives dY/dxd, dX/dxd, dXd/dxd, and DZ/dxd are returned.
SUBROUTINE ExtPtfm_JacobianPDiscState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdxd, dXdxd, dXddxd, dZdxd )
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdxd.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdxd(:,:) !< Partial derivatives of output functions
                                                                                    !!  (Y) with respect to the discrete
                                                                                    !!  states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdxd(:,:) !< Partial derivatives of continuous state
                                                                                    !!   functions (X) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddxd(:,:)!< Partial derivatives of discrete state
                                                                                    !!   functions (Xd) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdxd(:,:) !< Partial derivatives of constraint state
                                                                                    !!   functions (Z) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''


   IF ( PRESENT( dYdxd ) ) THEN

      ! Calculate the partial derivative of the output functions (Y) with respect to the discrete states (xd) here:

      ! allocate and set dYdxd

   END IF

   IF ( PRESENT( dXdxd ) ) THEN

      ! Calculate the partial derivative of the continuous state functions (X) with respect to the discrete states (xd) here:

      ! allocate and set dXdxd

   END IF

   IF ( PRESENT( dXddxd ) ) THEN

      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the discrete states (xd) here:

      ! allocate and set dXddxd

   END IF

   IF ( PRESENT( dZdxd ) ) THEN

      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the discrete states (xd) here:

      ! allocate and set dZdxd

   END IF


END SUBROUTINE ExtPtfm_JacobianPDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the constraint states (z). The partial derivatives dY/dz, dX/dz, dXd/dz, and DZ/dz are returned.
SUBROUTINE ExtPtfm_JacobianPConstrState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdz, dXdz, dXddz, dZdz )
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdz.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdz(:,:)  !< Partial derivatives of output
                                                                                    !!  functions (Y) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdz(:,:)  !< Partial derivatives of continuous
                                                                                    !!  state functions (X) with respect to
                                                                                    !!  the constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddz(:,:) !< Partial derivatives of discrete state
                                                                                    !!  functions (Xd) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdz(:,:)  !< Partial derivatives of constraint
                                                                                    !! state functions (Z) with respect to
                                                                                    !!  the constraint states (z) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( dYdz ) ) THEN

         ! Calculate the partial derivative of the output functions (Y) with respect to the constraint states (z) here:

      ! allocate and set dYdz

   END IF

   IF ( PRESENT( dXdz ) ) THEN

         ! Calculate the partial derivative of the continuous state functions (X) with respect to the constraint states (z) here:

      ! allocate and set dXdz

   END IF

   IF ( PRESENT( dXddz ) ) THEN

         ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the constraint states (z) here:

      ! allocate and set dXddz

   END IF

   IF ( PRESENT( dZdz ) ) THEN

         ! Calculate the partial derivative of the constraint state functions (Z) with respect to the constraint states (z) here:

      ! allocate and set dZdz

   END IF


END SUBROUTINE ExtPtfm_JacobianPConstrState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to pack the data structures representing the operating points into arrays for linearization.
SUBROUTINE ExtPtfm_GetOP( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, u_op, y_op, x_op, dx_op, xd_op, z_op )

   REAL(DbKi),                           INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),              INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),          INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),    INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),      INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),    INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),         INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),             INTENT(IN   )           :: y          !< Output at operating point
   TYPE(ExtPtfm_MiscVarType),            INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                       INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                         INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: u_op(:)    !< values of linearized inputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: y_op(:)    !< values of linearized outputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: x_op(:)    !< values of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: dx_op(:)   !< values of first time derivatives of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: xd_op(:)   !< values of linearized discrete states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: z_op(:)    !< values of linearized constraint states


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( u_op ) ) THEN

   END IF

   IF ( PRESENT( y_op ) ) THEN
   END IF

   IF ( PRESENT( x_op ) ) THEN

   END IF

   IF ( PRESENT( dx_op ) ) THEN

   END IF

   IF ( PRESENT( xd_op ) ) THEN

   END IF
   
   IF ( PRESENT( z_op ) ) THEN

   END IF

END SUBROUTINE ExtPtfm_GetOP
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

END MODULE ExtPtfm_MCKF
!**********************************************************************************************************************************
