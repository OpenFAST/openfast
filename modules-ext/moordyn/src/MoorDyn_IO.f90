!..................................................................................................................................

!    This file is part of MoorDyn.
!

MODULE MoorDyn_IO

      ! This MODULE stores variables used for output.

   USE                              NWTC_Library
   USE                              MoorDyn_Types
!   USE                              SD_FEM
   IMPLICIT                         NONE

        ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi),PUBLIC, PARAMETER      :: MaxOutPts = 2265

   INTEGER(IntKi)                 :: UnOutFile   ! unit number of main output file
   REAL(ReKi),      ALLOCATABLE   :: MDWrOutput(:)        ! one line of output data (duplicate of y%WriteOutput, should fix)

   INTEGER(IntKi), ALLOCATABLE    :: UnLineOuts(:) ! Unit numbers of line output files
   REAL(ReKi),      ALLOCATABLE   :: MDWrOutput2(:)        ! one line of output data for Lines


   PRIVATE

       ! Indices for computing output channels:  - customized for the MD_OutParmType approach
    ! these are the "QTypes"

  INTEGER, PARAMETER             :: Time      =    0

  INTEGER, PARAMETER             :: PosX      =    1
  INTEGER, PARAMETER             :: PosY      =    2
  INTEGER, PARAMETER             :: PosZ      =    3
  INTEGER, PARAMETER             :: VelX      =    4
  INTEGER, PARAMETER             :: VelY      =    5
  INTEGER, PARAMETER             :: VelZ      =    6
  INTEGER, PARAMETER             :: AccX      =    7
  INTEGER, PARAMETER             :: AccY      =    8
  INTEGER, PARAMETER             :: AccZ      =    9
  INTEGER, PARAMETER             :: Ten      =    10
  INTEGER, PARAMETER             :: FX      =    11
  INTEGER, PARAMETER             :: FY      =    12
  INTEGER, PARAMETER             :: FZ      =    13

  CHARACTER(ChanLen), PARAMETER :: UnitList(0:13) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(s)       ","(m)       ","(m)       ","(m)       ", &
                               "(m/s)     ","(m/s)     ","(m/s)     ", &
                               "(m/s2)    ","(m/s2)    ","(m/s2)    ", &
                               "(N)       ","(N)       ","(N)       ","(N)       " /)

  CHARACTER(28), PARAMETER  :: OutPFmt = "( I4, 3X,A 10,1 X, A10 )"   ! Output format parameter output list.
  CHARACTER(28), PARAMETER  :: OutSFmt = "ES10.3E2"

  ! These are the "OTypes": 0=Connect object, 1=Line Object

  ! output naming scheme is as
  ! examples:
  !  FairTen1, AnchTen1
  !  Con1x
  !  Con3u


    ! Member Forces:

!   INTEGER(IntKi), PARAMETER      :: M1N1FKxe  =    1
 !  INTEGER(IntKi), PARAMETER      :: M1N2FKxe  =    2


     ! The maximum number of output channels which can be output by the code.
   !INTEGER(IntKi), PARAMETER      :: MaxOutPts = 2265

!End of code generated by Matlab script

!   INTEGER, PARAMETER             :: MNfmKe(6,9,9) = reshape((/ M1N1FKxe,M1N1FKye,M1N1FKze,M1N1MKxe,M1N1MKye,M1N1MKze, &
!                                                              M1N2FKxe,M1N2FKye,M1N2FKze,M1N2MKxe,M1N2MKye,M1N2MKze, &
!                                                              M1N3FKxe,M1N3FKye,M1N3FKze,M1N3MKxe,M1N3MKye,M1N3MKze, &
!                                                                    M9N9TAxe,M9N9TAye,M9N9TAze,M9N9RAxe,M9N9RAye,M9N9RAze/), (/6,9,9/))

!      INTEGER, PARAMETER             :: ReactSS(6) =    (/ReactFXss,   ReactFYss,   ReactFZss   , &
 !                                                         ReactMXss,  ReactMYss,  ReactMZss/)

!   CHARACTER(10), PARAMETER  :: ValidParamAry(2265) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
!                               "INTFFXSS ","INTFFYSS ","INTFFZSS ","INTFMXSS ","INTFMYSS ","INTFMZSS ","INTFRAXSS", &
!                               "SSQMDD96 ","SSQMDD97 ","SSQMDD98 ","SSQMDD99 "/)

!   INTEGER(IntKi), PARAMETER :: ParamIndxAry(2265) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
!                                 IntfFXss ,  IntfFYss ,  IntfFZss ,  IntfMXss ,  IntfMYss ,  IntfMZss , IntfRAXss , &
!                                 SSqmdd89 ,  SSqmdd90 ,  SSqmdd91 ,  SSqmdd92 ,  SSqmdd93 ,  SSqmdd94 ,  SSqmdd95 , &
!                                 SSqmdd96 ,  SSqmdd97 ,  SSqmdd98 ,  SSqmdd99 /)
!   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(2265) =  (/ &                     ! This lists the units corresponding to the allowed parameters
!                               "(N)       ","(N)       ","(N)       ","(Nm)      ","(Nm)      ","(Nm)      ","(rad/s^2) ", &
!                               "(1/s^2)   ","(1/s^2)   ","(1/s^2)   ","(1/s^2)   "/)

!  LOGICAL                  :: InvalidOutput(0:MaxOutPts)                        ! This array determines if the output channel is valid for this configuration


!End of code generated by Matlab script



      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: MDIO_ReadInput
   PUBLIC :: MDIO_OpenOutput
   PUBLIC :: MDIO_CloseOutput
  ! PUBLIC :: MDIO_WriteOutputNames
  ! PUBLIC :: MDIO_WriteOutputUnits
   PUBLIC :: MDIO_SetOutParam
   PUBLIC :: MDIO_WriteOutputs
  ! PUBLIC :: MDIO_Init

CONTAINS




  !====================================================================================================
  SUBROUTINE MDIO_ReadInput( InitInp, p, other, ErrStat, ErrMsg )
  !     This subroutine reads the input required for MoorDyn from the file whose name is an
  !     input parameter.  It sets the size of p%NTypes, NConnects, and NLines,
  !     allocates LineTypeList, ConnectList, and LineList, and puts all the read contents of
  !     the input file into the respective slots in those lists of types.
  !----------------------------------------------------------------------------------------------------


        ! Passed variables

      TYPE(MD_InitInputType), INTENT( INOUT )   :: InitInp              ! the MoorDyn data
      TYPE(MD_ParameterType),       INTENT(  OUT)     :: p           ! INTENT( OUT) : Parameters
      TYPE(MD_OtherStateType),      INTENT(  OUT)     :: other       ! INTENT( OUT) : Initial other/optimization states
      INTEGER,                      INTENT(   OUT )   :: ErrStat              ! returns a non-zero value when an error occurs
      CHARACTER(*),                 INTENT(   OUT )   :: ErrMsg               ! Error message if ErrStat /= ErrID_None


        ! Local variables

     INTEGER                      :: I                    ! generic integer for counting
     INTEGER                      :: J                    ! generic integer for counting
  !   CHARACTER(   2)              :: strI                 ! string version of the loop counter
      INTEGER                      :: UnIn                 ! Unit number for the input file
  !   LOGICAL                      :: EchoStore            ! Stored version of NWTC_Library Echo variable
  !   INTEGER                      :: UnEchoStore          ! Stored unit name for another module's echo file
      INTEGER                      :: UnEc          ! The local unit number for this module's echo file
      CHARACTER(1024)              :: EchoFile             ! Name of MoorDyn echo file
  !   INTEGER                      :: MemberID             ! Temporary storage of MemberID read from MoorDyn input file
  !   INTEGER, ALLOCATABLE         :: tmpArray(:)          ! Temporary array storage of the joint output list
      CHARACTER(1024)              :: Line                 ! String to temporarially hold value of read line
      CHARACTER(20)              :: OptString              ! String to temporarially hold name of option variable
      CHARACTER(20)              :: OptValue               ! String to temporarially hold value of options variable input
      CHARACTER(1024)              :: FileName             !

  !      ! Initialize local data
     UnEc = -1
  !   Frmt      = "( 2X, L11, 2X, A, T30, ' - ', A )"


     ! Initialize ErrStat
     ErrStat = ErrID_None
     ErrMsg  = ""

     !-------------------------------------------------------------------------------------------------
     ! Open the file
     !-------------------------------------------------------------------------------------------------
     FileName = TRIM(InitInp%FileName)

     CALL GetNewUnit( UnIn )
     CALL OpenFInpFile( UnIn, FileName, ErrStat )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to open MoorDyn input file: '//FileName
        CALL CleanUp()
        RETURN
     END IF


     CALL WrScr( 'Opening MoorDyn input file:  '//FileName )


     !-------------------------------------------------------------------------------------------------
     ! File header
     !-------------------------------------------------------------------------------------------------

     CALL ReadCom( UnIn, FileName, 'MoorDyn input file header line 1', ErrStat )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read MoorDyn input file header line 1.'
        !CALL SetErrStat(ErrID_Fatal, 'Failed to read MoorDyn input file header line 1.',ErrStat,ErrMsg,'MDIO_ReadInput')
        CALL CleanUp()
        RETURN
     END IF


     CALL ReadCom( UnIn, FileName, 'MoorDyn input file header line 2', ErrStat )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read MoorDyn input file header line 2.'
        CALL CleanUp()
        RETURN
     END IF


     ! Echo Input Files.
     CALL ReadVar ( UnIn, FileName, InitInp%Echo, 'Echo', 'Echo Input', ErrStat )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read Echo parameter.'
        CALL CleanUp()
        RETURN
     END IF


        ! If we are Echoing the input then we should re-read the first three lines so that we can echo them
        ! using the NWTC_Library routines.  The echoing is done inside those routines via a global variable
        ! which we must store, set, and then replace on error or completion.

     IF ( InitInp%Echo ) THEN

        EchoFile = TRIM(FileName)//'.ech'                      ! open an echo file for writing
        CALL GetNewUnit( UnEc )
        CALL OpenEcho ( UnEc, EchoFile, ErrStat, ErrMsg )
        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to open Echo file.'
           CALL CleanUp()
           RETURN
        END IF

        REWIND(UnIn)      ! rewind to start of input file to re-read the first few lines

        CALL ReadCom( UnIn, FileName, 'MoorDyn input file header line 1', ErrStat, ErrMsg, UnEc )

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read MoorDyn input file header line 1.'
           CALL CleanUp()
           RETURN
        END IF


        CALL ReadCom( UnIn, FileName, 'MoorDyn input file header line 2', ErrStat, ErrMsg, UnEc )

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read MoorDyn input file header line 2.'
           CALL CleanUp()
           RETURN
        END IF


        ! Echo Input Files. Note this line is prevented from being echoed by the ReadVar routine.
        CALL ReadVar ( UnIn, FileName, InitInp%Echo, 'Echo', 'Echo the input file data', ErrStat, ErrMsg, UnEc )
        !WRITE (UnEc,Frmt      ) InitInp%Echo, 'Echo', 'Echo input file'
        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read Echo parameter.'
           CALL CleanUp()
           RETURN
        END IF

     END IF


     !-------------------------------------------------------------------------------------------------
     !  Line Types Properties Section
     !-------------------------------------------------------------------------------------------------

     CALL ReadCom( UnIn, FileName, 'Line types header', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read line types header line.'
        CALL CleanUp()
        RETURN
     END IF


     CALL ReadVar ( UnIn, FileName, p%NTypes, 'NTypes', 'Number of line types', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read NTypes parameter.'
        CALL CleanUp()
        RETURN
     END IF


     ! Table header
     DO I = 1, 2
        CALL ReadCom( UnIn, FileName, 'Line types table header', ErrStat, ErrMsg, UnEc )

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read Line types table header line.'
           CALL CleanUp()
           RETURN
        END IF
     END DO

     ! make sure NTypes isn't zero
     IF ( p%NTypes < 1 ) THEN
        ErrMsg  = ' NTypes parameter must be greater than zero.'
        CALL CleanUp()
        RETURN
     END IF

     ! Allocate memory for LineTypeList array to hold line type properties
     ALLOCATE ( other%LineTypeList(p%NTypes), STAT = ErrStat )
     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Error allocating space for LineTypeList array.'
        CALL CleanUp()
        RETURN
     END IF

     ! read each line
     DO I = 1,p%NTypes
           ! read the table entries   Name      Diam    MassDenInAir    EA        cIntDamp     Can     Cat    Cdn     Cdt     in the MoorDyn input file
        READ(UnIn,'(A)',IOSTAT=ErrStat) Line      !read into a line

        IF (ErrStat == 0) THEN
           READ(Line,*,IOSTAT=ErrStat) other%LineTypeList(I)%name, other%LineTypeList(I)%d,  &
              other%LineTypeList(I)%w, other%LineTypeList(I)%EA, other%LineTypeList(I)%BA, &
              other%LineTypeList(I)%Can, other%LineTypeList(I)%Cat, other%LineTypeList(I)%Cdn, other%LineTypeList(I)%Cdt
        END IF

        other%LineTypeList(I)%IdNum = I  ! specify IdNum of line type for error checking


        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read line type properties for line '//trim(Num2LStr(I))
           CALL CleanUp()
           RETURN
        END IF

        IF ( InitInp%Echo ) THEN
           WRITE( UnEc, '(A)' ) TRIM(Line)
        END IF

     END DO



     !-------------------------------------------------------------------------------------------------
     !  Connections Section
     !-------------------------------------------------------------------------------------------------

     CALL ReadCom( UnIn, FileName, 'Connections header', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read connections header line.'
        CALL CleanUp()
        RETURN
     END IF


     CALL ReadVar ( UnIn, FileName, p%NConnects, 'NConnects', 'Number of Connects', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read NConnects parameter.'
        CALL CleanUp()
        RETURN
     END IF


     ! Table header
     DO I = 1, 2
        CALL ReadCom( UnIn, FileName, 'Connects header', ErrStat, ErrMsg, UnEc )

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read Connects table header line.'
           CALL CleanUp()
           RETURN
        END IF
     END DO

     ! make sure NConnects is at least two
     IF ( p%NConnects < 2 ) THEN
        ErrMsg  = ' NConnects parameter must be at least 2.'
        CALL CleanUp()
        RETURN
     END IF

      ! allocate ConnectList
     ALLOCATE ( other%ConnectList(p%NConnects), STAT = ErrStat )
     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Error allocating space for ConnectList array.'
        CALL CleanUp()
        RETURN
     END IF

     ! read each line
     DO I = 1,p%NConnects
           ! read the table entries   Node      Type      X        Y         Z        M        V        FX       FY      FZ
        READ(UnIn,'(A)',IOSTAT=ErrStat) Line      !read into a line

        IF (ErrStat == 0) THEN
           READ(Line,*,IOSTAT=ErrStat) other%ConnectList(I)%IdNum, other%ConnectList(I)%type, other%ConnectList(I)%conX, &
                other%ConnectList(I)%conY, other%ConnectList(I)%conZ, other%ConnectList(I)%conM, &
                other%ConnectList(I)%conV, other%ConnectList(I)%conFX, other%ConnectList(I)%conFY, &
                 other%ConnectList(I)%conFZ
        END IF

        ! check for sequential IdNums
        IF ( other%ConnectList(I)%IdNum .NE. I ) THEN
          ErrMsg  = ' Node numbers must be sequential starting from 1.'
          CALL CleanUp()
          RETURN
        END IF


        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read connects.'  ! would be nice to specify which line
           CALL CleanUp()
           RETURN
        END IF

        IF ( InitInp%Echo ) THEN
           WRITE( UnEc, '(A)' ) TRIM(Line)
        END IF

     END DO




     !-------------------------------------------------------------------------------------------------
     !  Lines Section
     !-------------------------------------------------------------------------------------------------

     CALL ReadCom( UnIn, FileName, 'Lines header', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read lines header line.'
        CALL CleanUp()
        RETURN
     END IF


     CALL ReadVar ( UnIn, FileName, p%NLines, 'NLines', 'Number of Lines', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read NLines parameter.'
        CALL CleanUp()
        RETURN
     END IF


     ! Table header
     DO I = 1, 2
        CALL ReadCom( UnIn, FileName, 'Lines header', ErrStat, ErrMsg, UnEc )

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read Lines table header line.'
           CALL CleanUp()
           RETURN
        END IF
     END DO

     ! make sure NLines is at least one
     IF ( p%NLines < 1 ) THEN
        ErrMsg  = ' NLines parameter must be at least 1.'
        CALL CleanUp()
        RETURN
     END IF

      ! allocate LineList
     ALLOCATE ( other%LineList(p%NLines), STAT = ErrStat )
     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Error allocating space for LineList array.'
        CALL CleanUp()
        RETURN
     END IF

     ! read each line
     DO I = 1,p%NLines
           ! read the table entries   Line     LineType  UnstrLen  NumSegs   NodeAnch  NodeFair  Flags/Outputs
        READ(UnIn,'(A)',IOSTAT=ErrStat) Line      !read into a line

        IF (ErrStat == 0) THEN
           READ(Line,*,IOSTAT=ErrStat) other%LineList(I)%IdNum, other%LineList(I)%type, other%LineList(I)%UnstrLen, &
             other%LineList(I)%N, other%LineList(I)%AnchConnect, other%LineList(I)%FairConnect, other%LineList(I)%OutFlags
        END IF

        ! check for sequential IdNums
        IF ( other%LineList(I)%IdNum .NE. I ) THEN
          ErrMsg  = ' Line numbers must be sequential starting from 1.'
          CALL CleanUp()
          RETURN
        END IF

        ! identify index of line type
        DO J = 1,p%NTypes
          IF (trim(other%LineList(I)%type) == trim(other%LineTypeList(J)%name)) THEN
            other%LineList(I)%PropsIdNum = J
            EXIT
            IF (J == p%NTypes) THEN   ! call an error if there is no match
              ErrMsg = 'Unable to find matching line type name for Line '//trim(Num2LStr(I))
              ErrStat = ErrID_Severe
            END IF
          END IF
        END DO

        IF ( ErrStat /= ErrID_None ) THEN
           ErrMsg  = ' Failed to read line data for Line '//trim(Num2LStr(I))  ! would be nice to specify which line
           CALL CleanUp()
           RETURN
        END IF

        IF ( InitInp%Echo ) THEN
           WRITE( UnEc, '(A)' ) TRIM(Line)
        END IF

     END DO  ! I


     !-------------------------------------------------------------------------------------------------
     ! Read any options lines
     !-------------------------------------------------------------------------------------------------

     CALL ReadCom( UnIn, FileName, 'Options header', ErrStat, ErrMsg, UnEc )

     IF ( ErrStat /= ErrID_None ) THEN
        ErrMsg  = ' Failed to read options header line.'
        CALL CleanUp()
        RETURN
     END IF

      ! loop through any remaining input lines, and use them to set options (overwriting default values in many cases).
      ! doing this manually since I'm not sure that there is a built in subroutine for reading any input value on any line number.
      DO

        READ(UnIn,'(A)',IOSTAT=ErrStat) Line      !read into a line

        IF (ErrStat == 0) THEN
          IF (( Line(1:3) == '---' ) .OR. ( Line(1:3) == 'END' ) .OR. ( Line(1:3) == 'end' ))  EXIT  ! check if it's the end line

          READ(Line,*,IOSTAT=ErrStat) OptValue, OptString  ! look at first two entries, ignore remaining words in line, which should be comments
        END IF

        CALL Conv2UC(OptString)

        ! check all possible options types and see if OptString is one of them, in which case set the variable.
        if ( OptString == 'DT') THEN
          read (OptValue,*) InitInp%DTmooring   ! or something
          print *, 'set p dt to ', InitInp%DTmooring
        else if ( OptString == 'G') then
          read (OptValue,*) p%G
        else if ( OptString == 'RHOW') then
          read (OptValue,*) p%rhoW
        else if ( OptString == 'WTRDPTH') then
          read (OptValue,*) p%WtrDpth
        else if ( OptString == 'KBOT')  then
          read (OptValue,*) p%kBot
        else if ( OptString == 'CBOT')  then
          read (OptValue,*) p%cBot
        else if ( OptString == 'DTIC')  then
          read (OptValue,*) InitInp%dtIC
        else if ( OptString == 'TMAXIC')  then
          read (OptValue,*) InitInp%TMaxIC
        else if ( OptString == 'CDSCALEIC')  then
          read (OptValue,*) InitInp%CdScaleIC
        else if ( OptString == 'THRESHIC')  then
          read (OptValue,*) InitInp%threshIC
        else
          ErrStat = ErrID_Warn
  print *, 'unable to interpret input ', OptString
        end if

        IF ( ErrStat > ErrID_Warn ) THEN
           ErrMsg  = ' Failed to read options.'  ! would be nice to specify which line had the error
           CALL CleanUp()
           RETURN
        END IF

        IF ( InitInp%Echo ) THEN
           WRITE( UnEc, '(A)' ) TRIM(Line)
        END IF

      END DO


     !-------------------------------------------------------------------------------------------------
     ! Read the FAST-style outputs list in the final section, if there is one
     !-------------------------------------------------------------------------------------------------
!     we don't read in the outputs header line because it's already been read in for detecting the end of the variable-length options section
!     CALL ReadCom( UnIn, FileName, 'Outputs header', ErrStat, ErrMsg, UnEc )

    ! allocate InitInp%Outliest
    CALL AllocAry( InitInp%OutList, MaxOutPts, "MoorDyn Input File's Outlist", ErrStat, ErrMsg )
    !  CALL CheckError( ErrStat2, ErrMsg2 )
    !  IF ( ErrStat >= AbortErrLev ) RETURN

    ! OutList - List of user-requested output channels (-):
    CALL ReadOutputList ( UnIn, FileName, InitInp%OutList, p%NumOuts, 'OutList', "List of user-requested output channels", ErrStat, ErrMsg, UnEc  )     ! Routine in NWTC Subroutine Library
   !   CALL CheckError( ErrStat2, ErrMsg2 )
   !   IF ( ErrStat >= AbortErrLev ) RETURN
    IF ( ErrStat > ErrID_Warn ) THEN
       ErrMsg  = ' Failed to read output list.'
       CALL CleanUp()
       RETURN
    END IF

  print *, 'NumOuts is ', p%NumOuts
  print *, 'OutList is ', InitInp%OutList(1:p%NumOuts)


     !-------------------------------------------------------------------------------------------------
     ! This is the end of the input file
     !-------------------------------------------------------------------------------------------------

           CLOSE( UnIn )
        IF (InitInp%Echo) CLOSE( UnEc )

        CALL WrScr( 'Done reading MoorDyn input file:  '//FileName )


  CONTAINS
     ! subroutine to set ErrState and close the files if an error occurs
     SUBROUTINE CleanUp()

        ErrStat = ErrID_Fatal
        CLOSE( UnIn )
        IF (InitInp%Echo) CLOSE( UnEc )

     END SUBROUTINE

  END SUBROUTINE MDIO_ReadInput
! ====================================================================================================


! should rename this sub:  (called from ReadInput sub above...)

SUBROUTINE MDIO_SetOutParam(OutList, p, other, y, ErrStat, ErrMsg )
! This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a
! warning if any of the channels are not available outputs from the module.
!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!  the sign is set to 0 if the channel is invalid.
! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!..................................................................................................................................

  IMPLICIT                        NONE

    ! Passed variables

  CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        ! The list out user-requested outputs
  TYPE(MD_ParameterType),    INTENT(INOUT)  :: p                                 ! The module parameters
  TYPE(MD_OtherStateType),   INTENT(IN)     :: other
  TYPE(MD_OutputType),       INTENT(INOUT)  :: y           ! INTENT( OUT) : Initial system outputs (outputs are not calculated; only the output mesh is initialized)
  INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           ! The error status code
  CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            ! The error message, if an error occurred

    ! Local variables

  INTEGER                      :: I                                               ! Generic loop-counting index
  INTEGER                      :: J                                               ! Generic loop-counting index
  INTEGER                      :: INDX                                            ! Index for valid arrays

  !LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
  !LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
  CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I), the name of each output channel

!  CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(8) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
!                             "BLPITCHC1","BLPITCHC2","BLPITCHC3","GENPWR   ","GENTQ    ","HSSBRTQ  ","YAWMOM   ", &
!                             "YAWMOMCOM"/)
!  INTEGER(IntKi), PARAMETER :: ParamIndxAry(8) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
!                              BlPitchC1 , BlPitchC2 , BlPitchC3 ,    GenPwr ,     GenTq ,   HSSBrTq , YawMomCom , &
!                              YawMomCom /)
!  CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(8) =  (/ &                     ! This lists the units corresponding to the allowed parameters
!                             "(deg)     ","(deg)     ","(deg)     ","(kW)      ","(kN·m)    ","(kN·m)    ","(kN·m)    ", &
!                               "(kN·m)    "/)


   INTEGER                      :: Ch                                           ! Character position within the string.
   INTEGER                      :: ID                                           ! ID number of connect or line object
   INTEGER                      :: NextNum                                    ! The location of the next number


   CHARACTER(ChanLen)    :: Line                                         ! The string to search, which is the name of one channel

  ! see the top of the module for info on the output labelling types

      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
!   InvalidOutput = .FALSE.

   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

  ALLOCATE ( p%OutParam(1:p%NumOuts) , STAT=ErrStat )   ! note: I'm skipping the time output entry at index 0 for simplicity
  IF ( ErrStat /= 0_IntKi )  THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = "Error allocating memory for the MoorDyn OutParam array."
    RETURN
  ELSE
    ErrStat = ErrID_None
  ENDIF


  ! Set index, name, and units for the time output channel: ! note: I'm skipping the time output entry at index 0
  !p%OutParam(0)%Indx  = Time
  !p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
  !p%OutParam(0)%Units = "(s)"
  !p%OutParam(0)%SignM = 1
  !p%


  ! Set index, name, and units for all of the output channels.
  ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.


  ! go through list of requested output names and process
  DO I = 1,p%NumOuts

    OutListTmp          = OutList(I)  ! current requested output name
    p%OutParam(I)%Name  = OutListTmp
    CALL Conv2UC(OutListTmp)       ! convert to all uppercase for string matching purposes

    !Ch = 0  ! not really using this
    NextNum = SCAN( OutListTmp , '1234567890' )

    ! process each requested output
    IF (OutListTmp(1:NextNum-1) == 'FAIRTEN') THEN     ! this is the fairlead tension case
      p%OutParam(I)%OType = 1                ! line object type
      p%OutParam(I)%QType = Ten              ! tension quantity type
      p%OutParam(I)%Units = UnitList(Ten)    ! set units according to QType
      READ (OutListTmp(:),*) ID
      p%OutParam(I)%ObjID =  ID
      p%OutParam(I)%NodeID =  other%LineList(ID)%N  ! line type
  ! ELSE IF ...
          ! more output types to be added...
          ! ...
    ELSE ! requested output not recognized
      ! should set a proper warning here...
      PRINT *, 'only FAIRTENx (where x is the line number) outputs are supported so far.'
      PRINT *, '  non-matching string is: ', OutListTmp(1:NextNum-1)
    END IF

    ! also check whether each object index (ID) is in range ... should also check node indices if applicable
    IF (p%OutParam(I)%OType==0) THEN
      IF (p%OutParam(I)%ObjID > p%NConnects) THEN
        print *, 'warning, output Connect index excedes number of Connects'
      END IF
    ELSE IF (p%OutParam(I)%OType==1) THEN
      IF (p%OutParam(I)%ObjID > p%NLines) THEN
        print *, 'warning, output Line index excedes number of Line'
      END IF
    END IF

!
!      ! Reverse the sign (+/-) of the output channel if the user prefixed the
!      !   channel name with a "-", "_", "m", or "M" character indicating "minus".
!      CheckOutListAgain = .FALSE.
!
!      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
!         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
!         OutListTmp          = OutListTmp(2:)
!      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
!         CheckOutListAgain   = .TRUE.
!         p%OutParam(I)%SignM = 1
!      ELSE
!         p%OutParam(I)%SignM = 1
!      END IF

!
!      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
!
!         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)
!
!      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
!         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
!         OutListTmp          = OutListTmp(2:)
!
!         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
!      END IF
!
!
!      IF ( Indx > 0 ) THEN ! we found the channel name
!         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
!         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
!            p%OutParam(I)%Units = "INVALID"
!            p%OutParam(I)%SignM = 0
!         ELSE
!            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
!         END IF
!      ELSE ! this channel isn't valid
!         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
!         p%OutParam(I)%Units = "INVALID"
!         p%OutParam(I)%SignM = 0                    ! multiply all results by zero
!
!         ErrStat = ErrID_Warn
!         ErrMsg  = p%OutParam(I)%Name//" is not an available output channel. "//TRIM(ErrMsg)
!      END IF

   END DO  ! I ... looping through OutList



  ! Allocate MDWrOuput which is used to store a time step's worth of output channels, prior to writing to a file.
  ALLOCATE( MDWrOutput( p%NumOuts),  STAT = ErrStat )
  IF ( ErrStat /= ErrID_None ) THEN
    ErrMsg  = ' Error allocating space for MDWrOutput array.'
    ErrStat = ErrID_Fatal
    RETURN
  END IF


  ! Allocate MDWrOuput2 which is used to store a time step's worth of output data for each line, just making it really big for now <<<
  ALLOCATE( MDWrOutput2( 200),  STAT = ErrStat )
  IF ( ErrStat /= ErrID_None ) THEN
    ErrMsg  = ' Error allocating space for MDWrOutput2 array.'
    ErrStat = ErrID_Fatal
    RETURN
  END IF

  !Allocate WriteOuput
  ALLOCATE( y%WriteOutput( p%NumOuts),  STAT = ErrStat )
  IF ( ErrStat /= ErrID_None ) THEN
    ErrMsg  = ' Error allocating space for y%WriteOutput array.'
    ErrStat = ErrID_Fatal
    RETURN
  END IF

  print *, "y%WriteOutput allocated to size ", size(y%WriteOutput)

 ! These variables are to help follow the framework template, but the data in them is simply a copy of data
 ! already available in the OutParam data structure
!  ALLOCATE ( InitOut%WriteOutputHdr(p%NumOuts+p%OutAllint*p%OutAllDims), STAT = ErrStat )
!  ALLOCATE ( InitOut%WriteOutputUnt(p%NumOuts+p%OutAllint*p%OutAllDims), STAT = ErrStat )

!   DO I = 1,p%NumOuts+p%OutAllint*p%OutAllDims
!    InitOut%WriteOutputHdr(I) = TRIM( p%OutParam(I)%Name  )
!    InitOut%WriteOutputUnt(I) = TRIM( p%OutParam(I)%Units )
!   END DO


END SUBROUTINE MDIO_SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------





!====================================================================================================
SUBROUTINE MDIO_OpenOutput( OutRootName,  p, other, InitOut, ErrStat, ErrMsg )
!----------------------------------------------------------------------------------------------------

      ! Passed variables

 !  TYPE(ProgDesc),                INTENT( IN    ) :: ProgVer
   CHARACTER(*),                  INTENT( IN    ) :: OutRootName          ! Root name for the output file
   TYPE(MD_ParameterType),        INTENT( INOUT ) :: p
   TYPE(MD_OtherStateType),       INTENT (IN)     :: other
   TYPE(MD_InitOutPutType ),      INTENT( IN    ) :: InitOut              !
   INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred
   CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None

      ! Local variables
   INTEGER                                        :: I                    ! Generic loop counter
   INTEGER                                        :: J                    ! Generic loop counter
   CHARACTER(1024)                                :: OutFileName          ! The name of the output file  including the full path.
   CHARACTER(200)                                 :: Frmt                 ! a string to hold a format statement
   INTEGER                                        :: ErrStat2

   !-------------------------------------------------------------------------------------------------
   ! Initialize local variables
   !-------------------------------------------------------------------------------------------------
   ErrStat = ErrID_None
   ErrMsg  = ""

    p%Delim = ' '  ! for now

   !-------------------------------------------------------------------------------------------------
   ! Open the output file, if necessary, and write the header
   !-------------------------------------------------------------------------------------------------

   IF ( ALLOCATED( p%OutParam ) .AND. p%NumOuts > 0 ) THEN           ! Output has been requested so let's open an output file

         ! Open the file for output
      OutFileName = 'MoorDyn.out'
      CALL GetNewUnit( UnOutFile )

      CALL OpenFOutFile ( UnOutFile, OutFileName, ErrStat, ErrMsg )
      IF ( ErrStat >= AbortErrLev ) THEN
         ErrMsg = ' Error opening MoorDyn-level output file: '//TRIM(ErrMsg)
         RETURN
      END IF


         ! Write the output file header

   !   WRITE (p%UnOutFile,'(/,A/)', IOSTAT=ErrStat2)  'These predictions were generated by '//TRIM(GETNVD(ProgVer))//&
    !                  ' on '//CurDate()//' at '//CurTime()//'.'

  !   WRITE(p%UnOutFile, '(//)') ! add 3 lines to make file format consistant with FAST v8 (headers on line 7; units on line 8) [this allows easier post-processing]

    !Write the names of the output parameters:

    Frmt = '(A10,'//TRIM(Int2LStr(p%NumOuts))//'(A1,A10))'


    print *, 'Names Frmt is ', Frmt

    WRITE(UnOutFile,Frmt, IOSTAT=ErrStat2)  TRIM( 'Time' ), ( p%Delim, TRIM( p%OutParam(I)%Name), I=1,p%NumOuts )


    Frmt = '(A10,'//TRIM(Int2LStr(p%NumOuts))//'(A1,A10))'    !??? <<<<<<<

    WRITE(UnOutFile,Frmt)  TRIM( '(s)' ), ( p%Delim, TRIM( p%OutParam(I)%Units ), I=1,p%NumOuts )

   print *, 'Units is ', p%OutParam(1:p%NumOuts)%Units

   print *, '1 name is ', p%OutParam(1)%Name
   print *, '1 units is ', p%OutParam(1)%Units
   print *, '1 QType is ', p%OutParam(1)%QType

    ELSE  ! if no outputs requested

      print *, 'note, MDIO_OpenOutput things that no outputs have been requested.'

   END IF

   !--------------------------------------------------------------------------
   ! -------------- now do the same for line output files --------------------

   ! allocate UnLineOuts
   ALLOCATE(UnLineOuts(p%NLines))  ! should add error checking

   DO I = 1,p%NLines

      ! Open the file for output
      OutFileName = 'Line'//TRIM(Int2LStr(I))//'.out'
      CALL GetNewUnit( UnLineOuts(I) )

      CALL OpenFOutFile ( UnLineOuts(I), OutFileName, ErrStat, ErrMsg )
      IF ( ErrStat >= AbortErrLev ) THEN
         ErrMsg = ' Error opening Line output file '//TRIM(ErrMsg)
         RETURN
      END IF


    !Write the names of the output parameters:

    Frmt = '(A10,'//TRIM(Int2LStr(3+3*other%LineList(I)%N))//'(A1,A10))'

    !WRITE(UnLineOuts(I),Frmt, IOSTAT=ErrStat2)  TRIM( 'Time' ), ( p%Delim,

    WRITE(UnLineOuts(I),Frmt, IOSTAT=ErrStat2)  TRIM( 'Time' ), ( p%Delim, 'Node'//TRIM(Int2Lstr(J))//'px', p%Delim, 'Node'//TRIM(Int2Lstr(J))//'py', p%Delim, 'Node'//TRIM(Int2Lstr(J))//'pz', J=0,(other%LineList(I)%N) )

!   WRITE(UnOutFile,Frmt)  TRIM( '(s)' ), ( p%Delim, TRIM( p%OutParam(I)%Units ), I=1,p%NumOuts )

  END DO ! I


END SUBROUTINE MDIO_OpenOutput

!====================================================================================================


!====================================================================================================
SUBROUTINE MDIO_CloseOutput ( p, ErrStat, ErrMsg )
! This function cleans up after running the MoorDyn output module. It closes the output file,
! releases memory, and resets the number of outputs requested to 0.
!----------------------------------------------------------------------------------------------------

         ! Passed variables

   TYPE(MD_ParameterType),  INTENT( INOUT )  :: p                    ! data for this instance of the floating platform module
   INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred
   CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None

!      ! Internal variables
   LOGICAL                               :: Err
   INTEGER(IntKi)       :: I  ! generic counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize error information
   !-------------------------------------------------------------------------------------------------
   ErrStat = 0
   ErrMsg  = ""

   Err     = .FALSE.

   !-------------------------------------------------------------------------------------------------
   ! Close our output file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnOutFile, IOSTAT = ErrStat )
   IF ( ErrStat /= 0 ) Err = .TRUE.

  ! also close line output files
  DO I=1,p%NLines
       CLOSE( UnLineOuts(I), IOSTAT = ErrStat )
       IF ( ErrStat /= 0 ) Err = .TRUE.
  END DO


   !-------------------------------------------------------------------------------------------------
   ! Make sure ErrStat is non-zero if an error occurred
   !-------------------------------------------------------------------------------------------------
   IF ( Err ) ErrStat = ErrID_Fatal

   RETURN

END SUBROUTINE MDIO_CloseOutput
!====================================================================================================


!====================================================================================================
SUBROUTINE MDIO_WriteOutputs( Time, p, other, y, ErrStat, ErrMsg )
! This subroutine gathers the output data defined by the OutParams list and
! writes it to the output file opened in MDIO_OutInit()
!----------------------------------------------------------------------------------------------------

      ! Passed variables
!   INTEGER,                      INTENT( IN    ) :: UnOutFile               ! file unit for the output file
   REAL(DbKi),                   INTENT( IN    ) :: Time                 ! Time for this output
!   REAL(ReKi),                   INTENT( IN    ) :: MDWrOutput(:)        ! MoorDyn module's output data
   TYPE(MD_ParameterType),       INTENT( IN    ) :: p                    ! MoorDyn module's parameter data
   TYPE(MD_OutputType),          INTENT(INOUT)  :: y           ! INTENT( OUT) : Initial system outputs (outputs are not calculated; only the output mesh is initialized)
   TYPE(MD_OtherStateType),      INTENT( IN    ) :: other                ! MoorDyn module's other data
   INTEGER,                      INTENT(   OUT ) :: ErrStat              ! returns a non-zero value when an error occurs
   CHARACTER(*),                 INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None

      ! Local variables
  ! REAL(ReKi)                             :: OutData (0:p%NumOuts)       ! an output array
   INTEGER                                :: I                           ! Generic loop counter
   INTEGER                                :: J                           ! Generic loop counter
   INTEGER                                :: K                           ! Generic loop counter
   CHARACTER(200)                         :: Frmt                        ! a string to hold a format statement

      ! Initialize ErrStat and determine if it makes any sense to write output

   IF ( .NOT. ALLOCATED( p%OutParam ) .OR. UnOutFile < 0 )  THEN
      ErrStat = ErrID_Fatal
      ErrMsg  = ' To write outputs for MoorDyn there must be a valid file ID and OutParam must be allocated.'
      RETURN
   ELSE
      ErrStat = ErrID_None
   END IF

  ! gather the required output quantities
  DO I = 1,p%NumOuts
    IF (p%OutParam(I)%OType == 0) THEN  ! if dealing with a Connect output
      IF (p%OutParam(I)%QType == PosX) THEN  ! x position
        MDWrOutput(I) = other%ConnectList(I)%r(1)
      ELSE IF (p%OutParam(I)%QType == PosX) THEN  ! y position
        MDWrOutput(I) = other%ConnectList(I)%r(2)
      ELSE IF (p%OutParam(I)%QType == PosX) THEN  ! z position
        MDWrOutput(I) = other%ConnectList(I)%r(3)
      ELSE
        MDWrOutput(I) = 0.0
        ErrStat = ErrID_Warn
        ErrMsg = ' Unsupported output quantity from Connect object requested.'
      END IF
    ELSE IF (p%OutParam(I)%OType == 1) THEN  ! if dealing with a Line output
      IF (p%OutParam(I)%QType == Ten) THEN  ! tension
        ! this needs to be corrected!!! <<<
        MDWrOutput(I) = TwoNorm(other%LineList(I)%T(:,p%OutParam(I)%NodeID))  ! this isn't quite right, since it's segment tension...
      ELSE
        MDWrOutput(I) = 0.0
        ErrStat = ErrID_Warn
        ErrMsg = ' Unsupported output quantity from Line object requested.'
      END IF
    END IF


    ! oops, these two are redundant I think.  should eliminate MDWrOutput probably...

        y%WriteOutput(I) = MDWrOutput(I)

  END DO ! I, loop through OutParam




  ! Write the output parameters to the file

   Frmt = '(F10.4,'//TRIM(Int2LStr(p%NumOuts))//'(A1,e10.4))'   ! should evenutally use user specified format?

!   print *, 'in WriteOutputs, Frmt is ', Frmt

 !  print *, ' and MDWrOutput is ', MDWrOutput(1:p%NumOuts)

   WRITE(UnOutFile,Frmt)  Time, ( p%Delim, MDWrOutput(I), I=1,p%NumOuts )


  !------------------------------------------------------------------------
  ! now do the outputs for each line!

  DO I=1,p%NLines
    Frmt = '(F10.4,'//TRIM(Int2LStr(3+3*other%LineList(I)%N))//'(A1,e10.4))'   ! should evenutally use user specified format?

    DO J = 0,other%LineList(I)%N  ! note index starts at zero because these are nodes
      DO K = 1,3
        MDWrOutput2(3*J+K) = other%LineList(I)%r(K,J)
      END DO
    END DO

    WRITE(UnLineOuts(I),Frmt)  Time, ( p%Delim, MDWrOutput2(J), J=1,(3+3*other%LineList(I)%N) )

!    print *, 'Line', I, Time, ( p%Delim, MDWrOutput2(J), J=1,(3+3*other%LineList(I)%N) )

  END DO ! I



END SUBROUTINE MDIO_WriteOutputs

!====================================================================================================


END MODULE MoorDyn_IO
