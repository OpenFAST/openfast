!STARTOFREGISTRYGENERATEDFILE './MAP_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! MAP_Types
!.................................................................................................................................
! This file is part of MAP.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE MAP_Types
! This module contains all of the user-defined types needed in MAP. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
!USE, INTRINSIC :: ISO_C_Binding
USE NWTC_Library
IMPLICIT NONE
! =========  MAP_InitInputType_C  =======
  TYPE, BIND(C) :: MAP_InitInputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_DOUBLE) :: gravity 
    REAL(KIND=C_DOUBLE) :: sea_density 
    REAL(KIND=C_DOUBLE) :: depth 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: file_name 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: summary_file_name 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: library_input_str 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: node_input_str 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: line_input_str 
    CHARACTER(KIND=C_CHAR), DIMENSION(255) :: option_input_str 
  END TYPE MAP_InitInputType_C
  TYPE, PUBLIC :: MAP_InitInputType
    TYPE( MAP_InitInputType_C ) :: C_obj
    REAL(DbKi)  :: gravity = -999.9      ! gravity constant [[m/s^2]]
    REAL(DbKi)  :: sea_density = -999.9      ! sea density [[kg/m^3]]
    REAL(DbKi)  :: depth = -999.9      ! depth of water [[m]]
    CHARACTER(255)  :: file_name      ! MAP input file [-]
    CHARACTER(255)  :: summary_file_name      ! MAP summary file name [-]
    CHARACTER(255)  :: library_input_str      ! cable library string information (from input file) [-]
    CHARACTER(255)  :: node_input_str      ! node string information (from input file) [-]
    CHARACTER(255)  :: line_input_str      ! element library string information (from input file) [-]
    CHARACTER(255)  :: option_input_str      ! solver options library string information (from input file) [-]
  END TYPE MAP_InitInputType
! =======================
! =========  MAP_InitOutputType_C  =======
  TYPE, BIND(C) :: MAP_InitOutputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    CHARACTER(KIND=C_CHAR), DIMENSION(99) :: progName 
    CHARACTER(KIND=C_CHAR), DIMENSION(99) :: version 
    CHARACTER(KIND=C_CHAR), DIMENSION(24) :: compilingData 
    TYPE(C_ptr) :: writeOutputHdr = C_NULL_PTR 
    INTEGER(C_int) :: writeOutputHdr_Len = 0 
    TYPE(C_ptr) :: writeOutputUnt = C_NULL_PTR 
    INTEGER(C_int) :: writeOutputUnt_Len = 0 
  END TYPE MAP_InitOutputType_C
  TYPE, PUBLIC :: MAP_InitOutputType
    TYPE( MAP_InitOutputType_C ) :: C_obj
    CHARACTER(99)  :: progName      ! program name [-]
    CHARACTER(99)  :: version      ! version numnber [-]
    CHARACTER(24)  :: compilingData      ! compiling data [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      ! first line output file contents: output variable names [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      ! second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      ! his module's name, version, and date [-]
  END TYPE MAP_InitOutputType
! =======================
! =========  MAP_ContinuousStateType_C  =======
  TYPE, BIND(C) :: MAP_ContinuousStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_ContinuousStateType_C
  TYPE, PUBLIC :: MAP_ContinuousStateType
    TYPE( MAP_ContinuousStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy      ! Remove this variable if you have continuous states [-]
  END TYPE MAP_ContinuousStateType
! =======================
! =========  MAP_DiscreteStateType_C  =======
  TYPE, BIND(C) :: MAP_DiscreteStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_DiscreteStateType_C
  TYPE, PUBLIC :: MAP_DiscreteStateType
    TYPE( MAP_DiscreteStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy      ! Remove this variable if you have discrete states [-]
  END TYPE MAP_DiscreteStateType
! =======================
! =========  MAP_OtherStateType_C  =======
  TYPE, BIND(C) :: MAP_OtherStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    TYPE(C_ptr) :: H = C_NULL_PTR 
    INTEGER(C_int) :: H_Len = 0 
    TYPE(C_ptr) :: V = C_NULL_PTR 
    INTEGER(C_int) :: V_Len = 0 
    TYPE(C_ptr) :: Ha = C_NULL_PTR 
    INTEGER(C_int) :: Ha_Len = 0 
    TYPE(C_ptr) :: Va = C_NULL_PTR 
    INTEGER(C_int) :: Va_Len = 0 
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
    TYPE(C_ptr) :: xa = C_NULL_PTR 
    INTEGER(C_int) :: xa_Len = 0 
    TYPE(C_ptr) :: ya = C_NULL_PTR 
    INTEGER(C_int) :: ya_Len = 0 
    TYPE(C_ptr) :: za = C_NULL_PTR 
    INTEGER(C_int) :: za_Len = 0 
    TYPE(C_ptr) :: Fx_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fx_connect_Len = 0 
    TYPE(C_ptr) :: Fy_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fy_connect_Len = 0 
    TYPE(C_ptr) :: Fz_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fz_connect_Len = 0 
    TYPE(C_ptr) :: Fx_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fx_anchor_Len = 0 
    TYPE(C_ptr) :: Fy_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fy_anchor_Len = 0 
    TYPE(C_ptr) :: Fz_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fz_anchor_Len = 0 
  END TYPE MAP_OtherStateType_C
  TYPE, PUBLIC :: MAP_OtherStateType
    TYPE( MAP_OtherStateType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: H => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: V => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Ha => NULL()      ! horizontal line force at anchor [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Va => NULL()      ! Vertical line force at anchor [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! x fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! y fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! z fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: xa => NULL()      ! x fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: ya => NULL()      ! y fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: za => NULL()      ! z fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx_connect => NULL()      ! horizontal x line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy_connect => NULL()      ! horizontal y line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz_connect => NULL()      ! vertical z line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx_anchor => NULL()      ! horizontal x line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy_anchor => NULL()      ! horizontal y line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz_anchor => NULL()      ! vertical z line force at connect node [[N]]
  END TYPE MAP_OtherStateType
! =======================
! =========  MAP_ConstraintStateType_C  =======
  TYPE, BIND(C) :: MAP_ConstraintStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    TYPE(C_ptr) :: H = C_NULL_PTR 
    INTEGER(C_int) :: H_Len = 0 
    TYPE(C_ptr) :: V = C_NULL_PTR 
    INTEGER(C_int) :: V_Len = 0 
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
  END TYPE MAP_ConstraintStateType_C
  TYPE, PUBLIC :: MAP_ConstraintStateType
    TYPE( MAP_ConstraintStateType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: H => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: V => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! fairlead x displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! fairlead y displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! fairlead z displacement [[m]]
  END TYPE MAP_ConstraintStateType
! =======================
! =========  MAP_ParameterType_C  =======
  TYPE, BIND(C) :: MAP_ParameterType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_DOUBLE) :: g 
    REAL(KIND=C_DOUBLE) :: depth 
    REAL(KIND=C_DOUBLE) :: rho_sea 
    REAL(KIND=C_DOUBLE) :: dt 
  END TYPE MAP_ParameterType_C
  TYPE, PUBLIC :: MAP_ParameterType
    TYPE( MAP_ParameterType_C ) :: C_obj
    REAL(DbKi)  :: g      ! gravitational constant [[kg/m^2]]
    REAL(DbKi)  :: depth      ! distance to seabed [[m]]
    REAL(DbKi)  :: rho_sea      ! density of seawater [[m]]
    REAL(DbKi)  :: dt      ! time step coupling interval [[sec]]
  END TYPE MAP_ParameterType
! =======================
! =========  MAP_InputType_C  =======
  TYPE, BIND(C) :: MAP_InputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
  END TYPE MAP_InputType_C
  TYPE, PUBLIC :: MAP_InputType
    TYPE( MAP_InputType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! fairlead x displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! fairlead y displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! fairlead z displacement [[m]]
    TYPE(MeshType)  :: PtFairDisplacement      ! position of each fairlead in X,Y,Z [[m]]
  END TYPE MAP_InputType
! =======================
! =========  MAP_OutputType_C  =======
  TYPE, BIND(C) :: MAP_OutputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    TYPE(C_ptr) :: Fx = C_NULL_PTR 
    INTEGER(C_int) :: Fx_Len = 0 
    TYPE(C_ptr) :: Fy = C_NULL_PTR 
    INTEGER(C_int) :: Fy_Len = 0 
    TYPE(C_ptr) :: Fz = C_NULL_PTR 
    INTEGER(C_int) :: Fz_Len = 0 
    TYPE(C_ptr) :: WriteOutput = C_NULL_PTR 
    INTEGER(C_int) :: WriteOutput_Len = 0 
    TYPE(C_ptr) :: wrtOutput = C_NULL_PTR 
    INTEGER(C_int) :: wrtOutput_Len = 0 
  END TYPE MAP_OutputType_C
  TYPE, PUBLIC :: MAP_OutputType
    TYPE( MAP_OutputType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz => NULL()      ! horizontal line force at anchor [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! outpur vector []
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: wrtOutput => NULL()      ! outpur vector []
    TYPE(MeshType)  :: ptFairleadLoad      ! point mesh for forces in X,Y,Z [[N]]
  END TYPE MAP_OutputType
! =======================
CONTAINS
 SUBROUTINE MAP_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(MAP_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%gravity = SrcInitInputData%gravity
   DstInitInputData%sea_density = SrcInitInputData%sea_density
   DstInitInputData%depth = SrcInitInputData%depth
   DstInitInputData%file_name = SrcInitInputData%file_name
   DstInitInputData%summary_file_name = SrcInitInputData%summary_file_name
   DstInitInputData%library_input_str = SrcInitInputData%library_input_str
   DstInitInputData%node_input_str = SrcInitInputData%node_input_str
   DstInitInputData%line_input_str = SrcInitInputData%line_input_str
   DstInitInputData%option_input_str = SrcInitInputData%option_input_str
 END SUBROUTINE MAP_CopyInitInput

 SUBROUTINE MAP_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MAP_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyInitInput

 SUBROUTINE MAP_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! gravity
  Db_BufSz   = Db_BufSz   + 1  ! sea_density
  Db_BufSz   = Db_BufSz   + 1  ! depth
!  missing buffer for file_name
!  missing buffer for summary_file_name
!  missing buffer for library_input_str
!  missing buffer for node_input_str
!  missing buffer for line_input_str
!  missing buffer for option_input_str
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%gravity )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%sea_density )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%depth )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackInitInput

 SUBROUTINE MAP_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%gravity = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%sea_density = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%depth = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitInput

 SUBROUTINE MAP_C2Fary_CopyInitInput( InitInputData, ErrStat, ErrMsg )
    TYPE(MAP_InitInputType), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2Fary_CopyInitInput

 SUBROUTINE MAP_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(MAP_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitOutputData%progName = SrcInitOutputData%progName
   DstInitOutputData%version = SrcInitOutputData%version
   DstInitOutputData%compilingData = SrcInitOutputData%compilingData
IF (ALLOCATED(SrcInitOutputData%writeOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputHdr.', ErrStat, ErrMsg,'MAP_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%writeOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputUnt.', ErrStat, ErrMsg,'MAP_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE MAP_CopyInitOutput

 SUBROUTINE MAP_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MAP_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%writeOutputHdr)) THEN
   DEALLOCATE(InitOutputData%writeOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%writeOutputUnt)) THEN
   DEALLOCATE(InitOutputData%writeOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyInitOutput

 SUBROUTINE MAP_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for progName
!  missing buffer for version
!  missing buffer for compilingData
!  missing buffer for writeOutputHdr
!  missing buffer for writeOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE MAP_PackInitOutput

 SUBROUTINE MAP_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitOutput

 SUBROUTINE MAP_C2Fary_CopyInitOutput( InitOutputData, ErrStat, ErrMsg )
    TYPE(MAP_InitOutputType), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2Fary_CopyInitOutput

 SUBROUTINE MAP_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%dummy = SrcContStateData%dummy
 END SUBROUTINE MAP_CopyContState

 SUBROUTINE MAP_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyContState

 SUBROUTINE MAP_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackContState

 SUBROUTINE MAP_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackContState

 SUBROUTINE MAP_C2Fary_CopyContState( ContStateData, ErrStat, ErrMsg )
    TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2Fary_CopyContState

 SUBROUTINE MAP_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(MAP_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MAP_CopyDiscState

 SUBROUTINE MAP_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MAP_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyDiscState

 SUBROUTINE MAP_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackDiscState

 SUBROUTINE MAP_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackDiscState

 SUBROUTINE MAP_C2Fary_CopyDiscState( DiscStateData, ErrStat, ErrMsg )
    TYPE(MAP_DiscreteStateType), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2Fary_CopyDiscState

 SUBROUTINE MAP_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(MAP_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcOtherStateData%H)) THEN
   i1_l = LBOUND(SrcOtherStateData%H,1)
   i1_u = UBOUND(SrcOtherStateData%H,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%H)) THEN 
      ALLOCATE(DstOtherStateData%H(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%H.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%H_Len = SIZE(DstOtherStateData%H)
      IF (DstOtherStateData%c_obj%H_Len > 0) &
         DstOtherStateData%c_obj%H = C_LOC( DstOtherStateData%H(i1_l) ) 
   END IF
   DstOtherStateData%H = SrcOtherStateData%H
ENDIF
IF (ASSOCIATED(SrcOtherStateData%V)) THEN
   i1_l = LBOUND(SrcOtherStateData%V,1)
   i1_u = UBOUND(SrcOtherStateData%V,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%V)) THEN 
      ALLOCATE(DstOtherStateData%V(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%V.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%V_Len = SIZE(DstOtherStateData%V)
      IF (DstOtherStateData%c_obj%V_Len > 0) &
         DstOtherStateData%c_obj%V = C_LOC( DstOtherStateData%V(i1_l) ) 
   END IF
   DstOtherStateData%V = SrcOtherStateData%V
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Ha)) THEN
   i1_l = LBOUND(SrcOtherStateData%Ha,1)
   i1_u = UBOUND(SrcOtherStateData%Ha,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Ha)) THEN 
      ALLOCATE(DstOtherStateData%Ha(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Ha.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Ha_Len = SIZE(DstOtherStateData%Ha)
      IF (DstOtherStateData%c_obj%Ha_Len > 0) &
         DstOtherStateData%c_obj%Ha = C_LOC( DstOtherStateData%Ha(i1_l) ) 
   END IF
   DstOtherStateData%Ha = SrcOtherStateData%Ha
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Va)) THEN
   i1_l = LBOUND(SrcOtherStateData%Va,1)
   i1_u = UBOUND(SrcOtherStateData%Va,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Va)) THEN 
      ALLOCATE(DstOtherStateData%Va(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Va.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Va_Len = SIZE(DstOtherStateData%Va)
      IF (DstOtherStateData%c_obj%Va_Len > 0) &
         DstOtherStateData%c_obj%Va = C_LOC( DstOtherStateData%Va(i1_l) ) 
   END IF
   DstOtherStateData%Va = SrcOtherStateData%Va
ENDIF
IF (ASSOCIATED(SrcOtherStateData%x)) THEN
   i1_l = LBOUND(SrcOtherStateData%x,1)
   i1_u = UBOUND(SrcOtherStateData%x,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%x)) THEN 
      ALLOCATE(DstOtherStateData%x(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%x.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%x_Len = SIZE(DstOtherStateData%x)
      IF (DstOtherStateData%c_obj%x_Len > 0) &
         DstOtherStateData%c_obj%x = C_LOC( DstOtherStateData%x(i1_l) ) 
   END IF
   DstOtherStateData%x = SrcOtherStateData%x
ENDIF
IF (ASSOCIATED(SrcOtherStateData%y)) THEN
   i1_l = LBOUND(SrcOtherStateData%y,1)
   i1_u = UBOUND(SrcOtherStateData%y,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%y)) THEN 
      ALLOCATE(DstOtherStateData%y(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%y.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%y_Len = SIZE(DstOtherStateData%y)
      IF (DstOtherStateData%c_obj%y_Len > 0) &
         DstOtherStateData%c_obj%y = C_LOC( DstOtherStateData%y(i1_l) ) 
   END IF
   DstOtherStateData%y = SrcOtherStateData%y
ENDIF
IF (ASSOCIATED(SrcOtherStateData%z)) THEN
   i1_l = LBOUND(SrcOtherStateData%z,1)
   i1_u = UBOUND(SrcOtherStateData%z,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%z)) THEN 
      ALLOCATE(DstOtherStateData%z(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%z.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%z_Len = SIZE(DstOtherStateData%z)
      IF (DstOtherStateData%c_obj%z_Len > 0) &
         DstOtherStateData%c_obj%z = C_LOC( DstOtherStateData%z(i1_l) ) 
   END IF
   DstOtherStateData%z = SrcOtherStateData%z
ENDIF
IF (ASSOCIATED(SrcOtherStateData%xa)) THEN
   i1_l = LBOUND(SrcOtherStateData%xa,1)
   i1_u = UBOUND(SrcOtherStateData%xa,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%xa)) THEN 
      ALLOCATE(DstOtherStateData%xa(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%xa.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%xa_Len = SIZE(DstOtherStateData%xa)
      IF (DstOtherStateData%c_obj%xa_Len > 0) &
         DstOtherStateData%c_obj%xa = C_LOC( DstOtherStateData%xa(i1_l) ) 
   END IF
   DstOtherStateData%xa = SrcOtherStateData%xa
ENDIF
IF (ASSOCIATED(SrcOtherStateData%ya)) THEN
   i1_l = LBOUND(SrcOtherStateData%ya,1)
   i1_u = UBOUND(SrcOtherStateData%ya,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%ya)) THEN 
      ALLOCATE(DstOtherStateData%ya(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%ya.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%ya_Len = SIZE(DstOtherStateData%ya)
      IF (DstOtherStateData%c_obj%ya_Len > 0) &
         DstOtherStateData%c_obj%ya = C_LOC( DstOtherStateData%ya(i1_l) ) 
   END IF
   DstOtherStateData%ya = SrcOtherStateData%ya
ENDIF
IF (ASSOCIATED(SrcOtherStateData%za)) THEN
   i1_l = LBOUND(SrcOtherStateData%za,1)
   i1_u = UBOUND(SrcOtherStateData%za,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%za)) THEN 
      ALLOCATE(DstOtherStateData%za(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%za.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%za_Len = SIZE(DstOtherStateData%za)
      IF (DstOtherStateData%c_obj%za_Len > 0) &
         DstOtherStateData%c_obj%za = C_LOC( DstOtherStateData%za(i1_l) ) 
   END IF
   DstOtherStateData%za = SrcOtherStateData%za
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fx_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fx_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fx_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fx_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fx_connect(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fx_connect.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fx_connect_Len = SIZE(DstOtherStateData%Fx_connect)
      IF (DstOtherStateData%c_obj%Fx_connect_Len > 0) &
         DstOtherStateData%c_obj%Fx_connect = C_LOC( DstOtherStateData%Fx_connect(i1_l) ) 
   END IF
   DstOtherStateData%Fx_connect = SrcOtherStateData%Fx_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fy_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fy_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fy_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fy_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fy_connect(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fy_connect.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fy_connect_Len = SIZE(DstOtherStateData%Fy_connect)
      IF (DstOtherStateData%c_obj%Fy_connect_Len > 0) &
         DstOtherStateData%c_obj%Fy_connect = C_LOC( DstOtherStateData%Fy_connect(i1_l) ) 
   END IF
   DstOtherStateData%Fy_connect = SrcOtherStateData%Fy_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fz_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fz_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fz_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fz_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fz_connect(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fz_connect.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fz_connect_Len = SIZE(DstOtherStateData%Fz_connect)
      IF (DstOtherStateData%c_obj%Fz_connect_Len > 0) &
         DstOtherStateData%c_obj%Fz_connect = C_LOC( DstOtherStateData%Fz_connect(i1_l) ) 
   END IF
   DstOtherStateData%Fz_connect = SrcOtherStateData%Fz_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fx_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fx_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fx_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fx_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fx_anchor(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fx_anchor.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fx_anchor_Len = SIZE(DstOtherStateData%Fx_anchor)
      IF (DstOtherStateData%c_obj%Fx_anchor_Len > 0) &
         DstOtherStateData%c_obj%Fx_anchor = C_LOC( DstOtherStateData%Fx_anchor(i1_l) ) 
   END IF
   DstOtherStateData%Fx_anchor = SrcOtherStateData%Fx_anchor
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fy_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fy_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fy_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fy_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fy_anchor(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fy_anchor.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fy_anchor_Len = SIZE(DstOtherStateData%Fy_anchor)
      IF (DstOtherStateData%c_obj%Fy_anchor_Len > 0) &
         DstOtherStateData%c_obj%Fy_anchor = C_LOC( DstOtherStateData%Fy_anchor(i1_l) ) 
   END IF
   DstOtherStateData%Fy_anchor = SrcOtherStateData%Fy_anchor
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fz_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fz_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fz_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fz_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fz_anchor(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Fz_anchor.', ErrStat, ErrMsg,'MAP_CopyOtherState')
         RETURN
      END IF
      DstOtherStateData%c_obj%Fz_anchor_Len = SIZE(DstOtherStateData%Fz_anchor)
      IF (DstOtherStateData%c_obj%Fz_anchor_Len > 0) &
         DstOtherStateData%c_obj%Fz_anchor = C_LOC( DstOtherStateData%Fz_anchor(i1_l) ) 
   END IF
   DstOtherStateData%Fz_anchor = SrcOtherStateData%Fz_anchor
ENDIF
 END SUBROUTINE MAP_CopyOtherState

 SUBROUTINE MAP_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MAP_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(OtherStateData%H)) THEN
   DEALLOCATE(OtherStateData%H)
   OtherStateData%H => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%V)) THEN
   DEALLOCATE(OtherStateData%V)
   OtherStateData%V => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Ha)) THEN
   DEALLOCATE(OtherStateData%Ha)
   OtherStateData%Ha => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Va)) THEN
   DEALLOCATE(OtherStateData%Va)
   OtherStateData%Va => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%x)) THEN
   DEALLOCATE(OtherStateData%x)
   OtherStateData%x => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%y)) THEN
   DEALLOCATE(OtherStateData%y)
   OtherStateData%y => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%z)) THEN
   DEALLOCATE(OtherStateData%z)
   OtherStateData%z => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%xa)) THEN
   DEALLOCATE(OtherStateData%xa)
   OtherStateData%xa => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%ya)) THEN
   DEALLOCATE(OtherStateData%ya)
   OtherStateData%ya => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%za)) THEN
   DEALLOCATE(OtherStateData%za)
   OtherStateData%za => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fx_connect)) THEN
   DEALLOCATE(OtherStateData%Fx_connect)
   OtherStateData%Fx_connect => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fy_connect)) THEN
   DEALLOCATE(OtherStateData%Fy_connect)
   OtherStateData%Fy_connect => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fz_connect)) THEN
   DEALLOCATE(OtherStateData%Fz_connect)
   OtherStateData%Fz_connect => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fx_anchor)) THEN
   DEALLOCATE(OtherStateData%Fx_anchor)
   OtherStateData%Fx_anchor => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fy_anchor)) THEN
   DEALLOCATE(OtherStateData%Fy_anchor)
   OtherStateData%Fy_anchor => NULL()
ENDIF
IF (ASSOCIATED(OtherStateData%Fz_anchor)) THEN
   DEALLOCATE(OtherStateData%Fz_anchor)
   OtherStateData%Fz_anchor => NULL()
ENDIF
 END SUBROUTINE MAP_DestroyOtherState

 SUBROUTINE MAP_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(InData%H) )   Db_BufSz    = Db_BufSz    + SIZE( InData%H )  ! H 
  IF ( ASSOCIATED(InData%V) )   Db_BufSz    = Db_BufSz    + SIZE( InData%V )  ! V 
  IF ( ASSOCIATED(InData%Ha) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Ha )  ! Ha 
  IF ( ASSOCIATED(InData%Va) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Va )  ! Va 
  IF ( ASSOCIATED(InData%x) )   Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  IF ( ASSOCIATED(InData%y) )   Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  IF ( ASSOCIATED(InData%z) )   Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
  IF ( ASSOCIATED(InData%xa) )   Db_BufSz    = Db_BufSz    + SIZE( InData%xa )  ! xa 
  IF ( ASSOCIATED(InData%ya) )   Db_BufSz    = Db_BufSz    + SIZE( InData%ya )  ! ya 
  IF ( ASSOCIATED(InData%za) )   Db_BufSz    = Db_BufSz    + SIZE( InData%za )  ! za 
  IF ( ASSOCIATED(InData%Fx_connect) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fx_connect )  ! Fx_connect 
  IF ( ASSOCIATED(InData%Fy_connect) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fy_connect )  ! Fy_connect 
  IF ( ASSOCIATED(InData%Fz_connect) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fz_connect )  ! Fz_connect 
  IF ( ASSOCIATED(InData%Fx_anchor) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fx_anchor )  ! Fx_anchor 
  IF ( ASSOCIATED(InData%Fy_anchor) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fy_anchor )  ! Fy_anchor 
  IF ( ASSOCIATED(InData%Fz_anchor) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fz_anchor )  ! Fz_anchor 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%H) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%H))-1 ) =  PACK(InData%H ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%H)
  ENDIF
  IF ( ASSOCIATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ASSOCIATED(InData%Ha) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Ha))-1 ) =  PACK(InData%Ha ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Ha)
  ENDIF
  IF ( ASSOCIATED(InData%Va) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Va))-1 ) =  PACK(InData%Va ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Va)
  ENDIF
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
  IF ( ASSOCIATED(InData%xa) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%xa))-1 ) =  PACK(InData%xa ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%xa)
  ENDIF
  IF ( ASSOCIATED(InData%ya) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%ya))-1 ) =  PACK(InData%ya ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%ya)
  ENDIF
  IF ( ASSOCIATED(InData%za) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%za))-1 ) =  PACK(InData%za ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%za)
  ENDIF
  IF ( ASSOCIATED(InData%Fx_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx_connect))-1 ) =  PACK(InData%Fx_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fy_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy_connect))-1 ) =  PACK(InData%Fy_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fz_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz_connect))-1 ) =  PACK(InData%Fz_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fx_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx_anchor))-1 ) =  PACK(InData%Fx_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx_anchor)
  ENDIF
  IF ( ASSOCIATED(InData%Fy_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy_anchor))-1 ) =  PACK(InData%Fy_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy_anchor)
  ENDIF
  IF ( ASSOCIATED(InData%Fz_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz_anchor))-1 ) =  PACK(InData%Fz_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz_anchor)
  ENDIF
 END SUBROUTINE MAP_PackOtherState

 SUBROUTINE MAP_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%H) ) THEN
  ALLOCATE(mask1(SIZE(OutData%H,1)))
  mask1 = .TRUE.
    OutData%H = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%H))-1 ),mask1,REAL(OutData%H,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%H)
  ENDIF
  IF ( ASSOCIATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1)))
  mask1 = .TRUE.
    OutData%V = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,REAL(OutData%V,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ASSOCIATED(OutData%Ha) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Ha,1)))
  mask1 = .TRUE.
    OutData%Ha = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Ha))-1 ),mask1,REAL(OutData%Ha,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Ha)
  ENDIF
  IF ( ASSOCIATED(OutData%Va) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Va,1)))
  mask1 = .TRUE.
    OutData%Va = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Va))-1 ),mask1,REAL(OutData%Va,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Va)
  ENDIF
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1)))
  mask1 = .TRUE.
    OutData%x = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,REAL(OutData%x,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1)))
  mask1 = .TRUE.
    OutData%y = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,REAL(OutData%y,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1)))
  mask1 = .TRUE.
    OutData%z = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,REAL(OutData%z,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
  IF ( ASSOCIATED(OutData%xa) ) THEN
  ALLOCATE(mask1(SIZE(OutData%xa,1)))
  mask1 = .TRUE.
    OutData%xa = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%xa))-1 ),mask1,REAL(OutData%xa,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%xa)
  ENDIF
  IF ( ASSOCIATED(OutData%ya) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ya,1)))
  mask1 = .TRUE.
    OutData%ya = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%ya))-1 ),mask1,REAL(OutData%ya,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%ya)
  ENDIF
  IF ( ASSOCIATED(OutData%za) ) THEN
  ALLOCATE(mask1(SIZE(OutData%za,1)))
  mask1 = .TRUE.
    OutData%za = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%za))-1 ),mask1,REAL(OutData%za,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%za)
  ENDIF
  IF ( ASSOCIATED(OutData%Fx_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx_connect,1)))
  mask1 = .TRUE.
    OutData%Fx_connect = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx_connect))-1 ),mask1,REAL(OutData%Fx_connect,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy_connect,1)))
  mask1 = .TRUE.
    OutData%Fy_connect = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy_connect))-1 ),mask1,REAL(OutData%Fy_connect,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz_connect,1)))
  mask1 = .TRUE.
    OutData%Fz_connect = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz_connect))-1 ),mask1,REAL(OutData%Fz_connect,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fx_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx_anchor,1)))
  mask1 = .TRUE.
    OutData%Fx_anchor = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx_anchor))-1 ),mask1,REAL(OutData%Fx_anchor,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx_anchor)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy_anchor,1)))
  mask1 = .TRUE.
    OutData%Fy_anchor = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy_anchor))-1 ),mask1,REAL(OutData%Fy_anchor,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy_anchor)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz_anchor,1)))
  mask1 = .TRUE.
    OutData%Fz_anchor = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz_anchor))-1 ),mask1,REAL(OutData%Fz_anchor,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz_anchor)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOtherState

 SUBROUTINE MAP_C2Fary_CopyOtherState( OtherStateData, ErrStat, ErrMsg )
    TYPE(MAP_OtherStateType), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%H ) ) THEN
       NULLIFY( OtherStateData%H )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%H, OtherStateData%H, (/OtherStateData%C_obj%H_Len/))
    END IF

    ! -- V OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%V ) ) THEN
       NULLIFY( OtherStateData%V )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%V, OtherStateData%V, (/OtherStateData%C_obj%V_Len/))
    END IF

    ! -- Ha OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Ha ) ) THEN
       NULLIFY( OtherStateData%Ha )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Ha, OtherStateData%Ha, (/OtherStateData%C_obj%Ha_Len/))
    END IF

    ! -- Va OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Va ) ) THEN
       NULLIFY( OtherStateData%Va )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Va, OtherStateData%Va, (/OtherStateData%C_obj%Va_Len/))
    END IF

    ! -- x OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%x ) ) THEN
       NULLIFY( OtherStateData%x )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%x, OtherStateData%x, (/OtherStateData%C_obj%x_Len/))
    END IF

    ! -- y OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%y ) ) THEN
       NULLIFY( OtherStateData%y )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%y, OtherStateData%y, (/OtherStateData%C_obj%y_Len/))
    END IF

    ! -- z OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%z ) ) THEN
       NULLIFY( OtherStateData%z )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%z, OtherStateData%z, (/OtherStateData%C_obj%z_Len/))
    END IF

    ! -- xa OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%xa ) ) THEN
       NULLIFY( OtherStateData%xa )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%xa, OtherStateData%xa, (/OtherStateData%C_obj%xa_Len/))
    END IF

    ! -- ya OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%ya ) ) THEN
       NULLIFY( OtherStateData%ya )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%ya, OtherStateData%ya, (/OtherStateData%C_obj%ya_Len/))
    END IF

    ! -- za OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%za ) ) THEN
       NULLIFY( OtherStateData%za )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%za, OtherStateData%za, (/OtherStateData%C_obj%za_Len/))
    END IF

    ! -- Fx_connect OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fx_connect ) ) THEN
       NULLIFY( OtherStateData%Fx_connect )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fx_connect, OtherStateData%Fx_connect, (/OtherStateData%C_obj%Fx_connect_Len/))
    END IF

    ! -- Fy_connect OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fy_connect ) ) THEN
       NULLIFY( OtherStateData%Fy_connect )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fy_connect, OtherStateData%Fy_connect, (/OtherStateData%C_obj%Fy_connect_Len/))
    END IF

    ! -- Fz_connect OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fz_connect ) ) THEN
       NULLIFY( OtherStateData%Fz_connect )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fz_connect, OtherStateData%Fz_connect, (/OtherStateData%C_obj%Fz_connect_Len/))
    END IF

    ! -- Fx_anchor OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fx_anchor ) ) THEN
       NULLIFY( OtherStateData%Fx_anchor )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fx_anchor, OtherStateData%Fx_anchor, (/OtherStateData%C_obj%Fx_anchor_Len/))
    END IF

    ! -- Fy_anchor OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fy_anchor ) ) THEN
       NULLIFY( OtherStateData%Fy_anchor )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fy_anchor, OtherStateData%Fy_anchor, (/OtherStateData%C_obj%Fy_anchor_Len/))
    END IF

    ! -- Fz_anchor OtherState Data fields
    IF ( .NOT. C_ASSOCIATED( OtherStateData%C_obj%Fz_anchor ) ) THEN
       NULLIFY( OtherStateData%Fz_anchor )
    ELSE
       CALL C_F_POINTER(OtherStateData%C_obj%Fz_anchor, OtherStateData%Fz_anchor, (/OtherStateData%C_obj%Fz_anchor_Len/))
    END IF
 END SUBROUTINE MAP_C2Fary_CopyOtherState

 SUBROUTINE MAP_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcConstrStateData%H)) THEN
   i1_l = LBOUND(SrcConstrStateData%H,1)
   i1_u = UBOUND(SrcConstrStateData%H,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%H)) THEN 
      ALLOCATE(DstConstrStateData%H(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%H.', ErrStat, ErrMsg,'MAP_CopyConstrState')
         RETURN
      END IF
      DstConstrStateData%c_obj%H_Len = SIZE(DstConstrStateData%H)
      IF (DstConstrStateData%c_obj%H_Len > 0) &
         DstConstrStateData%c_obj%H = C_LOC( DstConstrStateData%H(i1_l) ) 
   END IF
   DstConstrStateData%H = SrcConstrStateData%H
ENDIF
IF (ASSOCIATED(SrcConstrStateData%V)) THEN
   i1_l = LBOUND(SrcConstrStateData%V,1)
   i1_u = UBOUND(SrcConstrStateData%V,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%V)) THEN 
      ALLOCATE(DstConstrStateData%V(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%V.', ErrStat, ErrMsg,'MAP_CopyConstrState')
         RETURN
      END IF
      DstConstrStateData%c_obj%V_Len = SIZE(DstConstrStateData%V)
      IF (DstConstrStateData%c_obj%V_Len > 0) &
         DstConstrStateData%c_obj%V = C_LOC( DstConstrStateData%V(i1_l) ) 
   END IF
   DstConstrStateData%V = SrcConstrStateData%V
ENDIF
IF (ASSOCIATED(SrcConstrStateData%x)) THEN
   i1_l = LBOUND(SrcConstrStateData%x,1)
   i1_u = UBOUND(SrcConstrStateData%x,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%x)) THEN 
      ALLOCATE(DstConstrStateData%x(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%x.', ErrStat, ErrMsg,'MAP_CopyConstrState')
         RETURN
      END IF
      DstConstrStateData%c_obj%x_Len = SIZE(DstConstrStateData%x)
      IF (DstConstrStateData%c_obj%x_Len > 0) &
         DstConstrStateData%c_obj%x = C_LOC( DstConstrStateData%x(i1_l) ) 
   END IF
   DstConstrStateData%x = SrcConstrStateData%x
ENDIF
IF (ASSOCIATED(SrcConstrStateData%y)) THEN
   i1_l = LBOUND(SrcConstrStateData%y,1)
   i1_u = UBOUND(SrcConstrStateData%y,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%y)) THEN 
      ALLOCATE(DstConstrStateData%y(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%y.', ErrStat, ErrMsg,'MAP_CopyConstrState')
         RETURN
      END IF
      DstConstrStateData%c_obj%y_Len = SIZE(DstConstrStateData%y)
      IF (DstConstrStateData%c_obj%y_Len > 0) &
         DstConstrStateData%c_obj%y = C_LOC( DstConstrStateData%y(i1_l) ) 
   END IF
   DstConstrStateData%y = SrcConstrStateData%y
ENDIF
IF (ASSOCIATED(SrcConstrStateData%z)) THEN
   i1_l = LBOUND(SrcConstrStateData%z,1)
   i1_u = UBOUND(SrcConstrStateData%z,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%z)) THEN 
      ALLOCATE(DstConstrStateData%z(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%z.', ErrStat, ErrMsg,'MAP_CopyConstrState')
         RETURN
      END IF
      DstConstrStateData%c_obj%z_Len = SIZE(DstConstrStateData%z)
      IF (DstConstrStateData%c_obj%z_Len > 0) &
         DstConstrStateData%c_obj%z = C_LOC( DstConstrStateData%z(i1_l) ) 
   END IF
   DstConstrStateData%z = SrcConstrStateData%z
ENDIF
 END SUBROUTINE MAP_CopyConstrState

 SUBROUTINE MAP_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(ConstrStateData%H)) THEN
   DEALLOCATE(ConstrStateData%H)
   ConstrStateData%H => NULL()
ENDIF
IF (ASSOCIATED(ConstrStateData%V)) THEN
   DEALLOCATE(ConstrStateData%V)
   ConstrStateData%V => NULL()
ENDIF
IF (ASSOCIATED(ConstrStateData%x)) THEN
   DEALLOCATE(ConstrStateData%x)
   ConstrStateData%x => NULL()
ENDIF
IF (ASSOCIATED(ConstrStateData%y)) THEN
   DEALLOCATE(ConstrStateData%y)
   ConstrStateData%y => NULL()
ENDIF
IF (ASSOCIATED(ConstrStateData%z)) THEN
   DEALLOCATE(ConstrStateData%z)
   ConstrStateData%z => NULL()
ENDIF
 END SUBROUTINE MAP_DestroyConstrState

 SUBROUTINE MAP_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(InData%H) )   Db_BufSz    = Db_BufSz    + SIZE( InData%H )  ! H 
  IF ( ASSOCIATED(InData%V) )   Db_BufSz    = Db_BufSz    + SIZE( InData%V )  ! V 
  IF ( ASSOCIATED(InData%x) )   Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  IF ( ASSOCIATED(InData%y) )   Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  IF ( ASSOCIATED(InData%z) )   Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%H) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%H))-1 ) =  PACK(InData%H ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%H)
  ENDIF
  IF ( ASSOCIATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
 END SUBROUTINE MAP_PackConstrState

 SUBROUTINE MAP_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%H) ) THEN
  ALLOCATE(mask1(SIZE(OutData%H,1)))
  mask1 = .TRUE.
    OutData%H = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%H))-1 ),mask1,REAL(OutData%H,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%H)
  ENDIF
  IF ( ASSOCIATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1)))
  mask1 = .TRUE.
    OutData%V = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,REAL(OutData%V,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1)))
  mask1 = .TRUE.
    OutData%x = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,REAL(OutData%x,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1)))
  mask1 = .TRUE.
    OutData%y = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,REAL(OutData%y,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1)))
  mask1 = .TRUE.
    OutData%z = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,REAL(OutData%z,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackConstrState

 SUBROUTINE MAP_C2Fary_CopyConstrState( ConstrStateData, ErrStat, ErrMsg )
    TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H ConstrState Data fields
    IF ( .NOT. C_ASSOCIATED( ConstrStateData%C_obj%H ) ) THEN
       NULLIFY( ConstrStateData%H )
    ELSE
       CALL C_F_POINTER(ConstrStateData%C_obj%H, ConstrStateData%H, (/ConstrStateData%C_obj%H_Len/))
    END IF

    ! -- V ConstrState Data fields
    IF ( .NOT. C_ASSOCIATED( ConstrStateData%C_obj%V ) ) THEN
       NULLIFY( ConstrStateData%V )
    ELSE
       CALL C_F_POINTER(ConstrStateData%C_obj%V, ConstrStateData%V, (/ConstrStateData%C_obj%V_Len/))
    END IF

    ! -- x ConstrState Data fields
    IF ( .NOT. C_ASSOCIATED( ConstrStateData%C_obj%x ) ) THEN
       NULLIFY( ConstrStateData%x )
    ELSE
       CALL C_F_POINTER(ConstrStateData%C_obj%x, ConstrStateData%x, (/ConstrStateData%C_obj%x_Len/))
    END IF

    ! -- y ConstrState Data fields
    IF ( .NOT. C_ASSOCIATED( ConstrStateData%C_obj%y ) ) THEN
       NULLIFY( ConstrStateData%y )
    ELSE
       CALL C_F_POINTER(ConstrStateData%C_obj%y, ConstrStateData%y, (/ConstrStateData%C_obj%y_Len/))
    END IF

    ! -- z ConstrState Data fields
    IF ( .NOT. C_ASSOCIATED( ConstrStateData%C_obj%z ) ) THEN
       NULLIFY( ConstrStateData%z )
    ELSE
       CALL C_F_POINTER(ConstrStateData%C_obj%z, ConstrStateData%z, (/ConstrStateData%C_obj%z_Len/))
    END IF
 END SUBROUTINE MAP_C2Fary_CopyConstrState

 SUBROUTINE MAP_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(MAP_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%g = SrcParamData%g
   DstParamData%depth = SrcParamData%depth
   DstParamData%rho_sea = SrcParamData%rho_sea
   DstParamData%dt = SrcParamData%dt
 END SUBROUTINE MAP_CopyParam

 SUBROUTINE MAP_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MAP_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyParam

 SUBROUTINE MAP_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! g
  Db_BufSz   = Db_BufSz   + 1  ! depth
  Db_BufSz   = Db_BufSz   + 1  ! rho_sea
  Db_BufSz   = Db_BufSz   + 1  ! dt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%g )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%depth )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%rho_sea )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dt )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackParam

 SUBROUTINE MAP_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%depth = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%rho_sea = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%dt = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackParam

 SUBROUTINE MAP_C2Fary_CopyParam( ParamData, ErrStat, ErrMsg )
    TYPE(MAP_ParameterType), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2Fary_CopyParam

 SUBROUTINE MAP_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(MAP_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcInputData%x)) THEN
   i1_l = LBOUND(SrcInputData%x,1)
   i1_u = UBOUND(SrcInputData%x,1)
   IF (.NOT. ASSOCIATED(DstInputData%x)) THEN 
      ALLOCATE(DstInputData%x(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%x.', ErrStat, ErrMsg,'MAP_CopyInput')
         RETURN
      END IF
      DstInputData%c_obj%x_Len = SIZE(DstInputData%x)
      IF (DstInputData%c_obj%x_Len > 0) &
         DstInputData%c_obj%x = C_LOC( DstInputData%x(i1_l) ) 
   END IF
   DstInputData%x = SrcInputData%x
ENDIF
IF (ASSOCIATED(SrcInputData%y)) THEN
   i1_l = LBOUND(SrcInputData%y,1)
   i1_u = UBOUND(SrcInputData%y,1)
   IF (.NOT. ASSOCIATED(DstInputData%y)) THEN 
      ALLOCATE(DstInputData%y(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%y.', ErrStat, ErrMsg,'MAP_CopyInput')
         RETURN
      END IF
      DstInputData%c_obj%y_Len = SIZE(DstInputData%y)
      IF (DstInputData%c_obj%y_Len > 0) &
         DstInputData%c_obj%y = C_LOC( DstInputData%y(i1_l) ) 
   END IF
   DstInputData%y = SrcInputData%y
ENDIF
IF (ASSOCIATED(SrcInputData%z)) THEN
   i1_l = LBOUND(SrcInputData%z,1)
   i1_u = UBOUND(SrcInputData%z,1)
   IF (.NOT. ASSOCIATED(DstInputData%z)) THEN 
      ALLOCATE(DstInputData%z(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%z.', ErrStat, ErrMsg,'MAP_CopyInput')
         RETURN
      END IF
      DstInputData%c_obj%z_Len = SIZE(DstInputData%z)
      IF (DstInputData%c_obj%z_Len > 0) &
         DstInputData%c_obj%z = C_LOC( DstInputData%z(i1_l) ) 
   END IF
   DstInputData%z = SrcInputData%z
ENDIF
  DstInputData%C_obj = SrcInputData%C_obj
     CALL MeshCopy( SrcInputData%PtFairDisplacement, DstInputData%PtFairDisplacement, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_CopyInput:PtFairDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE MAP_CopyInput

 SUBROUTINE MAP_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MAP_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(InputData%x)) THEN
   DEALLOCATE(InputData%x)
   InputData%x => NULL()
ENDIF
IF (ASSOCIATED(InputData%y)) THEN
   DEALLOCATE(InputData%y)
   InputData%y => NULL()
ENDIF
IF (ASSOCIATED(InputData%z)) THEN
   DEALLOCATE(InputData%z)
   InputData%z => NULL()
ENDIF
  CALL MeshDestroy( InputData%PtFairDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyInput

 SUBROUTINE MAP_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(InData%x) )   Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  IF ( ASSOCIATED(InData%y) )   Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  IF ( ASSOCIATED(InData%z) )   Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairDisplacement_Buf  ) ! PtFairDisplacement
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairDisplacement_Buf  ) ! PtFairDisplacement
  IF(ALLOCATED(Int_PtFairDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairDisplacement_Buf ) ! PtFairDisplacement
  IF(ALLOCATED(Re_PtFairDisplacement_Buf))  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairDisplacement_Buf))  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) DEALLOCATE(Int_PtFairDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
  CALL MeshPack( InData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairDisplacement_Buf)-1 ) = Re_PtFairDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairDisplacement_Buf)-1 ) = Db_PtFairDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairDisplacement_Buf)-1 ) = Int_PtFairDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairDisplacement_Buf) )  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairDisplacement_Buf) )  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairDisplacement_Buf) ) DEALLOCATE(Int_PtFairDisplacement_Buf)
 END SUBROUTINE MAP_PackInput

 SUBROUTINE MAP_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1)))
  mask1 = .TRUE.
    OutData%x = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,REAL(OutData%x,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1)))
  mask1 = .TRUE.
    OutData%y = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,REAL(OutData%y,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1)))
  mask1 = .TRUE.
    OutData%z = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,REAL(OutData%z,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) THEN
    Re_PtFairDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) THEN
    Db_PtFairDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) THEN
    Int_PtFairDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairDisplacement 
  IF( ALLOCATED(Re_PtFairDisplacement_Buf) )  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairDisplacement_Buf) )  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairDisplacement_Buf) ) DEALLOCATE(Int_PtFairDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInput

 SUBROUTINE MAP_C2Fary_CopyInput( InputData, ErrStat, ErrMsg )
    TYPE(MAP_InputType), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- x Input Data fields
    IF ( .NOT. C_ASSOCIATED( InputData%C_obj%x ) ) THEN
       NULLIFY( InputData%x )
    ELSE
       CALL C_F_POINTER(InputData%C_obj%x, InputData%x, (/InputData%C_obj%x_Len/))
    END IF

    ! -- y Input Data fields
    IF ( .NOT. C_ASSOCIATED( InputData%C_obj%y ) ) THEN
       NULLIFY( InputData%y )
    ELSE
       CALL C_F_POINTER(InputData%C_obj%y, InputData%y, (/InputData%C_obj%y_Len/))
    END IF

    ! -- z Input Data fields
    IF ( .NOT. C_ASSOCIATED( InputData%C_obj%z ) ) THEN
       NULLIFY( InputData%z )
    ELSE
       CALL C_F_POINTER(InputData%C_obj%z, InputData%z, (/InputData%C_obj%z_Len/))
    END IF
 END SUBROUTINE MAP_C2Fary_CopyInput

 SUBROUTINE MAP_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(MAP_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcOutputData%Fx)) THEN
   i1_l = LBOUND(SrcOutputData%Fx,1)
   i1_u = UBOUND(SrcOutputData%Fx,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fx)) THEN 
      ALLOCATE(DstOutputData%Fx(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Fx.', ErrStat, ErrMsg,'MAP_CopyOutput')
         RETURN
      END IF
      DstOutputData%c_obj%Fx_Len = SIZE(DstOutputData%Fx)
      IF (DstOutputData%c_obj%Fx_Len > 0) &
         DstOutputData%c_obj%Fx = C_LOC( DstOutputData%Fx(i1_l) ) 
   END IF
   DstOutputData%Fx = SrcOutputData%Fx
ENDIF
IF (ASSOCIATED(SrcOutputData%Fy)) THEN
   i1_l = LBOUND(SrcOutputData%Fy,1)
   i1_u = UBOUND(SrcOutputData%Fy,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fy)) THEN 
      ALLOCATE(DstOutputData%Fy(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Fy.', ErrStat, ErrMsg,'MAP_CopyOutput')
         RETURN
      END IF
      DstOutputData%c_obj%Fy_Len = SIZE(DstOutputData%Fy)
      IF (DstOutputData%c_obj%Fy_Len > 0) &
         DstOutputData%c_obj%Fy = C_LOC( DstOutputData%Fy(i1_l) ) 
   END IF
   DstOutputData%Fy = SrcOutputData%Fy
ENDIF
IF (ASSOCIATED(SrcOutputData%Fz)) THEN
   i1_l = LBOUND(SrcOutputData%Fz,1)
   i1_u = UBOUND(SrcOutputData%Fz,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fz)) THEN 
      ALLOCATE(DstOutputData%Fz(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Fz.', ErrStat, ErrMsg,'MAP_CopyOutput')
         RETURN
      END IF
      DstOutputData%c_obj%Fz_Len = SIZE(DstOutputData%Fz)
      IF (DstOutputData%c_obj%Fz_Len > 0) &
         DstOutputData%c_obj%Fz = C_LOC( DstOutputData%Fz(i1_l) ) 
   END IF
   DstOutputData%Fz = SrcOutputData%Fz
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'MAP_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
IF (ASSOCIATED(SrcOutputData%wrtOutput)) THEN
   i1_l = LBOUND(SrcOutputData%wrtOutput,1)
   i1_u = UBOUND(SrcOutputData%wrtOutput,1)
   IF (.NOT. ASSOCIATED(DstOutputData%wrtOutput)) THEN 
      ALLOCATE(DstOutputData%wrtOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%wrtOutput.', ErrStat, ErrMsg,'MAP_CopyOutput')
         RETURN
      END IF
      DstOutputData%c_obj%wrtOutput_Len = SIZE(DstOutputData%wrtOutput)
      IF (DstOutputData%c_obj%wrtOutput_Len > 0) &
         DstOutputData%c_obj%wrtOutput = C_LOC( DstOutputData%wrtOutput(i1_l) ) 
   END IF
   DstOutputData%wrtOutput = SrcOutputData%wrtOutput
ENDIF
  DstOutputData%C_obj = SrcOutputData%C_obj
     CALL MeshCopy( SrcOutputData%ptFairleadLoad, DstOutputData%ptFairleadLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_CopyOutput:ptFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE MAP_CopyOutput

 SUBROUTINE MAP_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MAP_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(OutputData%Fx)) THEN
   DEALLOCATE(OutputData%Fx)
   OutputData%Fx => NULL()
ENDIF
IF (ASSOCIATED(OutputData%Fy)) THEN
   DEALLOCATE(OutputData%Fy)
   OutputData%Fy => NULL()
ENDIF
IF (ASSOCIATED(OutputData%Fz)) THEN
   DEALLOCATE(OutputData%Fz)
   OutputData%Fz => NULL()
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
IF (ASSOCIATED(OutputData%wrtOutput)) THEN
   DEALLOCATE(OutputData%wrtOutput)
   OutputData%wrtOutput => NULL()
ENDIF
  CALL MeshDestroy( OutputData%ptFairleadLoad, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyOutput

 SUBROUTINE MAP_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_ptFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ptFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ptFairleadLoad_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(InData%Fx) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fx )  ! Fx 
  IF ( ASSOCIATED(InData%Fy) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fy )  ! Fy 
  IF ( ASSOCIATED(InData%Fz) )   Db_BufSz    = Db_BufSz    + SIZE( InData%Fz )  ! Fz 
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( ASSOCIATED(InData%wrtOutput) )   Db_BufSz    = Db_BufSz    + SIZE( InData%wrtOutput )  ! wrtOutput 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ptFairleadLoad_Buf  ) ! ptFairleadLoad
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ptFairleadLoad_Buf  ) ! ptFairleadLoad
  IF(ALLOCATED(Int_ptFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ptFairleadLoad_Buf ) ! ptFairleadLoad
  IF(ALLOCATED(Re_ptFairleadLoad_Buf))  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF(ALLOCATED(Db_ptFairleadLoad_Buf))  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) DEALLOCATE(Int_ptFairleadLoad_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%Fx) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx))-1 ) =  PACK(InData%Fx ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx)
  ENDIF
  IF ( ASSOCIATED(InData%Fy) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy))-1 ) =  PACK(InData%Fy ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy)
  ENDIF
  IF ( ASSOCIATED(InData%Fz) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz))-1 ) =  PACK(InData%Fz ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz)
  ENDIF
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
  IF ( ASSOCIATED(InData%wrtOutput) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%wrtOutput))-1 ) =  PACK(InData%wrtOutput ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%wrtOutput)
  ENDIF
  CALL MeshPack( InData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ptFairleadLoad_Buf)-1 ) = Re_ptFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ptFairleadLoad_Buf)-1 ) = Db_ptFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ptFairleadLoad_Buf)-1 ) = Int_ptFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ptFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_ptFairleadLoad_Buf) )  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF( ALLOCATED(Db_ptFairleadLoad_Buf) )  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF( ALLOCATED(Int_ptFairleadLoad_Buf) ) DEALLOCATE(Int_ptFairleadLoad_Buf)
 END SUBROUTINE MAP_PackOutput

 SUBROUTINE MAP_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_ptFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ptFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ptFairleadLoad_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%Fx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx,1)))
  mask1 = .TRUE.
    OutData%Fx = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx))-1 ),mask1,REAL(OutData%Fx,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy,1)))
  mask1 = .TRUE.
    OutData%Fy = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy))-1 ),mask1,REAL(OutData%Fy,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz,1)))
  mask1 = .TRUE.
    OutData%Fz = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz))-1 ),mask1,REAL(OutData%Fz,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz)
  ENDIF
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  IF ( ASSOCIATED(OutData%wrtOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%wrtOutput,1)))
  mask1 = .TRUE.
    OutData%wrtOutput = REAL( UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%wrtOutput))-1 ),mask1,REAL(OutData%wrtOutput,DbKi)), C_DOUBLE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%wrtOutput)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) THEN
    Re_ptFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ptFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) THEN
    Db_ptFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ptFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) THEN
    Int_ptFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ptFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ptFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg ) ! ptFairleadLoad 
  IF( ALLOCATED(Re_ptFairleadLoad_Buf) )  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF( ALLOCATED(Db_ptFairleadLoad_Buf) )  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF( ALLOCATED(Int_ptFairleadLoad_Buf) ) DEALLOCATE(Int_ptFairleadLoad_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOutput

 SUBROUTINE MAP_C2Fary_CopyOutput( OutputData, ErrStat, ErrMsg )
    TYPE(MAP_OutputType), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- Fx Output Data fields
    IF ( .NOT. C_ASSOCIATED( OutputData%C_obj%Fx ) ) THEN
       NULLIFY( OutputData%Fx )
    ELSE
       CALL C_F_POINTER(OutputData%C_obj%Fx, OutputData%Fx, (/OutputData%C_obj%Fx_Len/))
    END IF

    ! -- Fy Output Data fields
    IF ( .NOT. C_ASSOCIATED( OutputData%C_obj%Fy ) ) THEN
       NULLIFY( OutputData%Fy )
    ELSE
       CALL C_F_POINTER(OutputData%C_obj%Fy, OutputData%Fy, (/OutputData%C_obj%Fy_Len/))
    END IF

    ! -- Fz Output Data fields
    IF ( .NOT. C_ASSOCIATED( OutputData%C_obj%Fz ) ) THEN
       NULLIFY( OutputData%Fz )
    ELSE
       CALL C_F_POINTER(OutputData%C_obj%Fz, OutputData%Fz, (/OutputData%C_obj%Fz_Len/))
    END IF

    ! -- wrtOutput Output Data fields
    IF ( .NOT. C_ASSOCIATED( OutputData%C_obj%wrtOutput ) ) THEN
       NULLIFY( OutputData%wrtOutput )
    ELSE
       CALL C_F_POINTER(OutputData%C_obj%wrtOutput, OutputData%wrtOutput, (/OutputData%C_obj%wrtOutput_Len/))
    END IF
 END SUBROUTINE MAP_C2Fary_CopyOutput


 SUBROUTINE MAP_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  u_out%x = u(1)%x
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  u_out%y = u(1)%y
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  u_out%z = u(1)%z
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairDisplacement, u_out%PtFairDisplacement, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Input_ExtrapInterp:%PtFairDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = -(u(1)%x - u(2)%x)/t(2)
  u_out%x = u(1)%x + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = -(u(1)%y - u(2)%y)/t(2)
  u_out%y = u(1)%y + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = -(u(1)%z - u(2)%z)/t(2)
  u_out%z = u(1)%z + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairDisplacement, u(2)%PtFairDisplacement, tin, u_out%PtFairDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Input_ExtrapInterp:%PtFairDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = (t(3)**2*(u(1)%x - u(2)%x) + t(2)**2*(-u(1)%x + u(3)%x))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%x + t(3)*u(2)%x - t(2)*u(3)%x ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%x = u(1)%x + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = (t(3)**2*(u(1)%y - u(2)%y) + t(2)**2*(-u(1)%y + u(3)%y))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%y + t(3)*u(2)%y - t(2)*u(3)%y ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%y = u(1)%y + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = (t(3)**2*(u(1)%z - u(2)%z) + t(2)**2*(-u(1)%z + u(3)%z))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%z + t(3)*u(2)%z - t(2)*u(3)%z ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%z = u(1)%z + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairDisplacement, u(2)%PtFairDisplacement, u(3)%PtFairDisplacement, tin, u_out%PtFairDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Input_ExtrapInterp:%PtFairDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Input_ExtrapInterp


 SUBROUTINE MAP_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  u_out%Fx = u(1)%Fx
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  u_out%Fy = u(1)%Fy
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  u_out%Fz = u(1)%Fz
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  u_out%wrtOutput = u(1)%wrtOutput
END IF ! check if allocated
  CALL MeshCopy(u(1)%ptFairleadLoad, u_out%ptFairleadLoad, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Output_ExtrapInterp:%ptFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = -(u(1)%Fx - u(2)%Fx)/t(2)
  u_out%Fx = u(1)%Fx + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = -(u(1)%Fy - u(2)%Fy)/t(2)
  u_out%Fy = u(1)%Fy + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = -(u(1)%Fz - u(2)%Fz)/t(2)
  u_out%Fz = u(1)%Fz + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%wrtOutput,1)))
  ALLOCATE(c1(SIZE(u_out%wrtOutput,1)))
  b1 = -(u(1)%wrtOutput - u(2)%wrtOutput)/t(2)
  u_out%wrtOutput = u(1)%wrtOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%ptFairleadLoad, u(2)%ptFairleadLoad, tin, u_out%ptFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Output_ExtrapInterp:%ptFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = (t(3)**2*(u(1)%Fx - u(2)%Fx) + t(2)**2*(-u(1)%Fx + u(3)%Fx))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fx + t(3)*u(2)%Fx - t(2)*u(3)%Fx ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fx = u(1)%Fx + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = (t(3)**2*(u(1)%Fy - u(2)%Fy) + t(2)**2*(-u(1)%Fy + u(3)%Fy))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fy + t(3)*u(2)%Fy - t(2)*u(3)%Fy ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fy = u(1)%Fy + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = (t(3)**2*(u(1)%Fz - u(2)%Fz) + t(2)**2*(-u(1)%Fz + u(3)%Fz))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fz + t(3)*u(2)%Fz - t(2)*u(3)%Fz ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fz = u(1)%Fz + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%wrtOutput,1)))
  ALLOCATE(c1(SIZE(u_out%wrtOutput,1)))
  b1 = (t(3)**2*(u(1)%wrtOutput - u(2)%wrtOutput) + t(2)**2*(-u(1)%wrtOutput + u(3)%wrtOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%wrtOutput + t(3)*u(2)%wrtOutput - t(2)*u(3)%wrtOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%wrtOutput = u(1)%wrtOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%ptFairleadLoad, u(2)%ptFairleadLoad, u(3)%ptFairleadLoad, tin, u_out%ptFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MAP_Output_ExtrapInterp:%ptFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Output_ExtrapInterp

END MODULE MAP_Types
!ENDOFREGISTRYGENERATEDFILE
