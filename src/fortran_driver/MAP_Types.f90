!STARTOFREGISTRYGENERATEDFILE './MAP_Types.f90'

! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! MAP_Types
!.................................................................................................................................
! LICENSING
! Copyright (C) 2012 National Renewable Energy Laboratory
!
! This file is part of MAP.
!
! MAP is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with ModuleName.
! If not, see <http://www.gnu.org/licenses/>.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE MAP_Types
! This module contains all of the user-defined types needed in MAP. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
USE MAP_C_Types
USE, INTRINSIC :: ISO_C_Binding
IMPLICIT NONE
! =========  MAP_InitInputType_C  =======
  TYPE, BIND(C) :: MAP_InitInputType_C
    TYPE( MAP_InitInput_C ) :: object
    REAL(KIND=C_DOUBLE) :: gravity 
    REAL(KIND=C_DOUBLE) :: sea_density 
    REAL(KIND=C_DOUBLE) :: depth 
    LOGICAL(KIND=C_BOOL) :: coupled_to_FAST 
    CHARACTER(KIND=C_CHAR,LEN=255) :: filename 
    CHARACTER(KIND=C_CHAR,LEN=255) :: cable_library_data 
    CHARACTER(KIND=C_CHAR,LEN=255) :: node_data 
    CHARACTER(KIND=C_CHAR,LEN=255) :: element_data 
    CHARACTER(KIND=C_CHAR,LEN=255) :: solver_data 
  END TYPE MAP_InitInputType_C
  TYPE, PUBLIC :: MAP_InitInputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InitInputType_C ) :: C_obj
    REAL(DbKi)  :: gravity = -999.9 
    REAL(DbKi)  :: sea_density = -999.9 
    REAL(DbKi)  :: depth = -999.9 
    LOGICAL  :: coupled_to_FAST 
    CHARACTER(255)  :: filename 
    CHARACTER(255)  :: cable_library_data 
    CHARACTER(255)  :: node_data 
    CHARACTER(255)  :: element_data 
    CHARACTER(255)  :: solver_data 
  END TYPE MAP_InitInputType
! =======================
! =========  MAP_InitOutputType  =======
  TYPE, BIND(C) :: MAP_InitOutputType_C
    TYPE( MAP_InitOutput_C ) :: object
    CHARACTER(KIND=C_CHAR,LEN=99) :: MAP_name 
    CHARACTER(KIND=C_CHAR,LEN=99) :: MAP_version 
    CHARACTER(KIND=C_CHAR,LEN=24) :: MAP_date 
    TYPE(C_ptr) :: WriteOutputHdr = C_NULL_PTR 
    INTEGER(C_int) :: WriteOutputHdr_Len = 0 
    TYPE(C_ptr) :: WriteOutputUnt = C_NULL_PTR 
    INTEGER(C_int) :: WriteOutputUnt_Len = 0 
  END TYPE MAP_InitOutputType_C
  TYPE, PUBLIC :: MAP_InitOutputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InitOutputType_C ) :: C_obj
    CHARACTER(99)  :: MAP_name 
    CHARACTER(99)  :: MAP_version 
    CHARACTER(24)  :: MAP_date 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt 
    TYPE(ProgDesc)  :: Ver 
  END TYPE MAP_InitOutputType
! =======================
! =========  MAP_ContinuousStateType  =======
  TYPE, BIND(C) :: MAP_ContinuousStateType_C
    TYPE( MAP_ContState_C ) :: object
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_ContinuousStateType_C
  TYPE, PUBLIC :: MAP_ContinuousStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ContinuousStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy 
  END TYPE MAP_ContinuousStateType
! =======================
! =========  MAP_DiscreteStateType  =======
  TYPE, BIND(C) :: MAP_DiscreteStateType_C
    TYPE( MAP_DiscState_C ) :: object
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_DiscreteStateType_C
  TYPE, PUBLIC :: MAP_DiscreteStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_DiscreteStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy 
  END TYPE MAP_DiscreteStateType
! =======================
! =========  MAP_OtherStateType  =======
  TYPE, BIND(C) :: MAP_OtherStateType_C
    TYPE( MAP_OtherState_C ) :: object
    TYPE(C_ptr) :: FX = C_NULL_PTR 
    INTEGER(C_int) :: FX_Len = 0 
    TYPE(C_ptr) :: FY = C_NULL_PTR 
    INTEGER(C_int) :: FY_Len = 0 
    TYPE(C_ptr) :: FZ = C_NULL_PTR 
    INTEGER(C_int) :: FZ_Len = 0 
    TYPE(C_ptr) :: u_index = C_NULL_PTR 
    INTEGER(C_int) :: u_index_Len = 0 
    TYPE(C_ptr) :: p_index = C_NULL_PTR 
    INTEGER(C_int) :: p_index_Len = 0 
    TYPE(C_ptr) :: x_index = C_NULL_PTR 
    INTEGER(C_int) :: x_index_Len = 0 
    TYPE(C_ptr) :: xd_index = C_NULL_PTR 
    INTEGER(C_int) :: xd_index_Len = 0 
    TYPE(C_ptr) :: z_index = C_NULL_PTR 
    INTEGER(C_int) :: z_index_Len = 0 
    TYPE(C_ptr) :: y_index = C_NULL_PTR 
    INTEGER(C_int) :: y_index_Len = 0 
    TYPE(C_ptr) :: o_index = C_NULL_PTR 
    INTEGER(C_int) :: o_index_Len = 0 
  END TYPE MAP_OtherStateType_C
  TYPE, PUBLIC :: MAP_OtherStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_OtherStateType_C ) :: C_obj
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FX 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FY 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FZ 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: u_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: p_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: x_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: xd_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: z_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: y_index 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: o_index 
  END TYPE MAP_OtherStateType
! =======================
! =========  MAP_ConstraintStateType  =======
  TYPE, BIND(C) :: MAP_ConstraintStateType_C
    TYPE( MAP_ConstrState_C ) :: object
    TYPE(C_ptr) :: X = C_NULL_PTR 
    INTEGER(C_int) :: X_Len = 0 
    TYPE(C_ptr) :: Y = C_NULL_PTR 
    INTEGER(C_int) :: Y_Len = 0 
    TYPE(C_ptr) :: Z = C_NULL_PTR 
    INTEGER(C_int) :: Z_Len = 0 
    TYPE(C_ptr) :: H = C_NULL_PTR 
    INTEGER(C_int) :: H_Len = 0 
    TYPE(C_ptr) :: V = C_NULL_PTR 
    INTEGER(C_int) :: V_Len = 0 
  END TYPE MAP_ConstraintStateType_C
  TYPE, PUBLIC :: MAP_ConstraintStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ConstraintStateType_C ) :: C_obj
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: X 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Y 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Z 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: H 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V 
  END TYPE MAP_ConstraintStateType
! =======================
! =========  MAP_ParameterType  =======
  TYPE, BIND(C) :: MAP_ParameterType_C
    TYPE( MAP_Param_C ) :: object
    TYPE(C_ptr) :: Diam = C_NULL_PTR 
    INTEGER(C_int) :: Diam_Len = 0 
    TYPE(C_ptr) :: MassDenInAir = C_NULL_PTR 
    INTEGER(C_int) :: MassDenInAir_Len = 0 
    TYPE(C_ptr) :: EA = C_NULL_PTR 
    INTEGER(C_int) :: EA_Len = 0 
    TYPE(C_ptr) :: CB = C_NULL_PTR 
    INTEGER(C_int) :: CB_Len = 0 
    TYPE(C_ptr) :: Lu = C_NULL_PTR 
    INTEGER(C_int) :: Lu_Len = 0 
    TYPE(C_ptr) :: X = C_NULL_PTR 
    INTEGER(C_int) :: X_Len = 0 
    TYPE(C_ptr) :: Y = C_NULL_PTR 
    INTEGER(C_int) :: Y_Len = 0 
    TYPE(C_ptr) :: Z = C_NULL_PTR 
    INTEGER(C_int) :: Z_Len = 0 
    TYPE(C_ptr) :: FX = C_NULL_PTR 
    INTEGER(C_int) :: FX_Len = 0 
    TYPE(C_ptr) :: FY = C_NULL_PTR 
    INTEGER(C_int) :: FY_Len = 0 
    TYPE(C_ptr) :: FZ = C_NULL_PTR 
    INTEGER(C_int) :: FZ_Len = 0 
    TYPE(C_ptr) :: M = C_NULL_PTR 
    INTEGER(C_int) :: M_Len = 0 
    TYPE(C_ptr) :: B = C_NULL_PTR 
    INTEGER(C_int) :: B_Len = 0 
  END TYPE MAP_ParameterType_C
  TYPE, PUBLIC :: MAP_ParameterType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ParameterType_C ) :: C_obj
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Diam 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: MassDenInAir 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: EA 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: CB 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Lu 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: X 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Y 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Z 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FX 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FY 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FZ 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: M 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: B 
  END TYPE MAP_ParameterType
! =======================
! =========  MAP_InputType  =======
  TYPE, BIND(C) :: MAP_InputType_C
    TYPE( MAP_Input_C ) :: object
    TYPE(C_ptr) :: X = C_NULL_PTR 
    INTEGER(C_int) :: X_Len = 0 
    TYPE(C_ptr) :: Y = C_NULL_PTR 
    INTEGER(C_int) :: Y_Len = 0 
    TYPE(C_ptr) :: Z = C_NULL_PTR 
    INTEGER(C_int) :: Z_Len = 0 
  END TYPE MAP_InputType_C
  TYPE, PUBLIC :: MAP_InputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InputType_C ) :: C_obj
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: X 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Y 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Z 
    TYPE(MeshType)  :: PtFairleadDisplacement 
  END TYPE MAP_InputType
! =======================
! =========  MAP_OutputType  =======
  TYPE, BIND(C) :: MAP_OutputType_C
    TYPE( MAP_Output_C ) :: object
    TYPE(C_ptr) :: FX = C_NULL_PTR 
    INTEGER(C_int) :: FX_Len = 0 
    TYPE(C_ptr) :: FY = C_NULL_PTR 
    INTEGER(C_int) :: FY_Len = 0 
    TYPE(C_ptr) :: FZ = C_NULL_PTR 
    INTEGER(C_int) :: FZ_Len = 0 
    TYPE(C_ptr) :: writeOutput = C_NULL_PTR 
    INTEGER(C_int) :: writeOutput_Len = 0 
  END TYPE MAP_OutputType_C
  TYPE, PUBLIC :: MAP_OutputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_OutputType_C ) :: C_obj
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FX 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FY 
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: FZ 
    TYPE(MeshType)  :: PtFairleadLoad 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: writeOutput 
  END TYPE MAP_OutputType
! =======================

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_FX( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_FX_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_FX
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_FY( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_FY_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_FY
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_FZ( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_FZ_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_FZ
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_u_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_u_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_u_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_p_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_p_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_p_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_x_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_x_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_x_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_xd_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_xd_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_xd_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_z_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_z_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_z_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_y_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_y_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_y_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_o_index( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_o_index_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       INTEGER(KIND=C_INT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_o_index
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_X( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_X_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_X
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_Y( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_Y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_Y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_Z( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_Z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_Z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_H( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_H_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_H
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_V( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_V_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_V
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_Diam( Object, arr, len) BIND(C,name='MAP_F2C_Param_Diam_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_Diam
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_MassDenInAir( Object, arr, len) BIND(C,name='MAP_F2C_Param_MassDenInAir_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_MassDenInAir
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_EA( Object, arr, len) BIND(C,name='MAP_F2C_Param_EA_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_EA
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_CB( Object, arr, len) BIND(C,name='MAP_F2C_Param_CB_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_CB
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_Lu( Object, arr, len) BIND(C,name='MAP_F2C_Param_Lu_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_Lu
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_X( Object, arr, len) BIND(C,name='MAP_F2C_Param_X_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_X
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_Y( Object, arr, len) BIND(C,name='MAP_F2C_Param_Y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_Y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_Z( Object, arr, len) BIND(C,name='MAP_F2C_Param_Z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_Z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_FX( Object, arr, len) BIND(C,name='MAP_F2C_Param_FX_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_FX
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_FY( Object, arr, len) BIND(C,name='MAP_F2C_Param_FY_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_FY
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_FZ( Object, arr, len) BIND(C,name='MAP_F2C_Param_FZ_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_FZ
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_M( Object, arr, len) BIND(C,name='MAP_F2C_Param_M_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_M
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Param_B( Object, arr, len) BIND(C,name='MAP_F2C_Param_B_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ParameterType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Param_B
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_X( Object, arr, len) BIND(C,name='MAP_F2C_Input_X_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_X
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_Y( Object, arr, len) BIND(C,name='MAP_F2C_Input_Y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_Y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_Z( Object, arr, len) BIND(C,name='MAP_F2C_Input_Z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_Z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_FX( Object, arr, len) BIND(C,name='MAP_F2C_Output_FX_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_FX
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_FY( Object, arr, len) BIND(C,name='MAP_F2C_Output_FY_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_FY
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_FZ( Object, arr, len) BIND(C,name='MAP_F2C_Output_FZ_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_FZ
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_writeOutput( Object, arr, len) BIND(C,name='MAP_F2C_Output_writeOutput_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_FLOAT), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_writeOutput
  END INTERFACE
CONTAINS
  SUBROUTINE MAP_F2C_CopyInitInput( InitInputData, ErrStat, ErrMsg )
    TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    InitInputData%C_obj%gravity = InitInputData%gravity
    InitInputData%C_obj%sea_density = InitInputData%sea_density
    InitInputData%C_obj%depth = InitInputData%depth
    InitInputData%C_obj%coupled_to_FAST = InitInputData%coupled_to_FAST
 END SUBROUTINE MAP_F2C_CopyInitInput

  SUBROUTINE MAP_C2F_CopyInitInput( InitInputData, ErrStat, ErrMsg )
    TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    InitInputData%gravity = InitInputData%C_obj%gravity
    InitInputData%sea_density = InitInputData%C_obj%sea_density
    InitInputData%depth = InitInputData%C_obj%depth
    InitInputData%coupled_to_FAST = InitInputData%C_obj%coupled_to_FAST
 END SUBROUTINE MAP_C2F_CopyInitInput

 SUBROUTINE MAP_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_initinputtype), INTENT(INOUT) :: SrcInitInputData
  TYPE(MAP_initinputtype), INTENT(INOUT) :: DstInitInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstInitInputData%gravity = SrcInitInputData%gravity
  DstInitInputData%sea_density = SrcInitInputData%sea_density
  DstInitInputData%depth = SrcInitInputData%depth
  DstInitInputData%coupled_to_FAST = SrcInitInputData%coupled_to_FAST
  DstInitInputData%filename = SrcInitInputData%filename
  DstInitInputData%cable_library_data = SrcInitInputData%cable_library_data
  DstInitInputData%node_data = SrcInitInputData%node_data
  DstInitInputData%element_data = SrcInitInputData%element_data
  DstInitInputData%solver_data = SrcInitInputData%solver_data
 END SUBROUTINE MAP_CopyInitInput

 SUBROUTINE MAP_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyInitInput

 SUBROUTINE MAP_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! gravity
  Db_BufSz   = Db_BufSz   + 1  ! sea_density
  Db_BufSz   = Db_BufSz   + 1  ! depth
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%gravity )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%sea_density )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%depth )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackInitInput

 SUBROUTINE MAP_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%gravity = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%sea_density = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%depth = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitInput

  SUBROUTINE MAP_F2C_CopyInitOutput( InitOutputData, ErrStat, ErrMsg )
    TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_F2C_CopyInitOutput

  SUBROUTINE MAP_C2F_CopyInitOutput( InitOutputData, ErrStat, ErrMsg )
    TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2F_CopyInitOutput

 SUBROUTINE MAP_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: DstInitOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstInitOutputData%MAP_name = SrcInitOutputData%MAP_name
  DstInitOutputData%MAP_version = SrcInitOutputData%MAP_version
  DstInitOutputData%MAP_date = SrcInitOutputData%MAP_date
IF ( ALLOCATED( SrcInitOutputData%WriteOutputHdr ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputHdr)) ALLOCATE(DstInitOutputData%WriteOutputHdr(i1))
  DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF ( ALLOCATED( SrcInitOutputData%WriteOutputUnt ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputUnt)) ALLOCATE(DstInitOutputData%WriteOutputUnt(i1))
  DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
  DstInitOutputData%Ver = SrcInitOutputData%Ver
 END SUBROUTINE MAP_CopyInitOutput

 SUBROUTINE MAP_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(InitOutputData%WriteOutputHdr) ) DEALLOCATE(InitOutputData%WriteOutputHdr)
  IF ( ALLOCATED(InitOutputData%WriteOutputUnt) ) DEALLOCATE(InitOutputData%WriteOutputUnt)
 END SUBROUTINE MAP_DestroyInitOutput

 SUBROUTINE MAP_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
 END SUBROUTINE MAP_PackInitOutput

 SUBROUTINE MAP_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitOutput

  SUBROUTINE MAP_F2C_CopyContState( ContStateData, ErrStat, ErrMsg )
    TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ContStateData%C_obj%dummy = ContStateData%dummy
 END SUBROUTINE MAP_F2C_CopyContState

  SUBROUTINE MAP_C2F_CopyContState( ContStateData, ErrStat, ErrMsg )
    TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ContStateData%dummy = ContStateData%C_obj%dummy
 END SUBROUTINE MAP_C2F_CopyContState

 SUBROUTINE MAP_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: SrcContStateData
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: DstContStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstContStateData%dummy = SrcContStateData%dummy
 END SUBROUTINE MAP_CopyContState

 SUBROUTINE MAP_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyContState

 SUBROUTINE MAP_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackContState

 SUBROUTINE MAP_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackContState

  SUBROUTINE MAP_F2C_CopyDiscState( DiscStateData, ErrStat, ErrMsg )
    TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    DiscStateData%C_obj%dummy = DiscStateData%dummy
 END SUBROUTINE MAP_F2C_CopyDiscState

  SUBROUTINE MAP_C2F_CopyDiscState( DiscStateData, ErrStat, ErrMsg )
    TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    DiscStateData%dummy = DiscStateData%C_obj%dummy
 END SUBROUTINE MAP_C2F_CopyDiscState

 SUBROUTINE MAP_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: DstDiscStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MAP_CopyDiscState

 SUBROUTINE MAP_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyDiscState

 SUBROUTINE MAP_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackDiscState

 SUBROUTINE MAP_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackDiscState

  SUBROUTINE MAP_F2C_CopyOtherState( OtherStateData, ErrStat, ErrMsg )
    TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- FX OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FX ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%FX_Len) )
       DO i = 1 , OtherStateData%C_obj%FX_Len
          c_dbl_value(i) = OtherStateData%FX(i)
       END DO
       CALL MAP_F2C_OtherState_FX( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%FX_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FY OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FY ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%FY_Len) )
       DO i = 1 , OtherStateData%C_obj%FY_Len
          c_dbl_value(i) = OtherStateData%FY(i)
       END DO
       CALL MAP_F2C_OtherState_FY( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%FY_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FZ OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FZ ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%FZ_Len) )
       DO i = 1 , OtherStateData%C_obj%FZ_Len
          c_dbl_value(i) = OtherStateData%FZ(i)
       END DO
       CALL MAP_F2C_OtherState_FZ( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%FZ_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- u_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%u_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%u_index_Len) )
       DO i = 1 , OtherStateData%C_obj%u_index_Len
          c_int_value(i) = OtherStateData%u_index(i)
       END DO
       CALL MAP_F2C_OtherState_u_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%u_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- p_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%p_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%p_index_Len) )
       DO i = 1 , OtherStateData%C_obj%p_index_Len
          c_int_value(i) = OtherStateData%p_index(i)
       END DO
       CALL MAP_F2C_OtherState_p_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%p_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- x_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%x_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%x_index_Len) )
       DO i = 1 , OtherStateData%C_obj%x_index_Len
          c_int_value(i) = OtherStateData%x_index(i)
       END DO
       CALL MAP_F2C_OtherState_x_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%x_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- xd_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%xd_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%xd_index_Len) )
       DO i = 1 , OtherStateData%C_obj%xd_index_Len
          c_int_value(i) = OtherStateData%xd_index(i)
       END DO
       CALL MAP_F2C_OtherState_xd_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%xd_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- z_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%z_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%z_index_Len) )
       DO i = 1 , OtherStateData%C_obj%z_index_Len
          c_int_value(i) = OtherStateData%z_index(i)
       END DO
       CALL MAP_F2C_OtherState_z_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%z_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- y_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%y_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%y_index_Len) )
       DO i = 1 , OtherStateData%C_obj%y_index_Len
          c_int_value(i) = OtherStateData%y_index(i)
       END DO
       CALL MAP_F2C_OtherState_y_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%y_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF

    ! -- o_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%o_index ) ) THEN
       ALLOCATE( c_int_value(OtherStateData%C_obj%o_index_Len) )
       DO i = 1 , OtherStateData%C_obj%o_index_Len
          c_int_value(i) = OtherStateData%o_index(i)
       END DO
       CALL MAP_F2C_OtherState_o_index( OtherStateData%C_obj, c_int_value, OtherStateData%C_obj%o_index_Len )
       DEALLOCATE( c_int_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyOtherState

  SUBROUTINE MAP_C2F_CopyOtherState( OtherStateData, ErrStat, ErrMsg )
    TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- FX OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FX ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%FX, dbl_arr, (/OtherStateData%C_obj%FX_Len/) )
       DO i = 1, OtherStateData%C_obj%FX_Len
          OtherStateData%FX(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FY OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FY ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%FY, dbl_arr, (/OtherStateData%C_obj%FY_Len/) )
       DO i = 1, OtherStateData%C_obj%FY_Len
          OtherStateData%FY(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FZ OtherState Data fields
    IF ( ALLOCATED( OtherStateData%FZ ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%FZ, dbl_arr, (/OtherStateData%C_obj%FZ_Len/) )
       DO i = 1, OtherStateData%C_obj%FZ_Len
          OtherStateData%FZ(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- u_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%u_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%u_index, int_arr, (/OtherStateData%C_obj%u_index_Len/) )
       DO i = 1, OtherStateData%C_obj%u_index_Len
          OtherStateData%u_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- p_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%p_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%p_index, int_arr, (/OtherStateData%C_obj%p_index_Len/) )
       DO i = 1, OtherStateData%C_obj%p_index_Len
          OtherStateData%p_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- x_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%x_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%x_index, int_arr, (/OtherStateData%C_obj%x_index_Len/) )
       DO i = 1, OtherStateData%C_obj%x_index_Len
          OtherStateData%x_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- xd_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%xd_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%xd_index, int_arr, (/OtherStateData%C_obj%xd_index_Len/) )
       DO i = 1, OtherStateData%C_obj%xd_index_Len
          OtherStateData%xd_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- z_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%z_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%z_index, int_arr, (/OtherStateData%C_obj%z_index_Len/) )
       DO i = 1, OtherStateData%C_obj%z_index_Len
          OtherStateData%z_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- y_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%y_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%y_index, int_arr, (/OtherStateData%C_obj%y_index_Len/) )
       DO i = 1, OtherStateData%C_obj%y_index_Len
          OtherStateData%y_index(i) = int_arr(i)
       END DO
    ENDIF

    ! -- o_index OtherState Data fields
    IF ( ALLOCATED( OtherStateData%o_index ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%o_index, int_arr, (/OtherStateData%C_obj%o_index_Len/) )
       DO i = 1, OtherStateData%C_obj%o_index_Len
          OtherStateData%o_index(i) = int_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyOtherState

 SUBROUTINE MAP_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: DstOtherStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcOtherStateData%FX ) ) THEN
  i1 = SIZE(SrcOtherStateData%FX,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%FX)) ALLOCATE(DstOtherStateData%FX(i1))
  DstOtherStateData%FX = SrcOtherStateData%FX
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FY ) ) THEN
  i1 = SIZE(SrcOtherStateData%FY,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%FY)) ALLOCATE(DstOtherStateData%FY(i1))
  DstOtherStateData%FY = SrcOtherStateData%FY
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FZ ) ) THEN
  i1 = SIZE(SrcOtherStateData%FZ,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%FZ)) ALLOCATE(DstOtherStateData%FZ(i1))
  DstOtherStateData%FZ = SrcOtherStateData%FZ
ENDIF
IF ( ALLOCATED( SrcOtherStateData%u_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%u_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%u_index)) ALLOCATE(DstOtherStateData%u_index(i1))
  DstOtherStateData%u_index = SrcOtherStateData%u_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%p_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%p_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%p_index)) ALLOCATE(DstOtherStateData%p_index(i1))
  DstOtherStateData%p_index = SrcOtherStateData%p_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%x_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%x_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%x_index)) ALLOCATE(DstOtherStateData%x_index(i1))
  DstOtherStateData%x_index = SrcOtherStateData%x_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%xd_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%xd_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%xd_index)) ALLOCATE(DstOtherStateData%xd_index(i1))
  DstOtherStateData%xd_index = SrcOtherStateData%xd_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%z_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%z_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%z_index)) ALLOCATE(DstOtherStateData%z_index(i1))
  DstOtherStateData%z_index = SrcOtherStateData%z_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%y_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%y_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%y_index)) ALLOCATE(DstOtherStateData%y_index(i1))
  DstOtherStateData%y_index = SrcOtherStateData%y_index
ENDIF
IF ( ALLOCATED( SrcOtherStateData%o_index ) ) THEN
  i1 = SIZE(SrcOtherStateData%o_index,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%o_index)) ALLOCATE(DstOtherStateData%o_index(i1))
  DstOtherStateData%o_index = SrcOtherStateData%o_index
ENDIF
 END SUBROUTINE MAP_CopyOtherState

 SUBROUTINE MAP_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(OtherStateData%FX) ) DEALLOCATE(OtherStateData%FX)
  IF ( ALLOCATED(OtherStateData%FY) ) DEALLOCATE(OtherStateData%FY)
  IF ( ALLOCATED(OtherStateData%FZ) ) DEALLOCATE(OtherStateData%FZ)
  IF ( ALLOCATED(OtherStateData%u_index) ) DEALLOCATE(OtherStateData%u_index)
  IF ( ALLOCATED(OtherStateData%p_index) ) DEALLOCATE(OtherStateData%p_index)
  IF ( ALLOCATED(OtherStateData%x_index) ) DEALLOCATE(OtherStateData%x_index)
  IF ( ALLOCATED(OtherStateData%xd_index) ) DEALLOCATE(OtherStateData%xd_index)
  IF ( ALLOCATED(OtherStateData%z_index) ) DEALLOCATE(OtherStateData%z_index)
  IF ( ALLOCATED(OtherStateData%y_index) ) DEALLOCATE(OtherStateData%y_index)
  IF ( ALLOCATED(OtherStateData%o_index) ) DEALLOCATE(OtherStateData%o_index)
 END SUBROUTINE MAP_DestroyOtherState

 SUBROUTINE MAP_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%FX )  ! FX 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FY )  ! FY 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FZ )  ! FZ 
  Int_BufSz   = Int_BufSz   + SIZE( InData%u_index )  ! u_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%p_index )  ! p_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%x_index )  ! x_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%xd_index )  ! xd_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%z_index )  ! z_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%y_index )  ! y_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%o_index )  ! o_index 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%FZ) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FZ))-1 ) =  PACK(InData%FZ ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FZ)
  ENDIF
  IF ( ALLOCATED(InData%u_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%u_index))-1 ) = PACK(InData%u_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%u_index)
  ENDIF
  IF ( ALLOCATED(InData%p_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%p_index))-1 ) = PACK(InData%p_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%p_index)
  ENDIF
  IF ( ALLOCATED(InData%x_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%x_index))-1 ) = PACK(InData%x_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%x_index)
  ENDIF
  IF ( ALLOCATED(InData%xd_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%xd_index))-1 ) = PACK(InData%xd_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%xd_index)
  ENDIF
  IF ( ALLOCATED(InData%z_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%z_index))-1 ) = PACK(InData%z_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%z_index)
  ENDIF
  IF ( ALLOCATED(InData%y_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%y_index))-1 ) = PACK(InData%y_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%y_index)
  ENDIF
  IF ( ALLOCATED(InData%o_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%o_index))-1 ) = PACK(InData%o_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%o_index)
  ENDIF
 END SUBROUTINE MAP_PackOtherState

 SUBROUTINE MAP_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%FZ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FZ,1))); mask1 = .TRUE.
    OutData%FZ = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FZ))-1 ),mask1,OutData%FZ)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FZ)
  ENDIF
  IF ( ALLOCATED(OutData%u_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%u_index,1))); mask1 = .TRUE.
    OutData%u_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%u_index))-1 ),mask1,OutData%u_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%u_index)
  ENDIF
  IF ( ALLOCATED(OutData%p_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%p_index,1))); mask1 = .TRUE.
    OutData%p_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%p_index))-1 ),mask1,OutData%p_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%p_index)
  ENDIF
  IF ( ALLOCATED(OutData%x_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x_index,1))); mask1 = .TRUE.
    OutData%x_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%x_index))-1 ),mask1,OutData%x_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%x_index)
  ENDIF
  IF ( ALLOCATED(OutData%xd_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%xd_index,1))); mask1 = .TRUE.
    OutData%xd_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%xd_index))-1 ),mask1,OutData%xd_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%xd_index)
  ENDIF
  IF ( ALLOCATED(OutData%z_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z_index,1))); mask1 = .TRUE.
    OutData%z_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%z_index))-1 ),mask1,OutData%z_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%z_index)
  ENDIF
  IF ( ALLOCATED(OutData%y_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y_index,1))); mask1 = .TRUE.
    OutData%y_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%y_index))-1 ),mask1,OutData%y_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%y_index)
  ENDIF
  IF ( ALLOCATED(OutData%o_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%o_index,1))); mask1 = .TRUE.
    OutData%o_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%o_index))-1 ),mask1,OutData%o_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%o_index)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOtherState

  SUBROUTINE MAP_F2C_CopyConstrState( ConstrStateData, ErrStat, ErrMsg )
    TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- X ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%X ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%X_Len) )
       DO i = 1 , ConstrStateData%C_obj%X_Len
          c_dbl_value(i) = ConstrStateData%X(i)
       END DO
       CALL MAP_F2C_ConstrState_X( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%X_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Y ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%Y ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%Y_Len) )
       DO i = 1 , ConstrStateData%C_obj%Y_Len
          c_dbl_value(i) = ConstrStateData%Y(i)
       END DO
       CALL MAP_F2C_ConstrState_Y( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%Y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Z ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%Z ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%Z_Len) )
       DO i = 1 , ConstrStateData%C_obj%Z_Len
          c_dbl_value(i) = ConstrStateData%Z(i)
       END DO
       CALL MAP_F2C_ConstrState_Z( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%Z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- H ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%H ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%H_Len) )
       DO i = 1 , ConstrStateData%C_obj%H_Len
          c_dbl_value(i) = ConstrStateData%H(i)
       END DO
       CALL MAP_F2C_ConstrState_H( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%H_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- V ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%V ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%V_Len) )
       DO i = 1 , ConstrStateData%C_obj%V_Len
          c_dbl_value(i) = ConstrStateData%V(i)
       END DO
       CALL MAP_F2C_ConstrState_V( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%V_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyConstrState

  SUBROUTINE MAP_C2F_CopyConstrState( ConstrStateData, ErrStat, ErrMsg )
    TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- X ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%X ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%X, dbl_arr, (/ConstrStateData%C_obj%X_Len/) )
       DO i = 1, ConstrStateData%C_obj%X_Len
          ConstrStateData%X(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Y ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%Y ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%Y, dbl_arr, (/ConstrStateData%C_obj%Y_Len/) )
       DO i = 1, ConstrStateData%C_obj%Y_Len
          ConstrStateData%Y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Z ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%Z ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%Z, dbl_arr, (/ConstrStateData%C_obj%Z_Len/) )
       DO i = 1, ConstrStateData%C_obj%Z_Len
          ConstrStateData%Z(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- H ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%H ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%H, dbl_arr, (/ConstrStateData%C_obj%H_Len/) )
       DO i = 1, ConstrStateData%C_obj%H_Len
          ConstrStateData%H(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- V ConstrState Data fields
    IF ( ALLOCATED( ConstrStateData%V ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%V, dbl_arr, (/ConstrStateData%C_obj%V_Len/) )
       DO i = 1, ConstrStateData%C_obj%V_Len
          ConstrStateData%V(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyConstrState

 SUBROUTINE MAP_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcConstrStateData%X ) ) THEN
  i1 = SIZE(SrcConstrStateData%X,1)
  IF (.NOT.ALLOCATED(DstConstrStateData%X)) ALLOCATE(DstConstrStateData%X(i1))
  DstConstrStateData%X = SrcConstrStateData%X
ENDIF
IF ( ALLOCATED( SrcConstrStateData%Y ) ) THEN
  i1 = SIZE(SrcConstrStateData%Y,1)
  IF (.NOT.ALLOCATED(DstConstrStateData%Y)) ALLOCATE(DstConstrStateData%Y(i1))
  DstConstrStateData%Y = SrcConstrStateData%Y
ENDIF
IF ( ALLOCATED( SrcConstrStateData%Z ) ) THEN
  i1 = SIZE(SrcConstrStateData%Z,1)
  IF (.NOT.ALLOCATED(DstConstrStateData%Z)) ALLOCATE(DstConstrStateData%Z(i1))
  DstConstrStateData%Z = SrcConstrStateData%Z
ENDIF
IF ( ALLOCATED( SrcConstrStateData%H ) ) THEN
  i1 = SIZE(SrcConstrStateData%H,1)
  IF (.NOT.ALLOCATED(DstConstrStateData%H)) ALLOCATE(DstConstrStateData%H(i1))
  DstConstrStateData%H = SrcConstrStateData%H
ENDIF
IF ( ALLOCATED( SrcConstrStateData%V ) ) THEN
  i1 = SIZE(SrcConstrStateData%V,1)
  IF (.NOT.ALLOCATED(DstConstrStateData%V)) ALLOCATE(DstConstrStateData%V(i1))
  DstConstrStateData%V = SrcConstrStateData%V
ENDIF
 END SUBROUTINE MAP_CopyConstrState

 SUBROUTINE MAP_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ConstrStateData%X) ) DEALLOCATE(ConstrStateData%X)
  IF ( ALLOCATED(ConstrStateData%Y) ) DEALLOCATE(ConstrStateData%Y)
  IF ( ALLOCATED(ConstrStateData%Z) ) DEALLOCATE(ConstrStateData%Z)
  IF ( ALLOCATED(ConstrStateData%H) ) DEALLOCATE(ConstrStateData%H)
  IF ( ALLOCATED(ConstrStateData%V) ) DEALLOCATE(ConstrStateData%V)
 END SUBROUTINE MAP_DestroyConstrState

 SUBROUTINE MAP_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%X )  ! X 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Y )  ! Y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Z )  ! Z 
  Db_BufSz    = Db_BufSz    + SIZE( InData%H )  ! H 
  Db_BufSz    = Db_BufSz    + SIZE( InData%V )  ! V 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%X) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%X))-1 ) =  PACK(InData%X ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%X)
  ENDIF
  IF ( ALLOCATED(InData%Y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Y))-1 ) =  PACK(InData%Y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Y)
  ENDIF
  IF ( ALLOCATED(InData%Z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Z))-1 ) =  PACK(InData%Z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Z)
  ENDIF
  IF ( ALLOCATED(InData%H) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%H))-1 ) =  PACK(InData%H ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%H)
  ENDIF
  IF ( ALLOCATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%V)
  ENDIF
 END SUBROUTINE MAP_PackConstrState

 SUBROUTINE MAP_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%X) ) THEN
  ALLOCATE(mask1(SIZE(OutData%X,1))); mask1 = .TRUE.
    OutData%X = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%X))-1 ),mask1,OutData%X)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%X)
  ENDIF
  IF ( ALLOCATED(OutData%Y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y,1))); mask1 = .TRUE.
    OutData%Y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Y))-1 ),mask1,OutData%Y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Y)
  ENDIF
  IF ( ALLOCATED(OutData%Z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Z,1))); mask1 = .TRUE.
    OutData%Z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Z))-1 ),mask1,OutData%Z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Z)
  ENDIF
  IF ( ALLOCATED(OutData%H) ) THEN
  ALLOCATE(mask1(SIZE(OutData%H,1))); mask1 = .TRUE.
    OutData%H = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%H))-1 ),mask1,OutData%H)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%H)
  ENDIF
  IF ( ALLOCATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1))); mask1 = .TRUE.
    OutData%V = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,OutData%V)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%V)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackConstrState

  SUBROUTINE MAP_F2C_CopyParam( ParamData, ErrStat, ErrMsg )
    TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- Diam Param Data fields
    IF ( ALLOCATED( ParamData%Diam ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%Diam_Len) )
       DO i = 1 , ParamData%C_obj%Diam_Len
          c_dbl_value(i) = ParamData%Diam(i)
       END DO
       CALL MAP_F2C_Param_Diam( ParamData%C_obj, c_dbl_value, ParamData%C_obj%Diam_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- MassDenInAir Param Data fields
    IF ( ALLOCATED( ParamData%MassDenInAir ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%MassDenInAir_Len) )
       DO i = 1 , ParamData%C_obj%MassDenInAir_Len
          c_dbl_value(i) = ParamData%MassDenInAir(i)
       END DO
       CALL MAP_F2C_Param_MassDenInAir( ParamData%C_obj, c_dbl_value, ParamData%C_obj%MassDenInAir_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- EA Param Data fields
    IF ( ALLOCATED( ParamData%EA ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%EA_Len) )
       DO i = 1 , ParamData%C_obj%EA_Len
          c_dbl_value(i) = ParamData%EA(i)
       END DO
       CALL MAP_F2C_Param_EA( ParamData%C_obj, c_dbl_value, ParamData%C_obj%EA_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- CB Param Data fields
    IF ( ALLOCATED( ParamData%CB ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%CB_Len) )
       DO i = 1 , ParamData%C_obj%CB_Len
          c_dbl_value(i) = ParamData%CB(i)
       END DO
       CALL MAP_F2C_Param_CB( ParamData%C_obj, c_dbl_value, ParamData%C_obj%CB_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Lu Param Data fields
    IF ( ALLOCATED( ParamData%Lu ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%Lu_Len) )
       DO i = 1 , ParamData%C_obj%Lu_Len
          c_dbl_value(i) = ParamData%Lu(i)
       END DO
       CALL MAP_F2C_Param_Lu( ParamData%C_obj, c_dbl_value, ParamData%C_obj%Lu_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- X Param Data fields
    IF ( ALLOCATED( ParamData%X ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%X_Len) )
       DO i = 1 , ParamData%C_obj%X_Len
          c_dbl_value(i) = ParamData%X(i)
       END DO
       CALL MAP_F2C_Param_X( ParamData%C_obj, c_dbl_value, ParamData%C_obj%X_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Y Param Data fields
    IF ( ALLOCATED( ParamData%Y ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%Y_Len) )
       DO i = 1 , ParamData%C_obj%Y_Len
          c_dbl_value(i) = ParamData%Y(i)
       END DO
       CALL MAP_F2C_Param_Y( ParamData%C_obj, c_dbl_value, ParamData%C_obj%Y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Z Param Data fields
    IF ( ALLOCATED( ParamData%Z ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%Z_Len) )
       DO i = 1 , ParamData%C_obj%Z_Len
          c_dbl_value(i) = ParamData%Z(i)
       END DO
       CALL MAP_F2C_Param_Z( ParamData%C_obj, c_dbl_value, ParamData%C_obj%Z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FX Param Data fields
    IF ( ALLOCATED( ParamData%FX ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%FX_Len) )
       DO i = 1 , ParamData%C_obj%FX_Len
          c_dbl_value(i) = ParamData%FX(i)
       END DO
       CALL MAP_F2C_Param_FX( ParamData%C_obj, c_dbl_value, ParamData%C_obj%FX_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FY Param Data fields
    IF ( ALLOCATED( ParamData%FY ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%FY_Len) )
       DO i = 1 , ParamData%C_obj%FY_Len
          c_dbl_value(i) = ParamData%FY(i)
       END DO
       CALL MAP_F2C_Param_FY( ParamData%C_obj, c_dbl_value, ParamData%C_obj%FY_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FZ Param Data fields
    IF ( ALLOCATED( ParamData%FZ ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%FZ_Len) )
       DO i = 1 , ParamData%C_obj%FZ_Len
          c_dbl_value(i) = ParamData%FZ(i)
       END DO
       CALL MAP_F2C_Param_FZ( ParamData%C_obj, c_dbl_value, ParamData%C_obj%FZ_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- M Param Data fields
    IF ( ALLOCATED( ParamData%M ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%M_Len) )
       DO i = 1 , ParamData%C_obj%M_Len
          c_dbl_value(i) = ParamData%M(i)
       END DO
       CALL MAP_F2C_Param_M( ParamData%C_obj, c_dbl_value, ParamData%C_obj%M_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- B Param Data fields
    IF ( ALLOCATED( ParamData%B ) ) THEN
       ALLOCATE( c_dbl_value(ParamData%C_obj%B_Len) )
       DO i = 1 , ParamData%C_obj%B_Len
          c_dbl_value(i) = ParamData%B(i)
       END DO
       CALL MAP_F2C_Param_B( ParamData%C_obj, c_dbl_value, ParamData%C_obj%B_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyParam

  SUBROUTINE MAP_C2F_CopyParam( ParamData, ErrStat, ErrMsg )
    TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- Diam Param Data fields
    IF ( ALLOCATED( ParamData%Diam ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%Diam, dbl_arr, (/ParamData%C_obj%Diam_Len/) )
       DO i = 1, ParamData%C_obj%Diam_Len
          ParamData%Diam(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- MassDenInAir Param Data fields
    IF ( ALLOCATED( ParamData%MassDenInAir ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%MassDenInAir, dbl_arr, (/ParamData%C_obj%MassDenInAir_Len/) )
       DO i = 1, ParamData%C_obj%MassDenInAir_Len
          ParamData%MassDenInAir(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- EA Param Data fields
    IF ( ALLOCATED( ParamData%EA ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%EA, dbl_arr, (/ParamData%C_obj%EA_Len/) )
       DO i = 1, ParamData%C_obj%EA_Len
          ParamData%EA(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- CB Param Data fields
    IF ( ALLOCATED( ParamData%CB ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%CB, dbl_arr, (/ParamData%C_obj%CB_Len/) )
       DO i = 1, ParamData%C_obj%CB_Len
          ParamData%CB(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Lu Param Data fields
    IF ( ALLOCATED( ParamData%Lu ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%Lu, dbl_arr, (/ParamData%C_obj%Lu_Len/) )
       DO i = 1, ParamData%C_obj%Lu_Len
          ParamData%Lu(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- X Param Data fields
    IF ( ALLOCATED( ParamData%X ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%X, dbl_arr, (/ParamData%C_obj%X_Len/) )
       DO i = 1, ParamData%C_obj%X_Len
          ParamData%X(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Y Param Data fields
    IF ( ALLOCATED( ParamData%Y ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%Y, dbl_arr, (/ParamData%C_obj%Y_Len/) )
       DO i = 1, ParamData%C_obj%Y_Len
          ParamData%Y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Z Param Data fields
    IF ( ALLOCATED( ParamData%Z ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%Z, dbl_arr, (/ParamData%C_obj%Z_Len/) )
       DO i = 1, ParamData%C_obj%Z_Len
          ParamData%Z(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FX Param Data fields
    IF ( ALLOCATED( ParamData%FX ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%FX, dbl_arr, (/ParamData%C_obj%FX_Len/) )
       DO i = 1, ParamData%C_obj%FX_Len
          ParamData%FX(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FY Param Data fields
    IF ( ALLOCATED( ParamData%FY ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%FY, dbl_arr, (/ParamData%C_obj%FY_Len/) )
       DO i = 1, ParamData%C_obj%FY_Len
          ParamData%FY(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FZ Param Data fields
    IF ( ALLOCATED( ParamData%FZ ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%FZ, dbl_arr, (/ParamData%C_obj%FZ_Len/) )
       DO i = 1, ParamData%C_obj%FZ_Len
          ParamData%FZ(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- M Param Data fields
    IF ( ALLOCATED( ParamData%M ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%M, dbl_arr, (/ParamData%C_obj%M_Len/) )
       DO i = 1, ParamData%C_obj%M_Len
          ParamData%M(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- B Param Data fields
    IF ( ALLOCATED( ParamData%B ) ) THEN
       CALL C_F_POINTER( ParamData%C_obj%B, dbl_arr, (/ParamData%C_obj%B_Len/) )
       DO i = 1, ParamData%C_obj%B_Len
          ParamData%B(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyParam

 SUBROUTINE MAP_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_parametertype), INTENT(INOUT) :: SrcParamData
  TYPE(MAP_parametertype), INTENT(INOUT) :: DstParamData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcParamData%Diam ) ) THEN
  i1 = SIZE(SrcParamData%Diam,1)
  IF (.NOT.ALLOCATED(DstParamData%Diam)) ALLOCATE(DstParamData%Diam(i1))
  DstParamData%Diam = SrcParamData%Diam
ENDIF
IF ( ALLOCATED( SrcParamData%MassDenInAir ) ) THEN
  i1 = SIZE(SrcParamData%MassDenInAir,1)
  IF (.NOT.ALLOCATED(DstParamData%MassDenInAir)) ALLOCATE(DstParamData%MassDenInAir(i1))
  DstParamData%MassDenInAir = SrcParamData%MassDenInAir
ENDIF
IF ( ALLOCATED( SrcParamData%EA ) ) THEN
  i1 = SIZE(SrcParamData%EA,1)
  IF (.NOT.ALLOCATED(DstParamData%EA)) ALLOCATE(DstParamData%EA(i1))
  DstParamData%EA = SrcParamData%EA
ENDIF
IF ( ALLOCATED( SrcParamData%CB ) ) THEN
  i1 = SIZE(SrcParamData%CB,1)
  IF (.NOT.ALLOCATED(DstParamData%CB)) ALLOCATE(DstParamData%CB(i1))
  DstParamData%CB = SrcParamData%CB
ENDIF
IF ( ALLOCATED( SrcParamData%Lu ) ) THEN
  i1 = SIZE(SrcParamData%Lu,1)
  IF (.NOT.ALLOCATED(DstParamData%Lu)) ALLOCATE(DstParamData%Lu(i1))
  DstParamData%Lu = SrcParamData%Lu
ENDIF
IF ( ALLOCATED( SrcParamData%X ) ) THEN
  i1 = SIZE(SrcParamData%X,1)
  IF (.NOT.ALLOCATED(DstParamData%X)) ALLOCATE(DstParamData%X(i1))
  DstParamData%X = SrcParamData%X
ENDIF
IF ( ALLOCATED( SrcParamData%Y ) ) THEN
  i1 = SIZE(SrcParamData%Y,1)
  IF (.NOT.ALLOCATED(DstParamData%Y)) ALLOCATE(DstParamData%Y(i1))
  DstParamData%Y = SrcParamData%Y
ENDIF
IF ( ALLOCATED( SrcParamData%Z ) ) THEN
  i1 = SIZE(SrcParamData%Z,1)
  IF (.NOT.ALLOCATED(DstParamData%Z)) ALLOCATE(DstParamData%Z(i1))
  DstParamData%Z = SrcParamData%Z
ENDIF
IF ( ALLOCATED( SrcParamData%FX ) ) THEN
  i1 = SIZE(SrcParamData%FX,1)
  IF (.NOT.ALLOCATED(DstParamData%FX)) ALLOCATE(DstParamData%FX(i1))
  DstParamData%FX = SrcParamData%FX
ENDIF
IF ( ALLOCATED( SrcParamData%FY ) ) THEN
  i1 = SIZE(SrcParamData%FY,1)
  IF (.NOT.ALLOCATED(DstParamData%FY)) ALLOCATE(DstParamData%FY(i1))
  DstParamData%FY = SrcParamData%FY
ENDIF
IF ( ALLOCATED( SrcParamData%FZ ) ) THEN
  i1 = SIZE(SrcParamData%FZ,1)
  IF (.NOT.ALLOCATED(DstParamData%FZ)) ALLOCATE(DstParamData%FZ(i1))
  DstParamData%FZ = SrcParamData%FZ
ENDIF
IF ( ALLOCATED( SrcParamData%M ) ) THEN
  i1 = SIZE(SrcParamData%M,1)
  IF (.NOT.ALLOCATED(DstParamData%M)) ALLOCATE(DstParamData%M(i1))
  DstParamData%M = SrcParamData%M
ENDIF
IF ( ALLOCATED( SrcParamData%B ) ) THEN
  i1 = SIZE(SrcParamData%B,1)
  IF (.NOT.ALLOCATED(DstParamData%B)) ALLOCATE(DstParamData%B(i1))
  DstParamData%B = SrcParamData%B
ENDIF
 END SUBROUTINE MAP_CopyParam

 SUBROUTINE MAP_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ParamData%Diam) ) DEALLOCATE(ParamData%Diam)
  IF ( ALLOCATED(ParamData%MassDenInAir) ) DEALLOCATE(ParamData%MassDenInAir)
  IF ( ALLOCATED(ParamData%EA) ) DEALLOCATE(ParamData%EA)
  IF ( ALLOCATED(ParamData%CB) ) DEALLOCATE(ParamData%CB)
  IF ( ALLOCATED(ParamData%Lu) ) DEALLOCATE(ParamData%Lu)
  IF ( ALLOCATED(ParamData%X) ) DEALLOCATE(ParamData%X)
  IF ( ALLOCATED(ParamData%Y) ) DEALLOCATE(ParamData%Y)
  IF ( ALLOCATED(ParamData%Z) ) DEALLOCATE(ParamData%Z)
  IF ( ALLOCATED(ParamData%FX) ) DEALLOCATE(ParamData%FX)
  IF ( ALLOCATED(ParamData%FY) ) DEALLOCATE(ParamData%FY)
  IF ( ALLOCATED(ParamData%FZ) ) DEALLOCATE(ParamData%FZ)
  IF ( ALLOCATED(ParamData%M) ) DEALLOCATE(ParamData%M)
  IF ( ALLOCATED(ParamData%B) ) DEALLOCATE(ParamData%B)
 END SUBROUTINE MAP_DestroyParam

 SUBROUTINE MAP_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%Diam )  ! Diam 
  Db_BufSz    = Db_BufSz    + SIZE( InData%MassDenInAir )  ! MassDenInAir 
  Db_BufSz    = Db_BufSz    + SIZE( InData%EA )  ! EA 
  Db_BufSz    = Db_BufSz    + SIZE( InData%CB )  ! CB 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Lu )  ! Lu 
  Db_BufSz    = Db_BufSz    + SIZE( InData%X )  ! X 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Y )  ! Y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Z )  ! Z 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FX )  ! FX 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FY )  ! FY 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FZ )  ! FZ 
  Db_BufSz    = Db_BufSz    + SIZE( InData%M )  ! M 
  Db_BufSz    = Db_BufSz    + SIZE( InData%B )  ! B 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Diam) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Diam))-1 ) =  PACK(InData%Diam ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Diam)
  ENDIF
  IF ( ALLOCATED(InData%MassDenInAir) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%MassDenInAir))-1 ) =  PACK(InData%MassDenInAir ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%MassDenInAir)
  ENDIF
  IF ( ALLOCATED(InData%EA) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%EA))-1 ) =  PACK(InData%EA ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%EA)
  ENDIF
  IF ( ALLOCATED(InData%CB) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%CB))-1 ) =  PACK(InData%CB ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%CB)
  ENDIF
  IF ( ALLOCATED(InData%Lu) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Lu))-1 ) =  PACK(InData%Lu ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Lu)
  ENDIF
  IF ( ALLOCATED(InData%X) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%X))-1 ) =  PACK(InData%X ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%X)
  ENDIF
  IF ( ALLOCATED(InData%Y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Y))-1 ) =  PACK(InData%Y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Y)
  ENDIF
  IF ( ALLOCATED(InData%Z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Z))-1 ) =  PACK(InData%Z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Z)
  ENDIF
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%FZ) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FZ))-1 ) =  PACK(InData%FZ ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FZ)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%M)
  ENDIF
  IF ( ALLOCATED(InData%B) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%B))-1 ) =  PACK(InData%B ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%B)
  ENDIF
 END SUBROUTINE MAP_PackParam

 SUBROUTINE MAP_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Diam) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Diam,1))); mask1 = .TRUE.
    OutData%Diam = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Diam))-1 ),mask1,OutData%Diam)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Diam)
  ENDIF
  IF ( ALLOCATED(OutData%MassDenInAir) ) THEN
  ALLOCATE(mask1(SIZE(OutData%MassDenInAir,1))); mask1 = .TRUE.
    OutData%MassDenInAir = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%MassDenInAir))-1 ),mask1,OutData%MassDenInAir)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%MassDenInAir)
  ENDIF
  IF ( ALLOCATED(OutData%EA) ) THEN
  ALLOCATE(mask1(SIZE(OutData%EA,1))); mask1 = .TRUE.
    OutData%EA = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%EA))-1 ),mask1,OutData%EA)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%EA)
  ENDIF
  IF ( ALLOCATED(OutData%CB) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CB,1))); mask1 = .TRUE.
    OutData%CB = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%CB))-1 ),mask1,OutData%CB)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%CB)
  ENDIF
  IF ( ALLOCATED(OutData%Lu) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Lu,1))); mask1 = .TRUE.
    OutData%Lu = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Lu))-1 ),mask1,OutData%Lu)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Lu)
  ENDIF
  IF ( ALLOCATED(OutData%X) ) THEN
  ALLOCATE(mask1(SIZE(OutData%X,1))); mask1 = .TRUE.
    OutData%X = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%X))-1 ),mask1,OutData%X)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%X)
  ENDIF
  IF ( ALLOCATED(OutData%Y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y,1))); mask1 = .TRUE.
    OutData%Y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Y))-1 ),mask1,OutData%Y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Y)
  ENDIF
  IF ( ALLOCATED(OutData%Z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Z,1))); mask1 = .TRUE.
    OutData%Z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Z))-1 ),mask1,OutData%Z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Z)
  ENDIF
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%FZ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FZ,1))); mask1 = .TRUE.
    OutData%FZ = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FZ))-1 ),mask1,OutData%FZ)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FZ)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask1(SIZE(OutData%M,1))); mask1 = .TRUE.
    OutData%M = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask1,OutData%M)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%M)
  ENDIF
  IF ( ALLOCATED(OutData%B) ) THEN
  ALLOCATE(mask1(SIZE(OutData%B,1))); mask1 = .TRUE.
    OutData%B = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%B))-1 ),mask1,OutData%B)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%B)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackParam

  SUBROUTINE MAP_F2C_CopyInput( InputData, ErrStat, ErrMsg )
    TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- X Input Data fields
    IF ( ALLOCATED( InputData%X ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%X_Len) )
       DO i = 1 , InputData%C_obj%X_Len
          c_dbl_value(i) = InputData%X(i)
       END DO
       CALL MAP_F2C_Input_X( InputData%C_obj, c_dbl_value, InputData%C_obj%X_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Y Input Data fields
    IF ( ALLOCATED( InputData%Y ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%Y_Len) )
       DO i = 1 , InputData%C_obj%Y_Len
          c_dbl_value(i) = InputData%Y(i)
       END DO
       CALL MAP_F2C_Input_Y( InputData%C_obj, c_dbl_value, InputData%C_obj%Y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Z Input Data fields
    IF ( ALLOCATED( InputData%Z ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%Z_Len) )
       DO i = 1 , InputData%C_obj%Z_Len
          c_dbl_value(i) = InputData%Z(i)
       END DO
       CALL MAP_F2C_Input_Z( InputData%C_obj, c_dbl_value, InputData%C_obj%Z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyInput

  SUBROUTINE MAP_C2F_CopyInput( InputData, ErrStat, ErrMsg )
    TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- X Input Data fields
    IF ( ALLOCATED( InputData%X ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%X, dbl_arr, (/InputData%C_obj%X_Len/) )
       DO i = 1, InputData%C_obj%X_Len
          InputData%X(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Y Input Data fields
    IF ( ALLOCATED( InputData%Y ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%Y, dbl_arr, (/InputData%C_obj%Y_Len/) )
       DO i = 1, InputData%C_obj%Y_Len
          InputData%Y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Z Input Data fields
    IF ( ALLOCATED( InputData%Z ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%Z, dbl_arr, (/InputData%C_obj%Z_Len/) )
       DO i = 1, InputData%C_obj%Z_Len
          InputData%Z(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyInput

 SUBROUTINE MAP_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_inputtype), INTENT(INOUT) :: SrcInputData
  TYPE(MAP_inputtype), INTENT(INOUT) :: DstInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcInputData%X ) ) THEN
  i1 = SIZE(SrcInputData%X,1)
  IF (.NOT.ALLOCATED(DstInputData%X)) ALLOCATE(DstInputData%X(i1))
  DstInputData%X = SrcInputData%X
ENDIF
IF ( ALLOCATED( SrcInputData%Y ) ) THEN
  i1 = SIZE(SrcInputData%Y,1)
  IF (.NOT.ALLOCATED(DstInputData%Y)) ALLOCATE(DstInputData%Y(i1))
  DstInputData%Y = SrcInputData%Y
ENDIF
IF ( ALLOCATED( SrcInputData%Z ) ) THEN
  i1 = SIZE(SrcInputData%Z,1)
  IF (.NOT.ALLOCATED(DstInputData%Z)) ALLOCATE(DstInputData%Z(i1))
  DstInputData%Z = SrcInputData%Z
ENDIF
  DstInputData%C_obj = SrcInputData%C_obj
  CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MAP_CopyInput

 SUBROUTINE MAP_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(InputData%X) ) DEALLOCATE(InputData%X)
  IF ( ALLOCATED(InputData%Y) ) DEALLOCATE(InputData%Y)
  IF ( ALLOCATED(InputData%Z) ) DEALLOCATE(InputData%Z)
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyInput

 SUBROUTINE MAP_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%X )  ! X 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Y )  ! Y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Z )  ! Z 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%X) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%X))-1 ) =  PACK(InData%X ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%X)
  ENDIF
  IF ( ALLOCATED(InData%Y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Y))-1 ) =  PACK(InData%Y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Y)
  ENDIF
  IF ( ALLOCATED(InData%Z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Z))-1 ) =  PACK(InData%Z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Z)
  ENDIF
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE MAP_PackInput

 SUBROUTINE MAP_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%X) ) THEN
  ALLOCATE(mask1(SIZE(OutData%X,1))); mask1 = .TRUE.
    OutData%X = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%X))-1 ),mask1,OutData%X)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%X)
  ENDIF
  IF ( ALLOCATED(OutData%Y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y,1))); mask1 = .TRUE.
    OutData%Y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Y))-1 ),mask1,OutData%Y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Y)
  ENDIF
  IF ( ALLOCATED(OutData%Z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Z,1))); mask1 = .TRUE.
    OutData%Z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Z))-1 ),mask1,OutData%Z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Z)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInput

  SUBROUTINE MAP_F2C_CopyOutput( OutputData, ErrStat, ErrMsg )
    TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- FX Output Data fields
    IF ( ALLOCATED( OutputData%FX ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%FX_Len) )
       DO i = 1 , OutputData%C_obj%FX_Len
          c_dbl_value(i) = OutputData%FX(i)
       END DO
       CALL MAP_F2C_Output_FX( OutputData%C_obj, c_dbl_value, OutputData%C_obj%FX_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FY Output Data fields
    IF ( ALLOCATED( OutputData%FY ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%FY_Len) )
       DO i = 1 , OutputData%C_obj%FY_Len
          c_dbl_value(i) = OutputData%FY(i)
       END DO
       CALL MAP_F2C_Output_FY( OutputData%C_obj, c_dbl_value, OutputData%C_obj%FY_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- FZ Output Data fields
    IF ( ALLOCATED( OutputData%FZ ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%FZ_Len) )
       DO i = 1 , OutputData%C_obj%FZ_Len
          c_dbl_value(i) = OutputData%FZ(i)
       END DO
       CALL MAP_F2C_Output_FZ( OutputData%C_obj, c_dbl_value, OutputData%C_obj%FZ_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- writeOutput Output Data fields
    IF ( ALLOCATED( OutputData%writeOutput ) ) THEN
       ALLOCATE( c_float_value(OutputData%C_obj%writeOutput_Len) )
       DO i = 1 , OutputData%C_obj%writeOutput_Len
          c_float_value(i) = OutputData%writeOutput(i)
       END DO
       CALL MAP_F2C_Output_writeOutput( OutputData%C_obj, c_float_value, OutputData%C_obj%writeOutput_Len )
       DEALLOCATE( c_float_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyOutput

  SUBROUTINE MAP_C2F_CopyOutput( OutputData, ErrStat, ErrMsg )
    TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- FX Output Data fields
    IF ( ALLOCATED( OutputData%FX ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%FX, dbl_arr, (/OutputData%C_obj%FX_Len/) )
       DO i = 1, OutputData%C_obj%FX_Len
          OutputData%FX(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FY Output Data fields
    IF ( ALLOCATED( OutputData%FY ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%FY, dbl_arr, (/OutputData%C_obj%FY_Len/) )
       DO i = 1, OutputData%C_obj%FY_Len
          OutputData%FY(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- FZ Output Data fields
    IF ( ALLOCATED( OutputData%FZ ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%FZ, dbl_arr, (/OutputData%C_obj%FZ_Len/) )
       DO i = 1, OutputData%C_obj%FZ_Len
          OutputData%FZ(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- writeOutput Output Data fields
    IF ( ALLOCATED( OutputData%writeOutput ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%writeOutput, float_arr, (/OutputData%C_obj%writeOutput_Len/) )
       DO i = 1, OutputData%C_obj%writeOutput_Len
          OutputData%writeOutput(i) = float_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyOutput

 SUBROUTINE MAP_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(MAP_outputtype), INTENT(INOUT) :: SrcOutputData
  TYPE(MAP_outputtype), INTENT(INOUT) :: DstOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcOutputData%FX ) ) THEN
  i1 = SIZE(SrcOutputData%FX,1)
  IF (.NOT.ALLOCATED(DstOutputData%FX)) ALLOCATE(DstOutputData%FX(i1))
  DstOutputData%FX = SrcOutputData%FX
ENDIF
IF ( ALLOCATED( SrcOutputData%FY ) ) THEN
  i1 = SIZE(SrcOutputData%FY,1)
  IF (.NOT.ALLOCATED(DstOutputData%FY)) ALLOCATE(DstOutputData%FY(i1))
  DstOutputData%FY = SrcOutputData%FY
ENDIF
IF ( ALLOCATED( SrcOutputData%FZ ) ) THEN
  i1 = SIZE(SrcOutputData%FZ,1)
  IF (.NOT.ALLOCATED(DstOutputData%FZ)) ALLOCATE(DstOutputData%FZ(i1))
  DstOutputData%FZ = SrcOutputData%FZ
ENDIF
  DstOutputData%C_obj = SrcOutputData%C_obj
  CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat, ErrMsg )
IF ( ALLOCATED( SrcOutputData%writeOutput ) ) THEN
  i1 = SIZE(SrcOutputData%writeOutput,1)
  IF (.NOT.ALLOCATED(DstOutputData%writeOutput)) ALLOCATE(DstOutputData%writeOutput(i1))
  DstOutputData%writeOutput = SrcOutputData%writeOutput
ENDIF
 END SUBROUTINE MAP_CopyOutput

 SUBROUTINE MAP_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(OutputData%FX) ) DEALLOCATE(OutputData%FX)
  IF ( ALLOCATED(OutputData%FY) ) DEALLOCATE(OutputData%FY)
  IF ( ALLOCATED(OutputData%FZ) ) DEALLOCATE(OutputData%FZ)
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
  IF ( ALLOCATED(OutputData%writeOutput) ) DEALLOCATE(OutputData%writeOutput)
 END SUBROUTINE MAP_DestroyOutput

 SUBROUTINE MAP_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%FX )  ! FX 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FY )  ! FY 
  Db_BufSz    = Db_BufSz    + SIZE( InData%FZ )  ! FZ 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%writeOutput )  ! writeOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%FZ) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%FZ))-1 ) =  PACK(InData%FZ ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%FZ)
  ENDIF
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(InData%writeOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%writeOutput))-1 ) =  PACK(InData%writeOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%writeOutput)
  ENDIF
 END SUBROUTINE MAP_PackOutput

 SUBROUTINE MAP_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%FZ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FZ,1))); mask1 = .TRUE.
    OutData%FZ = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%FZ))-1 ),mask1,OutData%FZ)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%FZ)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(OutData%writeOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%writeOutput,1))); mask1 = .TRUE.
    OutData%writeOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%writeOutput))-1 ),mask1,OutData%writeOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%writeOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOutput

 SUBROUTINE MAP_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(MAP_InputType),           INTENT(INOUT) :: InData
  TYPE(MAP_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(MAP_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(MAP_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(MAP_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE MAP_Pack

 SUBROUTINE MAP_UnPack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(MAP_InputType),           INTENT(INOUT) :: InData
  TYPE(MAP_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(MAP_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(MAP_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(MAP_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! UnPack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL MAP_UnPackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPack


 SUBROUTINE MAP_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%X = u(1)%X
  u_out%Y = u(1)%Y
  u_out%Z = u(1)%Z
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%X,1)))
  ALLOCATE(c1(SIZE(u_out%X,1)))
  b1 = -(u(1)%X - u(2)%X)/t(2)
  u_out%X = u(1)%X + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%Y,1)))
  ALLOCATE(c1(SIZE(u_out%Y,1)))
  b1 = -(u(1)%Y - u(2)%Y)/t(2)
  u_out%Y = u(1)%Y + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%Z,1)))
  ALLOCATE(c1(SIZE(u_out%Z,1)))
  b1 = -(u(1)%Z - u(2)%Z)/t(2)
  u_out%Z = u(1)%Z + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshExtrapInterp1(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%X,1)))
  ALLOCATE(c1(SIZE(u_out%X,1)))
  b1 = (t(3)**2*(u(1)%X - u(2)%X) + t(2)**2*(-u(1)%X + u(3)%X))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%X + t(3)*u(2)%X - t(2)*u(3)%X ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%X = u(1)%X + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%Y,1)))
  ALLOCATE(c1(SIZE(u_out%Y,1)))
  b1 = (t(3)**2*(u(1)%Y - u(2)%Y) + t(2)**2*(-u(1)%Y + u(3)%Y))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Y + t(3)*u(2)%Y - t(2)*u(3)%Y ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Y = u(1)%Y + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%Z,1)))
  ALLOCATE(c1(SIZE(u_out%Z,1)))
  b1 = (t(3)**2*(u(1)%Z - u(2)%Z) + t(2)**2*(-u(1)%Z + u(3)%Z))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Z + t(3)*u(2)%Z - t(2)*u(3)%Z ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Z = u(1)%Z + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshExtrapInterp2(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, u(3)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Input_ExtrapInterp


 SUBROUTINE MAP_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%FX = u(1)%FX
  u_out%FY = u(1)%FY
  u_out%FZ = u(1)%FZ
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
  u_out%writeOutput = u(1)%writeOutput
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%FX,1)))
  ALLOCATE(c1(SIZE(u_out%FX,1)))
  b1 = -(u(1)%FX - u(2)%FX)/t(2)
  u_out%FX = u(1)%FX + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%FY,1)))
  ALLOCATE(c1(SIZE(u_out%FY,1)))
  b1 = -(u(1)%FY - u(2)%FY)/t(2)
  u_out%FY = u(1)%FY + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%FZ,1)))
  ALLOCATE(c1(SIZE(u_out%FZ,1)))
  b1 = -(u(1)%FZ - u(2)%FZ)/t(2)
  u_out%FZ = u(1)%FZ + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshExtrapInterp1(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(u_out%writeOutput,1)))
  ALLOCATE(c1(SIZE(u_out%writeOutput,1)))
  b1 = -(u(1)%writeOutput - u(2)%writeOutput)/t(2)
  u_out%writeOutput = u(1)%writeOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%FX,1)))
  ALLOCATE(c1(SIZE(u_out%FX,1)))
  b1 = (t(3)**2*(u(1)%FX - u(2)%FX) + t(2)**2*(-u(1)%FX + u(3)%FX))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%FX + t(3)*u(2)%FX - t(2)*u(3)%FX ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%FX = u(1)%FX + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%FY,1)))
  ALLOCATE(c1(SIZE(u_out%FY,1)))
  b1 = (t(3)**2*(u(1)%FY - u(2)%FY) + t(2)**2*(-u(1)%FY + u(3)%FY))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%FY + t(3)*u(2)%FY - t(2)*u(3)%FY ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%FY = u(1)%FY + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(u_out%FZ,1)))
  ALLOCATE(c1(SIZE(u_out%FZ,1)))
  b1 = (t(3)**2*(u(1)%FZ - u(2)%FZ) + t(2)**2*(-u(1)%FZ + u(3)%FZ))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%FZ + t(3)*u(2)%FZ - t(2)*u(3)%FZ ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%FZ = u(1)%FZ + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshExtrapInterp2(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, u(3)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(u_out%writeOutput,1)))
  ALLOCATE(c1(SIZE(u_out%writeOutput,1)))
  b1 = (t(3)**2*(u(1)%writeOutput - u(2)%writeOutput) + t(2)**2*(-u(1)%writeOutput + u(3)%writeOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%writeOutput + t(3)*u(2)%writeOutput - t(2)*u(3)%writeOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%writeOutput = u(1)%writeOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Output_ExtrapInterp

END MODULE MAP_Types
!ENDOFREGISTRYGENERATEDFILE
